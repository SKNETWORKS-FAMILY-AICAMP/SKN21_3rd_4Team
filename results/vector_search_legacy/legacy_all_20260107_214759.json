{
  "metadata": {
    "timestamp": "20260107_214759",
    "embedding_model": "text-embedding-3-small",
    "collection_name": "learning_ai_legacy",
    "use_translation": false,
    "use_hybrid": false,
    "total_queries": 10,
    "avg_top_score": 0.5285043650000001
  },
  "results": [
    {
      "query": "파이썬에서 숫자 연산하는 방법",
      "is_korean": true,
      "top_score": 0.537268,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.537268,
          "source": "python_doc",
          "content_preview": "파이썬은 왼쪽에서 오른쪽으로 표현식의 값을 구합니다. 대입의 값을 구하 는 동안, 우변의 값이 좌변보다 먼저 구해짐에 주목하십시오.  다음 줄들에서, 표현식은 그들의 끝에 붙은 숫자들의 순서대로 값이 구해집 니다:     expr1, expr2, expr3, expr4    (expr1, expr2, expr3, expr4)    {expr1: expr2,"
        },
        {
          "score": 0.52528286,
          "source": "python_doc",
          "content_preview": "이 표는 추상 연산이 파이썬 문법의 연산자 기호와 \"operator\" 모듈의 함수 로 어떻게 대응되는지를 보여줍니다."
        },
        {
          "score": 0.4944954,
          "source": "python_doc",
          "content_preview": "파이썬은 문자열과 바이트열 리터럴과 여러 가지 숫자 리터럴들을 지원합니 다:     literal: strings | NUMBER  Evaluation of a literal yields an object of the given type (string, bytes, integer, floating-point number, complex number) wit"
        }
      ]
    },
    {
      "query": "문자열 슬라이싱 하는 법",
      "is_korean": true,
      "top_score": 0.5651532,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.5651532,
          "source": "python_doc",
          "content_preview": "문자열은 공통 시퀀스 연산들을 모두 구현하고, 아래에 기술된 추가적인 메 서드도 구현합니다.  문자열은 또한 두 가지 스타일의 문자열 포매팅을 지원합니다. 하나는 큰 폭의 유연성과 사용자 지정을 제공하고 (참조 \"str.format()\", 포맷 문자열 문법, 사용자 지정 문자열 포매팅을 참조하세요) 다른 하나는 C \"printf\" 스타일에 기반을 두는데, "
        },
        {
          "score": 0.5420659,
          "source": "python_doc",
          "content_preview": "문자열을 추상 문자 수준에서 비교하려면 (즉, 사람에게 직관적인 방법     으로), \"unicodedata.normalize()\" 를 사용하십시오.  [4] 자동 가비지-수거(automatic garbage-collection)와 자유 목록(free     lists)과 디스크립터(descriptor)의 동적인 성격 때문에, \"is\" 연산자     를 인"
        },
        {
          "score": 0.4961532,
          "source": "python_doc",
          "content_preview": "문자열은 \"U+0000\"--\"U+10FFFF\" 범위의 코드 포인트 시퀀스로 내부적으로 저장됩니다. (구현에 대한 자세한 내용은 **PEP 393**을 참조하십시오.) 일 단 문자열 객체가 CPU와 메모리 외부에서 사용되면, 엔디안(endianness)과 이러한 배열이 바이트열로 저장되는 방식이 문제가 됩니다. 다른 코덱과 마 찬가지로, 문자열을 바이트 시퀀"
        }
      ]
    },
    {
      "query": "리스트 컴프리헨션이란",
      "is_korean": true,
      "top_score": 0.49941456,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.49941456,
          "source": "python_doc",
          "content_preview": "리스트 디스플레이는 대괄호(square brackets)로 둘러싸인 표현식의 나열인 데 비어있을 수 있습니다:     list_display: \"[\" [flexible_expression_list | comprehension] \"]\"  리스트 디스플레이는 리스트 객체를 만드는데, 그 내용은 표현식의 목록이 나 컴프리헨션으로 지정할 수 있습니다. 쉼표로 분리"
        },
        {
          "score": 0.48729533,
          "source": "python_doc",
          "content_preview": "리스트, 집합, 딕셔너리를 구성하기 위해, 파이썬은 \"디스플레이 (displays)\"라고 부르는 특별한 문법을 각기 두 가지 스타일로 제공합니다:  * 컨테이너의 내용을 명시적으로 나열하거나,  * 일련의 루프와 필터링 지시들을 통해 계산되는데, *컴프리헨션   (comprehension)* 이라고 불립니다.  컴프리헨션의 공통 문법 요소들은 이렇습니다: "
        },
        {
          "score": 0.4063844,
          "source": "python_doc",
          "content_preview": "컴프리헨션이 항상 적절한 형의 컨테이너가 되게 하려고, 묵시적으로 중첩 된 스코프에서 \"yield\" 와 \"yield from\" 표현식은 금지됩니다.  Since Python 3.6, in an \"async def\" function, an \"async for\" clause may be used to iterate over a *asynchronous iter"
        }
      ]
    },
    {
      "query": "if elif else 조건문 사용법",
      "is_korean": true,
      "top_score": 0.6418822,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.6418822,
          "source": "python_doc",
          "content_preview": "\"if\" 문은 조건부 실행에 사용됩니다:     if_stmt: \"if\" assignment_expression \":\" suite             (\"elif\" assignment_expression \":\" suite)*             [\"else\" \":\" suite]  참이 되는 것을 발견할 때까지 표현식들의 값을 하나씩 차례대로 구해서 정 "
        },
        {
          "score": 0.57132506,
          "source": "python_doc",
          "content_preview": "conditional_expression: or_test [\"if\" or_test \"else\" expression]    expression:             conditional_expression | lambda_expr  A conditional expression (sometimes called a \"ternary operator\") is an"
        },
        {
          "score": 0.56576425,
          "source": "python_doc",
          "content_preview": "참고:    \"else\"와 같은 선택적 절은 존재하지 않으면 빈 목록으로 저장됩니다.  class ast.If(test, body, orelse)     \"if\" 문. \"test\"는 (\"Compare\" 노드와 같은) 단일 노드를 보유합니다.    \"body\"와 \"orelse\"는 각각 노드 리스트를 보유합니다.     \"elif\" 절은 AST에서 특별한 표현"
        }
      ]
    },
    {
      "query": "람다 함수 사용법",
      "is_korean": true,
      "top_score": 0.49247086,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.49247086,
          "source": "python_doc",
          "content_preview": "lambda_expr: \"lambda\" [parameter_list] \":\" expression  람다 표현식은 (때로 람다 형식(lambda forms)이라고 불립니다) 이름 없는 함수를 만드는 데 사용됩니다. 표현식 \"lambda parameters: expression\" 는 함수 객체를 줍니다. 이 이름 없는 객체는 이렇게 정의된 함수 객체처럼 동 작"
        },
        {
          "score": 0.45615664,
          "source": "python_doc",
          "content_preview": "이것들은 함수 호출 연산(호출 섹션 참고)이 적용될 수 있는 형들입니다:"
        },
        {
          "score": 0.44628614,
          "source": "python_doc",
          "content_preview": "| \"lambda\"                                        | 람다 표현식                           | +-------------------------------------------------+---------------------------------------+ | \":=\"               "
        }
      ]
    },
    {
      "query": "딕셔너리 리터럴 사용법",
      "is_korean": true,
      "top_score": 0.45538232,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.45538232,
          "source": "python_doc",
          "content_preview": "patch 데코레이터는 데코레이트 하는 함수의 스코프 내에서만 객체를 패치 하는 데 사용됩니다. 예외가 발생하더라도 자동으로 패치 해제를 처리합니 다. 이러한 함수는 모두 with 문에서 사용될 수 있고, 클래스 데코레이터로 도 사용할 수 있습니다."
        },
        {
          "score": 0.4283971,
          "source": "python_doc",
          "content_preview": "필터 체인 지정자는 딕셔너리의 시퀀스로, 각 딕셔너리에는 단일 필터의 ID 와 옵션이 포함됩니다. 각 딕셔너리는 키 \"\"id\"\"를 포함해야 하며, 필터 종 속 옵션을 지정하기 위해 추가 키를 포함할 수 있습니다. 유효한 필터 ID는 다음과 같습니다:  * 압축 필터:    * \"FILTER_LZMA1\" (\"FORMAT_ALONE\"과 함께 사용)    * \""
        },
        {
          "score": 0.41886964,
          "source": "python_doc",
          "content_preview": "**조합형 이터레이터:**"
        }
      ]
    },
    {
      "query": "from import로 특정 이름만 가져오는 방법",
      "is_korean": true,
      "top_score": 0.5283379,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.5283379,
          "source": "python_doc",
          "content_preview": "*이름 (Names)* 은 객체를 가리킵니다. 이름은 이름 연결 연산 때문에 만들 어집니다.  The following constructs bind names:  * formal parameters to functions,  * class definitions,  * function definitions,  * assignment expressions,  "
        },
        {
          "score": 0.51183313,
          "source": "python_doc",
          "content_preview": "class ast.Import(names)     import 문. \"names\"는 \"alias\" 노드의 리스트입니다.        >>> print(ast.dump(ast.parse('import x,y,z'), indent=4))       Module(           body=[               Import(                 "
        },
        {
          "score": 0.4917021,
          "source": "python_doc",
          "content_preview": "사용 예:     import foo                 # foo 가 임포트되고 지역적으로 연결됩니다    import foo.bar.baz         # foo, foo.bar, foo.bar.baz 가 임포트되고, foo 가 지역적으로 연결됩니다    import foo.bar.baz as fbb  # foo, foo.bar, foo.ba"
        }
      ]
    },
    {
      "query": "파일 객체 메서드 read write close",
      "is_korean": true,
      "top_score": 0.60738444,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.60738444,
          "source": "python_doc",
          "content_preview": "*파일 객체* 는 열린 파일을 나타냅니다. 파일 객체를 만드는 여러 가지 단 축법이 있습니다: \"open()\" 내장 함수, \"os.popen()\", \"os.fdopen()\" 과 소 켓 객체의 \"makefile()\" 메서드 (그리고, 아마도 확장 모듈들이 제공하는 다른 함수들이나 메서드들).  \"sys.stdin\", \"sys.stdout\", \"sys.stde"
        },
        {
          "score": 0.5326351,
          "source": "python_doc",
          "content_preview": "이 함수들은 파일 기술자를 사용하여 참조된 I/O 스트림에 작용합니다.  파일 기술자는 현재 프로세스에 의해 열린 파일에 대응하는 작은 정수입니 다. 예를 들어, 표준 입력은 보통 파일 기술자 0이고, 표준 출력은 1이며, 표준 에러는 2입니다. 프로세스에 의해 열린 추가 파일은 3, 4, 5 등으로 지정됩니다. \"파일 기술자\"라는 이름은 약간 기만적입니다"
        },
        {
          "score": 0.52129245,
          "source": "python_doc",
          "content_preview": "*file* 을 열고 해당 *파일 객체* 를 돌려줍니다. 파일을 열 수 없으면,    \"OSError\" 가 발생합니다. 이 함수를 사용하는 방법에 대한 더 많은 예    제는 파일을 읽고 쓰기를 참조하십시오.     *file* is a *path-like object* giving the pathname (absolute or    relative to "
        }
      ]
    },
    {
      "query": "try except 예외 처리하는 방법",
      "is_korean": true,
      "top_score": 0.5923672,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.5923672,
          "source": "python_doc",
          "content_preview": "생략 가능한 \"else\" 절은 제어 흐름이 \"try\" 스위트를 빠져나가고, 예외가 발생하지 않았고, \"return\", \"continue\" 또는 \"break\" 문이 실행되지 않으 면 실행됩니다. \"else\" 절에서 발생하는 예외는 앞에 나오는 \"except\" 절에 서 처리되지 않습니다."
        },
        {
          "score": 0.58713806,
          "source": "python_doc",
          "content_preview": "-[ 에러 처리 ]-  +----------------------------------------------------+----------------------------------------------------+ | \"loop.call_exception_handler()\"                    | 예외 처리기를 호출합니다.          "
        },
        {
          "score": 0.5547792,
          "source": "python_doc",
          "content_preview": "다음 예외는 일반적으로 직접 일으키는데 사용하는 예외입니다.  exception AssertionError     \"assert\" 문이 실패할 때 발생합니다.  exception AttributeError     어트리뷰트 참조(어트리뷰트 참조를 보세요)나 대입이 실패할 때 발생합    니다. (객체가 어트리뷰트 참조나 어트리뷰트 대입을 아예 지원하지 않 "
        }
      ]
    },
    {
      "query": "상속이란 무엇인가",
      "is_korean": true,
      "top_score": 0.36538297,
      "lecture_count": 0,
      "python_doc_count": 5,
      "top_3_results": [
        {
          "score": 0.36538297,
          "source": "python_doc",
          "content_preview": "Added in version 3.4.  파일 기술자는 자식 프로세스가 파일 기술자를 상속받을 수 있는지를 나타 내는 \"상속 가능\" 플래그를 가지고 있습니다. 파이썬 3.4부터, 파이썬에 의 해 생성된 파일 기술자는 기본적으로 상속 불가능합니다.  유닉스에서는, 상속 불가능한 파일 기술자는 새 프로그램 실행 시 자식 프 로세스에서 닫히고, 다른 파일 기술자"
        },
        {
          "score": 0.30405426,
          "source": "python_doc",
          "content_preview": "모의 객체를 다른 모의 객체의 어트리뷰트로 (또는 반환 값으로) 연결하면 그 모의 객체의 \"자식\"이 됩니다. 자식에 대한 호출은 부모의 \"method_calls\"와 \"mock_calls\" 어트리뷰트에 기록됩니다. 이는 자식 모의 객체를 구성한 다음 부모에 연결하는 데 유용합니다. 또는 자식들에 대한 모든 호출을 기록하는 부모에 여러 모의 객체를 연결하고 모"
        },
        {
          "score": 0.29785067,
          "source": "python_doc",
          "content_preview": "\"__*\"    클래스-비공개 이름. 이 부류의 이름들을 클래스 정의 문맥에서 사용하    면 뒤섞인 형태로 변형됩니다. 부모 클래스와 자식 클래스의 \"비공개    (private)\" 어트리뷰트 간의 이름 충돌을 피하기 위함입니다. 식별자 (    이름) 섹션을 보세요."
        }
      ]
    }
  ]
}