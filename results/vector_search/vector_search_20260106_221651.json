{
  "metadata": {
    "timestamp": "20260106_221651",
    "embedding_model": "text-embedding-3-large",
    "collection_name": "learning_ai",
    "use_translation": true,
    "prompt_version": {
      "file": "src\\agent\\prompts\\translate_prompt.py",
      "hash": "741ed11617bac58d",
      "modified_time": "2026-01-06T22:07:53.043158"
    },
    "preprocessing_config": {
      "file": "src\\ingestion_rst.py",
      "hash": "fd7aef214dc40285",
      "embedding_model": "text-embedding-3-large",
      "chunk_size": 900,
      "chunk_overlap": 200
    },
    "total_queries": 11,
    "avg_top_score": 0.5556918518181818
  },
  "results": [
    {
      "query": "파이썬에서 숫자 연산하는 방법",
      "is_korean": true,
      "translated_query": "arithmetic operators addition subtraction multiplication division floor division (//) modulo operator (%) power operator (**)",
      "translation_error": null,
      "top_score": 0.5700708,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5700708,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The division operation can be customized using the special object.__truediv__ and object.__rtruediv__ methods. The floor division operation can b"
        },
        {
          "score": 0.5596058,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``. Floor division and modulo are also co"
        },
        {
          "score": 0.55129826,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The binary arithmetic operations have the conventional priority levels. Note that some of these operations also apply to certain non-numeric type"
        }
      ]
    },
    {
      "query": "정수 나눗셈과 나머지 연산자 사용법",
      "is_korean": true,
      "translated_query": "integer division floor division (//) modulo operator (%) arithmetic operators remainder operator",
      "translation_error": null,
      "top_score": 0.63594615,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.63594615,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``. Floor division and modulo are also co"
        },
        {
          "score": 0.614174,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The division operation can be customized using the special object.__truediv__ and object.__rtruediv__ methods. The floor division operation can b"
        },
        {
          "score": 0.5148877,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] programming [H1] Numbers and strings [H2] Why does -22 // 10 return -3?  It's primarily driven by the desire that ``i % j`` have the same sign as ``j``. If you want that, and also want::      "
        }
      ]
    },
    {
      "query": "문자열 슬라이싱 하는 법",
      "is_korean": true,
      "translated_query": "string slicing syntax string literal brackets [] start index end index step slice object",
      "translation_error": null,
      "top_score": 0.53834367,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.53834367,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Primaries [H2] Slicings  A slicing selects a range of items in a sequence object (e.g., a string, tuple or list). Slicings may be used as expressions or as targets in assignme"
        },
        {
          "score": 0.514809,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Primaries [H2] Slicings  The semantics for a slicing are as follows. The primary is indexed (using the same object.__getitem__ method as normal subscription) with a key that i"
        },
        {
          "score": 0.49021384,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] functions [H1] Built-in Functions  Since private name mangling happens at       compilation time, one must manually mangle a private attribute's       (attributes with two leading underscores)"
        }
      ]
    },
    {
      "query": "리스트 컴프리헨션이란",
      "is_korean": true,
      "translated_query": "list comprehension syntax iterable for loop expression brackets [] generator expression",
      "translation_error": null,
      "top_score": 0.6329086,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6329086,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] functional [H1] Generator expressions and list comprehensions  Generator expressions are surrounded by parentheses (\"()\") and list comprehensions are surrounded by square brackets (\"[]\"). Gene"
        },
        {
          "score": 0.5639014,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] functional [H1] Generator expressions and list comprehensions  To put it another way, a list comprehension or generator expression is equivalent to the following Python code::      for expr1 i"
        },
        {
          "score": 0.5477711,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Generator expressions  A generator expression is a compact generator notation in parentheses:  A generator expression yields a new generator object. Its syntax is t"
        }
      ]
    },
    {
      "query": "if elif else 조건문 사용법",
      "is_korean": true,
      "translated_query": "if statement elif else conditional expression control flow branching logic indentation",
      "translation_error": null,
      "top_score": 0.5661366,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5661366,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] if Statements  Perhaps the most well-known statement type is the if statement. For example::     >>> x = int(input(\"Please enter an integer: \"))    Please enter an integer: 42"
        },
        {
          "score": 0.5398983,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] compound_stmts [H1] The if statement  The if statement is used for conditional execution:  It selects exactly one of the suites by evaluating the expressions one by one until one is found to b"
        },
        {
          "score": 0.50484514,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Conditional expressions  A conditional expression (sometimes called a \"ternary operator\") is an alternative to the if-else statement. As it is an expression, it returns a valu"
        }
      ]
    },
    {
      "query": "for문에서 range 함수 사용하는 방법",
      "is_korean": true,
      "translated_query": "for statement range() function iterable syntax loop control variable index step size",
      "translation_error": null,
      "top_score": 0.5843202,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5843202,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive i"
        },
        {
          "score": 0.5698521,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  If you do need to iterate over a sequence of numbers, the built-in function range comes in handy. It generates arithmetic progressions::      >>> for i in "
        },
        {
          "score": 0.5299804,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  >>> list(range(0, 10, 3))     [0, 3, 6, 9]      >>> list(range(-10, -100, -30))     [-10, -40, -70]  To iterate over the indices of a sequence, you can com"
        }
      ]
    },
    {
      "query": "함수 정의하는 방법 def 키워드",
      "is_korean": true,
      "translated_query": "function definition def keyword parameters arguments return statement callable",
      "translation_error": null,
      "top_score": 0.47993845,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.47993845,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] compound_stmts [H1] Function definitions  Function call semantics are described in more detail in section calls. A function call always assigns values to all parameters mentioned in the parame"
        },
        {
          "score": 0.47383162,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Primaries [H2] Calls  A call calls a callable object (e.g., a function) with a possibly empty series of arguments:  An optional trailing comma may be present after the positio"
        },
        {
          "score": 0.46483696,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Special parameters  By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and p"
        }
      ]
    },
    {
      "query": "람다 함수 사용법",
      "is_korean": true,
      "translated_query": "lambda expression anonymous function parameters arguments return statement function definition",
      "translation_error": null,
      "top_score": 0.52453005,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.52453005,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Lambdas  Lambda expressions (sometimes called lambda forms) are used to create anonymous functions. The expression ``lambda parameters: expression`` yields a function object. "
        },
        {
          "score": 0.47397298,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Lambda Expressions  Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: ``lam"
        },
        {
          "score": 0.4483009,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] compound_stmts [H1] Function definitions  Parameters of the form \"``*identifier``\" may have an annotation    \"``: *expression``\". See 646.  It is also possible to create anonymous functions (f"
        }
      ]
    },
    {
      "query": "딕셔너리 리터럴 사용법",
      "is_korean": true,
      "translated_query": "dictionary display dict literal key value pairs curly braces {} dict.get()",
      "translation_error": null,
      "top_score": 0.49361682,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.49361682,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] Dictionaries  Extracting a value for a non-existent key by subscripting (``d[key]``) raises a KeyError. To avoid getting this error when trying to access a possibly non-exi"
        },
        {
          "score": 0.4925755,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Dictionary displays  A dictionary display is a possibly empty series of dict items (key/value pairs) enclosed in curly braces:  A dictionary display yields a new di"
        },
        {
          "score": 0.44744754,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] Dictionaries  It is best to think of a dictionary as a set of *key: value* pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces cr"
        }
      ]
    },
    {
      "query": "모듈 임포트 하는 방법",
      "is_korean": true,
      "translated_query": "import statement from import module namespace standard library __init__.py package directory",
      "translation_error": null,
      "top_score": 0.5538838,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5538838,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] simple_stmts [H1] The import statement  If the requested module is retrieved successfully, it will be made available in the local namespace in one of three ways:  * If the module name is follo"
        },
        {
          "score": 0.55322874,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] simple_stmts [H1] The import statement  importlib.import_module is provided to support applications that determine dynamically the modules to be loaded."
        },
        {
          "score": 0.5479896,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] simple_stmts [H1] The import statement  import mod`` from within ``pkg.subpkg1`` you will import ``pkg.subpkg2.mod``. The specification for relative imports is contained in the relativeimports"
        }
      ]
    },
    {
      "query": "try except 예외 처리하는 방법",
      "is_korean": true,
      "translated_query": "try except exception handling built-in exceptions KeyError ValueError IndexError traceback raise statement",
      "translation_error": null,
      "top_score": 0.53291523,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.53291523,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  The try statement works as follows.  * First, the *try clause* (the statement(s) between the try and  * If no exception occurs, the *except clause* is skipped "
        },
        {
          "score": 0.52893937,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] exceptions [H1] Built-in Exceptions  In Python, all exceptions must be instances of a class that derives from BaseException. In a try statement with an except clause that mentions a particular"
        },
        {
          "score": 0.52664167,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] compound_stmts [H1] The try statement [H2] except clause  >>> print(sys.exception())    None    >>> try:    ...     raise TypeError    ... except:    ...     print(repr(sys.exception()))    .."
        }
      ]
    }
  ]
}