{
  "metadata": {
    "timestamp": "20260107_001414",
    "embedding_model": "text-embedding-3-large",
    "collection_name": "learning_ai",
    "use_translation": true,
    "use_hybrid": true,
    "prompt_version": {
      "file": "src\\agent\\prompts\\translate_prompt.py",
      "hash": "741ed11617bac58d",
      "modified_time": "2026-01-06T23:32:29.645353"
    },
    "preprocessing_config": {
      "file": "src\\ingestion_rst.py",
      "hash": "972c640979dd49e5",
      "embedding_model": "text-embedding-3-large",
      "chunk_size": 900,
      "chunk_overlap": 200
    },
    "total_queries": 11,
    "avg_top_score": 0.6446913730057214
  },
  "results": [
    {
      "query": "파이썬에서 숫자 연산하는 방법",
      "is_korean": true,
      "translated_query": "arithmetic operators addition subtraction multiplication division floor division (//) modulo operator (%) power operator (**)",
      "translation_error": null,
      "top_score": 0.695587218,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.695587218,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] power operator floor division [TITLE] expressions [H1] Operator precedence  | await x | Await expression | +-----------------------------------------------+---------------------------------"
        },
        {
          "score": 0.6397236900000001,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] floor division divmod formatting __mod__ __rmod__ [TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x"
        },
        {
          "score": 0.61624188,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] __matmul__ __rmatmul__ floor division [TITLE] expressions [H1] Binary arithmetic operations  If only one operand is a complex number, the other operand is converted    to a floating-point n"
        }
      ]
    },
    {
      "query": "정수 나눗셈과 나머지 연산자 사용법",
      "is_korean": true,
      "translated_query": "integer division floor division (//) modulo operator (%) arithmetic operators remainder operator",
      "translation_error": null,
      "top_score": 0.735022721,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.735022721,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] __truediv__ __rtruediv__ __floordiv__ __rfloordiv__ modulo operator operand [TITLE] expressions [H1] Binary arithmetic operations  The division operation can be customized using the special"
        },
        {
          "score": 0.728281,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] floor division divmod formatting __mod__ __rmod__ [TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x"
        },
        {
          "score": 0.68001782,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] __matmul__ __rmatmul__ floor division [TITLE] expressions [H1] Binary arithmetic operations  If only one operand is a complex number, the other operand is converted    to a floating-point n"
        }
      ]
    },
    {
      "query": "문자열 슬라이싱 하는 법",
      "is_korean": true,
      "translated_query": "string slicing syntax string literal brackets [] start index end index step slice object",
      "translation_error": null,
      "top_score": 0.6098347823076923,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6098347823076923,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] indexed __getitem__ object [TITLE] expressions [H1] Primaries [H2] Slicings  The semantics for a slicing are as follows. The primary is indexed (using the same object.__getitem__ method as "
        },
        {
          "score": 0.5909659326923077,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] object slicing [TITLE] expressions [H1] Primaries [H2] Slicings  A slicing selects a range of items in a sequence object (e.g., a string, tuple or list). Slicings may be used as expressions"
        },
        {
          "score": 0.5785120643076923,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] last [TITLE] introduction [H1] Using Python as a Calculator [H2] Text  Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the s"
        }
      ]
    },
    {
      "query": "리스트 컴프리헨션이란",
      "is_korean": true,
      "translated_query": "list comprehension syntax iterable for loop expression brackets [] generator expression",
      "translation_error": null,
      "top_score": 0.6831598399999999,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6831598399999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Generator expressions  A generator expression is a compact generator notation in parentheses:  A generator expression yields a new generator object. Its syntax is t"
        },
        {
          "score": 0.65518462,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Displays for lists, sets and dictionaries  For constructing a list, a set or a dictionary Python provides special syntax called \"displays\", each of them in two flav"
        },
        {
          "score": 0.63905302,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] range [TITLE] expressions [H1] Atoms [H2] Displays for lists, sets and dictionaries  However, aside from the iterable expression in the leftmost for clause, the comprehension is executed in"
        }
      ]
    },
    {
      "query": "if elif else 조건문 사용법",
      "is_korean": true,
      "translated_query": "if statement, elif, else, conditional expression, control flow, boolean expression, comparison operators, logical operators",
      "translation_error": null,
      "top_score": 0.4703869228461538,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.4703869228461538,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] More on Conditions  The conditions used in ``while`` and ``if`` statements can contain any operators, not just comparisons.  The comparison operators ``in`` and ``not in`` "
        },
        {
          "score": 0.46372791384615386,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[API] A conditional expression (sometimes called a \"ternary operator\") [KEYWORDS] expression [TITLE] expressions [H1] Conditional expressions  A conditional expression (sometimes called a \"ternary ope"
        },
        {
          "score": 0.4514463158461538,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] comparison [TITLE] datastructures [H1] More on Conditions  Comparisons can be chained. For example, ``a < b == c`` tests whether ``a`` is less than ``b`` and moreover ``b`` equals ``c``.  C"
        }
      ]
    },
    {
      "query": "for문에서 range 함수 사용하는 방법",
      "is_korean": true,
      "translated_query": "for statement range() function iterable syntax loop control flow step size",
      "translation_error": null,
      "top_score": 0.6441116854545454,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6441116854545454,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] sum range [TITLE] controlflow [H1] The range Function  We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they ca"
        },
        {
          "score": 0.6163591995454545,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] range increment list [TITLE] controlflow [H1] The range Function  If you do need to iterate over a sequence of numbers, the built-in function range comes in handy. It generates arithmetic p"
        },
        {
          "score": 0.5980448254545455,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] numbers condition sequence example len [TITLE] controlflow [H1] for Statements  The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always ite"
        }
      ]
    },
    {
      "query": "함수 정의하는 방법 def 키워드",
      "is_korean": true,
      "translated_query": "function definition def keyword parameters arguments return statement callable",
      "translation_error": null,
      "top_score": 0.6612629299999999,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6612629299999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[API] The actual parameters (arguments) [KEYWORDS] parameters f [TITLE] controlflow [H1] Defining Functions  The actual parameters (arguments) to a function call are introduced in the local symbol tab"
        },
        {
          "score": 0.625120509,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] f [TITLE] controlflow [H1] More on Defining Functions [H2] Special parameters  By default, arguments may be passed to a Python function either by position or explicitly by keyword. For read"
        },
        {
          "score": 0.611159198,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] f [TITLE] controlflow [H1] More on Defining Functions [H2] Recap  The use case will determine which parameters to use in the function definition::     def f(pos1, pos2, /, pos_or_kwd, *, kw"
        }
      ]
    },
    {
      "query": "람다 함수 사용법",
      "is_korean": true,
      "translated_query": "lambda expression anonymous function parameters arguments return statement function definition",
      "translation_error": null,
      "top_score": 0.673293382,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.673293382,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[API] Lambda expressions (sometimes called lambda forms) [KEYWORDS] expressions [TITLE] expressions [H1] Lambdas  Lambda expressions (sometimes called lambda forms) are used to create anonymous functi"
        },
        {
          "score": 0.603938488,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] make_incrementor f [TITLE] controlflow [H1] More on Defining Functions [H2] Lambda Expressions  Small anonymous functions can be created with the lambda keyword. This function returns the s"
        },
        {
          "score": 0.488039105,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[API] The actual parameters (arguments) [KEYWORDS] parameters f [TITLE] controlflow [H1] Defining Functions  The actual parameters (arguments) to a function call are introduced in the local symbol tab"
        }
      ]
    },
    {
      "query": "딕셔너리 리터럴 사용법",
      "is_korean": true,
      "translated_query": "dictionary display dict literal key value pairs curly braces {} dict.get()",
      "translation_error": null,
      "top_score": 0.65103719,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.65103719,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[API] A dictionary display is a possibly empty series of dict items (key/value pairs) [KEYWORDS] items power operator [TITLE] expressions [H1] Atoms [H2] Dictionary displays  A dictionary display is a"
        },
        {
          "score": 0.58509443,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] unique [TITLE] datastructures [H1] Dictionaries  It is best to think of a dictionary as a set of *key: value* pairs, with the requirement that the keys are unique (within one dictionary). A"
        },
        {
          "score": 0.577669028,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Set displays  A set display is denoted by curly braces and distinguishable from dictionary displays by the lack of colons separating keys and values:  A set display"
        }
      ]
    },
    {
      "query": "모듈 임포트 하는 방법",
      "is_korean": true,
      "translated_query": "import statement from import module namespace standard library __init__.py package directory",
      "translation_error": null,
      "top_score": 0.5925667304545454,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5925667304545454,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] module fib namespace [TITLE] modules [H1] More on Modules  Modules can import other modules. It is customary but not required to place all import statements at the beginning of a module (or"
        },
        {
          "score": 0.5863041163636363,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] __init__ __all__ [TITLE] modules [H1] Packages [H2] Importing \\* From a Package  The only solution is for the package author to provide an explicit index of the package. The import statemen"
        },
        {
          "score": 0.57982934,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] __init__ packages __all__ echofilter method echo echofilter [TITLE] modules [H1] Packages  When importing the package, Python searches through the directories on ``sys.path`` looking for th"
        }
      ]
    },
    {
      "query": "try except 예외 처리하는 방법",
      "is_korean": true,
      "translated_query": "try except exception handling built-in exceptions KeyError ValueError IndexError traceback raise statement",
      "translation_error": null,
      "top_score": 0.675341701,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.675341701,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] it open readline strip int type [TITLE] errors [H1] Handling Exceptions  The most common pattern for handling Exception is to print or log the exception and then re-raise it (allowing a cal"
        },
        {
          "score": 0.62368185,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] statement [TITLE] errors [H1] Handling Exceptions  The try statement works as follows.  * First, the *try clause* (the statement(s) between the try and  * If no exception occurs, the *excep"
        },
        {
          "score": 0.621901168,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[KEYWORDS] NameError Traceback ValueError [TITLE] errors [H1] Raising Exceptions  The raise statement allows the programmer to force a specified exception to occur. For example::     >>> raise NameErr"
        }
      ]
    }
  ]
}