{
  "metadata": {
    "timestamp": "20260106_224707",
    "embedding_model": "text-embedding-3-large",
    "collection_name": "learning_ai",
    "use_translation": true,
    "use_hybrid": true,
    "prompt_version": {
      "file": "src\\agent\\prompts\\translate_prompt.py",
      "hash": "741ed11617bac58d",
      "modified_time": "2026-01-06T22:07:53.043158"
    },
    "preprocessing_config": {
      "file": "src\\ingestion_rst.py",
      "hash": "5bf84b123fdcf8a2",
      "embedding_model": "text-embedding-3-large",
      "chunk_size": 900,
      "chunk_overlap": 200
    },
    "total_queries": 11,
    "avg_top_score": 0.6360483086230134
  },
  "results": [
    {
      "query": "파이썬에서 숫자 연산하는 방법",
      "is_korean": true,
      "translated_query": "arithmetic operators addition subtraction multiplication division floor division (//) modulo operator (%) power operator (**)",
      "translation_error": null,
      "top_score": 0.66193462,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.66193462,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``. Floor division and modulo are also co"
        },
        {
          "score": 0.644286101,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division operator, the modulo operator, and the divmod function are not defined for complex numbers. Instead, convert to a floating-poi"
        },
        {
          "score": 0.62565604,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  If only one operand is a complex number, the other operand is converted    to a floating-point number.  The ``@`` (at) operator is intended to be"
        }
      ]
    },
    {
      "query": "정수 나눗셈과 나머지 연산자 사용법",
      "is_korean": true,
      "translated_query": "integer division floor division (//) modulo operator (%) arithmetic operators remainder operator",
      "translation_error": null,
      "top_score": 0.7454862999999999,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.7454862999999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``. Floor division and modulo are also co"
        },
        {
          "score": 0.7300326100000001,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The division operation can be customized using the special object.__truediv__ and object.__rtruediv__ methods. The floor division operation can b"
        },
        {
          "score": 0.660039281,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  If only one operand is a complex number, the other operand is converted    to a floating-point number.  The ``@`` (at) operator is intended to be"
        }
      ]
    },
    {
      "query": "문자열 슬라이싱 하는 법",
      "is_korean": true,
      "translated_query": "string slicing syntax string literal indices brackets [] substring extraction slice notation",
      "translation_error": null,
      "top_score": 0.6054127745454545,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6054127745454545,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Primaries [H2] Slicings  A slicing selects a range of items in a sequence object (e.g., a string, tuple or list). Slicings may be used as expressions or as targets in assignme"
        },
        {
          "score": 0.5683205445454546,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Primaries [H2] Subscriptions  The formal syntax makes no special provision for negative indices in sequences. However, built-in sequences all provide a object.__getitem__ meth"
        },
        {
          "score": 0.5668916054545454,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] introduction [H1] Using Python as a Calculator [H2] Text  >>> word = 'Python'    >>> word[0]  # character in position 0    'P'    >>> word[5]  # character in position 5    'n'  Indices may als"
        }
      ]
    },
    {
      "query": "리스트 컴프리헨션이란",
      "is_korean": true,
      "translated_query": "list comprehension syntax iterable for loop expression brackets [] list.append()",
      "translation_error": null,
      "top_score": 0.6272296159999999,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6272296159999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Displays for lists, sets and dictionaries  For constructing a list, a set or a dictionary Python provides special syntax called \"displays\", each of them in two flav"
        },
        {
          "score": 0.5825796249999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Displays for lists, sets and dictionaries  However, aside from the iterable expression in the leftmost for clause, the comprehension is executed in a separate impli"
        },
        {
          "score": 0.5739008990000001,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] More on Lists [H2] List Comprehensions  List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the resul"
        }
      ]
    },
    {
      "query": "if elif else 조건문 사용법",
      "is_korean": true,
      "translated_query": "if statement, elif, else, conditional expression, control flow, branching, logical operators, comparison operators",
      "translation_error": null,
      "top_score": 0.48575507799999995,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.48575507799999995,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] More on Conditions  The conditions used in ``while`` and ``if`` statements can contain any operators, not just comparisons.  The comparison operators ``in`` and ``not in`` "
        },
        {
          "score": 0.46133637,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Conditional expressions  A conditional expression (sometimes called a \"ternary operator\") is an alternative to the if-else statement. As it is an expression, it returns a valu"
        },
        {
          "score": 0.44502411,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] if Statements  Perhaps the most well-known statement type is the if statement. For example::     >>> x = int(input(\"Please enter an integer: \"))    Please enter an integer: 42"
        }
      ]
    },
    {
      "query": "for문에서 range 함수 사용하는 방법",
      "is_korean": true,
      "translated_query": "for statement range() function iterable syntax loop control flow step size list comprehension",
      "translation_error": null,
      "top_score": 0.6715884603076923,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6715884603076923,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive i"
        },
        {
          "score": 0.6233784876923076,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  If you do need to iterate over a sequence of numbers, the built-in function range comes in handy. It generates arithmetic progressions::      >>> for i in "
        },
        {
          "score": 0.6060150223076923,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] for Statements  The for statement in Python differs a bit from what you may be used to in C or Pascal. Rather than always iterating over an arithmetic progression of numbers ("
        }
      ]
    },
    {
      "query": "함수 정의하는 방법 def 키워드",
      "is_korean": true,
      "translated_query": "function definition def keyword parameters arguments return statement callable",
      "translation_error": null,
      "top_score": 0.625379068,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.625379068,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Special parameters  By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and p"
        },
        {
          "score": 0.6213200409999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Primaries [H2] Calls  Formal parameters using the syntax ``*identifier`` or ``**identifier`` cannot be used as positional argument slots or as keyword argument names.     Func"
        },
        {
          "score": 0.610555462,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Function Examples  >>> kwd_only_arg(arg=3)    3  And the last uses all three calling conventions in the same function definition::     >>> comb"
        }
      ]
    },
    {
      "query": "람다 함수 사용법",
      "is_korean": true,
      "translated_query": "lambda expression anonymous function parameters arguments return statement function definition",
      "translation_error": null,
      "top_score": 0.66661541,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.66661541,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Lambdas  Lambda expressions (sometimes called lambda forms) are used to create anonymous functions. The expression ``lambda parameters: expression`` yields a function object. "
        },
        {
          "score": 0.6317507899999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Lambda Expressions  Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: ``lam"
        },
        {
          "score": 0.48632565899999997,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Function Annotations  Function annotations are completely optional metadata information about the types used by user-defined functions (see 310"
        }
      ]
    },
    {
      "query": "딕셔너리 리터럴 사용법",
      "is_korean": true,
      "translated_query": "dictionary display dict literal key value pairs curly braces {} dict.get()",
      "translation_error": null,
      "top_score": 0.644808604,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.644808604,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Dictionary displays  A dictionary display is a possibly empty series of dict items (key/value pairs) enclosed in curly braces:  A dictionary display yields a new di"
        },
        {
          "score": 0.583138091,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] Dictionaries  It is best to think of a dictionary as a set of *key: value* pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces cr"
        },
        {
          "score": 0.577694312,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Set displays  A set display is denoted by curly braces and distinguishable from dictionary displays by the lack of colons separating keys and values:  A set display"
        }
      ]
    },
    {
      "query": "모듈 임포트 하는 방법",
      "is_korean": true,
      "translated_query": "import statement from import module namespace standard library __init__.py package directory",
      "translation_error": null,
      "top_score": 0.6065185339999999,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6065185339999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] modules [H1] Packages  When importing the package, Python searches through the directories on ``sys.path`` looking for the package subdirectory.  The __init__.py files are required to make Pyt"
        },
        {
          "score": 0.5944887263636364,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] modules [H1] Packages [H2] Importing \\* From a Package  The only solution is for the package author to provide an explicit index of the package. The import statement uses the following convent"
        },
        {
          "score": 0.5850813773636363,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] modules [H1] Packages [H2] Importing \\* From a Package  import sound.effects.echo    import sound.effects.surround    from sound.effects import *  In this example, the echo and surround module"
        }
      ]
    },
    {
      "query": "try except 예외 처리하는 방법",
      "is_korean": true,
      "translated_query": "try except exception handling built-in exceptions KeyError ValueError IndexError traceback raise statement",
      "translation_error": null,
      "top_score": 0.6558029299999999,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.6558029299999999,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  The most common pattern for handling Exception is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well)::     "
        },
        {
          "score": 0.62574134,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  It is possible to write programs that handle selected exceptions. Look at the following example, which asks the user for input until a valid integer has been e"
        },
        {
          "score": 0.598040661,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  The try statement works as follows.  * First, the *try clause* (the statement(s) between the try and  * If no exception occurs, the *except clause* is skipped "
        }
      ]
    }
  ]
}