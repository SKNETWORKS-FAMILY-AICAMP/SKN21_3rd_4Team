{
  "metadata": {
    "timestamp": "20260106_232816",
    "embedding_model": "text-embedding-3-large",
    "collection_name": "learning_ai",
    "use_translation": true,
    "prompt_version": {
      "file": "src\\agent\\prompts\\translate_prompt.py",
      "hash": "7890b8038d691777",
      "modified_time": "2026-01-06T23:27:49.828806"
    },
    "preprocessing_config": {
      "file": "src\\ingestion_rst.py",
      "hash": "122e1e86e93bfd3b",
      "embedding_model": "text-embedding-3-large",
      "chunk_size": 500,
      "chunk_overlap": 100
    },
    "total_queries": 11,
    "avg_top_score": 0.5190545227272727
  },
  "results": [
    {
      "query": "파이썬에서 숫자 연산하는 방법",
      "is_korean": true,
      "translated_query": "python numeric operations arithmetic calculations methods",
      "translation_error": null,
      "top_score": 0.49618924,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.49618924,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The division operation can be customized using the special object.__truediv__ and object.__rtruediv__ methods. The floor division operation can b"
        },
        {
          "score": 0.49090174,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division operator, the modulo operator, and the divmod function are not defined for complex numbers. Instead, convert to a floating-poi"
        },
        {
          "score": 0.48184022,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  If only one operand is a complex number, the other operand is converted    to a floating-point number.  The ``@`` (at) operator is intended to be"
        }
      ]
    },
    {
      "query": "정수 나눗셈과 나머지 연산자 사용법",
      "is_korean": true,
      "translated_query": "integer division modulo operator usage",
      "translation_error": null,
      "top_score": 0.55819666,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.55819666,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The floor division and modulo operators are connected by the following identity: ``x == (x//y)*y + (x%y)``. Floor division and modulo are also co"
        },
        {
          "score": 0.49614474,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  The division operation can be customized using the special object.__truediv__ and object.__rtruediv__ methods. The floor division operation can b"
        },
        {
          "score": 0.38349247,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Binary arithmetic operations  If only one operand is a complex number, the other operand is converted    to a floating-point number.  The ``@`` (at) operator is intended to be"
        }
      ]
    },
    {
      "query": "문자열 슬라이싱 하는 법",
      "is_korean": true,
      "translated_query": "string slicing substring indexing Python",
      "translation_error": null,
      "top_score": 0.5059519,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5059519,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] introduction [H1] Using Python as a Calculator [H2] Text  Slice indices have useful defaults; an omitted first index defaults to zero, an omitted second index defaults to the size of the strin"
        },
        {
          "score": 0.49803984,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] introduction [H1] Using Python as a Calculator [H2] Text  >>> word = 'Python'    >>> word[0]  # character in position 0    'P'    >>> word[5]  # character in position 5    'n'  Indices may als"
        },
        {
          "score": 0.48501796,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] introduction [H1] Using Python as a Calculator [H2] Text  +---+---+---+---+---+---+     | P | y | t | h | o | n |     +---+---+---+---+---+---+     0   1   2   3   4   5   6    -6  -5  -4  -3 "
        }
      ]
    },
    {
      "query": "리스트 컴프리헨션이란",
      "is_korean": true,
      "translated_query": "list comprehension definition syntax features",
      "translation_error": null,
      "top_score": 0.5283061,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5283061,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] More on Lists [H2] List Comprehensions  squares = list(map(lambda x: x**2, range(10)))  or, equivalently::     squares = [x**2 for x in range(10)]  which is more concise an"
        },
        {
          "score": 0.52616274,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] More on Lists [H2] List Comprehensions  List comprehensions provide a concise way to create lists. Common applications are to make new lists where each element is the resul"
        },
        {
          "score": 0.52143776,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Displays for lists, sets and dictionaries  For constructing a list, a set or a dictionary Python provides special syntax called \"displays\", each of them in two flav"
        }
      ]
    },
    {
      "query": "if elif else 조건문 사용법",
      "is_korean": true,
      "translated_query": "if elif else conditional statements usage",
      "translation_error": null,
      "top_score": 0.5451988,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5451988,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] if Statements  Perhaps the most well-known statement type is the if statement. For example::     >>> x = int(input(\"Please enter an integer: \"))    Please enter an integer: 42"
        },
        {
          "score": 0.48957643,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Conditional expressions  A conditional expression (sometimes called a \"ternary operator\") is an alternative to the if-else statement. As it is an expression, it returns a valu"
        },
        {
          "score": 0.45374,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] else Clauses on Loops  (Yes, this is the correct code. Look closely: the ``else`` clause belongs to the ``for`` loop, **not** the ``if`` statement.)  One way to think of the e"
        }
      ]
    },
    {
      "query": "for문에서 range 함수 사용하는 방법",
      "is_korean": true,
      "translated_query": "for loop range function usage",
      "translation_error": null,
      "top_score": 0.5609422,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5609422,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  We say such an object is iterable, that is, suitable as a target for functions and constructs that expect something from which they can obtain successive i"
        },
        {
          "score": 0.55256194,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  If you do need to iterate over a sequence of numbers, the built-in function range comes in handy. It generates arithmetic progressions::      >>> for i in "
        },
        {
          "score": 0.53440976,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] The range Function  >>> list(range(0, 10, 3))     [0, 3, 6, 9]      >>> list(range(-10, -100, -30))     [-10, -40, -70]  To iterate over the indices of a sequence, you can com"
        }
      ]
    },
    {
      "query": "함수 정의하는 방법 def 키워드",
      "is_korean": true,
      "translated_query": "function definition def keyword Python",
      "translation_error": null,
      "top_score": 0.48513395,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.48513395,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Keyword-Only Arguments  To mark parameters as *keyword-only*, indicating the parameters must be passed by keyword argument, place an ``*`` in t"
        },
        {
          "score": 0.48444182,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Keyword Arguments  >>> def function(a):    ...     pass    ...    >>> function(0, a=0)    Traceback (most recent call last):      File \"<stdin>"
        },
        {
          "score": 0.48373133,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Special parameters  By default, arguments may be passed to a Python function either by position or explicitly by keyword. For readability and p"
        }
      ]
    },
    {
      "query": "람다 함수 사용법",
      "is_korean": true,
      "translated_query": "lambda function usage syntax Python",
      "translation_error": null,
      "top_score": 0.4984072,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.4984072,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Lambda Expressions  Small anonymous functions can be created with the lambda keyword. This function returns the sum of its two arguments: ``lam"
        },
        {
          "score": 0.4899924,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Lambdas  Lambda expressions (sometimes called lambda forms) are used to create anonymous functions. The expression ``lambda parameters: expression`` yields a function object. "
        },
        {
          "score": 0.45009086,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] controlflow [H1] More on Defining Functions [H2] Lambda Expressions  >>> pairs = [(1, 'one'), (2, 'two'), (3, 'three'), (4, 'four')]    >>> pairs.sort(key=lambda pair: pair[1])    >>> pairs   "
        }
      ]
    },
    {
      "query": "딕셔너리 리터럴 사용법",
      "is_korean": true,
      "translated_query": "dictionary literal usage syntax keys values",
      "translation_error": null,
      "top_score": 0.43030685,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.43030685,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] Dictionaries  It is best to think of a dictionary as a set of *key: value* pairs, with the requirement that the keys are unique (within one dictionary). A pair of braces cr"
        },
        {
          "score": 0.42913032,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] expressions [H1] Atoms [H2] Dictionary displays  Unpacking into dictionary displays, originally proposed by 448.  A dict comprehension, in contrast to list and set comprehensions, needs two ex"
        },
        {
          "score": 0.42000562,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] datastructures [H1] Dictionaries  The dict constructor builds dictionaries directly from sequences of key-value pairs::     >>> dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])    {'sap"
        }
      ]
    },
    {
      "query": "모듈 임포트 하는 방법",
      "is_korean": true,
      "translated_query": "import module importation Python packages",
      "translation_error": null,
      "top_score": 0.5182427,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.5182427,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] modules [H1] Packages [H2] Intra-package References  When packages are structured into subpackages (as with the sound package in the example), you can use absolute imports to refer to submodul"
        },
        {
          "score": 0.51238525,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] modules [H1] Packages [H2] Importing \\* From a Package  Now what happens when the user writes ``from sound.effects import *``? Ideally, one would hope that this somehow goes out to the filesys"
        },
        {
          "score": 0.50601554,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] modules [H1] Packages  When importing the package, Python searches through the directories on ``sys.path`` looking for the package subdirectory.  The __init__.py files are required to make Pyt"
        }
      ]
    },
    {
      "query": "try except 예외 처리하는 방법",
      "is_korean": true,
      "translated_query": "try except exception handling error",
      "translation_error": null,
      "top_score": 0.58272415,
      "lecture_count": 0,
      "python_doc_rst_count": 5,
      "top_3_results": [
        {
          "score": 0.58272415,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  The try statement works as follows.  * First, the *try clause* (the statement(s) between the try and  * If no exception occurs, the *except clause* is skipped "
        },
        {
          "score": 0.5488671,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  A try statement may have more than one *except clause*, to specify handlers for different exceptions. At most one handler will be executed. Handlers only handl"
        },
        {
          "score": 0.54142034,
          "source": "python_doc_rst",
          "query_type": "translated",
          "content_preview": "[TITLE] errors [H1] Handling Exceptions  The most common pattern for handling Exception is to print or log the exception and then re-raise it (allowing a caller to handle the exception as well)::     "
        }
      ]
    }
  ]
}