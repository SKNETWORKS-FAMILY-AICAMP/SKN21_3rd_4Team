
## Mermaid 모음 (발표/문서용)

### 1) `execute_dual_query_search()` 흐름도
```mermaid
flowchart TD
    %% =========================
    %% execute_dual_query_search()
    %% =========================
    U[사용자 질문 입력] --> R[build_search_config(query)\n- top_k(3/5/7)\n- sources(lecture/python_doc)\n- topic_keywords]

    R --> S1{sources에\nlecture 포함?}
    R --> S2{sources에\npython_doc 포함?}

    %% lecture branch
    S1 -->|Yes| L1[search_by_source(query,\nlecture, top_k,\nkeywords=topic_keywords)]
    L1 --> L2[lecture_results\nquery_type=original]

    %% python_doc branch
    S2 -->|Yes| P0{질문이\n한글인가?}
    P0 -->|No(영어)| P1[search_by_source(query,\npython_doc, top_k)]
    P1 --> P2[python_results\nquery_type=original]

    P0 -->|Yes(한글)| T1[translate_to_english(query)]
    T1 --> T2[search_by_source(english_query,\npython_doc, top_k)]
    T2 --> T3[python_results_en\nquery_type=translated]
    T2 --> F{best_score < 0.45\n또는 결과 없음?}
    F -->|Yes| FB[Fallback:\nsearch_by_source(query,\npython_doc, top_k,\nkeywords=topic_keywords)]
    FB --> P3[python_results_fallback\nquery_type=original]
    F -->|No| P3a[Fallback 생략]

    %% merge & post-process
    L2 --> M[결과 합치기(all_results)]
    P2 --> M
    T3 --> M
    P3 --> M

    M --> D[중복 제거\n(content[:100] 키)]
    D --> O[점수순 정렬(score desc)\n상위 top_k 반환]
    O --> RET[(results, query_info)]

    %% style
    classDef decision fill:#fff4d6,stroke:#d49b00,stroke-width:1px,color:#1f1f1f;
    classDef action fill:#eaf2ff,stroke:#2b6cb0,stroke-width:1px,color:#1f1f1f;
    classDef output fill:#e9fbef,stroke:#2f855a,stroke-width:1px,color:#1f1f1f;
    class S1,S2,P0,F decision;
    class R,L1,L2,P1,P2,T1,T2,T3,FB,P3,P3a,M,D,O action;
    class RET output;
```

---

### 2) `search_by_source()` 하이브리드 검색 흐름도
```mermaid
flowchart TD
    %% =========================
    %% search_by_source()
    %% =========================
    A[search_by_source(query, source, top_k)] --> W{단일 단어 쿼리?\nlen(query.split())==1}

    W -->|Yes| CK1[candidate_k = min(top_k*6, 30)]
    W -->|No| CK2[candidate_k = min(top_k*4, 20)]

    CK1 --> E[query_vector = embed_query(query)]
    CK2 --> E

    E --> Q[Qdrant query_points\n(limit=candidate_k,\nfilter=metadata.source)]

    Q --> K[키워드 추출\n(query_cleaned → query_keywords)]
    K --> C[후보별 점수 계산\n- vector_score(hit.score)\n- keyword_score\n- bm25_raw]
    C --> N[BM25 정규화\nbm25_score = bm25_raw / max]

    N --> S{가중치 선택}
    S -->|단일 단어| H1[hybrid = v*0.4 + k*0.3 + b*0.3]
    S -->|일반| H2[hybrid = v*0.6 + k*0.2 + b*0.2]

    H1 --> R[점수 저장(score)\n+ (단일단어) 최소점수 보정]
    H2 --> R

    R --> SORT[score로 재정렬(desc)]
    SORT --> OUT[상위 top_k 반환]

    %% style
    classDef decision fill:#fff4d6,stroke:#d49b00,stroke-width:1px,color:#1f1f1f;
    classDef action fill:#f3f4f6,stroke:#4b5563,stroke-width:1px,color:#111827;
    classDef strong fill:#e9fbef,stroke:#2f855a,stroke-width:1px,color:#1f1f1f;
    class W,S decision;
    class A,CK1,CK2,E,Q,K,C,N,H1,H2,R,SORT action;
    class OUT strong;
```


