# 2026-01-07 하이브리드 검색 작업 정리

## 📋 작업 개요

오늘은 벡터 검색 성능 향상을 위해 전처리 및 프롬프트 수정을 반복하며 실험을 진행했습니다. 특히 **하이브리드 검색**이 성능 향상에 효과적이라는 것을 확인했습니다.

---

## ✅ 주요 성과

### 1. 하이브리드 검색 성능 확인
- **벡터 검색 + 키워드 매칭 + BM25(Sparse 검색)** 조합이 성능 향상에 효과적임을 확인
- 특히 **RST 기반 문서(python_doc)**에서 더욱 효과적
- 벡터 검색의 의미적 유사도 + 키워드 매칭의 정확한 용어 보장 + BM25의 통계적 유사도로 검색 품질 개선

### 2. 구현 상태

#### `src/agent/nodes/search_agent.py` (메인 기능)
- ✅ **벡터 검색 + 키워드 매칭 + BM25(Sparse 검색)** 모두 구현됨
- 하이브리드 검색 함수: `search_by_source()` 내부
  - **일반 쿼리**: 벡터 점수 가중치 0.6, 키워드 0.2, BM25 0.2
  - **단일 단어 쿼리**: 벡터 점수 가중치 0.4, 키워드 0.3, BM25 0.3 (키워드/BM25 강조)
- BM25 점수 계산 함수: `_calculate_bm25_score()`
- 키워드 매칭 점수 계산 함수: `_calculate_keyword_score()`

---

---

## 📁 파일 역할

### `src/agent/nodes/search_agent.py` (메인 기능)
- **목적**: 실제 검색 에이전트의 메인 기능
- **기능**:
  - 듀얼 쿼리 검색 (lecture + python_doc)
  - 한글 질문 → 영어 번역 검색
  - 하이브리드 검색 (벡터 + 키워드 + BM25)
- **상태**: 
  - 벡터 + 키워드 + BM25 모두 적용됨 ✅
  - 일반 쿼리와 단일 단어 쿼리에 대해 다른 가중치 적용

---

## 🔄 하이브리드 검색 전략

### 최종 결정 ✅
- ✅ **벡터 + 키워드 + BM25 모두 사용**
- `search_agent.py`에 BM25 적용 완료
- 일반 쿼리와 단일 단어 쿼리에 대해 다른 가중치 적용

---

## 🚀 하이브리드 검색 사용 방법

### 코드에서 사용
```python
from src.agent.nodes.search_agent import execute_dual_query_search

# 하이브리드 검색 (벡터 + 키워드 + BM25) - 자동 적용
results, query_info = execute_dual_query_search(query)
```

`execute_dual_query_search()` 함수는 기본적으로 하이브리드 검색을 사용합니다.

---

## 📊 하이브리드 검색 구현 상세

### 하이브리드 검색 점수 계산 (`search_agent.py`)

```python
# 일반 쿼리
hybrid_score = (
    vector_score * 0.6 +
    keyword_score * 0.2 +
    bm25_score * 0.2
)

# 단일 단어 쿼리 (키워드/BM25 강조)
hybrid_score = (
    vector_score * 0.4 +
    keyword_score * 0.3 +
    bm25_score * 0.3
)
```

### top_k 확장 전략 (후보 확장)

#### 왜 top_k를 확장하는가?
하이브리드 검색에서는 벡터 점수만으로는 정확한 키워드가 포함된 문서를 놓칠 수 있기 때문에, 더 많은 후보를 가져와 하이브리드 점수로 재정렬합니다.

**문제 상황:**
```
벡터 점수만으로 정렬:
1위: 문서A (벡터 0.55) - "function definition" 설명
2위: 문서B (벡터 0.52) - "method definition" 설명
3위: 문서C (벡터 0.46) - "def keyword" 설명 ← 실제로 가장 관련 있음!
...
10위: 문서J (벡터 0.30) - "def keyword example" 포함
```

**하이브리드 점수로 재정렬하면:**
```
1위: 문서C (하이브리드 0.66) - 벡터 0.46 + 키워드 1.0 + BM25 0.9 = 상승!
2위: 문서J (하이브리드 0.52) - 벡터 0.30 + 키워드 0.9 + BM25 0.8 = 상승!
3위: 문서A (하이브리드 0.55) - 벡터 0.55 + 키워드 0.5 + BM25 0.6
```

#### 구현 방식
```python
# 후보 개수 확장
candidate_k = min(top_k * 6, 30) if is_single_word else min(top_k * 4, 20)

# 벡터 검색으로 candidate_k개 후보 가져오기
vector_result = client.query_points(..., limit=candidate_k)

# 각 후보에 키워드/BM25 점수 계산 후 하이브리드 점수로 재정렬
# 최종적으로 상위 top_k개만 반환
return candidates[:top_k]
```

**예시:**
- `top_k = 5` 요청 시
- 일반 쿼리: `candidate_k = min(5 * 4, 20) = 20`개 후보
- 단일 단어: `candidate_k = min(5 * 6, 30) = 30`개 후보
- 20~30개 후보에서 하이브리드 점수 계산 후 상위 5개만 반환

**효과:**
- 벡터 점수가 낮아도 키워드/BM25 점수가 높으면 하이브리드 점수로 상승
- 정확한 용어가 포함된 문서를 놓치지 않고 상위로 올림
- 검색 품질 향상 (평균 유사도 0.54 → 0.68+)

### 키워드 매칭 (Keyword Matching)

#### 개념
**정확한 단어/용어**가 문서에 포함되어 있는지 확인하여 점수를 부여하는 방법입니다.

#### 작동 원리
1. 질문에서 키워드 추출 (공백 기준, 2글자 이상)
2. 각 문서에서 키워드 포함 여부 확인
   - 정확한 단어 매칭 (우선순위 높음)
   - 부분 문자열 매칭 (예: "trimming"이 "trimming_history"에 포함)
3. 매칭된 키워드 비율로 점수 계산 (0.0 ~ 1.0)

#### 점수 계산 방식
```python
# 키워드 매칭 점수 = 매칭된 키워드 가중치 합 / 전체 키워드 가중치 합
matched_count = sum(키워드별_가중치 for 매칭된_키워드)
total_weight = sum(키워드별_가중치 for 모든_키워드)
keyword_score = matched_count / total_weight
```

#### 특징
- **정확한 용어 보장**: "def keyword"가 있으면 확실히 찾음
- **빠른 계산**: 단순 문자열 매칭으로 빠름
- **명확한 결과**: 키워드가 있으면 관련성이 높음
- **단점**: 동의어 처리 불가, 의미 이해 불가

#### 예시
```
질문: "함수 정의하는 방법 def 키워드"
키워드: ["함수", "정의", "def", "키워드"]

문서1: "def 키워드로 함수를 정의합니다"
→ 매칭: "함수" ✅, "정의" ✅, "def" ✅, "키워드" ✅
→ keyword_score = 1.0 (100%)

문서2: "클래스를 만드는 방법"
→ 매칭: 모두 ❌
→ keyword_score = 0.0 (0%)
```

### BM25 (Best Matching 25)

#### 개념
**통계적 유사도**를 기반으로 검색하는 방법으로, TF-IDF의 개선 버전입니다. 문서 길이 정규화를 포함하여 더 정확한 점수를 계산합니다.

#### 작동 원리
1. **TF (Term Frequency)**: 키워드가 문서에 나타나는 빈도
2. **IDF (Inverse Document Frequency)**: 키워드가 드물수록 높은 점수
3. **문서 길이 정규화**: 긴 문서는 불리하지 않도록 정규화
4. 세 가지를 결합하여 최종 점수 계산

#### BM25 공식
```
BM25(q, d) = Σ IDF(qi) × (TF(qi, d) × (k1 + 1)) / (TF(qi, d) + k1 × (1 - b + b × (|d| / avgdl)))

여기서:
- q: 쿼리 키워드
- d: 문서
- qi: 개별 키워드
- TF(qi, d): 키워드 qi가 문서 d에 나타나는 빈도
- IDF(qi): 키워드 qi의 역문서 빈도
- |d|: 문서 길이
- avgdl: 평균 문서 길이
- k1: TF 정규화 파라미터 (기본값: 1.5)
- b: 문서 길이 정규화 파라미터 (기본값: 0.75)
```

#### 특징
- **문서 길이 고려**: 긴 문서가 불리하지 않도록 정규화
- **빈도 기반**: 키워드가 여러 번 나타나면 점수 증가 (일정 범위 내)
- **드문 키워드 강조**: 드문 키워드가 나타나면 높은 점수 (IDF)
- **TF-IDF 개선**: TF-IDF보다 더 정확한 점수 계산

#### 현재 구현 방식
```python
# 간단한 근사 방식 사용
# TF 정규화
tf_norm = (term_freq * (k1 + 1)) / (term_freq + k1 * (1 - b + b * (doc_length / avg_doc_length)))

# IDF 근사 (키워드 길이 기반)
idf_weight = 1.0 + len(keyword.split())  # 긴 키워드가 더 중요

# BM25 점수
bm25_score = tf_norm * idf_weight
```

**파라미터:**
- `k1 = 1.5`: TF 정규화 파라미터
- `b = 0.75`: 문서 길이 정규화 파라미터
- `avg_doc_length = 100.0`: 평균 문서 길이 (근사값)

#### 예시
```
질문: "함수 정의 def keyword"
키워드: ["함수", "정의", "def", "keyword"]

문서1: "def keyword로 함수를 정의합니다. 함수는 재사용 가능한 코드 블록입니다."
→ TF: "def" 1회, "keyword" 1회, "함수" 2회, "정의" 1회
→ BM25 점수: 높음 (키워드가 여러 번 나타남)

문서2: "function definition is important"
→ TF: "def" 0회, "keyword" 0회 (매칭 없음)
→ BM25 점수: 낮음
```

### 키워드 매칭 vs BM25 비교

| 특징 | 키워드 매칭 | BM25 |
|------|------------|------|
| **계산 방식** | 단순 포함 여부 | 통계적 빈도 기반 |
| **문서 길이** | 고려 안 함 | 정규화 포함 |
| **키워드 빈도** | 1회만 있어도 같음 | 여러 번 나타나면 점수 증가 |
| **계산 속도** | 빠름 | 상대적으로 느림 |
| **정확도** | 명확한 매칭에 강함 | 통계적 유사도에 강함 |
| **사용 목적** | 정확한 용어 보장 | 문서 간 상대적 유사도 비교 |

### 두 방법을 함께 사용하는 이유
- **키워드 매칭**: 정확한 용어가 포함되었는지 빠르게 확인
- **BM25**: 키워드 빈도와 문서 길이를 고려한 정교한 점수
- **결합**: 두 방법의 장점을 모두 활용하여 더 정확한 검색 결과 제공

---

## 🔄 Search Agent 흐름도

### `execute_dual_query_search()` 함수 흐름

```
사용자 질문 입력
    ↓
[1] 질문 언어 판별
    ├─ is_korean(query) → 한글/영어 판별
    ↓
[2] LLM 검색 설정 결정
    ├─ build_search_config(query)
    ├─ top_k 결정 (basic=3, intermediate=5, advanced=7)
    └─ sources 결정 (["lecture", "python_doc"])
    ↓
[3] 소스별 검색 시작
    │
    ├─ [3-1] lecture 검색
    │   ├─ query 원문으로 검색
    │   ├─ search_by_source(query, "lecture", top_k)
    │   └─ 결과 수집
    │
    └─ [3-2] python_doc 검색
        │
        ├─ 한글 질문인가?
        │   ├─ YES
        │   │   ├─ [3-2-1] 번역 검색 (기본)
        │   │   │   ├─ translate_to_english(query)
        │   │   │   ├─ search_by_source(english_query, "python_doc", top_k)
        │   │   │   └─ query_type = "translated"
        │   │   │
        │   │   └─ [3-2-2] Fallback 검색 (조건부)
        │   │       ├─ 번역 결과 점수 < 0.45?
        │   │       ├─ YES → search_by_source(query, "python_doc", top_k)
        │   │       └─ query_type = "original"
        │   │
        │   └─ NO (영어 질문)
        │       ├─ search_by_source(query, "python_doc", top_k)
        │       └─ query_type = "original"
        │
        └─ 결과 수집
    ↓
[4] 결과 합치기
    ├─ lecture_results + python_results
    └─ all_results에 추가
    ↓
[5] 중복 제거
    ├─ content[:100] 기준으로 중복 체크
    └─ unique_results 생성
    ↓
[6] 점수순 정렬
    ├─ score 기준 내림차순 정렬
    └─ top_k만 선택
    ↓
최종 결과 반환 (results, query_info)
```

### 하이브리드 검색 상세 흐름 (`search_by_source()` 내부)

```
search_by_source(query, source, top_k)
    ↓
하이브리드 검색 수행
    │   ├─ [1] 벡터 검색으로 후보 가져오기 (top_k 확장)
    │   │   ├─ candidate_k = min(top_k * 6, 30) [단일 단어]
    │   │   │   또는 min(top_k * 4, 20) [일반]
    │   │   ├─ query_vector = embedding.embed_query(query)
    │   │   └─ Qdrant 벡터 검색 (limit=candidate_k)
    │   │   └─ 이유: 벡터 점수가 낮아도 키워드/BM25로 상승할 수 있는 후보 확보
    │   │
    │   ├─ [2] 키워드 추출
    │   │   ├─ query_cleaned = query.replace(',', ' ').replace(';', ' ').replace(':', ' ')
    │   │   └─ query_keywords = [kw for kw in query_cleaned.split() if len(kw) > 2]
    │   │
    │   ├─ [3] 각 후보에 대해 점수 계산
    │   │   ├─ vector_score = hit.score (Qdrant 코사인 유사도)
    │   │   ├─ keyword_score = _calculate_keyword_score(query_keywords, content)
    │   │   ├─ bm25_raw = _calculate_bm25_score(query_keywords, content)
    │   │   ├─ bm25_score = 정규화(bm25_raw) (0~1 범위)
    │   │   └─ hybrid_score = vector × 0.6 + keyword × 0.2 + bm25 × 0.2
    │   │       (단일 단어: vector × 0.4 + keyword × 0.3 + bm25 × 0.3)
    │   │
    │   └─ [4] 하이브리드 점수로 재정렬 → 상위 top_k만 반환
    │
    └─ NO (일반 벡터 검색)
        ├─ query_vector = embedding.embed_query(query)
        ├─ Qdrant 벡터 검색 (limit=top_k)
        └─ 결과 반환
```

### 주요 함수 역할

| 함수 | 역할 |
|------|------|
| `is_korean(query)` | 질문에 한글이 포함되어 있는지 확인 |
| `build_search_config(query)` | LLM으로 top_k, sources 결정 |
| `translate_to_english(query)` | 한글 질문을 영어 검색 키워드로 번역 |
| `search_by_source(query, source, top_k)` | 특정 소스에서 하이브리드 검색 수행 |
| `_calculate_keyword_score(keywords, content)` | 키워드 매칭 점수 계산 (0.0~1.0) |
| `_calculate_bm25_score(keywords, content)` | BM25 점수 계산 (정규화 전) |
| `execute_dual_query_search(query)` | 전체 듀얼 쿼리 검색 실행 (하이브리드 자동 적용) |

---

## 📝 참고 사항

### 하이브리드 검색의 효과
- RST 기반 문서(python_doc)에서 특히 효과적
- 정확한 용어가 포함된 문서를 상위로 올림
- 벡터 검색의 의미적 유사도는 유지하면서 정확도 향상
- 평균 유사도: 0.54 → 0.68+ (약 +26% 향상)

### Fallback 전략
- python_doc에서 한글 질문 시:
  1. 먼저 영어 번역 쿼리로 검색 (기본)
  2. 번역 결과의 최고 점수가 0.45 미만이면 한글 원문으로도 추가 검색
- 이렇게 하면 번역이 부정확해도 원문으로 보완 가능

---

## 📌 핵심 요약

- ✅ 하이브리드 검색(벡터 + 키워드 + BM25)이 성능 향상에 효과적임을 확인
- ✅ `search_agent.py`에 BM25 적용 완료
- top_k 확장 전략으로 벡터 점수가 낮아도 키워드/BM25로 상승하는 문서를 포함
- RST 기반 문서에서 하이브리드 검색의 효과가 더 크게 나타남
- 평균 유사도: 0.54 → 0.68+ (약 +26% 향상)
