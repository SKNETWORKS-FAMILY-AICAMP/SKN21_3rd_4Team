"array" --- 효율적인 숫자 배열
******************************

======================================================================

이 모듈은 문자, 정수, 부동 소수점 숫자와 같은 기본적인 값의 배열을 간
결하게 표현할 수 있는 객체 형을 정의합니다. 배열은 시퀀스 형이며 리스
트와 매우 비슷하게 행동합니다만, 그곳에 저장되는 객체의 형이 제약된다
는 점이 다릅니다. 형은 객체 생성 시에 단일 문자인 *형 코드(type code)*
를 사용하여 지정됩니다. 다음 형 코드가 정의됩니다:

+-------------+----------------------+---------------------+-------------------------+---------+
| 형 코드     | C 형                 | 파이썬 형           | 최소 크기(바이트)       | 노트    |
|=============|======================|=====================|=========================|=========|
| "'b'"       | signed char          | int                 | 1                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'B'"       | unsigned char        | int                 | 1                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'u'"       | wchar_t              | 유니코드 문자       | 2                       | (1)     |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'w'"       | Py_UCS4              | 유니코드 문자       | 4                       | (2)     |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'h'"       | signed short         | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'H'"       | unsigned short       | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'i'"       | signed int           | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'I'"       | unsigned int         | int                 | 2                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'l'"       | signed long          | int                 | 4                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'L'"       | unsigned long        | int                 | 4                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'q'"       | signed long long     | int                 | 8                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'Q'"       | unsigned long long   | int                 | 8                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'f'"       | float                | float               | 4                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+
| "'d'"       | double               | float               | 8                       |         |
+-------------+----------------------+---------------------+-------------------------+---------+

노트:

1. 플랫폼에 따라 16비트 또는 32비트 일 수 있습니다.

   버전 3.9에서 변경: "array('u')"는 이제 폐지된 "Py_UNICODE" 대신
   "wchar_t"를 C형으로 사용합니다. "Py_UNICODE"는 파이썬 3.3부터
   "wchar_t"의 별칭이라서 이 변경은 동작에 영향을 미치지 않습니다.

   Deprecated since version 3.3, will be removed in version 3.16:
   Please migrate to "'w'" typecode.

2. Added in version 3.13.

값의 실제 표현은 기계 아키텍처에 의해(엄격히 말하자면 C 구현에 의해)
결정됩니다. 실제 크기는 "array.itemsize" 어트리뷰트를 통해 액세스할 수
있습니다.

모듈은 다음 항목을 정의합니다:

array.typecodes

   사용 가능한 모든 형 코드가 있는 문자열.

모듈은 다음 형을 정의합니다:

class array.array(typecode[, initializer])

   항목이 *typecode*에 의해 제한되는 새 배열, 선택적인 *initializer*
   값으로 초기화되는데, "bytes" 나 "bytearray" 객체, 유니코드 문자열
   또는 적절한 형의 요소에 대한 이터러블이어야 합니다.

   "bytes" 나 "bytearray" 객체가 주어지면, initializer는 새 배열의
   "frombytes()" 메서드로 전달됩니다; 유니코드 문자열이 주어지면,
   initializer는 "fromunicode()" 메서드로 전달됩니다; 그렇지 않으면,
   initializer의 이터레이터가 "extend()" 메서드에 전달되어 배열에 초기
   항목들을 추가합니다.

   배열 객체는 인덱싱, 슬라이싱, 이어붙이기 및 곱셈과 같은 일반적인 시
   퀀스 연산을 지원합니다. 슬라이스 대입을 사용할 때, 대입되는 값은 같
   은 형 코드의 배열 객체여야 합니다; 다른 모든 경우에는, "TypeError"
   가 발생합니다. 배열 객체는 버퍼 인터페이스도 구현하며, *바이트열류
   객체*가 지원되는 곳이면 어디에서나 사용될 수 있습니다.

   "typecode", "initializer" 인자로 감사 이벤트(auditing event)
   "array.__new__"를 발생시킵니다.

   typecode

      배열을 만드는 데 사용된 typecode 문자.

   itemsize

      내부 표현에서 하나의 배열 항목의 길이 (바이트).

   append(x)

      배열의 끝에 값 *x*로 새 항목을 추가합니다.

   buffer_info()

      배열의 내용을 담는 데 사용된 버퍼의 현재 메모리 주소와 요소의 수
      로 표현한 길이를 제공하는 튜플 "(address, length)"를 반환합니다.
      바이트 단위의 메모리 버퍼 크기는 "array.buffer_info()[1] *
      array.itemsize"로 계산할 수 있습니다. 이것은 특정 "ioctl()" 연산
      과 같은 메모리 주소가 필요한 저수준(그리고 근본적으로 안전하지
      않은) I/O 인터페이스로 작업할 때 간혹 유용합니다. 반환된 숫자는
      배열이 존재하고 길이 변경 연산이 적용되지 않는 한 유효합니다.

      참고:

        C나 C++로 작성된 코드(이 정보를 효율적으로 사용하는 유일한 방
        법)에서 배열 객체를 사용할 때, 배열 객체가 지원하는 버퍼 인터
        페이스를 사용하는 것이 좋습니다. 이 메서드는 이전 버전과의 호
        환성을 위해 유지되며 새 코드에서는 사용하지 않아야 합니다. 버
        퍼 인터페이스는 버퍼 프로토콜에 설명되어 있습니다.

   byteswap()

      배열의 모든 항목을 "바이트 스와프(byteswap)" 합니다. 1, 2, 4 또
      는 8바이트 크기의 값에 대해서만 지원됩니다; 다른 형의 값이면
      "RuntimeError"가 발생합니다. 바이트 순서가 다른 컴퓨터에서 작성
      된 파일에서 데이터를 읽을 때 유용합니다.

   count(x)

      배열 내에서 *x*가 등장하는 횟수를 반환합니다.

   extend(iterable)

      *iterable*의 항목을 배열의 끝에 추가합니다. *iterable*이 다른 배
      열이면, *정확히* 같은 형 코드를 가져야 합니다; 그렇지 않으면,
      "TypeError"가 발생합니다. *iterable*이 배열이 아니면, 이터러블이
      어야 하며 요소는 배열에 추가할 올바른 형이어야 합니다.

   frombytes(buffer)

      *바이트열류 객체*에서 항목을 추가합니다. 내용을 기곗값(machine
      value)의 배열로 해석합니다 (마치 "fromfile()" 메서드를 사용하여
      파일에서 읽은 것처럼).

      Added in version 3.2: "fromstring()"은 명확하게 하려고
      "frombytes()"로 이름을 바꿨습니다.

   fromfile(f, n)

      *파일 객체* *f*에서 (기곗값으로) *n* 항목을 읽고 배열의 끝에 추
      가합니다. *n* 미만의 항목만 사용할 수 있으면 "EOFError"가 발생하
      지만, 사용 가능한 항목은 여전히 배열에 삽입됩니다.

   fromlist(list)

      리스트에서 항목을 추가합니다. 이것은 형 에러가 있으면 배열이 변
      경되지 않는다는 점만 제외하면 "for x in list: a.append(x)"와 동
      등합니다.

   fromunicode(s)

      주어진 유니코드 문자열의 데이터로 이 배열을 확장합니다. 배열은
      형 코드가 "'u'" 나 "'w'" 이어야 합니다; 그렇지 않으면
      "ValueError"가 발생합니다. 다른 형의 배열에 유니코드 데이터를 추
      가하려면 "array.frombytes(unicodestring.encode(enc))"를 사용하십
      시오.

   index(x[, start[, stop]])

      Return the smallest *i* such that *i* is the index of the first
      occurrence of *x* in the array.  The optional arguments *start*
      and *stop* can be specified to search for *x* within a
      subsection of the array.  Raise "ValueError" if *x* is not
      found.

      버전 3.10에서 변경: Added optional *start* and *stop*
      parameters.

   insert(i, x)

      *i* 위치 앞에 값이 *x*인 새 항목을 배열에 삽입합니다. 음수 값은
      배열 끝에 상대적인 값으로 처리됩니다.

   pop([i])

      배열에서 인덱스 *i*에 있는 항목을 제거하고 이를 반환합니다. 선택
      적 인자의 기본값은 "-1"이므로, 기본적으로 마지막 항목이 제거되고
      반환됩니다.

   remove(x)

      배열에서 첫 번째 *x*를 제거합니다.

   clear()

      배열에서 모든 항목을 제거합니다.

      Added in version 3.13.

   reverse()

      배열의 항목 순서를 뒤집습니다.

   tobytes()

      배열을 기곗값 배열로 변환하고 바이트열 표현("tofile()" 메서드로
      파일에 기록될 바이트 시퀀스와 같습니다)을 반환합니다.

      Added in version 3.2: "tostring()"은 명확하게 하려고 "tobytes()"
      로 이름을 바꿨습니다.

   tofile(f)

      모든 항목을 (기곗값으로) *파일 객체* *f*에 씁니다.

   tolist()

      배열을 같은 항목이 있는 일반 리스트로 변환합니다.

   tounicode()

      배열을 유니코드 문자열로 변환합니다. 배열은 형 코드가 "'u'" 나
      "'w'" 이어야 합니다; 그렇지 않으면 "ValueError"가 발생합니다. 다
      른 형의 배열로부터 유니코드 문자열을 얻으려면
      "array.tobytes().decode(enc)"를 사용하십시오.

배열 객체의 문자열 표현은 "array(typecode, initializer)" 형태를 취합니
다. 배열이 비어 있으면 *initializer*가 생략되고, 그렇지 않으면
*typecode*가 "'u'" 나 "'w'" 인 경우 유니코드 문자열이 되고, 그렇지 않
으면 숫자 리스트가 됩니다. 문자열 표현은 "eval()"을 사용하여 같은 형과
값을 갖는 배열로 다시 변환될 수 있음이 보장됩니다. 단 "from array
import array"를 사용하여 "array" 클래스를 임포트 한다고 가정합니다. 변
수 "inf" 와 "nan" 도 해당 부동소수점 값을 포함하는 경우 정의해야합니다
. 예:

   array('l')
   array('w', 'hello \u2641')
   array('l', [1, 2, 3, 4, 5])
   array('d', [1.0, 2.0, 3.14, -inf, nan])

더 보기:

  모듈 "struct"
     이질적인(heterogeneous) 바이너리 데이터의 패킹과 언 패킹.

  NumPy
     NumPy 패키지는 다른 배열형을 정의합니다.
