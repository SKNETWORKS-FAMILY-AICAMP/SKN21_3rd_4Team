"glob" --- 유닉스 스타일 경로명 패턴 확장
*****************************************

**소스 코드:** Lib/glob.py

======================================================================

The "glob" module finds pathnames using pattern matching rules similar
to the Unix shell. No tilde expansion is done, but "*", "?", and
character ranges expressed with "[]" will be correctly matched.  This
is done by using the "os.scandir()" and "fnmatch.fnmatch()" functions
in concert, and not by actually invoking a subshell.

참고:

  The pathnames are returned in no particular order.  If you need a
  specific order, sort the results.

Files beginning with a dot (".") can only be matched by patterns that
also start with a dot, unlike "fnmatch.fnmatch()" or
"pathlib.Path.glob()". For tilde and shell variable expansion, use
"os.path.expanduser()" and "os.path.expandvars()".

리터럴 일치를 위해서는, 대괄호 안에 메타 문자를 넣습니다. 예를 들어,
"'[?]'"는 "'?'" 문자와 일치합니다.

The "glob" module defines the following functions:

glob.glob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)

   경로 지정을 포함하는 문자열인 *pathname*에 일치하는 경로 이름의 비
   어있을 수 있는 리스트를 반환합니다. *pathname*은 절대
   ("/usr/src/Python-1.5/Makefile"처럼)나 상대("../../Tools/*/*.gif"처
   럼)일 수 있으며, 셸 스타일 와일드카드를 포함할 수 있습니다. 깨진 심
   볼릭 링크가 결과에 포함됩니다 (셸과 마찬가지로). 결과가 정렬되는지
   는 파일 시스템에 따라 다릅니다. 이 함수 호출 중에 조건을 만족하는
   파일이 제거되거나 추가되면, 해당 파일의 경로 이름이 포함될지는 지정
   되지 않습니다.

   If *root_dir* is not "None", it should be a *path-like object*
   specifying the root directory for searching.  It has the same
   effect on "glob()" as changing the current directory before calling
   it.  If *pathname* is relative, the result will contain paths
   relative to *root_dir*.

   This function can support paths relative to directory descriptors
   with the *dir_fd* parameter.

   *recursive*가 참이면, ""**"" 패턴은 모든 파일과 0개 이상의 디렉터리
   , 서브 디렉터리 및 디렉터리로의 심볼릭 링크와 일치합니다. 패턴 다음
   에 "os.sep"이나 "os.altsep"이 오면, 파일은 일치하지 않습니다.

   If *include_hidden* is true, ""**"" pattern will match hidden
   directories.

   "pathname", "recursive"를 인자로 감사 이벤트(auditing event)
   "glob.glob"을 발생시킵니다.

   "pathname", "recursive", "root_dir", "dir_fd"를 인자로 감사 이벤트
   (auditing event) "glob.glob/2"을 발생시킵니다.

   참고:

     커다란 디렉터리 트리에서 ""**"" 패턴을 사용하면 과도한 시간이 걸
     릴 수 있습니다.

   참고:

     This function may return duplicate path names if *pathname*
     contains multiple ""**"" patterns and *recursive* is true.

   버전 3.5에서 변경: ""**"" 를 사용하는 재귀적 glob 지원.

   버전 3.10에서 변경: *root_dir* 과 *dir_fd* 매개 변수를 추가했습니다
   .

   버전 3.11에서 변경: *include_hidden* 매개 변수를 추가했습니다.

glob.iglob(pathname, *, root_dir=None, dir_fd=None, recursive=False, include_hidden=False)

   실제로 동시에 저장하지 않고 "glob()"과 같은 값을 산출하는 *이터레이
   터*를 반환합니다.

   "pathname", "recursive"를 인자로 감사 이벤트(auditing event)
   "glob.glob"을 발생시킵니다.

   "pathname", "recursive", "root_dir", "dir_fd"를 인자로 감사 이벤트
   (auditing event) "glob.glob/2"을 발생시킵니다.

   참고:

     This function may return duplicate path names if *pathname*
     contains multiple ""**"" patterns and *recursive* is true.

   버전 3.5에서 변경: ""**"" 를 사용하는 재귀적 glob 지원.

   버전 3.10에서 변경: *root_dir* 과 *dir_fd* 매개 변수를 추가했습니다
   .

   버전 3.11에서 변경: *include_hidden* 매개 변수를 추가했습니다.

glob.escape(pathname)

   모든 특수 문자("'?'", "'*'" 및 "'['")를 이스케이프 처리합니다. 이것
   은 특수 문자가 들어있을 수 있는 임의의 리터럴 문자열을 일치시키려는
   경우에 유용합니다. 드라이브/UNC 셰어 포인트의 특수 문자는 이스케이
   프 되지 않습니다, 예를 들어, 윈도우에서 "escape('//?/c:/Quo
   vadis?.txt')"는 "'//?/c:/Quo vadis[?].txt'"를 반환합니다.

   Added in version 3.4.

glob.translate(pathname, *, recursive=False, include_hidden=False, seps=None)

   Convert the given path specification to a regular expression for
   use with "re.match()". The path specification can contain shell-
   style wildcards.

   예를 들어:

   >>> import glob, re
   >>>
   >>> regex = glob.translate('**/*.txt', recursive=True, include_hidden=True)
   >>> regex
   '(?s:(?:.+/)?[^/]*\\.txt)\\z'
   >>> reobj = re.compile(regex)
   >>> reobj.match('foo/bar/baz.txt')
   <re.Match object; span=(0, 15), match='foo/bar/baz.txt'>

   Path separators and segments are meaningful to this function,
   unlike "fnmatch.translate()". By default wildcards do not match
   path separators, and "*" pattern segments match precisely one path
   segment.

   If *recursive* is true, the pattern segment ""**"" will match any
   number of path segments.

   If *include_hidden* is true, wildcards can match path segments that
   start with a dot (".").

   A sequence of path separators may be supplied to the *seps*
   argument. If not given, "os.sep" and "altsep" (if available) are
   used.

   더 보기:

     "pathlib.PurePath.full_match()" and "pathlib.Path.glob()"
     methods, which call this function to implement pattern matching
     and globbing.

   Added in version 3.13.


예제
====

다음과 같은 파일을 포함하는 디렉터리를 고려하십시오: "1.gif", "2.txt",
"card.gif" 및 "3.txt" 파일 만 포함하는 서브 디렉터리 "sub". "glob()"은
다음과 같은 결과를 산출합니다. 경로의 선행 구성 요소가 보존되는 방법에
유의하십시오.

   >>> import glob
   >>> glob.glob('./[0-9].*')
   ['./1.gif', './2.txt']
   >>> glob.glob('*.gif')
   ['1.gif', 'card.gif']
   >>> glob.glob('?.gif')
   ['1.gif']
   >>> glob.glob('**/*.txt', recursive=True)
   ['2.txt', 'sub/3.txt']
   >>> glob.glob('./**/', recursive=True)
   ['./', './sub/']

디렉터리에 "."으로 시작하는 파일이 있으면, 기본적으로 일치하지 않습니
다. 예를 들어, "card.gif" 와 ".card.gif"를 포함하는 디렉터리를 고려하
십시오:

   >>> import glob
   >>> glob.glob('*.gif')
   ['card.gif']
   >>> glob.glob('.c*')
   ['.card.gif']

더 보기: "fnmatch" 모듈은 셸 스타일 파일명 (경로가 아님) 확장을 제공합니다.

더 보기: "pathlib" 모듈은 고수준의 경로 객체를 제공합니다.
