"argparse" --- Parser for command-line options, arguments and subcommands
*************************************************************************

Added in version 3.2.

**소스 코드:** Lib/argparse.py

참고:

  While "argparse" is the default recommended standard library module
  for implementing basic command line applications, authors with more
  exacting requirements for exactly how their command line
  applications behave may find it doesn't provide the necessary level
  of control. Refer to Choosing an argument parsing library for
  alternatives to consider when "argparse" doesn't support behaviors
  that the application requires (such as entirely disabling support
  for interspersed options and positional arguments, or accepting
  option parameter values that start with "-" even when they
  correspond to another defined option).

======================================================================


자습서
^^^^^^

이 페이지는 API 레퍼런스 정보를 담고 있습니다. 파이썬 명령행 파싱에 대
한 더 친절한 소개를 원하시면, argparse 자습서 를 보십시오.

The "argparse" module makes it easy to write user-friendly command-
line interfaces. The program defines what arguments it requires, and
"argparse" will figure out how to parse those out of "sys.argv".  The
"argparse" module also automatically generates help and usage
messages.  The module will also issue errors when users give the
program invalid arguments.

The "argparse" module's support for command-line interfaces is built
around an instance of "argparse.ArgumentParser".  It is a container
for argument specifications and has options that apply to the parser
as whole:

   parser = argparse.ArgumentParser(
                       prog='ProgramName',
                       description='What the program does',
                       epilog='Text at the bottom of help')

The "ArgumentParser.add_argument()" method attaches individual
argument specifications to the parser.  It supports positional
arguments, options that accept values, and on/off flags:

   parser.add_argument('filename')           # positional argument
   parser.add_argument('-c', '--count')      # option that takes a value
   parser.add_argument('-v', '--verbose',
                       action='store_true')  # on/off flag

The "ArgumentParser.parse_args()" method runs the parser and places
the extracted data in a "argparse.Namespace" object:

   args = parser.parse_args()
   print(args.filename, args.count, args.verbose)

참고:

  If you're looking for a guide about how to upgrade "optparse" code
  to "argparse", see Upgrading Optparse Code.


ArgumentParser 객체
===================

class argparse.ArgumentParser(prog=None, usage=None, description=None, epilog=None, parents=[], formatter_class=argparse.HelpFormatter, prefix_chars='-', fromfile_prefix_chars=None, argument_default=None, conflict_handler='error', add_help=True, allow_abbrev=True, exit_on_error=True, *, suggest_on_error=False, color=True)

   새로운 "ArgumentParser" 객체를 만듭니다. 모든 매개 변수는 키워드 인
   자로 전달되어야 합니다. 매개 변수마다 아래에서 더 자세히 설명되지만
   , 요약하면 다음과 같습니다:

   * prog - The name of the program (default: generated from the
     "__main__" module attributes and "sys.argv[0]")

   * usage - 프로그램 사용법을 설명하는 문자열 (기본값: 파서에 추가된
     인자로부터 만들어지는 값)

   * description - Text to display before the argument help (by
     default, no text)

   * epilog - Text to display after the argument help (by default, no
     text)

   * parents - "ArgumentParser" 객체들의 리스트이고, 이 들의 인자들도
     포함된다

   * formatter_class - 도움말 출력을 사용자 정의하기 위한 클래스

   * prefix_chars - 선택 인자 앞에 붙는 문자 집합 (기본값: '-').

   * fromfile_prefix_chars - 추가 인자를 읽어야 하는 파일 앞에 붙는 문
     자 집합 (기본값: "None").

   * argument_default - 인자의 전역 기본값 (기본값: "None")

   * conflict_handler - 충돌하는 선택 사항을 해결하기 위한 전략 (일반
     적으로 불필요함)

   * add_help - 파서에 "-h/--help" 옵션을 추가합니다 (기본값: "True")

   * allow_abbrev - Allows long options to be abbreviated if the
     abbreviation is unambiguous (default: "True")

   * exit_on_error - Determines whether or not "ArgumentParser" exits
     with error info when an error occurs. (default: "True")

   * suggest_on_error - Enables suggestions for mistyped argument
     choices and subparser names (default: "False")

   * color - Allow color output (default: "True")

   버전 3.5에서 변경: *allow_abbrev* 매개 변수가 추가되었습니다.

   버전 3.8에서 변경: 이전 버전에서는, *allow_abbrev*는 "-vv"가 "-v
   -v"를 뜻하는 것과 같은 짧은 플래그의 그룹화도 비활성화했습니다.

   버전 3.9에서 변경: *exit_on_error* 매개 변수가 추가되었습니다.

   버전 3.14에서 변경: *suggest_on_error* and *color* parameters were
   added.

다음 절에서는 이들 각각의 사용 방법에 관해 설명합니다.


prog
----

By default, "ArgumentParser" calculates the name of the program to
display in help messages depending on the way the Python interpreter
was run:

* The "base name" of "sys.argv[0]" if a file was passed as argument.

* The Python interpreter name followed by "sys.argv[0]" if a directory
  or a zipfile was passed as argument.

* The Python interpreter name followed by "-m" followed by the module
  or package name if the "-m" option was used.

This default is almost always desirable because it will make the help
messages match the string that was used to invoke the program on the
command line. However, to change this default behavior, another value
can be supplied using the "prog=" argument to "ArgumentParser":

   >>> parser = argparse.ArgumentParser(prog='myprogram')
   >>> parser.print_help()
   usage: myprogram [-h]

   options:
    -h, --help  show this help message and exit

Note that the program name, whether determined from "sys.argv[0]",
from the "__main__" module attributes or from the "prog=" argument, is
available to help messages using the "%(prog)s" format specifier.

   >>> parser = argparse.ArgumentParser(prog='myprogram')
   >>> parser.add_argument('--foo', help='foo of the %(prog)s program')
   >>> parser.print_help()
   usage: myprogram [-h] [--foo FOO]

   options:
    -h, --help  show this help message and exit
    --foo FOO   foo of the myprogram program

버전 3.14에서 변경: The default "prog" value now reflects how
"__main__" was actually executed, rather than always being
"os.path.basename(sys.argv[0])".


usage
-----

By default, "ArgumentParser" calculates the usage message from the
arguments it contains. The default message can be overridden with the
"usage=" keyword argument:

   >>> parser = argparse.ArgumentParser(prog='PROG', usage='%(prog)s [options]')
   >>> parser.add_argument('--foo', nargs='?', help='foo help')
   >>> parser.add_argument('bar', nargs='+', help='bar help')
   >>> parser.print_help()
   usage: PROG [options]

   positional arguments:
    bar          bar help

   options:
    -h, --help   show this help message and exit
    --foo [FOO]  foo help

"%(prog)s" 포맷 지정자는 사용법 메시지에서 프로그램 이름을 채울 때 사
용할 수 있습니다.

When a custom usage message is specified for the main parser, you may
also want to consider passing  the "prog" argument to
"add_subparsers()" or the "prog" and the "usage" arguments to
"add_parser()", to ensure consistent command prefixes and usage
information across subparsers.


description
-----------

Most calls to the "ArgumentParser" constructor will use the
"description=" keyword argument.  This argument gives a brief
description of what the program does and how it works.  In help
messages, the description is displayed between the command-line usage
string and the help messages for the various arguments.

기본적으로, 설명은 주어진 공간에 맞도록 줄 바꿈 됩니다. 이 동작을 변경
하려면 formatter_class 인자를 참조하십시오.


epilog
------

일부 프로그램은 인자에 대한 설명 뒤에 프로그램에 대한 추가 설명을 표시
하려고 합니다. 이러한 텍스트는 "epilog=" 에 대한 인자를
"ArgumentParser" 에 사용하여 지정할 수 있습니다:

   >>> parser = argparse.ArgumentParser(
   ...     description='A foo that bars',
   ...     epilog="And that's how you'd foo a bar")
   >>> parser.print_help()
   usage: argparse.py [-h]

   A foo that bars

   options:
    -h, --help  show this help message and exit

   And that's how you'd foo a bar

description 인자와 마찬가지로, "epilog=" 텍스트가 기본적으로 줄 바꿈
됩니다만, 이 동작은 formatter_class 인자를 "ArgumentParser" 에 제공해
서 조정할 수 있습니다.


parents
-------

때로는 여러 파서가 공통 인자 집합을 공유하는 경우가 있습니다. 이러한
인자의 정의를 반복하는 대신, 모든 공유 인자를 갖는 파서를
"ArgumentParser" 에 "parents=" 인자로 전달할 수 있습니다. "parents="
인자는 "ArgumentParser" 객체의 리스트를 취하여, 그것들로부터 모든 위치
와 선택 액션을 수집해서 새로 만들어지는 "ArgumentParser" 객체에 추가합
니다:

   >>> parent_parser = argparse.ArgumentParser(add_help=False)
   >>> parent_parser.add_argument('--parent', type=int)

   >>> foo_parser = argparse.ArgumentParser(parents=[parent_parser])
   >>> foo_parser.add_argument('foo')
   >>> foo_parser.parse_args(['--parent', '2', 'XXX'])
   Namespace(foo='XXX', parent=2)

   >>> bar_parser = argparse.ArgumentParser(parents=[parent_parser])
   >>> bar_parser.add_argument('--bar')
   >>> bar_parser.parse_args(['--bar', 'YYY'])
   Namespace(bar='YYY', parent=None)

대부분의 부모 파서는 "add_help=False" 를 지정합니다. 그렇지 않으면,
"ArgumentParser" 는 (하나는 부모에, 하나는 자식에 있는) 두 개의
"-h/--help" 옵션을 보게 될 것이고, 에러를 발생시킵니다.

참고:

  "parents=" 를 통해 전달하기 전에 파서를 완전히 초기화해야 합니다. 자
  식 파서 다음에 부모 파서를 변경하면 자식에 반영되지 않습니다.


formatter_class
---------------

"ArgumentParser" 객체는 대체 포매팅 클래스를 지정함으로써 도움말 포매
팅을 사용자 정의 할 수 있도록 합니다. 현재 네 가지 클래스가 있습니다:

class argparse.RawDescriptionHelpFormatter
class argparse.RawTextHelpFormatter
class argparse.ArgumentDefaultsHelpFormatter
class argparse.MetavarTypeHelpFormatter

"RawDescriptionHelpFormatter" 와 "RawTextHelpFormatter" 는 텍스트 설명
이 표시되는 방법을 더 제어할 수 있도록 합니다. 기본적으로,
"ArgumentParser" 객체는 명령행 도움말 메시지에서 description 및 epilog
텍스트를 줄 바꿈 합니다.:

   >>> parser = argparse.ArgumentParser(
   ...     prog='PROG',
   ...     description='''this description
   ...         was indented weird
   ...             but that is okay''',
   ...     epilog='''
   ...             likewise for this epilog whose whitespace will
   ...         be cleaned up and whose words will be wrapped
   ...         across a couple lines''')
   >>> parser.print_help()
   usage: PROG [-h]

   this description was indented weird but that is okay

   options:
    -h, --help  show this help message and exit

   likewise for this epilog whose whitespace will be cleaned up and whose words
   will be wrapped across a couple lines

"RawDescriptionHelpFormatter" 를 "formatter_class=" 로 전달하는 것은
description 과 epilog 가 이미 올바르게 포맷되어 있어서 줄 바꿈 되어서
는 안 된다는 것을 가리킵니다:

   >>> parser = argparse.ArgumentParser(
   ...     prog='PROG',
   ...     formatter_class=argparse.RawDescriptionHelpFormatter,
   ...     description=textwrap.dedent('''\
   ...         Please do not mess up this text!
   ...         --------------------------------
   ...             I have indented it
   ...             exactly the way
   ...             I want it
   ...         '''))
   >>> parser.print_help()
   usage: PROG [-h]

   Please do not mess up this text!
   --------------------------------
      I have indented it
      exactly the way
      I want it

   options:
    -h, --help  show this help message and exit

"RawTextHelpFormatter" maintains whitespace for all sorts of help
text, including argument descriptions. However, multiple newlines are
replaced with one. If you wish to preserve multiple blank lines, add
spaces between the newlines.

"ArgumentDefaultsHelpFormatter" 는 기본값에 대한 정보를 각각의 인자 도
움말 메시지에 자동으로 추가합니다:

   >>> parser = argparse.ArgumentParser(
   ...     prog='PROG',
   ...     formatter_class=argparse.ArgumentDefaultsHelpFormatter)
   >>> parser.add_argument('--foo', type=int, default=42, help='FOO!')
   >>> parser.add_argument('bar', nargs='*', default=[1, 2, 3], help='BAR!')
   >>> parser.print_help()
   usage: PROG [-h] [--foo FOO] [bar ...]

   positional arguments:
    bar         BAR! (default: [1, 2, 3])

   options:
    -h, --help  show this help message and exit
    --foo FOO   FOO! (default: 42)

"MetavarTypeHelpFormatter" 는 각 인자 값의 표시 이름으로 (일반 포매터
처럼 dest 를 사용하는 대신에) type 인자의 이름을 사용합니다:

   >>> parser = argparse.ArgumentParser(
   ...     prog='PROG',
   ...     formatter_class=argparse.MetavarTypeHelpFormatter)
   >>> parser.add_argument('--foo', type=int)
   >>> parser.add_argument('bar', type=float)
   >>> parser.print_help()
   usage: PROG [-h] [--foo int] float

   positional arguments:
     float

   options:
     -h, --help  show this help message and exit
     --foo int


prefix_chars
------------

Most command-line options will use "-" as the prefix, e.g. "-f/--foo".
Parsers that need to support different or additional prefix
characters, e.g. for options like "+f" or "/foo", may specify them
using the "prefix_chars=" argument to the "ArgumentParser"
constructor:

   >>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='-+')
   >>> parser.add_argument('+f')
   >>> parser.add_argument('++bar')
   >>> parser.parse_args('+f X ++bar Y'.split())
   Namespace(bar='Y', f='X')

"prefix_chars=" 인자의 기본값은 "'-'" 입니다. "-" 를 포함하지 않는 문
자 집합을 제공하면 "-f/--foo" 옵션이 허용되지 않게 됩니다.


fromfile_prefix_chars
---------------------

Sometimes, when dealing with a particularly long argument list, it may
make sense to keep the list of arguments in a file rather than typing
it out at the command line.  If the "fromfile_prefix_chars=" argument
is given to the "ArgumentParser" constructor, then arguments that
start with any of the specified characters will be treated as files,
and will be replaced by the arguments they contain.  For example:

   >>> with open('args.txt', 'w', encoding=sys.getfilesystemencoding()) as fp:
   ...     fp.write('-f\nbar')
   ...
   >>> parser = argparse.ArgumentParser(fromfile_prefix_chars='@')
   >>> parser.add_argument('-f')
   >>> parser.parse_args(['-f', 'foo', '@args.txt'])
   Namespace(f='bar')

Arguments read from a file must be one per line by default (but see
also "convert_arg_line_to_args()") and are treated as if they were in
the same place as the original file referencing argument on the
command line.  So in the example above, the expression "['-f', 'foo',
'@args.txt']" is considered equivalent to the expression "['-f',
'foo', '-f', 'bar']".

참고:

  Empty lines are treated as empty strings ("''"), which are allowed
  as values but not as arguments. Empty lines that are read as
  arguments will result in an "unrecognized arguments" error.

"ArgumentParser" uses *filesystem encoding and error handler* to read
the file containing arguments.

"fromfile_prefix_chars=" 인자의 기본값은 "None" 입니다. 이것은 인자가
절대로 파일 참조로 취급되지 않는다는 것을 의미합니다.

버전 3.12에서 변경: "ArgumentParser" changed encoding and errors to
read arguments files from default (e.g.
"locale.getpreferredencoding(False)" and ""strict"") to the
*filesystem encoding and error handler*. Arguments file should be
encoded in UTF-8 instead of ANSI Codepage on Windows.


argument_default
----------------

일반적으로 인자의 기본값은 "add_argument()" 에 기본값을 전달하거나 특
정 이름-값 쌍 집합을 사용하여 "set_defaults()" 메서드를 호출하여 지정
됩니다. 그러나 때로는, 파서 전체에 적용되는 단일 기본값을 지정하는 것
이 유용 할 수 있습니다. 이것은 "argument_default=" 키워드 인자를
"ArgumentParser" 에 전달함으로써 이루어질 수 있습니다. 예를 들어,
"parse_args()" 호출에서 어트리뷰트 생성을 전역적으로 억제하려면,
"argument_default=SUPPRESS" 를 제공합니다:

   >>> parser = argparse.ArgumentParser(argument_default=argparse.SUPPRESS)
   >>> parser.add_argument('--foo')
   >>> parser.add_argument('bar', nargs='?')
   >>> parser.parse_args(['--foo', '1', 'BAR'])
   Namespace(bar='BAR', foo='1')
   >>> parser.parse_args([])
   Namespace()


allow_abbrev
------------

일반적으로 "ArgumentParser" 의 "parse_args()" 메서드에 인자 리스트를
건네주면 긴 옵션의 약어를 인식합니다.

"allow_abbrev" 를 "False" 로 설정하면 이 기능을 비활성화 할 수 있습니
다:

   >>> parser = argparse.ArgumentParser(prog='PROG', allow_abbrev=False)
   >>> parser.add_argument('--foobar', action='store_true')
   >>> parser.add_argument('--foonley', action='store_false')
   >>> parser.parse_args(['--foon'])
   usage: PROG [-h] [--foobar] [--foonley]
   PROG: error: unrecognized arguments: --foon

Added in version 3.5.


conflict_handler
----------------

"ArgumentParser" 객체는 같은 옵션 문자열을 가진 두 개의 액션을 허용하
지 않습니다. 기본적으로 "ArgumentParser" 객체는 이미 사용 중인 옵션 문
자열로 인자를 만들려고 시도하면 예외를 발생시킵니다

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-f', '--foo', help='old foo help')
   >>> parser.add_argument('--foo', help='new foo help')
   Traceback (most recent call last):
    ..
   ArgumentError: argument --foo: conflicting option string(s): --foo

때로는 (예를 들어 parents 를 사용하는 경우) 같은 옵션 문자열을 갖는 예
전의 인자들을 간단히 대체하는 것이 유용 할 수 있습니다. 이 동작을 얻으
려면, "ArgumentParser" 의 "conflict_handler=" 인자에 "'resolve'" 값을
제공합니다:

   >>> parser = argparse.ArgumentParser(prog='PROG', conflict_handler='resolve')
   >>> parser.add_argument('-f', '--foo', help='old foo help')
   >>> parser.add_argument('--foo', help='new foo help')
   >>> parser.print_help()
   usage: PROG [-h] [-f FOO] [--foo FOO]

   options:
    -h, --help  show this help message and exit
    -f FOO      old foo help
    --foo FOO   new foo help

"ArgumentParser" 객체는 모든 옵션 문자열이 재정의된 경우에만 액션을 제
거합니다. 위의 예에서, 이전의 "-f/--foo" 액션은 "--foo" 옵션 문자열만
재정의되었기 때문에 "-f" 액션으로 유지됩니다.


add_help
--------

By default, "ArgumentParser" objects add an option which simply
displays the parser's help message. If "-h" or "--help" is supplied at
the command line, the "ArgumentParser" help will be printed.

때에 따라, 이 도움말 옵션을 추가하지 않도록 설정하는 것이 유용 할 수
있습니다. "add_help=" 인자를 "False" 로 "ArgumentParser" 에 전달하면
됩니다:

   >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
   >>> parser.add_argument('--foo', help='foo help')
   >>> parser.print_help()
   usage: PROG [--foo FOO]

   options:
    --foo FOO  foo help

도움말 옵션은 일반적으로 "-h/--help" 입니다. 예외는 "prefix_chars=" 가
지정되고 "-" 을 포함하지 않는 경우입니다. 이 경우 "-h" 와 "--help" 는
유효한 옵션이 아닙니다. 이 경우, "prefix_chars" 의 첫 번째 문자가 도움
말 옵션 접두어로 사용됩니다:

   >>> parser = argparse.ArgumentParser(prog='PROG', prefix_chars='+/')
   >>> parser.print_help()
   usage: PROG [+h]

   options:
     +h, ++help  show this help message and exit


exit_on_error
-------------

Normally, when you pass an invalid argument list to the "parse_args()"
method of an "ArgumentParser", it will print a *message* to
"sys.stderr" and exit with a status code of 2.

If the user would like to catch errors manually, the feature can be
enabled by setting "exit_on_error" to "False":

   >>> parser = argparse.ArgumentParser(exit_on_error=False)
   >>> parser.add_argument('--integers', type=int)
   _StoreAction(option_strings=['--integers'], dest='integers', nargs=None, const=None, default=None, type=<class 'int'>, choices=None, help=None, metavar=None)
   >>> try:
   ...     parser.parse_args('--integers a'.split())
   ... except argparse.ArgumentError:
   ...     print('Catching an argumentError')
   ...
   Catching an argumentError

Added in version 3.9.


suggest_on_error
----------------

By default, when a user passes an invalid argument choice or subparser
name, "ArgumentParser" will exit with error info and list the
permissible argument choices (if specified) or subparser names as part
of the error message.

If the user would like to enable suggestions for mistyped argument
choices and subparser names, the feature can be enabled by setting
"suggest_on_error" to "True". Note that this only applies for
arguments when the choices specified are strings:

   >>> parser = argparse.ArgumentParser(description='Process some integers.',
                                        suggest_on_error=True)
   >>> parser.add_argument('--action', choices=['sum', 'max'])
   >>> parser.add_argument('integers', metavar='N', type=int, nargs='+',
   ...                     help='an integer for the accumulator')
   >>> parser.parse_args(['--action', 'sumn', 1, 2, 3])
   tester.py: error: argument --action: invalid choice: 'sumn', maybe you meant 'sum'? (choose from 'sum', 'max')

If you're writing code that needs to be compatible with older Python
versions and want to opportunistically use "suggest_on_error" when
it's available, you can set it as an attribute after initializing the
parser instead of using the keyword argument:

   >>> parser = argparse.ArgumentParser(description='Process some integers.')
   >>> parser.suggest_on_error = True

Added in version 3.14.


color
-----

By default, the help message is printed in color using ANSI escape
sequences. If you want plain text help messages, you can disable this
in your local environment, or in the argument parser itself by setting
"color" to "False":

   >>> parser = argparse.ArgumentParser(description='Process some integers.',
   ...                                  color=False)
   >>> parser.add_argument('--action', choices=['sum', 'max'])
   >>> parser.add_argument('integers', metavar='N', type=int, nargs='+',
   ...                     help='an integer for the accumulator')
   >>> parser.parse_args(['--help'])

Note that when "color=True", colored output depends on both
environment variables and terminal capabilities.  However, if
"color=False", colored output is always disabled, even if environment
variables like "FORCE_COLOR" are set.

참고:

  Error messages will include color codes when redirecting stderr to a
  file. To avoid this, set the "NO_COLOR" or "PYTHON_COLORS"
  environment variable (for example, "NO_COLOR=1 python script.py 2>
  errors.txt").

Added in version 3.14.


add_argument() 메서드
=====================

ArgumentParser.add_argument(name or flags..., *[, action][, nargs][, const][, default][, type][, choices][, required][, help][, metavar][, dest][, deprecated])

   단일 명령행 인자를 구문 분석하는 방법을 정의합니다. 매개 변수마다
   아래에서 더 자세히 설명되지만, 요약하면 다음과 같습니다:

   * name or flags - Either a name or a list of option strings, e.g.
     "'foo'" or "'-f', '--foo'".

   * action - 명령행에서 이 인자가 발견될 때 수행 할 액션의 기본형.

   * nargs - 소비되어야 하는 명령행 인자의 수.

   * const - 일부 action 및 nargs 를 선택할 때 필요한 상숫값.

   * default - 인자가 명령행에 없고 namespace 객체에 없으면 생성되는
     값.

   * type - 명령행 인자가 변환되어야 할 형.

   * choices - A sequence of the allowable values for the argument.

   * required - 명령행 옵션을 생략 할 수 있는지 아닌지 (선택적일 때만
     ).

   * help - 인자가 하는 일에 대한 간단한 설명.

   * metavar - 사용 메시지에 사용되는 인자의 이름.

   * dest - "parse_args()" 가 반환하는 객체에 추가될 어트리뷰트의 이름
     .

   * deprecated - Whether or not use of the argument is deprecated.

다음 절에서는 이들 각각의 사용 방법에 관해 설명합니다.


name or flags
-------------

The "add_argument()" method must know whether an optional argument,
like "-f" or "--foo", or a positional argument, like a list of
filenames, is expected.  The first arguments passed to
"add_argument()" must therefore be either a series of flags, or a
simple argument name.

For example, an optional argument could be created like:

   >>> parser.add_argument('-f', '--foo')

반면에 위치 인자는 이렇게 만들어집니다:

   >>> parser.add_argument('bar')

"parse_args()" 가 호출되면, 선택 인자는 "-" 접두사로 식별되고, 그 밖의
인자는 위치 인자로 간주합니다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-f', '--foo')
   >>> parser.add_argument('bar')
   >>> parser.parse_args(['BAR'])
   Namespace(bar='BAR', foo=None)
   >>> parser.parse_args(['BAR', '--foo', 'FOO'])
   Namespace(bar='BAR', foo='FOO')
   >>> parser.parse_args(['--foo', 'FOO'])
   usage: PROG [-h] [-f FOO] bar
   PROG: error: the following arguments are required: bar

By default, "argparse" automatically handles the internal naming and
display names of arguments, simplifying the process without requiring
additional configuration. As such, you do not need to specify the dest
and metavar parameters. The dest parameter defaults to the argument
name with underscores "_" replacing hyphens "-" . The metavar
parameter defaults to the upper-cased name. For example:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('--foo-bar')
   >>> parser.parse_args(['--foo-bar', 'FOO-BAR']
   Namespace(foo_bar='FOO-BAR')
   >>> parser.print_help()
   usage:  [-h] [--foo-bar FOO-BAR]

   optional arguments:
    -h, --help  show this help message and exit
    --foo-bar FOO-BAR


action
------

"ArgumentParser" 객체는 명령행 인자를 액션과 연관시킵니다. 대부분의 액
션은 단순히 "parse_args()" 에 의해 반환된 객체에 어트리뷰트를 추가하기
만 하지만, 액션은 관련된 명령행 인자로 무엇이든 할 수 있습니다.
"action" 키워드 인자는 명령행 인자의 처리 방법을 지정합니다. 제공되는
액션은 다음과 같습니다:

* "'store'" - This just stores the argument's value.  This is the
  default action.

* "'store_const'" - This stores the value specified by the const
  keyword argument; note that the const keyword argument defaults to
  "None".  The "'store_const'" action is most commonly used with
  optional arguments that specify some sort of flag.  For example:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', action='store_const', const=42)
     >>> parser.parse_args(['--foo'])
     Namespace(foo=42)

* "'store_true'" and "'store_false'" - These are special cases of
  "'store_const'" that respectively store the values "True" and
  "False" with default values of "False" and "True":

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', action='store_true')
     >>> parser.add_argument('--bar', action='store_false')
     >>> parser.add_argument('--baz', action='store_false')
     >>> parser.parse_args('--foo --bar'.split())
     Namespace(foo=True, bar=False, baz=True)

* "'append'" - This appends each argument value to a list. It is
  useful for allowing an option to be specified multiple times. If the
  default value is a non-empty list, the parsed value will start with
  the default list's elements and any values from the command line
  will be appended after those default values. Example usage:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', action='append', default=['0'])
     >>> parser.parse_args('--foo 1 --foo 2'.split())
     Namespace(foo=['0', '1', '2'])

* "'append_const'" - This appends the value specified by the const
  keyword argument to a list; note that the const keyword argument
  defaults to "None". The "'append_const'" action is typically useful
  when multiple arguments need to store constants to the same list.
  For example:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--str', dest='types', action='append_const', const=str)
     >>> parser.add_argument('--int', dest='types', action='append_const', const=int)
     >>> parser.parse_args('--str --int'.split())
     Namespace(types=[<class 'str'>, <class 'int'>])

* "'extend'" - This appends each item from a multi-value argument to a
  list. The "'extend'" action is typically used with the nargs keyword
  argument value "'+'" or "'*'". Note that when nargs is "None" (the
  default) or "'?'", each character of the argument string will be
  appended to the list. Example usage:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument("--foo", action="extend", nargs="+", type=str)
     >>> parser.parse_args(["--foo", "f1", "--foo", "f2", "f3", "f4"])
     Namespace(foo=['f1', 'f2', 'f3', 'f4'])

  Added in version 3.8.

* "'count'" - This counts the number of times an argument occurs. For
  example, this is useful for increasing verbosity levels:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--verbose', '-v', action='count', default=0)
     >>> parser.parse_args(['-vvv'])
     Namespace(verbose=3)

  참고, 명시적으로 *0*으로 설정되지 않으면 *default*는 "None"이 됩니다
  .

* "'help'" - 현재 파서의 모든 옵션에 대한 완전한 도움말 메시지를 출력
  하고 종료합니다. 기본적으로 help 액션은 자동으로 파서에 추가됩니다.
  출력이 만들어지는 방법에 대한 자세한 내용은 "ArgumentParser" 를 보세
  요.

* "'version'" - "add_argument()" 호출에서 "version=" 키워드 인자를 기
  대하고, 호출되면 버전 정보를 출력하고 종료합니다:

     >>> import argparse
     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('--version', action='version', version='%(prog)s 2.0')
     >>> parser.parse_args(['--version'])
     PROG 2.0

You may also specify an arbitrary action by passing an "Action"
subclass (e.g. "BooleanOptionalAction") or other object that
implements the same interface. Only actions that consume command-line
arguments (e.g. "'store'", "'append'", "'extend'", or custom actions
with non-zero "nargs") can be used with positional arguments.

The recommended way to create a custom action is to extend "Action",
overriding the "__call__()" method and optionally the "__init__()" and
"format_usage()" methods. You can also register custom actions using
the "register()" method and reference them by their registered name.

사용자 정의 액션의 예:

   >>> class FooAction(argparse.Action):
   ...     def __init__(self, option_strings, dest, nargs=None, **kwargs):
   ...         if nargs is not None:
   ...             raise ValueError("nargs not allowed")
   ...         super().__init__(option_strings, dest, **kwargs)
   ...     def __call__(self, parser, namespace, values, option_string=None):
   ...         print('%r %r %r' % (namespace, values, option_string))
   ...         setattr(namespace, self.dest, values)
   ...
   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', action=FooAction)
   >>> parser.add_argument('bar', action=FooAction)
   >>> args = parser.parse_args('1 --foo 2'.split())
   Namespace(bar=None, foo=None) '1' None
   Namespace(bar='1', foo=None) '2' '--foo'
   >>> args
   Namespace(bar='1', foo='2')

자세한 내용은 "Action" 을 참조하십시오.


nargs
-----

"ArgumentParser" objects usually associate a single command-line
argument with a single action to be taken.  The "nargs" keyword
argument associates a different number of command-line arguments with
a single action. See also Specifying ambiguous arguments. The
supported values are:

* "N" (정수). 명령행에서 "N" 개의 인자를 함께 모아서 리스트에 넣습니다
  . 예를 들면:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', nargs=2)
     >>> parser.add_argument('bar', nargs=1)
     >>> parser.parse_args('c --foo a b'.split())
     Namespace(bar=['c'], foo=['a', 'b'])

  "nargs=1" 은 하나의 항목을 갖는 리스트를 생성합니다. 이는 항목 그대
  로 생성되는 기본값과 다릅니다.

* "'?'". 가능하다면 한 인자가 명령행에서 소비되고 단일 항목으로 생성됩
  니다. 명령행 인자가 없으면 default 의 값이 생성됩니다. 선택 인자의
  경우 추가적인 경우가 있습니다 - 옵션 문자열은 있지만, 명령행 인자가
  따라붙지 않는 경우입니다. 이 경우 const 의 값이 생성됩니다. 이것을
  보여주기 위해 몇 가지 예를 듭니다:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', nargs='?', const='c', default='d')
     >>> parser.add_argument('bar', nargs='?', default='d')
     >>> parser.parse_args(['XX', '--foo', 'YY'])
     Namespace(bar='XX', foo='YY')
     >>> parser.parse_args(['XX', '--foo'])
     Namespace(bar='XX', foo='c')
     >>> parser.parse_args([])
     Namespace(bar='d', foo='d')

  "nargs='?'" 의 흔한 사용법 중 하나는 선택적 입출력 파일을 허용하는
  것입니다:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('infile', nargs='?')
     >>> parser.add_argument('outfile', nargs='?')
     >>> parser.parse_args(['input.txt', 'output.txt'])
     Namespace(infile='input.txt', outfile='output.txt')
     >>> parser.parse_args(['input.txt'])
     Namespace(infile='input.txt', outfile=None)
     >>> parser.parse_args([])
     Namespace(infile=None, outfile=None)

* "'*'". 모든 명령행 인자를 리스트로 수집합니다. 일반적으로 두 개 이상
  의 위치 인자에 대해 "nargs='*'" 를 사용하는 것은 별로 의미가 없지만,
  "nargs='*'" 를 갖는 여러 개의 선택 인자는 가능합니다. 예를 들면:

     >>> parser = argparse.ArgumentParser()
     >>> parser.add_argument('--foo', nargs='*')
     >>> parser.add_argument('--bar', nargs='*')
     >>> parser.add_argument('baz', nargs='*')
     >>> parser.parse_args('a b --foo x y --bar 1 2'.split())
     Namespace(bar=['1', '2'], baz=['a', 'b'], foo=['x', 'y'])

* "'+'". Just like "'*'", all command-line arguments present are
  gathered into a list.  Additionally, an error message will be
  generated if there wasn't at least one command-line argument
  present.  For example:

     >>> parser = argparse.ArgumentParser(prog='PROG')
     >>> parser.add_argument('foo', nargs='+')
     >>> parser.parse_args(['a', 'b'])
     Namespace(foo=['a', 'b'])
     >>> parser.parse_args([])
     usage: PROG [-h] foo [foo ...]
     PROG: error: the following arguments are required: foo

If the "nargs" keyword argument is not provided, the number of
arguments consumed is determined by the action.  Generally this means
a single command-line argument will be consumed and a single item (not
a list) will be produced. Actions that do not consume command-line
arguments (e.g. "'store_const'") set "nargs=0".


const
-----

"add_argument()" 의 "const" 인자는 명령행에서 읽지는 않지만 다양한
"ArgumentParser" 액션에 필요한 상숫값을 저장하는 데 사용됩니다. 가장
흔한 두 가지 용도는 다음과 같습니다:

* When "add_argument()" is called with "action='store_const'" or
  "action='append_const'".  These actions add the "const" value to one
  of the attributes of the object returned by "parse_args()". See the
  action description for examples. If "const" is not provided to
  "add_argument()", it will receive a default value of "None".

* When "add_argument()" is called with option strings (like "-f" or "
  --foo") and "nargs='?'".  This creates an optional argument that can
  be followed by zero or one command-line arguments. When parsing the
  command line, if the option string is encountered with no command-
  line argument following it, the value from "const" will be used. See
  the nargs description for examples.

버전 3.11에서 변경: "const=None" by default, including when
"action='append_const'" or "action='store_const'".


default
-------

모든 선택 인자와 일부 위치 인자는 명령행에서 생략될 수 있습니다.
"add_argument()" 의 "default" 키워드 인자는, 기본값은 "None" 입니다,
명령행 인자가 없을 때 어떤 값을 사용해야 하는지를 지정합니다. 선택 인
자의 경우, 옵션 문자열이 명령행에 없을 때 "default" 값이 사용됩니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', default=42)
   >>> parser.parse_args(['--foo', '2'])
   Namespace(foo='2')
   >>> parser.parse_args([])
   Namespace(foo=42)

If the target namespace already has an attribute set, the action
*default* will not overwrite it:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', default=42)
   >>> parser.parse_args([], namespace=argparse.Namespace(foo=101))
   Namespace(foo=101)

"default" 값이 문자열이면, 파서는 마치 명령행 인자인 것처럼 파싱합니다
. 특히, 파서는 "Namespace" 반환 값에 어트리뷰트를 설정하기 전에, 제공
된 모든 type 변환 인자를 적용합니다. 그렇지 않은 경우, 파서는 값을 있
는 그대로 사용합니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--length', default='10', type=int)
   >>> parser.add_argument('--width', default=10.5, type=int)
   >>> parser.parse_args()
   Namespace(length=10, width=10.5)

nargs 가 "?" 또는 "*" 인 위치 인자의 경우, 명령행 인자가 없을 때
"default" 값이 사용됩니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('foo', nargs='?', default=42)
   >>> parser.parse_args(['a'])
   Namespace(foo='a')
   >>> parser.parse_args([])
   Namespace(foo=42)

For required arguments, the "default" value is ignored. For example,
this applies to positional arguments with nargs values other than "?"
or "*", or optional arguments marked as "required=True".

"default=argparse.SUPPRESS" 를 지정하면 명령행 인자가 없는 경우 어트리
뷰트가 추가되지 않습니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', default=argparse.SUPPRESS)
   >>> parser.parse_args([])
   Namespace()
   >>> parser.parse_args(['--foo', '1'])
   Namespace(foo='1')


type
----

기본적으로, 파서는 명령행 인자를 간단한 문자열로 읽습니다. 그러나 꽤
자주 명령행 문자열은 "float"나 "int"와 같은 다른 형으로 해석되어야 합
니다. "add_argument()" 의 "type" 키워드는 필요한 형 검사와 형 변환이
수행되도록 합니다.

type 키워드가 default 키워드와 함께 사용되면, 형 변환기는 기본값이 문
자열일 때만 적용됩니다.

The argument to "type" can be a callable that accepts a single string
or the name of a registered type (see "register()") If the function
raises "ArgumentTypeError", "TypeError", or "ValueError", the
exception is caught and a nicely formatted error message is displayed.
Other exception types are not handled.

일반적인 내장형과 함수는 형 변환기로 사용될 수 있습니다:

   import argparse
   import pathlib

   parser = argparse.ArgumentParser()
   parser.add_argument('count', type=int)
   parser.add_argument('distance', type=float)
   parser.add_argument('street', type=ascii)
   parser.add_argument('code_point', type=ord)
   parser.add_argument('datapath', type=pathlib.Path)

사용자 정의 함수도 사용할 수 있습니다:

   >>> def hyphenated(string):
   ...     return '-'.join([word[:4] for word in string.casefold().split()])
   ...
   >>> parser = argparse.ArgumentParser()
   >>> _ = parser.add_argument('short_title', type=hyphenated)
   >>> parser.parse_args(['"The Tale of Two Cities"'])
   Namespace(short_title='"the-tale-of-two-citi')

"bool()" 함수는 형 변환기로 권장되지 않습니다. 빈 문자열을 "False"로,
비어 있지 않은 문자열을 "True"로 변환하는 것뿐입니다. 이것은 일반적으
로 원하는 것이 아닙니다.

일반적으로, "type" 키워드는 지원되는 세 가지 예외 중 하나만 발생할 수
있는 간단한 변환에만 사용해야 하는 편의 기능입니다. 더 흥미로운 에러
처리나 리소스 관리가 필요한 모든 작업은 인자가 구문 분석된 후에 수행되
어야 합니다.

For example, JSON or YAML conversions have complex error cases that
require better reporting than can be given by the "type" keyword.  A
"JSONDecodeError" would not be well formatted and a
"FileNotFoundError" exception would not be handled at all.

Even "FileType" has its limitations for use with the "type" keyword.
If one argument uses "FileType" and then a subsequent argument fails,
an error is reported but the file is not automatically closed.  In
this case, it would be better to wait until after the parser has run
and then use the "with"-statement to manage the files.

고정된 값 집합에 대해 단순히 확인하는 형 검사기의 경우, 대신 choices
키워드를 사용하는 것을 고려하십시오.


choices
-------

Some command-line arguments should be selected from a restricted set
of values. These can be handled by passing a sequence object as the
*choices* keyword argument to "add_argument()".  When the command line
is parsed, argument values will be checked, and an error message will
be displayed if the argument was not one of the acceptable values:

   >>> parser = argparse.ArgumentParser(prog='game.py')
   >>> parser.add_argument('move', choices=['rock', 'paper', 'scissors'])
   >>> parser.parse_args(['rock'])
   Namespace(move='rock')
   >>> parser.parse_args(['fire'])
   usage: game.py [-h] {rock,paper,scissors}
   game.py: error: argument move: invalid choice: 'fire' (choose from 'rock',
   'paper', 'scissors')

Any sequence can be passed as the *choices* value, so "list" objects,
"tuple" objects, and custom sequences are all supported.

"enum.Enum"은 사용법, 도움말 및 에러 메시지에서 나타나는 방식을 제어하
기 어렵기 때문에 사용하지 않는 것이 좋습니다.

Note that *choices* are checked after any type conversions have been
performed, so objects in *choices* should match the type specified.
This can make *choices* appear unfamiliar in usage, help, or error
messages.

To keep *choices* user-friendly, consider a custom type wrapper that
converts and formats values, or omit type and handle conversion in
your application code.

Formatted choices override the default *metavar* which is normally
derived from *dest*.  This is usually what you want because the user
never sees the *dest* parameter.  If this display isn't desirable
(perhaps because there are many choices), just specify an explicit
metavar.


required
--------

In general, the "argparse" module assumes that flags like "-f" and "--
bar" indicate *optional* arguments, which can always be omitted at the
command line. To make an option *required*, "True" can be specified
for the "required=" keyword argument to "add_argument()":

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', required=True)
   >>> parser.parse_args(['--foo', 'BAR'])
   Namespace(foo='BAR')
   >>> parser.parse_args([])
   usage: [-h] --foo FOO
   : error: the following arguments are required: --foo

예에서 보듯이, 옵션이 "required" 로 표시되면, "parse_args()" 는 그 옵
션이 명령행에 없을 때 에러를 보고합니다.

참고:

  필수 옵션은 사용자가 *옵션* 이 *선택적* 일 것으로 기대하기 때문에 일
  반적으로 나쁜 형식으로 간주하므로 가능하면 피해야 합니다.


help
----

The "help" value is a string containing a brief description of the
argument. When a user requests help (usually by using "-h" or "--help"
at the command line), these "help" descriptions will be displayed with
each argument.

"help" 문자열은 프로그램 이름이나 인자 default 와 같은 것들의 반복을
피하고자 다양한 포맷 지정자를 포함 할 수 있습니다. 사용할 수 있는 지정
자는 프로그램 이름, "%(prog)s" 와 "add_argument()" 의 대부분의 키워드
인자, "%(default)s", "%(type)s" 등을 포함합니다.:

   >>> parser = argparse.ArgumentParser(prog='frobble')
   >>> parser.add_argument('bar', nargs='?', type=int, default=42,
   ...                     help='the bar to %(prog)s (default: %(default)s)')
   >>> parser.print_help()
   usage: frobble [-h] [bar]

   positional arguments:
    bar     the bar to frobble (default: 42)

   options:
    -h, --help  show this help message and exit

도움말 문자열이 %-포매팅을 지원하기 때문에, 도움말 문자열에 리터럴 "%"
을 표시하려면, "%%" 로 이스케이프 처리해야 합니다.

"argparse" supports silencing the help entry for certain options, by
setting the "help" value to "argparse.SUPPRESS":

   >>> parser = argparse.ArgumentParser(prog='frobble')
   >>> parser.add_argument('--foo', help=argparse.SUPPRESS)
   >>> parser.print_help()
   usage: frobble [-h]

   options:
     -h, --help  show this help message and exit


metavar
-------

When "ArgumentParser" generates help messages, it needs some way to
refer to each expected argument.  By default, "ArgumentParser" objects
use the dest value as the "name" of each object.  By default, for
positional argument actions, the dest value is used directly, and for
optional argument actions, the dest value is uppercased.  So, a single
positional argument with "dest='bar'" will be referred to as "bar". A
single optional argument "--foo" that should be followed by a single
command-line argument will be referred to as "FOO".  An example:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo')
   >>> parser.add_argument('bar')
   >>> parser.parse_args('X --foo Y'.split())
   Namespace(bar='X', foo='Y')
   >>> parser.print_help()
   usage:  [-h] [--foo FOO] bar

   positional arguments:
    bar

   options:
    -h, --help  show this help message and exit
    --foo FOO

다른 이름은 "metavar" 로 지정할 수 있습니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', metavar='YYY')
   >>> parser.add_argument('bar', metavar='XXX')
   >>> parser.parse_args('X --foo Y'.split())
   Namespace(bar='X', foo='Y')
   >>> parser.print_help()
   usage:  [-h] [--foo YYY] XXX

   positional arguments:
    XXX

   options:
    -h, --help  show this help message and exit
    --foo YYY

"metavar" 는 *표시되는* 이름 만 변경합니다 - "parse_args()" 객체의 어
트리뷰트 이름은 여전히 dest 값에 의해 결정됩니다.

"nargs" 값이 다르면 metavar 가 여러 번 사용될 수 있습니다. "metavar"
에 튜플을 제공하면 인자마다 다른 디스플레이가 지정됩니다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-x', nargs=2)
   >>> parser.add_argument('--foo', nargs=2, metavar=('bar', 'baz'))
   >>> parser.print_help()
   usage: PROG [-h] [-x X X] [--foo bar baz]

   options:
    -h, --help     show this help message and exit
    -x X X
    --foo bar baz


dest
----

대부분 "ArgumentParser" 액션은 "parse_args()" 에 의해 반환된 객체의 어
트리뷰트로 어떤 값을 추가합니다. 이 어트리뷰트의 이름은
"add_argument()" 의 "dest" 키워드 인자에 의해 결정됩니다. 위치 인자 액
션의 경우, "dest" 는 일반적으로 "add_argument()" 에 첫 번째 인자로 제
공됩니다.:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('bar')
   >>> parser.parse_args(['XXX'])
   Namespace(bar='XXX')

선택 인자 액션의 경우, "dest" 의 값은 보통 옵션 문자열에서 유추됩니다.
"ArgumentParser" 는 첫 번째 긴 옵션 문자열을 취하고 앞의 "--" 문자열을
제거하여 "dest" 의 값을 만듭니다. 긴 옵션 문자열이 제공되지 않았다면
"dest" 는 첫 번째 짧은 옵션 문자열에서 앞의 "-" 문자를 제거하여 만듭니
다. 문자열이 항상 유효한 어트리뷰트 이름이 되도록 만들기 위해 중간에
나오는 "-" 문자는 "_" 문자로 변환됩니다. 아래 예제는 이 동작을 보여줍
니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('-f', '--foo-bar', '--foo')
   >>> parser.add_argument('-x', '-y')
   >>> parser.parse_args('-f 1 -x 2'.split())
   Namespace(foo_bar='1', x='2')
   >>> parser.parse_args('--foo 1 -y 2'.split())
   Namespace(foo_bar='1', x='2')

"dest" 는 사용자 정의 어트리뷰트 이름을 지정할 수 있게 합니다:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument('--foo', dest='bar')
   >>> parser.parse_args('--foo XXX'.split())
   Namespace(bar='XXX')


deprecated
----------

During a project's lifetime, some arguments may need to be removed
from the command line. Before removing them, you should inform your
users that the arguments are deprecated and will be removed. The
"deprecated" keyword argument of "add_argument()", which defaults to
"False", specifies if the argument is deprecated and will be removed
in the future. For arguments, if "deprecated" is "True", then a
warning will be printed to "sys.stderr" when the argument is used:

   >>> import argparse
   >>> parser = argparse.ArgumentParser(prog='snake.py')
   >>> parser.add_argument('--legs', default=0, type=int, deprecated=True)
   >>> parser.parse_args([])
   Namespace(legs=0)
   >>> parser.parse_args(['--legs', '4'])
   snake.py: warning: option '--legs' is deprecated
   Namespace(legs=4)

Added in version 3.13.


Action 클래스
-------------

"Action" classes implement the Action API, a callable which returns a
callable which processes arguments from the command-line. Any object
which follows this API may be passed as the "action" parameter to
"add_argument()".

class argparse.Action(option_strings, dest, nargs=None, const=None, default=None, type=None, choices=None, required=False, help=None, metavar=None)

   "Action" objects are used by an "ArgumentParser" to represent the
   information needed to parse a single argument from one or more
   strings from the command line. The "Action" class must accept the
   two positional arguments plus any keyword arguments passed to
   "ArgumentParser.add_argument()" except for the "action" itself.

   Instances of "Action" (or return value of any callable to the
   "action" parameter) should have attributes "dest",
   "option_strings", "default", "type", "required", "help", etc.
   defined. The easiest way to ensure these attributes are defined is
   to call "Action.__init__()".

   __call__(parser, namespace, values, option_string=None)

      "Action" instances should be callable, so subclasses must
      override the "__call__()" method, which should accept four
      parameters:

      * *parser* - The "ArgumentParser" object which contains this
        action.

      * *namespace* - The "Namespace" object that will be returned by
        "parse_args()".  Most actions add an attribute to this object
        using "setattr()".

      * *values* - The associated command-line arguments, with any
        type conversions applied.  Type conversions are specified with
        the type keyword argument to "add_argument()".

      * *option_string* - The option string that was used to invoke
        this action. The "option_string" argument is optional, and
        will be absent if the action is associated with a positional
        argument.

      The "__call__()" method may perform arbitrary actions, but will
      typically set attributes on the "namespace" based on "dest" and
      "values".

   format_usage()

      "Action" subclasses can define a "format_usage()" method that
      takes no argument and return a string which will be used when
      printing the usage of the program. If such method is not
      provided, a sensible default will be used.

class argparse.BooleanOptionalAction

   A subclass of "Action" for handling boolean flags with positive and
   negative options. Adding a single argument such as "--foo"
   automatically creates both "--foo" and "--no-foo" options, storing
   "True" and "False" respectively:

      >>> import argparse
      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo', action=argparse.BooleanOptionalAction)
      >>> parser.parse_args(['--no-foo'])
      Namespace(foo=False)

   Added in version 3.9.


parse_args() 메서드
===================

ArgumentParser.parse_args(args=None, namespace=None)

   인자 문자열을 객체로 변환하고 namespace의 어트리뷰트로 설정합니다.
   값들이 설정된 namespace를 돌려줍니다.

   Previous calls to "add_argument()" determine exactly what objects
   are created and how they are assigned. See the documentation for
   "add_argument()" for details.

   * args - 구문 분석할 문자열 리스트. 기본값은 "sys.argv" 에서 취합니
     다.

   * namespace - 어트리뷰트가 대입될 객체. 기본값은 새로 만들어지는 빈
     "Namespace" 객체입니다.


옵션값 문법
-----------

"parse_args()" 메서드는 (취할 것이 있다면) 옵션의 값을 지정하는 몇 가
지 방법을 지원합니다. 가장 단순한 경우, 옵션과 그 값은 두 개의 독립적
인 인자로 전달됩니다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-x')
   >>> parser.add_argument('--foo')
   >>> parser.parse_args(['-x', 'X'])
   Namespace(foo=None, x='X')
   >>> parser.parse_args(['--foo', 'FOO'])
   Namespace(foo='FOO', x=None)

긴 옵션(단일 문자보다 긴 이름을 가진 옵션)의 경우, 옵션과 값을 "=" 로
구분하여 단일 명령행 인자로 전달할 수도 있습니다:

   >>> parser.parse_args(['--foo=FOO'])
   Namespace(foo='FOO', x=None)

짧은 옵션(한 문자 길이의 옵션)의 경우, 옵션과 해당 값을 이어붙일 수 있
습니다:

   >>> parser.parse_args(['-xX'])
   Namespace(foo=None, x='X')

여러 개의 짧은 옵션은 마지막 옵션만 값을 요구하는 한 (또는 그들 중 아
무것도 값을 요구하지 않거나), 하나의 "-" 접두어를 사용하여 함께 결합
할 수 있습니다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-x', action='store_true')
   >>> parser.add_argument('-y', action='store_true')
   >>> parser.add_argument('-z')
   >>> parser.parse_args(['-xyzZ'])
   Namespace(x=True, y=True, z='Z')


잘못된 인자
-----------

명령행을 파싱할 때, "parse_args()" 는 모호한 옵션, 유효하지 않은 형,
유효하지 않은 옵션, 잘못된 위치 인자의 수 등을 포함한 다양한 에러를 검
사합니다. 이런 에러가 발생하면, 사용 메시지와 함께 에러를 인쇄합니다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('--foo', type=int)
   >>> parser.add_argument('bar', nargs='?')

   >>> # invalid type
   >>> parser.parse_args(['--foo', 'spam'])
   usage: PROG [-h] [--foo FOO] [bar]
   PROG: error: argument --foo: invalid int value: 'spam'

   >>> # invalid option
   >>> parser.parse_args(['--bar'])
   usage: PROG [-h] [--foo FOO] [bar]
   PROG: error: no such option: --bar

   >>> # wrong number of arguments
   >>> parser.parse_args(['spam', 'badger'])
   usage: PROG [-h] [--foo FOO] [bar]
   PROG: error: extra arguments found: badger


"-" 를 포함하는 인자들
----------------------

"parse_args()" 메서드는 사용자가 분명히 실수했을 때마다 에러를 주려고
하지만, 어떤 상황은 본질에서 모호합니다. 예를 들어, 명령행 인자 "-1"
은 옵션을 지정하려는 시도이거나 위치 인자를 제공하려는 시도일 수 있습
니다. "parse_args()" 메서드는 이럴 때 신중합니다: 위치 인자는 음수처럼
보이고 파서에 음수처럼 보이는 옵션이 없을 때만 "-" 로 시작할 수 있습니
다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-x')
   >>> parser.add_argument('foo', nargs='?')

   >>> # no negative number options, so -1 is a positional argument
   >>> parser.parse_args(['-x', '-1'])
   Namespace(foo=None, x='-1')

   >>> # no negative number options, so -1 and -5 are positional arguments
   >>> parser.parse_args(['-x', '-1', '-5'])
   Namespace(foo='-5', x='-1')

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-1', dest='one')
   >>> parser.add_argument('foo', nargs='?')

   >>> # negative number options present, so -1 is an option
   >>> parser.parse_args(['-1', 'X'])
   Namespace(foo=None, one='X')

   >>> # negative number options present, so -2 is an option
   >>> parser.parse_args(['-2'])
   usage: PROG [-h] [-1 ONE] [foo]
   PROG: error: no such option: -2

   >>> # negative number options present, so both -1s are options
   >>> parser.parse_args(['-1', '-1'])
   usage: PROG [-h] [-1 ONE] [foo]
   PROG: error: argument -1: expected one argument

"-" 로 시작해야 하고, 음수처럼 보이지 않는 위치 인자가 있는 경우,
"parse_args()" 에 다음과 같은 의사 인자 "'--'" 를 삽입 할 수 있습니다.
그 이후의 모든 것은 위치 인자입니다:

   >>> parser.parse_args(['--', '-f'])
   Namespace(foo='-f', one=None)

See also the argparse howto on ambiguous arguments for more details.


인자 약어 (접두사 일치)
-----------------------

"parse_args()" 메서드는 기본적으로 약어가 모호하지 않으면 (접두사가 오
직 하나의 옵션과 일치합니다) 긴 옵션을 접두사로 축약 할 수 있도록 합니
다:

   >>> parser = argparse.ArgumentParser(prog='PROG')
   >>> parser.add_argument('-bacon')
   >>> parser.add_argument('-badger')
   >>> parser.parse_args('-bac MMM'.split())
   Namespace(bacon='MMM', badger=None)
   >>> parser.parse_args('-bad WOOD'.split())
   Namespace(bacon=None, badger='WOOD')
   >>> parser.parse_args('-ba BA'.split())
   usage: PROG [-h] [-bacon BACON] [-badger BADGER]
   PROG: error: ambiguous option: -ba could match -badger, -bacon

둘 이상의 옵션과 일치하는 인자는 에러를 일으킵니다. 이 기능은
allow_abbrev를 "False" 로 설정함으로써 비활성화시킬 수 있습니다.


"sys.argv" 너머
---------------

Sometimes it may be useful to have an "ArgumentParser" parse arguments
other than those of "sys.argv".  This can be accomplished by passing a
list of strings to "parse_args()".  This is useful for testing at the
interactive prompt:

   >>> parser = argparse.ArgumentParser()
   >>> parser.add_argument(
   ...     'integers', metavar='int', type=int, choices=range(10),
   ...     nargs='+', help='an integer in the range 0..9')
   >>> parser.add_argument(
   ...     '--sum', dest='accumulate', action='store_const', const=sum,
   ...     default=max, help='sum the integers (default: find the max)')
   >>> parser.parse_args(['1', '2', '3', '4'])
   Namespace(accumulate=<built-in function max>, integers=[1, 2, 3, 4])
   >>> parser.parse_args(['1', '2', '3', '4', '--sum'])
   Namespace(accumulate=<built-in function sum>, integers=[1, 2, 3, 4])


Namespace 객체
--------------

class argparse.Namespace

   "parse_args()" 가 어트리뷰트를 저장하고 반환할 객체를 만드는 데 기
   본적으로 사용하는 간단한 클래스.

   이 클래스는 의도적으로 단순한데, 단지 가독성 있는 문자열 표현을 갖
   는 "object" 의 서브 클래스입니다. 어트리뷰트를 딕셔너리처럼 보기 원
   한다면, 표준 파이썬 관용구를 사용할 수 있습니다, "vars()":

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo')
      >>> args = parser.parse_args(['--foo', 'BAR'])
      >>> vars(args)
      {'foo': 'BAR'}

   "ArgumentParser" 가 새 "Namespace" 객체가 아니라 이미 존재하는 객체
   에 어트리뷰트를 대입하는 것이 유용 할 수 있습니다. "namespace=" 키
   워드 인자를 지정하면 됩니다:

      >>> class C:
      ...     pass
      ...
      >>> c = C()
      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo')
      >>> parser.parse_args(args=['--foo', 'BAR'], namespace=c)
      >>> c.foo
      'BAR'


기타 유틸리티
=============


Subcommands
-----------

ArgumentParser.add_subparsers(*[, title][, description][, prog][, parser_class][, action][, dest][, required][, help][, metavar])

   Many programs split up their functionality into a number of
   subcommands, for example, the "svn" program can invoke subcommands
   like "svn checkout", "svn update", and "svn commit".  Splitting up
   functionality this way can be a particularly good idea when a
   program performs several different functions which require
   different kinds of command-line arguments. "ArgumentParser"
   supports the creation of such subcommands with the
   "add_subparsers()" method.  The "add_subparsers()" method is
   normally called with no arguments and returns a special action
   object.  This object has a single method, "add_parser()", which
   takes a command name and any "ArgumentParser" constructor
   arguments, and returns an "ArgumentParser" object that can be
   modified as usual.

   매개 변수 설명:

   * *title* - title for the sub-parser group in help output; by
     default "subcommands" if description is provided, otherwise uses
     title for positional arguments

   * *description* - description for the sub-parser group in help
     output, by default "None"

   * *prog* - usage information that will be displayed with subcommand
     help, by default the name of the program and any positional
     arguments before the subparser argument

   * *parser_class* - class which will be used to create sub-parser
     instances, by default the class of the current parser (e.g.
     "ArgumentParser")

   * action - 이 인자를 명령행에서 만날 때 수행 할 액션의 기본형

   * dest - name of the attribute under which subcommand name will be
     stored; by default "None" and no value is stored

   * required - 부속 명령이 꼭 제공되어야 하는지 아닌지, 기본값은
     "False" (3.7에서 추가)

   * help - 도움말 출력의 부속 파서 그룹 도움말, 기본적으로 "None"

   * metavar - string presenting available subcommands in help; by
     default it is "None" and presents subcommands in form {cmd1,
     cmd2, ..}

   몇 가지 사용 예:

      >>> # create the top-level parser
      >>> parser = argparse.ArgumentParser(prog='PROG')
      >>> parser.add_argument('--foo', action='store_true', help='foo help')
      >>> subparsers = parser.add_subparsers(help='subcommand help')
      >>>
      >>> # create the parser for the "a" command
      >>> parser_a = subparsers.add_parser('a', help='a help')
      >>> parser_a.add_argument('bar', type=int, help='bar help')
      >>>
      >>> # create the parser for the "b" command
      >>> parser_b = subparsers.add_parser('b', help='b help')
      >>> parser_b.add_argument('--baz', choices=('X', 'Y', 'Z'), help='baz help')
      >>>
      >>> # parse some argument lists
      >>> parser.parse_args(['a', '12'])
      Namespace(bar=12, foo=False)
      >>> parser.parse_args(['--foo', 'b', '--baz', 'Z'])
      Namespace(baz='Z', foo=True)

   "parse_args()" 에 의해 반환된 객체는 주 파서와 명령행에 의해 선택된
   부속 파서(다른 부속 파서는 아님)의 어트리뷰트만을 포함한다는 것에
   주의하십시오. 그래서 위의 예에서, "a" 명령이 지정되면 "foo" 와
   "bar" 어트리뷰트 만 존재하고, "b" 명령이 지정되면 "foo" 와 "baz" 어
   트리뷰트만 존재합니다.

   Similarly, when a help message is requested from a subparser, only
   the help for that particular parser will be printed.  The help
   message will not include parent parser or sibling parser messages.
   (A help message for each subparser command, however, can be given
   by supplying the "help=" argument to "add_parser()" as above.)

      >>> parser.parse_args(['--help'])
      usage: PROG [-h] [--foo] {a,b} ...

      positional arguments:
        {a,b}   subcommand help
          a     a help
          b     b help

      options:
        -h, --help  show this help message and exit
        --foo   foo help

      >>> parser.parse_args(['a', '--help'])
      usage: PROG a [-h] bar

      positional arguments:
        bar     bar help

      options:
        -h, --help  show this help message and exit

      >>> parser.parse_args(['b', '--help'])
      usage: PROG b [-h] [--baz {X,Y,Z}]

      options:
        -h, --help     show this help message and exit
        --baz {X,Y,Z}  baz help

   "add_subparsers()" 메서드는 또한 "title" 과 "description" 키워드 인
   자를 지원합니다. 둘 중 하나가 있으면 부속 파서의 명령이 도움말 출력
   에서 자체 그룹으로 나타납니다. 예를 들면:

      >>> parser = argparse.ArgumentParser()
      >>> subparsers = parser.add_subparsers(title='subcommands',
      ...                                    description='valid subcommands',
      ...                                    help='additional help')
      >>> subparsers.add_parser('foo')
      >>> subparsers.add_parser('bar')
      >>> parser.parse_args(['-h'])
      usage:  [-h] {foo,bar} ...

      options:
        -h, --help  show this help message and exit

      subcommands:
        valid subcommands

        {foo,bar}   additional help

   Furthermore, "add_parser()" supports an additional *aliases*
   argument, which allows multiple strings to refer to the same
   subparser. This example, like "svn", aliases "co" as a shorthand
   for "checkout":

      >>> parser = argparse.ArgumentParser()
      >>> subparsers = parser.add_subparsers()
      >>> checkout = subparsers.add_parser('checkout', aliases=['co'])
      >>> checkout.add_argument('foo')
      >>> parser.parse_args(['co', 'bar'])
      Namespace(foo='bar')

   "add_parser()" supports also an additional *deprecated* argument,
   which allows to deprecate the subparser.

   >>> import argparse
   >>> parser = argparse.ArgumentParser(prog='chicken.py')
   >>> subparsers = parser.add_subparsers()
   >>> run = subparsers.add_parser('run')
   >>> fly = subparsers.add_parser('fly', deprecated=True)
   >>> parser.parse_args(['fly'])
   chicken.py: warning: command 'fly' is deprecated
   Namespace()

   Added in version 3.13.

   One particularly effective way of handling subcommands is to
   combine the use of the "add_subparsers()" method with calls to
   "set_defaults()" so that each subparser knows which Python function
   it should execute.  For example:

      >>> # subcommand functions
      >>> def foo(args):
      ...     print(args.x * args.y)
      ...
      >>> def bar(args):
      ...     print('((%s))' % args.z)
      ...
      >>> # create the top-level parser
      >>> parser = argparse.ArgumentParser()
      >>> subparsers = parser.add_subparsers(required=True)
      >>>
      >>> # create the parser for the "foo" command
      >>> parser_foo = subparsers.add_parser('foo')
      >>> parser_foo.add_argument('-x', type=int, default=1)
      >>> parser_foo.add_argument('y', type=float)
      >>> parser_foo.set_defaults(func=foo)
      >>>
      >>> # create the parser for the "bar" command
      >>> parser_bar = subparsers.add_parser('bar')
      >>> parser_bar.add_argument('z')
      >>> parser_bar.set_defaults(func=bar)
      >>>
      >>> # parse the args and call whatever function was selected
      >>> args = parser.parse_args('foo 1 -x 2'.split())
      >>> args.func(args)
      2.0
      >>>
      >>> # parse the args and call whatever function was selected
      >>> args = parser.parse_args('bar XYZYX'.split())
      >>> args.func(args)
      ((XYZYX))

   이렇게 하면 "parse_args()" 가 파싱이 완료된 후 적절한 함수를 호출하
   게 할 수 있습니다. 이처럼 액션과 함수를 연결하는 것이, 일반적으로
   각 부속 파서가 서로 다른 액션을 처리하도록 하는 가장 쉬운 방법입니
   다. 그러나 호출된 부속 파서의 이름을 확인해야 하는 경우
   "add_subparsers()" 호출에 "dest" 키워드 인자를 제공합니다:

      >>> parser = argparse.ArgumentParser()
      >>> subparsers = parser.add_subparsers(dest='subparser_name')
      >>> subparser1 = subparsers.add_parser('1')
      >>> subparser1.add_argument('-x')
      >>> subparser2 = subparsers.add_parser('2')
      >>> subparser2.add_argument('y')
      >>> parser.parse_args(['2', 'frobble'])
      Namespace(subparser_name='2', y='frobble')

   버전 3.7에서 변경: New *required* keyword-only parameter.

   버전 3.14에서 변경: Subparser's *prog* is no longer affected by a
   custom usage message in the main parser.


FileType 객체
-------------

class argparse.FileType(mode='r', bufsize=-1, encoding=None, errors=None)

   "FileType" 팩토리는 "ArgumentParser.add_argument()" 의 type 인자로
   전달될 수 있는 객체를 만듭니다. type으로 "FileType" 객체를 사용하는
   인자는 명령행 인자를 요청된 모드, 버퍼 크기, 인코딩 및 오류 처리의
   파일로 엽니다 (자세한 내용은 "open()" 함수를 참조하세요):

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--raw', type=argparse.FileType('wb', 0))
      >>> parser.add_argument('out', type=argparse.FileType('w', encoding='UTF-8'))
      >>> parser.parse_args(['--raw', 'raw.dat', 'file.txt'])
      Namespace(out=<_io.TextIOWrapper name='file.txt' mode='w' encoding='UTF-8'>, raw=<_io.FileIO name='raw.dat' mode='wb'>)

   FileType objects understand the pseudo-argument "'-'" and
   automatically convert this into "sys.stdin" for readable "FileType"
   objects and "sys.stdout" for writable "FileType" objects:

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('infile', type=argparse.FileType('r'))
      >>> parser.parse_args(['-'])
      Namespace(infile=<_io.TextIOWrapper name='<stdin>' encoding='UTF-8'>)

   참고:

     If one argument uses *FileType* and then a subsequent argument
     fails, an error is reported but the file is not automatically
     closed. This can also clobber the output files. In this case, it
     would be better to wait until after the parser has run and then
     use the "with"-statement to manage the files.

   버전 3.4에서 변경: Added the *encodings* and *errors* parameters.

   버전 3.14부터 폐지됨.


인자 그룹
---------

ArgumentParser.add_argument_group(title=None, description=None, *[, argument_default][, conflict_handler])

   By default, "ArgumentParser" groups command-line arguments into
   "positional arguments" and "options" when displaying help messages.
   When there is a better conceptual grouping of arguments than this
   default one, appropriate groups can be created using the
   "add_argument_group()" method:

      >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
      >>> group = parser.add_argument_group('group')
      >>> group.add_argument('--foo', help='foo help')
      >>> group.add_argument('bar', help='bar help')
      >>> parser.print_help()
      usage: PROG [--foo FOO] bar

      group:
        bar    bar help
        --foo FOO  foo help

   The "add_argument_group()" method returns an argument group object
   which has an "add_argument()" method just like a regular
   "ArgumentParser".  When an argument is added to the group, the
   parser treats it just like a normal argument, but displays the
   argument in a separate group for help messages.  The
   "add_argument_group()" method accepts *title* and *description*
   arguments which can be used to customize this display:

      >>> parser = argparse.ArgumentParser(prog='PROG', add_help=False)
      >>> group1 = parser.add_argument_group('group1', 'group1 description')
      >>> group1.add_argument('foo', help='foo help')
      >>> group2 = parser.add_argument_group('group2', 'group2 description')
      >>> group2.add_argument('--bar', help='bar help')
      >>> parser.print_help()
      usage: PROG [--bar BAR] foo

      group1:
        group1 description

        foo    foo help

      group2:
        group2 description

        --bar BAR  bar help

   The optional, keyword-only parameters argument_default and
   conflict_handler allow for finer-grained control of the behavior of
   the argument group. These parameters have the same meaning as in
   the "ArgumentParser" constructor, but apply specifically to the
   argument group rather than the entire parser.

   사용자 정의 그룹에 없는 인자는 일반적인 "positional arguments" 및
   "optional arguments" 섹션으로 들어갑니다.

   Deprecated since version 3.11, removed in version 3.14: Calling
   "add_argument_group()" on an argument group now raises an
   exception. This nesting was never supported, often failed to work
   correctly, and was unintentionally exposed through inheritance.

   버전 3.14부터 폐지됨: Passing prefix_chars to
   "add_argument_group()" is now deprecated.


상호 배제
---------

ArgumentParser.add_mutually_exclusive_group(required=False)

   Create a mutually exclusive group. "argparse" will make sure that
   only one of the arguments in the mutually exclusive group was
   present on the command line:

      >>> parser = argparse.ArgumentParser(prog='PROG')
      >>> group = parser.add_mutually_exclusive_group()
      >>> group.add_argument('--foo', action='store_true')
      >>> group.add_argument('--bar', action='store_false')
      >>> parser.parse_args(['--foo'])
      Namespace(bar=True, foo=True)
      >>> parser.parse_args(['--bar'])
      Namespace(bar=False, foo=False)
      >>> parser.parse_args(['--foo', '--bar'])
      usage: PROG [-h] [--foo | --bar]
      PROG: error: argument --bar: not allowed with argument --foo

   "add_mutually_exclusive_group()" 메서드는 상호 배타적 인자 중 적어
   도 하나가 필요하다는 것을 나타내기 위한 *required* 인자도 받아들입
   니다:

      >>> parser = argparse.ArgumentParser(prog='PROG')
      >>> group = parser.add_mutually_exclusive_group(required=True)
      >>> group.add_argument('--foo', action='store_true')
      >>> group.add_argument('--bar', action='store_false')
      >>> parser.parse_args([])
      usage: PROG [-h] (--foo | --bar)
      PROG: error: one of the arguments --foo --bar is required

   Note that currently mutually exclusive argument groups do not
   support the *title* and *description* arguments of
   "add_argument_group()". However, a mutually exclusive group can be
   added to an argument group that has a title and description. For
   example:

      >>> parser = argparse.ArgumentParser(prog='PROG')
      >>> group = parser.add_argument_group('Group title', 'Group description')
      >>> exclusive_group = group.add_mutually_exclusive_group(required=True)
      >>> exclusive_group.add_argument('--foo', help='foo help')
      >>> exclusive_group.add_argument('--bar', help='bar help')
      >>> parser.print_help()
      usage: PROG [-h] (--foo FOO | --bar BAR)

      options:
        -h, --help  show this help message and exit

      Group title:
        Group description

        --foo FOO   foo help
        --bar BAR   bar help

   Deprecated since version 3.11, removed in version 3.14: Calling
   "add_argument_group()" or "add_mutually_exclusive_group()" on a
   mutually exclusive group now raises an exception. This nesting was
   never supported, often failed to work correctly, and was
   unintentionally exposed through inheritance.


파서 기본값
-----------

ArgumentParser.set_defaults(**kwargs)

   대부분은, "parse_args()" 에 의해 반환된 객체의 어트리뷰트는 명령행
   인자와 인자 액션을 검사하여 완전히 결정됩니다. "set_defaults()" 는
   명령행을 검사하지 않고 결정되는 몇 가지 추가적인 어트리뷰트를 추가
   할 수 있도록 합니다:

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('foo', type=int)
      >>> parser.set_defaults(bar=42, baz='badger')
      >>> parser.parse_args(['736'])
      Namespace(bar=42, baz='badger', foo=736)

   Note that defaults can be set at both the parser level using
   "set_defaults()" and at the argument level using "add_argument()".
   If both are called for the same argument, the last default set for
   an argument is used:

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo', default='bar')
      >>> parser.set_defaults(foo='spam')
      >>> parser.parse_args([])
      Namespace(foo='spam')

   파서 수준의 기본값은 여러 파서로 작업 할 때 특히 유용 할 수 있습니
   다. 이 유형의 예제는 "add_subparsers()" 메서드를 참조하십시오.

ArgumentParser.get_default(dest)

   "add_argument()" 또는 "set_defaults()" 에 의해 설정된 이름 공간 어
   트리뷰트의 기본값을 가져옵니다:

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo', default='badger')
      >>> parser.get_default('foo')
      'badger'


도움말 인쇄
-----------

대부분의 일반적인 응용 프로그램에서 "parse_args()" 가 사용법이나 오류
메시지를 포매팅하고 인쇄하는 것을 담당합니다. 그러나 여러 가지 포매팅
방법이 제공됩니다:

ArgumentParser.print_usage(file=None)

   "ArgumentParser" 가 어떻게 명령행에서 호출되어야 하는지에 대한 간단
   한 설명을 인쇄합니다. *file* 이 "None" 이면, "sys.stdout" 이 가정됩
   니다.

ArgumentParser.print_help(file=None)

   프로그램 사용법과 "ArgumentParser" 에 등록된 인자에 대한 정보를 포
   함하는 도움말 메시지를 출력합니다. *file* 이 "None" 이면,
   "sys.stdout" 이 가정됩니다.

인쇄하는 대신 단순히 문자열을 반환하는, 이러한 메서드의 변형도 있습니
다:

ArgumentParser.format_usage()

   "ArgumentParser" 가 어떻게 명령행에서 호출되어야 하는지에 대한 간단
   한 설명을 담은 문자열을 반환합니다.

ArgumentParser.format_help()

   프로그램 사용법과 "ArgumentParser" 에 등록된 인자에 대한 정보를 포
   함하는 도움말 메시지를 담은 문자열을 반환합니다.


부분 파싱
---------

ArgumentParser.parse_known_args(args=None, namespace=None)

   Sometimes a script only needs to handle a specific set of command-
   line arguments, leaving any unrecognized arguments for another
   script or program. In these cases, the "parse_known_args()" method
   can be useful.

   This method works similarly to "parse_args()", but it does not
   raise an error for extra, unrecognized arguments. Instead, it
   parses the known arguments and returns a two item tuple that
   contains the populated namespace and the list of any unrecognized
   arguments.

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo', action='store_true')
      >>> parser.add_argument('bar')
      >>> parser.parse_known_args(['--foo', '--badger', 'BAR', 'spam'])
      (Namespace(bar='BAR', foo=True), ['--badger', 'spam'])

경고:

  Prefix matching rules apply to "parse_known_args()". The parser may
  consume an option even if it's just a prefix of one of its known
  options, instead of leaving it in the remaining arguments list.


파일 파싱 사용자 정의
---------------------

ArgumentParser.convert_arg_line_to_args(arg_line)

   파일에서 읽은 인자는 ("ArgumentParser" 생성자의
   *fromfile_prefix_chars* 키워드 인자를 참조하세요) 한 줄에 하나의 인
   자로 읽습니다. 이 동작을 변경하려면 "convert_arg_line_to_args()" 를
   재정의합니다.

   이 메서드는 하나의 인자 *arg_line* 를 받아들이는데, 인자 파일에서
   읽어 들인 문자열입니다. 이 문자열에서 파싱된 인자 리스트를 반환합니
   다. 메서드는 인자 파일에서 읽어 들이는 대로 한 줄에 한 번씩 순서대
   로 호출됩니다.

   이 메서드의 재정의하는 유용한 경우는 스페이스로 분리된 각 단어를 인
   자로 처리하는 것입니다. 다음 예제는 이렇게 하는 방법을 보여줍니다:

      class MyArgumentParser(argparse.ArgumentParser):
          def convert_arg_line_to_args(self, arg_line):
              return arg_line.split()


종료 메서드
-----------

ArgumentParser.exit(status=0, message=None)

   This method terminates the program, exiting with the specified
   *status* and, if given, it prints a *message* to "sys.stderr"
   before that. The user can override this method to handle these
   steps differently:

      class ErrorCatchingArgumentParser(argparse.ArgumentParser):
          def exit(self, status=0, message=None):
              if status:
                  raise Exception(f'Exiting because of an error: {message}')
              exit(status)

ArgumentParser.error(message)

   This method prints a usage message, including the *message*, to
   "sys.stderr" and terminates the program with a status code of 2.


혼합 파싱
---------

ArgumentParser.parse_intermixed_args(args=None, namespace=None)

ArgumentParser.parse_known_intermixed_args(args=None, namespace=None)

   많은 유닉스 명령은 사용자가 선택 인자와 위치 인자를 섞을 수 있도록
   합니다. "parse_intermixed_args()" 와
   "parse_known_intermixed_args()" 메서드는 이런 파싱 스타일을 지원합
   니다.

   These parsers do not support all the "argparse" features, and will
   raise exceptions if unsupported features are used.  In particular,
   subparsers, and mutually exclusive groups that include both
   optionals and positionals are not supported.

   다음 예제는 "parse_known_args()" 와 "parse_intermixed_args()" 의 차
   이점을 보여줍니다: 전자는 여분의 인자로 "['2', '3']" 을 반환하는 반
   면, 후자는 모든 위치 인자를 "rest" 로 모읍니다.

      >>> parser = argparse.ArgumentParser()
      >>> parser.add_argument('--foo')
      >>> parser.add_argument('cmd')
      >>> parser.add_argument('rest', nargs='*', type=int)
      >>> parser.parse_known_args('doit 1 --foo bar 2 3'.split())
      (Namespace(cmd='doit', foo='bar', rest=[1]), ['2', '3'])
      >>> parser.parse_intermixed_args('doit 1 --foo bar 2 3'.split())
      Namespace(cmd='doit', foo='bar', rest=[1, 2, 3])

   "parse_known_intermixed_args()" 는 채워진 이름 공간과 잔여 인자 문
   자열의 리스트를 포함하는 두 항목 튜플을 반환합니다.
   "parse_intermixed_args()" 는 파싱되지 않은 인자 문자열이 남아 있으
   면 에러를 발생시킵니다.

   Added in version 3.7.


Registering custom types or actions
-----------------------------------

ArgumentParser.register(registry_name, value, object)

   Sometimes it's desirable to use a custom string in error messages
   to provide more user-friendly output. In these cases, "register()"
   can be used to register custom actions or types with a parser and
   allow you to reference the type by their registered name instead of
   their callable name.

   The "register()" method accepts three arguments - a
   *registry_name*, specifying the internal registry where the object
   will be stored (e.g., "action", "type"), *value*, which is the key
   under which the object will be registered, and object, the callable
   to be registered.

   The following example shows how to register a custom type with a
   parser:

      >>> import argparse
      >>> parser = argparse.ArgumentParser()
      >>> parser.register('type', 'hexadecimal integer', lambda s: int(s, 16))
      >>> parser.add_argument('--foo', type='hexadecimal integer')
      _StoreAction(option_strings=['--foo'], dest='foo', nargs=None, const=None, default=None, type='hexadecimal integer', choices=None, required=False, help=None, metavar=None, deprecated=False)
      >>> parser.parse_args(['--foo', '0xFA'])
      Namespace(foo=250)
      >>> parser.parse_args(['--foo', '1.2'])
      usage: PROG [-h] [--foo FOO]
      PROG: error: argument --foo: invalid 'hexadecimal integer' value: '1.2'


Exceptions
==========

exception argparse.ArgumentError

   An error from creating or using an argument (optional or
   positional).

   The string value of this exception is the message, augmented with
   information about the argument that caused it.

exception argparse.ArgumentTypeError

   Raised when something goes wrong converting a command line string
   to a type.

-[ Guides and Tutorials ]-

* Argparse 자습서

* Migrating "optparse" code to "argparse"
