"email.message.Message": "compat32" API를 사용하여 이메일 메시지 표현하기
*************************************************************************

"Message" 클래스는 "EmailMessage" 클래스와 매우 유사지만, 이 클래스에
의해 추가된 메서드가 없고, 다른 특정 메서드의 기본 동작이 약간 다릅니
다. 또한 "EmailMessage" 클래스에서 지원하지만, 레거시 코드를 다루지 않
는 한 권장되지 않는 일부 메서드도 여기에서 설명합니다.

두 클래스의 철학과 구조는 그 외에는 같습니다.

이 문서는 기본 ("Message"의 경우) 정책 "Compat32"의 동작을 설명합니다.
다른 정책을 사용하려면, "EmailMessage" 클래스를 대신 사용해야 합니다.

이메일 메시지는 *헤더(headers)*와 *페이 로드(payload)*로 구성됩니다.
헤더는 **RFC 5322** 스타일 이름과 값이어야 하며, 필드 이름과 값은 콜론
으로 구분됩니다. 콜론은 필드 이름이나 필드 값의 일부가 아닙니다. 페이
로드는 간단한 텍스트 메시지, 바이너리 객체 또는 각각 자체 헤더 집합과
자체 페이 로드가 있는 서브 메시지의 구조화된 시퀀스일 수 있습니다. 후
자의 페이 로드 유형은 *multipart/**나 *message/rfc822*와 같은 MIME 유
형을 가진 메시지로 표시됩니다.

"Message" 객체가 제공하는 개념 모델은 헤더의 순서 있는 딕셔너리이면서,
헤더의 특수 정보에 액세스하고, 페이 로드에 액세스하고, 메시지의 직렬화
된 버전을 생성하고, 객체 트리를 재귀적으로 탐색하기 위한 추가 메서드가
제공되는 것입니다. 중복 헤더가 지원되지만, 특수한 메서드를 사용하여 액
세스해야 함에 유의하십시오.

"Message" 의사 딕셔너리는 헤더 이름으로 인덱싱되며, ASCII 값이어야 합
니다. 딕셔너리의 값은 ASCII 문자만 포함해야 하는 문자열입니다; 비
ASCII 입력에 대한 특수 처리가 있지만, 항상 올바른 결과를 생성하지는 않
습니다. 헤더는 대소 문자를 유지하면서 저장되고 반환되지만, 필드 이름은
대소 문자를 구분하지 않고 일치합니다. *Unix-From* 헤더나 "From_" 헤더
라고도 하는 단일 봉투 헤더가 있을 수도 있습니다. *페이 로드(payload)*
는 단순 메시지 객체의 경우는 문자열이나 바이트열이고, MIME 컨테이너 문
서(예를 들어 *multipart/**와 *message/rfc822*)의 경우는 "Message" 객체
의 리스트입니다.

"Message" 클래스의 메서드는 다음과 같습니다:

class email.message.Message(policy=compat32)

   *policy*가 지정되면 ("policy" 클래스의 인스턴스여야 합니다) 메시지
   표현을 갱신하고 직렬화하기 위해 지정된 규칙을 사용합니다. *policy*
   가 설정되지 않으면, "compat32" 정책을 사용하는데, 파이썬 3.2 버전의
   email 패키지와의 과거 호환성을 유지합니다. 자세한 내용은 "policy"
   설명서를 참조하십시오.

   버전 3.3에서 변경: *policy* 키워드 인자가 추가되었습니다.

   as_string(unixfrom=False, maxheaderlen=0, policy=None)

      평활화된 전체 메시지를 문자열로 반환합니다. 선택적 *unixfrom*이
      참이면, 봉투 헤더가 반환된 문자열에 포함됩니다. *unixfrom*의 기
      본값은 "False"입니다. 이전 버전과의 호환성을 위해,
      *maxheaderlen*의 기본값이 "0"이라서 다른 값을 원하면 명시적으로
      재정의해야 합니다 (정책에서 *max_line_length*에 지정된 값은 이
      메서드가 무시합니다). *policy* 인자는 메시지 인스턴스에서 얻은
      기본 정책을 대체하는 데 사용될 수 있습니다. 지정된 *policy*가
      "Generator"로 전달되므로, 메서드에서 생성된 일부 포매팅을 제어하
      는 데 사용할 수 있습니다.

      문자열로의 변환을 완료하기 위해 기본값을 채워야 하면 메시지 평활
      화는 "Message"에 대한 변경을 유발할 수 있습니다 (예를 들어, MIME
      경계가 생성되거나 수정될 수 있습니다).

      이 메서드는 편의상 제공되며 원하는 방식으로 메시지를 항상 포맷하
      지는 않음에 유의하십시오. 예를 들어, 기본적으로 유닉스 mbox 형식
      에 필요한 "From"으로 시작하는 줄을 맹글링(mangling)하지 않습니다
      . 유연성을 높이려면, "Generator" 인스턴스를 인스턴스 화하고 그것
      의 "flatten()" 메서드를 직접 사용하십시오. 예를 들면:

         from io import StringIO
         from email.generator import Generator
         fp = StringIO()
         g = Generator(fp, mangle_from_=True, maxheaderlen=60)
         g.flatten(msg)
         text = fp.getvalue()

      메시지 객체가 RFC 표준에 따라 인코딩되지 않은 바이너리 데이터를
      포함하면, 비 호환 데이터는 유니코드 "unknown character" 코드 포
      인트로 대체됩니다. ("as_bytes()"와 "BytesGenerator"도 참조하십시
      오.)

      버전 3.4에서 변경: *policy* 키워드 인자가 추가되었습니다.

   __str__()

      "as_string()"과 동등합니다. "str(msg)"가 포맷된 메시지를 포함하
      는 문자열을 생성할 수 있도록 합니다.

   as_bytes(unixfrom=False, policy=None)

      평활화된 전체 메시지를 바이트열 객체로 반환합니다. 선택적
      *unixfrom*이 참이면, 봉투 헤더가 반환된 문자열에 포함됩니다.
      *unixfrom*의 기본값은 "False"입니다. *policy* 인자는 메시지 인스
      턴스에서 얻은 기본 정책을 대체하는 데 사용될 수 있습니다. 지정된
      *policy*가 "BytesGenerator"로 전달되므로, 메서드에서 생성된 일부
      포매팅을 제어하는 데 사용할 수 있습니다.

      문자열로의 변환을 완료하기 위해 기본값을 채워야 하면 메시지 평활
      화는 "Message"에 대한 변경을 유발할 수 있습니다 (예를 들어, MIME
      경계가 생성되거나 수정될 수 있습니다).

      이 메서드는 편의상 제공되며 원하는 방식으로 메시지를 항상 포맷하
      지는 않음에 유의하십시오. 예를 들어, 기본적으로 유닉스 mbox 형식
      에 필요한 "From"으로 시작하는 줄을 맹글링(mangling)하지 않습니다
      . 유연성을 높이려면, "BytesGenerator" 인스턴스를 인스턴스 화하고
      그것의 "flatten()" 메서드를 직접 사용하십시오. 예를 들면:

         from io import BytesIO
         from email.generator import BytesGenerator
         fp = BytesIO()
         g = BytesGenerator(fp, mangle_from_=True, maxheaderlen=60)
         g.flatten(msg)
         text = fp.getvalue()

      Added in version 3.4.

   __bytes__()

      "as_bytes()"와 동등합니다. "bytes(msg)"가 포맷된 메시지를 포함하
      는 바이트열 객체를 생성할 수 있도록 합니다.

      Added in version 3.4.

   is_multipart()

      메시지의 페이 로드가 서브-"Message" 객체의 리스트이면 "True"를,
      그렇지 않으면 "False"를 반환합니다. "is_multipart()"가 "False"를
      반환할 때, 페이 로드는 문자열 객체(CTE로 인코딩된 바이너리 페이
      로드일 수 있습니다)여야 합니다. ("True"를 반환하는
      "is_multipart()"가 반드시 "msg.get_content_maintype() ==
      'multipart'" 가 "True"를 반환한다는 것을 의미하지는 않습니다. 예
      를 들어, "Message"가 "message/rfc822" 유형일 때, "is_multipart"
      는 "True"를 반환합니다.

   set_unixfrom(unixfrom)

      메시지의 봉투 헤더를 (문자열이어야 하는) *unixfrom*으로 설정합니
      다.

   get_unixfrom()

      메시지의 봉투 헤더를 반환합니다. 봉투 헤더가 설정되지 않았으면
      기본값은 "None"입니다.

   attach(payload)

      지정된 *payload*를 현재 페이 로드에 추가합니다. 호출 전에는 페이
      로드가 "None"이나 "Message" 객체의 리스트여야 합니다. 호출 후에
      는 페이 로드가 항상 "Message" 객체의 리스트입니다. 페이 로드를
      스칼라 객체(예를 들어 문자열)로 설정하려면, "set_payload()"를 대
      신 사용하십시오.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by "set_content()" and the related
      "make" and "add" methods.

   get_payload(i=None, decode=False)

      현재 페이 로드를 반환합니다. "is_multipart()"가 "True"이면
      "Message" 객체의 리스트이고, "is_multipart()"가 "False"이면 문자
      열입니다. 페이 로드가 리스트이고 리스트 객체를 변경하면, 메시지
      의 페이 로드를 제자리에서 수정하는 것입니다.

      선택적 인자 *i*를 사용하면, "get_payload()"는 "is_multipart()"가
      "True"일 때, 페이 로드의 *i* 번째 요소를 0부터 세어 반환합니다.
      *i*가 0보다 작거나 페이 로드의 항목 수보다 크거나 같으면
      "IndexError"가 발생합니다. 페이 로드가 문자열이고 (즉
      "is_multipart()"가 "False") *i*가 제공되면, "TypeError"가 발생합
      니다.

      선택적 *decode*는 *Content-Transfer-Encoding* 헤더에 따라 페이
      로드를 디코딩해야 하는지를 나타내는 플래그입니다. "True"이고 메
      시지가 멀티 파트가 아닐 때, 이 헤더 값이 "quoted-printable"이나
      "base64"이면 페이 로드가 디코딩됩니다. 다른 인코딩이 사용되거나
      *Content-Transfer-Encoding* 헤더가 누락되면, 페이 로드는 그대로
      (디코딩되지 않고) 반환됩니다. 모든 경우에 반환된 값은 바이너리
      데이터입니다. 메시지가 멀티 파트이고 *decode* 플래그가 "True"이
      면, "None"이 반환됩니다. 페이 로드가 base64이고 완벽하게 구성되
      지 않았으면 (패딩 누락, base64 알파벳 이외의 문자), 메시지의 결
      함 프로퍼티에 적절한 결함이 추가됩니다 (각각
      "InvalidBase64PaddingDefect"나 "InvalidBase64CharactersDefect").

      *decode*가 "False"(기본값)일 때 본문은 *Content-Transfer-
      Encoding*을 디코딩하지 않고 문자열로 반환됩니다. 그러나,
      *Content-Transfer-Encoding*이 8비트인 경우, "replace" 에러 처리
      기로, *Content-Type* 헤더에 지정된 "charset"을 사용하여 원래 바
      이트를 디코딩하려고 시도합니다. "charset"이 지정되지 않았거나
      email 패키지가 "charset"을 인식하지 못하면, 본문은 기본 ASCII 문
      자 집합을 사용하여 디코딩됩니다.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by "get_content()" and "iter_parts()".

   set_payload(payload, charset=None)

      전체 메시지 객체의 페이 로드를 *payload*로 설정합니다. 페이 로드
      불변량(invariants)을 보장하는 것은 고객의 책임입니다. 선택적
      *charset*은 메시지의 기본 문자 집합을 설정합니다; 자세한 내용은
      "set_charset()"을 참조하십시오.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by "set_content()".

   set_charset(charset)

      페이 로드의 문자 집합을 *charset*으로 설정합니다. 이는 "Charset"
      인스턴스 ("email.charset"을 참조하십시오), 문자 집합의 이름을 지
      정하는 문자열 또는 "None"일 수 있습니다. 문자열이면, "Charset"
      인스턴스로 변환됩니다. *charset*이 "None"이면, "charset" 매개 변
      수가 *Content-Type* 헤더에서 제거됩니다 (그렇지 않으면 메시지가
      수정되지 않습니다). 그 외의 경우는 "TypeError"를 생성합니다.

      기존 *MIME-Version* 헤더가 없으면 추가됩니다. 기존 *Content-
      Type* 헤더가 없으면, *text/plain* 값으로 추가됩니다. *Content-
      Type* 헤더가 존재하는지와 관계없이, "charset" 매개 변수는
      *charset.output_charset*으로 설정됩니다. *charset.input_charset*
      과 *charset.output_charset*이 다르면, 페이 로드가
      *output_charset*으로 다시 인코딩됩니다. 기존 *Content-Transfer-
      Encoding* 헤더가 없으면, 필요하면 지정된 "Charset"을 사용하여 페
      이 로드가 전송 인코딩되고(transfer-encoded), 적절한 값을 가진 헤
      더가 추가됩니다. *Content-Transfer-Encoding* 헤더가 이미 존재하
      면, 페이 로드는 해당 *Content-Transfer-Encoding*을 사용하여 이미
      올바르게 인코딩된 것으로 가정하며 수정하지 않습니다.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by the *charset* parameter of the
      "email.message.EmailMessage.set_content()" method.

   get_charset()

      메시지 페이 로드와 연관된 "Charset" 인스턴스를 반환합니다.

      This is a legacy method.  On the "EmailMessage" class it always
      returns "None".

   다음 메서드는 메시지의 **RFC 2822** 헤더에 액세스하기 위한 매핑과
   유사한 인터페이스를 구현합니다. 이 메서드들과 일반적인 매핑 (즉, 딕
   셔너리) 인터페이스 사이에는 의미상 차이가 있습니다. 예를 들어, 딕셔
   너리에는 중복 키가 없지만, 여기에는 중복 메시지 헤더가 있을 수 있습
   니다. 또한, 딕셔너리에서는 "keys()"가 반환하는 키의 순서가 보장되지
   않지만, "Message" 객체에서는 헤더가 항상 원래 메시지에 나타나거나
   나중에 메시지에 추가된 순서대로 반환됩니다. 삭제한 후 다시 추가된
   헤더는 항상 헤더 리스트의 끝에 추가됩니다.

   이러한 의미상 차이는 의도적이며 최대한의 편의를 위해 편향되어 있습
   니다.

   모든 경우에, 메시지에 존재하는 봉투 헤더는 매핑 인터페이스에 포함되
   지 않습니다.

   바이트열에서 생성된 모델에서, (RFC에 반하여) 비 ASCII 바이트를 포함
   하는 헤더 값은, 이 인터페이스를 통해 꺼낼 때, 문자 집합이 "unknown-
   8bit"인 "Header" 객체로 표시됩니다.

   __len__()

      중복을 포함하여, 총 헤더 수를 반환합니다.

   __contains__(name)

      메시지 객체에 *name*이라는 이름의 필드가 있으면 "True"를 반환합
      니다. 대소 문자를 구분하지 않고 일치하며 *name*은 후행 콜론을 포
      함하지 않아야 합니다. "in" 연산자에 사용됩니다, 예를 들어:

         if 'message-id' in myMessage:
            print('Message-ID:', myMessage['message-id'])

   __getitem__(name)

      명명된 헤더 필드의 값을 반환합니다. *name*은 콜론 필드 구분자를
      포함하지 않아야 합니다. 헤더가 없으면, "None"이 반환됩니다;
      "KeyError"는 절대 발생하지 않습니다.

      이름이 지정된 필드가 메시지 헤더에 두 번 이상 나타나면, 해당 필
      드 값 중 정확히 어떤 필드 값이 반환되는지 정의되지 않습니다. 기
      존의 모든 명명된 헤더의 값을 가져오려면 "get_all()" 메서드를 사
      용하십시오.

   __setitem__(name, val)

      메시지에 필드 이름이 *name*이고 값이 *val*인 헤더를 추가합니다.
      필드는 메시지의 기존 필드 끝에 추가됩니다.

      이것이 같은 이름을 가진 기존 헤더를 덮어쓰거나 삭제하지 *않음에*
      유의하십시오. 새 헤더가 메시지에 필드 이름이 *name*인 유일한 헤
      더가 되도록 하려면, 먼저 필드를 삭제하십시오. 예를 들어:

         del msg['subject']
         msg['subject'] = 'Python roolz!'

   __delitem__(name)

      메시지 헤더에서 이름이 *name*인 모든 필드를 삭제합니다. 명명된
      필드가 헤더에 없어도 예외가 발생하지 않습니다.

   keys()

      메시지 헤더의 모든 필드 이름의 리스트를 반환합니다.

   values()

      메시지의 모든 필드 값의 리스트를 반환합니다.

   items()

      메시지의 모든 필드 헤더와 값을 포함하는 2-튜플의 리스트를 반환합
      니다.

   get(name, failobj=None)

      명명된 헤더 필드의 값을 반환합니다. 명명된 헤더가 없으면 선택적
      *failobj*가 반환된다는 점을 제외하고는 "__getitem__()"과 동일합
      니다 (기본값은 "None"입니다).

   몇 가지 유용한 추가 메서드가 있습니다:

   get_all(name, failobj=None)

      *name*이라는 필드의 모든 값 리스트를 반환합니다. 메시지에 이런
      이름의 헤더가 없으면, *failobj*가 반환됩니다 (기본값은 "None"입
      니다).

   add_header(_name, _value, **_params)

      확장된 헤더 설정. 이 메서드는 추가 헤더 매개 변수가 키워드 인자
      로 제공될 수 있다는 점을 제외하고는 "__setitem__()"과 유사합니다
      . *_name*은 추가할 헤더 필드이고 *_value*는 헤더의 *기본
      (primary)*값입니다.

      키워드 인자 딕셔너리 *_params*의 각 항목에 대해, 키는 매개 변수
      이름으로 사용되며, 밑줄은 대시로 변환됩니다 (대시는 파이썬 식별
      자로 유효하지 않기 때문입니다). 일반적으로, 값이 "None"이 아니면
      매개 변수가 "key="value""로 추가되며, "None"이면 키만 추가됩니다
      . 값에 ASCII가 아닌 문자가 포함되면, "(CHARSET, LANGUAGE,
      VALUE)" 형식으로 3-튜플로 지정할 수 있습니다. 여기서 "CHARSET"은
      값을 인코딩하는 데 사용할 문자 집합의 이름을 지정하는 문자열이고
      , "LANGUAGE"는 일반적으로 "None"이나 빈 문자열(다른 가능성에 대
      해서는 **RFC 2231**을 참조하십시오)로 설정될 수 있고, "VALUE"는
      비 ASCII 코드 포인트를 포함하는 문자열 값입니다. 3-튜플이 전달되
      지 않고 값에 ASCII가 아닌 문자가 포함되면, "CHARSET"으로 "utf-8"
      을 "LANGUAGE"로 "None"을 사용하여 **RFC 2231** 형식으로 자동 인
      코딩됩니다.

      예를 들면 다음과 같습니다:

         msg.add_header('Content-Disposition', 'attachment', filename='bud.gif')

      이것은 다음과 같은 헤더를 추가합니다

         Content-Disposition: attachment; filename="bud.gif"

      비 ASCII 문자의 예:

         msg.add_header('Content-Disposition', 'attachment',
                        filename=('iso-8859-1', '', 'Fußballer.ppt'))

      이것은 다음을 생성합니다

         Content-Disposition: attachment; filename*="iso-8859-1''Fu%DFballer.ppt"

   replace_header(_name, _value)

      헤더를 교체합니다. 헤더 순서와 필드 이름 대소 문자를 유지하면서,
      메시지에서 *_name*과 일치하는 첫 번째로 발견된 헤더를 교체합니다
      . 일치하는 헤더가 없으면, "KeyError"가 발생합니다.

   get_content_type()

      메시지의 콘텐츠 유형을 반환합니다. 반환된 문자열은
      *maintype/subtype* 형식의 소문자로 강제 변환됩니다. 메시지에
      *Content-Type* 헤더가 없으면 "get_default_type()"에서 제공하는
      기본 유형이 반환됩니다. **RFC 2045**에 따르면, 메시지는 항상 기
      본 유형을 가지므로, "get_content_type()"은 항상 값을 반환합니다.

      **RFC 2045**는 메시지가 *multipart/digest* 컨테이너 안에 등장(이
      경우 기본 유형은 *message/rfc822*가 됩니다)하지 않는 한 기본 유
      형을 *text/plain*으로 정의합니다. *Content-Type* 헤더에 유효하지
      않은 유형 명세가 있으면, **RFC 2045**는 기본 유형이 *text/plain*
      으로 지정합니다.

   get_content_maintype()

      메시지의 주 콘텐츠 유형을 반환합니다. 이것은
      "get_content_type()"이 반환하는 문자열의 *maintype* 부분입니다.

   get_content_subtype()

      메시지의 부 콘텐츠 유형을 반환합니다. 이것은
      "get_content_type()"이 반환하는 문자열의 *subtype* 부분입니다.

   get_default_type()

      기본 콘텐츠 유형을 반환합니다. *multipart/digest* 컨테이너의 서
      브 파트인 메시지를 제외하고, 대부분의 메시지는 기본 콘텐츠 유형
      이 *text/plain*입니다. 이러한 서브 파트는 기본 콘텐츠 유형이
      *message/rfc822*입니다.

   set_default_type(ctype)

      기본 콘텐츠 유형을 설정합니다. *ctype*은 *text/plain*이나
      *message/rfc822*여야 하지만 강제하지는 않습니다. 기본 콘텐츠 유
      형은 *Content-Type* 헤더에 저장되지 않습니다.

   get_params(failobj=None, header='content-type', unquote=True)

      메시지의 *Content-Type* 매개 변수를 리스트로 반환합니다. 반환된
      리스트의 요소는 "'='" 부호로 분할된 키/값 쌍의 2-튜플입니다.
      "'='"의 왼쪽은 키이고 오른쪽은 값입니다. 매개 변수에 "'='" 부호
      가 없으면 값은 빈 문자열이고, 그렇지 않으면 값은 "get_param()"에
      설명된대로이며 선택적 *unquote*가 "True"(기본값)이면 인용되지 않
      습니다.

      선택적 *failobj*는 *Content-Type* 헤더가 없을 때 반환할 객체입니
      다. 선택적 *header*는 *Content-Type* 대신 검색할 헤더입니다.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by the *params* property of the
      individual header objects returned by the header access methods.

   get_param(param, failobj=None, header='content-type', unquote=True)

      *Content-Type* 헤더의 매개 변수 *param*의 값을 문자열로 반환합니
      다. 메시지에 *Content-Type* 헤더가 없거나 그러한 매개 변수가 없
      으면, *failobj*가 반환됩니다 (기본값은 "None"입니다).

      선택적 *header*가 제공되면, *Content-Type* 대신 사용할 메시지 헤
      더를 지정합니다.

      매개 변수 키는 항상 대소 문자를 구분하지 않고 비교됩니다. 반환
      값은 문자열이거나, 매개 변수가 **RFC 2231**로 인코딩되었으면 3-
      튜플일 수 있습니다. 3-튜플일 때, 값의 요소는 "(CHARSET,
      LANGUAGE, VALUE)" 형식입니다. "CHARSET"과 "LANGUAGE"는 모두
      "None"일 수 있으며, 이 경우 "VALUE"가 "us-ascii" 문자 집합으로
      인코딩된 것으로 간주해야 함에 유의하십시오. 일반적으로
      "LANGUAGE"를 무시할 수 있습니다.

      응용 프로그램이 **RFC 2231**로 매개 변수가 인코딩되었는지를 신경
      쓰지 않으면, "email.utils.collapse_rfc2231_value()"를 호출하면서
      "get_param()"의 반환 값을 전달하여 매개 변숫값을 축소할 수 있습
      니다. 이것은 값이 튜플이면 적절하게 디코딩된 유니코드 문자열을
      반환하고, 그렇지 않으면 원래 문자열을 인용 없이 반환합니다. 예를
      들면:

         rawparam = msg.get_param('foo')
         param = email.utils.collapse_rfc2231_value(rawparam)

      모든 경우에, *unquote*가 "False"로 설정되어 있지 않으면, 매개 변
      숫값(반환된 문자열이나 3-튜플의 "VALUE" 항목)은 항상 인용되지 않
      습니다.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by the *params* property of the
      individual header objects returned by the header access methods.

   set_param(param, value, header='Content-Type', requote=True, charset=None, language='', replace=False)

      *Content-Type* 헤더에서 매개 변수를 설정합니다. 매개 변수가 이미
      헤더에 존재하면, 해당 값은 *value*로 대체됩니다. 이 메시지에 대
      해 *Content-Type* 헤더가 아직 정의되지 않았으면, *text/plain*으
      로 설정되고 **RFC 2045**에 따라 새 매개 변숫값이 추가됩니다.

      선택적 *header*는 *Content-Type*의 대체 헤더를 지정하며, 선택적
      *requote*가 "False"(기본값은 "True")가 아닌 한 모든 매개 변수가
      필요에 따라 인용됩니다.

      선택적 *charset*이 지정되면, 매개 변수는 **RFC 2231**에 따라 인
      코딩됩니다. 선택적 *language*는 RFC 2231 언어를 지정하며, 기본값
      은 빈 문자열입니다. *charset*과 *language*는 모두 문자열이어야
      합니다.

      *replace*가 "False"(기본값)이면 헤더가 헤더 리스트의 끝으로 이동
      합니다. *replace*가 "True"이면, 헤더는 제자리에서 갱신됩니다.

      버전 3.4에서 변경: "replace" 키워드가 추가되었습니다.

   del_param(param, header='content-type', requote=True)

      *Content-Type* 헤더에서 지정된 매개 변수를 완전히 제거합니다. 매
      개 변수나 그 값 없이 헤더가 다시 작성됩니다. *requote*가
      "False"(기본값은 "True")가 아닌 한 모든 값이 필요에 따라 인용됩
      니다. 선택적 *header*는 *Content-Type*의 대체 헤더를 지정합니다.

   set_type(type, header='Content-Type', requote=True)

      *Content-Type* 헤더의 주 유형과 부 유형을 설정합니다. *type*은
      *maintype/subtype* 형식의 문자열이어야 합니다, 그렇지 않으면
      "ValueError"가 발생합니다.

      이 메서드는 모든 매개 변수를 그대로 유지하면서 *Content-Type* 헤
      더를 대체합니다. *requote*가 "False"이면, 기존 헤더의 인용을 그
      대로 두고, 그렇지 않으면 매개 변수가 인용됩니다 (기본값).

      *header* 인자에 대체 헤더를 지정할 수 있습니다. *Content-Type*
      헤더가 설정될 때 *MIME-Version* 헤더도 추가됩니다.

      This is a legacy method.  On the "EmailMessage" class its
      functionality is replaced by the "make_" and "add_" methods.

   get_filename(failobj=None)

      메시지의 *Content-Disposition* 헤더의 "filename" 매개 변숫값을
      반환합니다. 헤더에 "filename" 매개 변수가 없으면, 이 메서드는
      *Content-Type* 헤더에서 "name" 매개 변수를 찾는 것으로 폴 백합니
      다. 둘 다 없거나, 헤더가 없으면, *failobj*가 반환됩니다. 반환된
      문자열은 항상 "email.utils.unquote()"로 인용 해제됩니다.

   get_boundary(failobj=None)

      메시지의 *Content-Type* 헤더의 "boundary" 매개 변숫값이나, 헤더
      가 없거나 "boundary" 매개 변수가 없으면 *failobj*를 반환합니다.
      반환된 문자열은 항상 "email.utils.unquote()"로 인용 해제됩니다.

   set_boundary(boundary)

      *Content-Type* 헤더의 "boundary" 매개 변수를 *boundary*로 설정합
      니다. 필요하면 "set_boundary()"는 항상 *boundary*를 인용합니다.
      메시지 객체에 *Content-Type* 헤더가 없으면 "HeaderParseError" 가
      발생합니다.

      "set_boundary()"는 헤더 리스트에서 *Content-Type* 헤더의 순서를
      유지하므로, 이 메서드를 사용하는 것은 이전 *Content-Type* 헤더를
      삭제하고 "add_header()"를 통해 새 경계를 가진 새 헤더를 추가하는
      것과 미묘하게 다름에 유의하십시오. 그러나 원래 *Content-Type* 헤
      더에 있을 수 있는 이어지는 줄(continuation lines)을 유지하지 *않
      습니다*.

   get_content_charset(failobj=None)

      *Content-Type* 헤더의 "charset" 매개 변수를 소문자로 강제 변환하
      여 반환합니다. *Content-Type* 헤더가 없거나, 해당 헤더에
      "charset" 매개 변수가 없으면 *failobj*가 반환됩니다.

      이 메서드는 메시지 본문의 기본 인코딩에 대한 "Charset" 인스턴스
      를 반환하는 "get_charset()"과 다름에 유의하십시오.

   get_charsets(failobj=None)

      메시지 내의 문자 집합 이름을 포함하는 리스트를 반환합니다. 메시
      지가 *multipart*이면, 리스트에 페이 로드의 각 서브 파트마다 하나
      의 요소가 포함되며, 그렇지 않으면 길이 1인 리스트가 됩니다.

      리스트의 각 항목은 표현된 서브 파트에 대한 *Content-Type* 헤더의
      "charset" 매개 변숫값인 문자열입니다. 그러나, 서브 파트에
      *Content-Type* 헤더가 없거나, "charset" 매개 변수가 없거나,
      *text* 주 MIME 유형이 아니면, 반환된 목록의 해당 항목은
      *failobj*가 됩니다.

   get_content_disposition()

      있다면 메시지의 *Content-Disposition* 헤더의 (매개 변수가 없는)
      소문자 값을, 그렇지 않으면 "None"을 반환합니다. 메시지가 **RFC
      2183**을 따른다면 이 메서드의 가능한 값은 *inline*, *attachment*
      또는 "None"입니다.

      Added in version 3.5.

   walk()

      "walk()" 메서드는 메시지 객체 트리의 모든 파트와 서브 파트를 깊
      이 우선 탐색 순서로 이터레이트 하는 데 사용할 수 있는 범용 제너
      레이터입니다. 일반적으로 "walk()"를 "for" 루프에서 이터레이터로
      사용합니다; 각 이터레이션은 다음 서브 파트를 반환합니다.

      다음은 멀티 파트 메시지 구조의 모든 파트에 대한 MIME 유형을 인쇄
      하는 예입니다:

         >>> for part in msg.walk():
         ...     print(part.get_content_type())
         multipart/report
         text/plain
         message/delivery-status
         text/plain
         text/plain
         message/rfc822
         text/plain

      "msg.get_content_maintype() == 'multipart'"가 "False"를 반환하더
      라도, "walk"는 "is_multipart()"가 "True"를 반환하는 모든 파트의
      서브 파트를 이터레이트 합니다. "_structure" 디버그 도우미 함수를
      사용하여 예제에서 이를 확인할 수 있습니다:

         >>> for part in msg.walk():
         ...     print(part.get_content_maintype() == 'multipart',
         ...           part.is_multipart())
         True True
         False False
         False True
         False False
         False False
         False True
         False False
         >>> _structure(msg)
         multipart/report
             text/plain
             message/delivery-status
                 text/plain
                 text/plain
             message/rfc822
                 text/plain

      여기서 "message" 파트는 "multiparts"가 아니지만, 서브 파트를 포
      함합니다. "is_multipart()"는 "True"를 반환하고 "walk"는 서브 파
      트로 내려갑니다.

   "Message" 객체는 MIME 메시지의 단순 텍스트를 생성할 때 사용할 수 있
   는 두 개의 인스턴스 어트리뷰트를 선택적으로 포함할 수 있습니다.

   preamble

      MIME 문서의 형식은 헤더 다음의 빈 줄과 첫 번째 멀티 파트 경계 문
      자열 사이에 일부 텍스트를 허용합니다. 일반적으로, 이 텍스트는 표
      준 MIME 장비를 벗어나기 때문에 MIME 인식 메일 리더에서 볼 수 없
      습니다. 그러나, 메시지의 원시 텍스트를 보거나, MIME을 인식하지
      않는 리더에서 메시지를 볼 때, 이 텍스트가 보일 수 있습니다.

      *preamble* 어트리뷰트에는 MIME 문서에 대한 이 선행 추가 텍스트가
      포함됩니다. "Parser"가 헤더 다음이지만 첫 번째 경계 문자열 이전
      에 어떤 텍스트를 감지하면, 이 텍스트를 메시지의 *preamble* 어트
      리뷰트에 대입합니다. "Generator"가 MIME 메시지의 단순 텍스트 표
      현을 기록할 때, 메시지에 *preamble* 어트리뷰트가 있는 것을 발견
      하면, 헤더와 첫 번째 경계 사이의 영역에 이 텍스트를 기록합니다.
      자세한 내용은 "email.parser"와 "email.generator"를 참조하십시오.

      메시지 객체에 프리앰블이 없으면, *preamble* 어트리뷰트는 "None"
      이 됨에 유의하십시오.

   epilogue

      *epilogue* 어트리뷰트는 메시지의 마지막 경계와 끝 사이에 나타나
      는 텍스트를 포함한다는 점을 제외하고, *preamble* 어트리뷰트와 같
      은 방식으로 작동합니다.

      "Generator"가 파일 끝에서 줄 넘김을 인쇄하도록 하기 위해 에필로
      그를 빈 문자열로 설정할 필요는 없습니다.

   defects

      *defects* 어트리뷰트는 이 메시지를 구문 분석할 때 발견된 모든 결
      함의 리스트를 포함합니다. 가능한 구문 분석 결함에 대한 자세한 설
      명은 "email.errors"를 참조하십시오.
