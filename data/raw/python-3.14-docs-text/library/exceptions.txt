내장 예외
*********

파이썬에서, 모든 예외는 "BaseException" 에서 파생된 클래스의 인스턴스
여야 합니다. 특정 클래스를 언급하는 "except" 절을 갖는 "try" 문에서,
그 절은 그 클래스에서 파생된 모든 예외 클래스를 처리합니다 (하지만 *그
것* 이 계승하는 예외 클래스는 처리하지 않습니다). 서브 클래싱을 통해
관련되지 않은 두 개의 예외 클래스는 같은 이름을 갖는다 할지라도 결코
등등하게 취급되지 않습니다.

이 장에서 나열된 내장 예외는 인터프리터나 내장 함수에 의해 생성될 수
있습니다. 따로 언급된 경우를 제외하고는, 에러의 자세한 원인을 나타내는
"연관된 값"을 갖습니다. 이것은 여러 항목의 정보 (예, 에러 코드와 그 코
드를 설명하는 문자열)를 담은 문자열이나 튜플 일 수 있습니다. 연관된 값
은 보통 예외 클래스의 생성자에 인자로 전달됩니다.

사용자 코드는 내장 예외를 일으킬 수 있습니다. 이것은 예외 처리기를 검
사하거나 인터프리터가 같은 예외를 발생시키는 상황과 "같은" 에러 조건을
보고하는 데 사용할 수 있습니다. 그러나 사용자 코드가 부적절한 에러를
발생시키는 것을 막을 방법이 없음을 유의하십시오.

내장 예외 클래스는 새 예외를 정의하기 위해 서브 클래싱 될 수 있습니다.
"BaseException" 이 아니라 "Exception" 클래스 나 그 서브 클래스 중 하나
에서 새로운 예외를 파생시킬 것을 권장합니다. 예외 정의에 대한 더 많은
정보는 파이썬 자습서의 사용자 정의 예외 에 있습니다.


예외 컨텍스트
=============

Three attributes on exception objects provide information about the
context in which the exception was raised:

BaseException.__context__
BaseException.__cause__
BaseException.__suppress_context__

   When raising a new exception while another exception is already
   being handled, the new exception's "__context__" attribute is
   automatically set to the handled exception.  An exception may be
   handled when an "except" or "finally" clause, or a "with"
   statement, is used.

   이 묵시적인 예외 컨텍스트는 암시적인 예외 상황은 명시적 원인으로 보
   충될 수 있는데, "raise"와 "from"을 사용합니다:

      raise new_exc from original_exc

   "from" 다음의 표현식은 예외이거나 "None" 이어야 합니다. 이 표현식을
   새로 일으키는 예외의 "__cause__" 로 설정합니다. "__cause__" 를 설정
   하면, 묵시적으로 "__suppress_context__" 를 "True" 로 설정합니다. 그
   래서, "raise new_exc from None" 을 사용하면 표시의 목적상 이전 예외
   를 새로운 것으로 대체 하는 효과를 주면서 (예를 들어 "KeyError" 를
   "AttributeError" 로), 디버깅할 때 검사할 수 있도록 이전의 예외를
   "__context__" 에 남겨둡니다.

   기본 트레이스백 표시 코드는 예외 자체의 트레이스백 뿐만 아니라 이러
   한 연결된 예외를 보여줍니다. "__cause__" 에 명시적으로 연결된 예외
   는 있으면 항상 표시됩니다. "__context__" 에 묵시적으로 연결된 예외
   는 "__cause__" 가 "None" 이고 "__suppress_context__" 가 거짓인 경우
   에만 표시됩니다.

   두 경우 모두, 예외 자신은 항상 연결된 예외 뒤에 표시되어서, 트레이
   스백의 마지막 줄은 항상 마지막에 발생한 예외를 보여줍니다.


내장 예외를 상속받기
====================

User code can create subclasses that inherit from an exception type.
It's recommended to only subclass one exception type at a time to
avoid any possible conflicts between how the bases handle the "args"
attribute, as well as due to possible memory layout incompatibilities.

**CPython 구현 상세:** Most built-in exceptions are implemented in C
for efficiency, see: Objects/exceptions.c.  Some have custom memory
layouts which makes it impossible to create a subclass that inherits
from multiple exception types. The memory layout of a type is an
implementation detail and might change between Python versions,
leading to new conflicts in the future.  Therefore, it's recommended
to avoid subclassing multiple exception types altogether.


베이스 클래스
=============

다음 예외는 주로 다른 예외의 베이스 클래스로 사용됩니다.

exception BaseException

   모든 내장 예외의 베이스 클래스입니다. 사용자 정의 클래스에 의해 직
   접 상속되는 것이 아닙니다 (그런 목적으로는 "Exception"을 사용하세요
   ). 이 클래스의 인스턴스에 대해 "str()" 이 호출되면, 인스턴스로 전달
   된 인자(들)의 표현을 돌려줍니다. 인자가 없는 경우는 빈 문자열을 돌
   려줍니다.

   args

      예외 생성자에 주어진 인자들의 튜플. 일부 내장 예외(예,
      "OSError")는 특정 수의 인자를 기대하고 이 튜플의 요소에 특별한
      의미를 할당하는 반면, 다른 것들은 보통 오류 메시지를 제공하는 단
      일 문자열로만 호출됩니다.

   with_traceback(tb)

      This method sets *tb* as the new traceback for the exception and
      returns the exception object.  It was more commonly used before
      the exception chaining features of **PEP 3134** became
      available.  The following example shows how we can convert an
      instance of "SomeException" into an instance of "OtherException"
      while preserving the traceback.  Once raised, the current frame
      is pushed onto the traceback of the "OtherException", as would
      have happened to the traceback of the original "SomeException"
      had we allowed it to propagate to the caller.

         try:
             ...
         except SomeException:
             tb = sys.exception().__traceback__
             raise OtherException(...).with_traceback(tb)

   __traceback__

      A writable field that holds the traceback object associated with
      this exception. See also: raise 문.

   add_note(note)

      Add the string "note" to the exception's notes which appear in
      the standard traceback after the exception string. A "TypeError"
      is raised if "note" is not a string.

      Added in version 3.11.

   __notes__

      A list of the notes of this exception, which were added with
      "add_note()". This attribute is created when "add_note()" is
      called.

      Added in version 3.11.

exception Exception

   모든 시스템 종료 외의 내장 예외는 이 클래스 파생됩니다. 모든 사용자
   정의 예외도 이 클래스에서 파생되어야 합니다.

exception ArithmeticError

   다양한 산술 에러가 일으키는 내장 예외들의 베이스 클래스:
   "OverflowError", "ZeroDivisionError", "FloatingPointError".

exception BufferError

   버퍼 관련 연산을 수행할 수 없을 때 발생합니다.

exception LookupError

   매핑 또는 시퀀스에 사용된 키 나 인덱스가 잘못되었을 때 발생하는 예
   외의 베이스 클래스: "IndexError", "KeyError". "codecs.lookup()" 은
   이 예외를 직접 일으킬 수 있습니다.


구체적인 예외
=============

다음 예외는 일반적으로 직접 일으키는데 사용하는 예외입니다.

exception AssertionError

   "assert" 문이 실패할 때 발생합니다.

exception AttributeError

   어트리뷰트 참조(어트리뷰트 참조를 보세요)나 대입이 실패할 때 발생합
   니다. (객체가 어트리뷰트 참조나 어트리뷰트 대입을 아예 지원하지 않
   으면 "TypeError" 가 발생합니다.)

   The optional *name* and *obj* keyword-only arguments set the
   corresponding attributes:

   name

      The name of the attribute that was attempted to be accessed.

   obj

      The object that was accessed for the named attribute.

   버전 3.10에서 변경: "name"과 "obj" 어트리뷰트를 추가했습니다.

exception EOFError

   Raised when the "input()" function hits an end-of-file condition
   (EOF) without reading any data. (Note: the "io.IOBase.read()" and
   "io.IOBase.readline()" methods return an empty string when they hit
   EOF.)

exception FloatingPointError

   현재 사용되지 않습니다.

exception GeneratorExit

   *제너레이터* 또는 *코루틴* 이 닫힐 때 발생합니다;
   "generator.close()" 와 "coroutine.close()" 를 보십시오. 기술적으로
   에러가 아니므로 "Exception" 대신에 "BaseException" 을 직접 계승합니
   다.

exception ImportError

   "import" 문이 모듈을 로드하는 데 문제가 있을 때 발생합니다. 또한
   "from ... import" 에서 임포트 하려는 이름을 찾을 수 없을 때도 발생
   합니다.

   The optional *name* and *path* keyword-only arguments set the
   corresponding attributes:

   name

      임포트가 시도된 모듈의 이름.

   path

      The path to any file which triggered the exception.

   버전 3.3에서 변경: "name"과 "path" 어트리뷰트를 추가했습니다.

exception ModuleNotFoundError

   "ImportError" 의 서브 클래스인데, 모듈을 찾을 수 없을 때 "import"
   가 일으킵니다. "sys.modules" 에서 "None" 이 발견될 때도 발생합니다.

   Added in version 3.6.

exception IndexError

   시퀀스 인덱스가 범위를 벗어날 때 발생합니다. (슬라이스 인덱스는 허
   용된 범위 내에 들어가도록 자동으로 잘립니다; 인덱스가 정수가 아니면
   "TypeError" 가 발생합니다.)

exception KeyError

   매핑 (딕셔너리) 키가 기존 키 집합에서 발견되지 않을 때 발생합니다.

exception KeyboardInterrupt

   사용자가 인터럽트 키(일반적으로 "Control"-"C" 또는 "Delete")를 누를
   때 발생합니다. 실행 중에 인터럽트 검사가 정기적으로 수행됩니다.
   "Exception"을 잡는 코드에 의해 우연히 잡혀서, 인터프리터가 종료하는
   것을 막지 못하도록 "BaseException" 를 계승합니다.

   참고:

     Catching a "KeyboardInterrupt" requires special consideration.
     Because it can be raised at unpredictable points, it may, in some
     circumstances, leave the running program in an inconsistent
     state. It is generally best to allow "KeyboardInterrupt" to end
     the program as quickly as possible or avoid raising it entirely.
     (See 신호 처리기와 예외에 대한 참고 사항.)

exception MemoryError

   작업에 메모리가 부족하지만, 상황이 여전히 (일부 객체를 삭제해서) 복
   구될 수 있는 경우 발생합니다. 연관된 값은 어떤 종류의 (내부) 연산이
   메모리를 다 써 버렸는지를 나타내는 문자열입니다. 하부 메모리 관리
   아키텍처(C의 "malloc()" 함수)때문에, 인터프리터가 항상 이 상황을 완
   벽하게 복구할 수 있는 것은 아닙니다; 그런데도 통제를 벗어난 프로그
   램이 원인인 경우를 위해, 스택 트레이스백을 인쇄할 수 있도록 예외를
   일으킵니다.

exception NameError

   지역 또는 전역 이름을 찾을 수 없을 때 발생합니다. 이는 정규화되지
   않은 이름에만 적용됩니다. 연관된 값은 찾을 수 없는 이름을 포함하는
   에러 메시지입니다.

   The optional *name* keyword-only argument sets the attribute:

   name

      The name of the variable that was attempted to be accessed.

   버전 3.10에서 변경: "name" 어트리뷰트를 추가했습니다.

exception NotImplementedError

   이 예외는 "RuntimeError" 에서 파생됩니다. 사용자 정의 베이스 클래스
   에서, 파생 클래스가 재정의하도록 요구하는 추상 메서드나, 클래스가
   개발되는 도중에 실제 구현이 추가될 필요가 있음을 나타낼 때 이 예외
   를 발생시켜야 합니다.

   참고:

     연산자 나 메서드가 아예 지원되지 않는다는 것을 나타내는 데 사용해
     서는 안 됩니다 -- 그 경우는 연산자 / 메서드를 정의하지 않거나, 서
     브 클래스면 "None" 으로 설정하십시오.

   조심:

     "NotImplementedError" 와 "NotImplemented" 는 바꿔쓸 수 없습니다.
     이 예외는 위에서 설명한 대로만 사용되어야 합니다; 내장 상수의 올
     바른 사용에 대한 자세한 내용은 "NotImplemented" 를 참조하세요.

exception OSError([arg])
exception OSError(errno, strerror[, filename[, winerror[, filename2]]])

   이 예외는 시스템 함수가 시스템 관련 에러를 돌려줄 때 발생하는데, "
   파일을 찾을 수 없습니다(file not found)" 나 "디스크가 꽉 찼습니다
   (disk full)" 와 같은 (잘못된 인자형이나 다른 부수적인 에러가 아닌)
   입출력 실패를 포함합니다.

   생성자의 두 번째 형식은 아래에 설명된 해당 어트리뷰트를 설정합니다.
   어트리뷰트를 지정하지 않으면 기본적으로 "None" 이 됩니다. 이전 버전
   과의 호환성을 위해, 세 개의 인자가 전달되면, "args" 어트리뷰트는 처
   음 두 생성자 인자의 2-튜플만 포함합니다.

   아래의 OS 예외 에서 설명하는 것처럼, 생성자는 종종 "OSError" 의 서
   브 클래스를 돌려줍니다. 구체적인 서브 클래스는 최종 "errno" 값에 따
   라 다릅니다. 이 동작은 "OSError" 를 직접 혹은 별칭을 통해 생성할 때
   만 일어나고, 서브 클래싱할 때는 상속되지 않습니다.

   errno

      C 변수 "errno" 로부터 온 숫자 에러 코드.

   winerror

      윈도우에서, 네이티브 윈도우 에러 코드를 제공합니다. "errno" 어트
      리뷰트는 이 네이티브 에러 코드를 POSIX 코드로 대략 변환한 것입니
      다.

      윈도우에서, *winerror* 생성자 인자가 정수인 경우, "errno" 어트리
      뷰트는 윈도우 에러 코드에서 결정되며 *errno* 인자는 무시됩니다.
      다른 플랫폼에서는 *winerror* 인자가 무시되고 "winerror" 어트리뷰
      트가 없습니다.

   strerror

      The corresponding error message, as provided by the operating
      system.  It is formatted by the C functions "perror()" under
      POSIX, and "FormatMessage()" under Windows.

   filename
   filename2

      ("open()" 또는 "os.unlink()" 와 같은) 파일 시스템 경로와 관련된
      예외의 경우, "filename" 은 함수에 전달 된 파일 이름입니다.
      ("os.rename()"처럼) 두 개의 파일 시스템 경로를 수반하는 함수의
      경우, "filename2" 는 두 번째 파일 이름에 해당합니다.

   버전 3.3에서 변경: "EnvironmentError", "IOError", "WindowsError",
   "socket.error", "select.error" and "mmap.error" have been merged
   into "OSError", and the constructor may return a subclass.

   버전 3.4에서 변경: "filename" 속성은 이제 *파일 시스템 인코딩과 에
   러 처리기*로 인코딩되거나 디코딩된 이름 대신 함수에 전달 된 원래 파
   일 이름입니다. 또한 *filename2* 생성자 인자 및 어트리뷰트가 추가되
   었습니다.

exception OverflowError

   산술 연산의 결과가 너무 커서 표현할 수 없을 때 발생합니다. 정수에서
   는 발생하지 않습니다 (포기하기보다는 "MemoryError" 를 일으키게 될
   겁니다). 그러나, 역사적인 이유로, 때로 OverflowError는 요구되는 범
   위를 벗어난 정수의 경우도 발생합니다. C에서 부동 소수점 예외 처리의
   표준화가 부족하므로, 대부분의 부동 소수점 연산은 검사되지 않습니다.

exception PythonFinalizationError

   This exception is derived from "RuntimeError".  It is raised when
   an operation is blocked during interpreter shutdown also known as
   *Python finalization*.

   Examples of operations which can be blocked with a
   "PythonFinalizationError" during the Python finalization:

   * Creating a new Python thread.

   * "Joining" a running daemon thread.

   * "os.fork()".

   See also the "sys.is_finalizing()" function.

   Added in version 3.13: 이전에는 평범한 "RuntimeError" 가 발생했습니
   다.

   버전 3.14에서 변경: "threading.Thread.join()" can now raise this
   exception.

exception RecursionError

   이 예외는 "RuntimeError" 에서 파생됩니다. 인터프리터가 최대 재귀 깊
   이("sys.getrecursionlimit()" 참조)가 초과하였음을 감지할 때 발생합
   니다.

   Added in version 3.5: 이전에는 평범한 "RuntimeError" 가 발생했습니
   다.

exception ReferenceError

   이 예외는 "weakref.proxy()" 함수가 만든 약한 참조 프락시가 이미 가
   비지 수집된 참조 대상의 어트리뷰트를 액세스하는 데 사용될 때 발생합
   니다. 약한 참조에 대한 더 자세한 정보는 "weakref" 모듈을 보십시오.

exception RuntimeError

   다른 범주에 속하지 않는 에러가 감지될 때 발생합니다. 연관된 값은 정
   확히 무엇이 잘못되었는지를 나타내는 문자열입니다.

exception StopIteration

   이터레이터에 의해 생성된 항목이 더 없다는 것을 알려주기 위해, 내장
   함수 "next()"와 *이터레이터*의 "__next__()" 메서드가 일으킵니다.

   value

      예외 객체는 "value"라는 하나의 어트리뷰트를 가지고 있습니다. 이
      어트리뷰트는 예외를 생성할 때 인자로 주어지며, 기본값은 "None"
      입니다.

   *제너레이터* 나 *코루틴* 함수가 복귀할 때, 새 "StopIteration" 인스
   턴스를 발생시키고, 함수가 돌려주는 값을 예외 생성자의 "value" 매개
   변수로 사용합니다.

   제너레이터 코드가 직간접적으로 "StopIteration" 를 일으키면,
   "RuntimeError" 로 변환됩니다 ("StopIteration" 은 새 예외의 원인
   ("__cause__")으로 남겨둡니다).

   버전 3.3에서 변경: "value" 어트리뷰트와 제너레이터 함수가 이 값을
   돌려주는 기능을 추가했습니다.

   버전 3.5에서 변경: "from __future__ import generator_stop" 를 통한
   RuntimeError 변환을 도입했습니다. **PEP 479**를 참조하세요.

   버전 3.7에서 변경: 기본적으로 모든 코드에서 **PEP 479**를 활성화합
   니다: 제너레이터에서 발생한 "StopIteration" 에러는 "RuntimeError"
   로 변환됩니다.

exception StopAsyncIteration

   반드시 *비동기 이터레이터* 객체의 "__anext__()" 메서드가 이터레이션
   을 멈추고자 할 때 발생시켜야 합니다.

   Added in version 3.5.

exception SyntaxError(message, details)

   파서가 문법 오류를 만날 때 발생합니다. "import" 문에서, 내장 함수
   "compile()", "exec()" 또는 "eval()" 호출에서, 초기 스크립트나 (대화
   형으로) 표준 입력을 읽을 때 발생할 수 있습니다.

   예외 인스턴스의 "str()"은 에러 메시지만 돌려줍니다. details는 각 멤
   버가 별도의 어트리뷰트로도 제공되는 튜플입니다.

   filename

      문법 오류가 발생한 파일의 이름.

   lineno

      오류가 발생한 파일의 줄 번호. 1-인덱싱됩니다: 파일의 첫 번째 줄
      은 "lineno"가 1입니다.

   offset

      오류가 발생한 줄의 열. 1-인덱싱됩니다: 줄의 첫 번째 문자는
      "offset"이 1입니다.

   text

      오류를 수반한 소스 코드 텍스트.

   end_lineno

      오류가 발생한 파일의 끝나는 줄 번호. 1-인덱싱됩니다: 파일의 첫
      번째 줄은 "lineno"가 1입니다.

   end_offset

      발생한 오류가 끝나는 줄의 열. 1-인덱싱됩니다: 줄의 첫 번째 문자
      는 "offset"이 1입니다.

   For errors in f-string fields, the message is prefixed by
   "f-string: " and the offsets are offsets in a text constructed from
   the replacement expression.  For example, compiling f'Bad {a b}
   field' results in this args attribute: ('f-string: ...', ('', 1, 2,
   '(a b)n', 1, 5)).

   버전 3.10에서 변경: "end_lineno"과 "end_offset" 어트리뷰트를 추가했
   습니다.

exception IndentationError

   잘못된 들여쓰기와 관련된 문법 오류의 베이스 클래스입니다.
   "SyntaxError" 의 서브 클래스입니다.

exception TabError

   들여쓰기가 일관성없는 탭과 스페이스 사용을 포함하는 경우 발생합니다
   . "IndentationError" 의 서브 클래스입니다.

exception SystemError

   인터프리터가 내부 에러를 발견했지만, 모든 희망을 포기할 만큼 상황이
   심각해 보이지는 않을 때 발생합니다. 연관된 값은 무엇이 잘못되었는지
   (저수준의 용어로) 나타내는 문자열입니다. *CPython*에서, 이는 가령
   예외를 설정하지 않고 "NULL"을 반환하는 것과 같이, 파이썬의 C API를
   잘못 사용함으로써 발생할 수 있습니다.

   이 예외가 여러분이나 사용 중인 패키지의 책임이 아니라고 확싱한다면,
   파이썬 인터프리터의 저자나 관리자에게 알려야 합니다. 파이썬 인터프
   리터의 버전 ("sys.version"; 대화식 파이썬 세션의 시작 부분에도 출력
   됩니다), 정확한 에러 메시지 (예외의 연관된 값) 그리고 가능하다면 에
   러를 일으킨 프로그램의 소스를 제공해 주십시오.

exception SystemExit

   This exception is raised by the "sys.exit()" function.  It inherits
   from "BaseException" instead of "Exception" so that it is not
   accidentally caught by code that catches "Exception".  This allows
   the exception to properly propagate up and cause the interpreter to
   exit.  When it is not handled, the Python interpreter exits; no
   stack traceback is printed.  The constructor accepts the same
   optional argument passed to "sys.exit()". If the value is an
   integer, it specifies the system exit status (passed to C's
   "exit()" function); if it is "None", the exit status is zero; if it
   has another type (such as a string), the object's value is printed
   and the exit status is one.

   "sys.exit()" 에 대한 호출은 예외로 변환되어 뒷정리 처리기 ("try" 문
   의 "finally" 절) 가 실행될 수 있도록 합니다. 그래서 디버거는 제어권
   을 잃을 위험 없이 스크립트를 실행할 수 있습니다. 즉시 종료가 절대적
   으로 필요한 경우에는 "os._exit()" 함수를 사용할 수 있습니다 (예를
   들어, "os.fork()" 호출 후의 자식 프로세스에서).

   code

      생성자에 전달되는 종료 상태 또는 에러 메시지입니다. (기본값은
      "None" 입니다.)

exception TypeError

   연산이나 함수가 부적절한 형의 객체에 적용될 때 발생합니다. 연관된
   값은 형 불일치에 대한 세부 정보를 제공하는 문자열입니다.

   이 예외는 객체에 시도된 연산이 지원되지 않으며 그럴 의도도 없음을
   나타내기 위해 사용자 코드가 발생시킬 수 있습니다. 만약 객체가 주어
   진 연산을 지원할 의사는 있지만, 아직 구현을 제공하지 않는 경우라면,
   "NotImplementedError" 를 발생시키는 것이 적합합니다.

   잘못된 형의 인자를 전달하면 (가령 "int" 를 기대하는데 "list"를 전달
   하기), "TypeError" 를 일으켜야 합니다. 하지만 잘못된 값을 갖는 인자
   를 전달하면 (가령 범위를 넘어서는 숫자) "ValueError" 를 일으켜야 합
   니다.

exception UnboundLocalError

   함수 나 메서드에서 지역 변수를 참조하지만, 해당 변수에 값이 연결되
   지 않으면 발생합니다. 이것은 "NameError" 의 서브 클래스입니다.

exception UnicodeError

   유니코드 관련 인코딩 또는 디코딩 에러가 일어날 때 발생합니다.
   "ValueError" 의 서브 클래스입니다.

   "UnicodeError" 는 인코딩이나 디코딩 에러를 설명하는 어트리뷰트를 가
   지고 있습니다. 예를 들어, "err.object[err.start:err.end]" 는 코덱이
   실패한 잘못된 입력을 제공합니다.

   encoding

      에러를 발생시킨 인코딩의 이름입니다.

   reason

      구체적인 코덱 오류를 설명하는 문자열입니다.

   object

      코덱이 인코딩 또는 디코딩하려고 시도한 객체입니다.

   start

      "object" 에 있는 잘못된 데이터의 최초 인덱스입니다.

      This value should not be negative as it is interpreted as an
      absolute offset but this constraint is not enforced at runtime.

   end

      "object" 에 있는 마지막으로 잘못된 데이터의 바로 다음 인덱스입니
      다.

      This value should not be negative as it is interpreted as an
      absolute offset but this constraint is not enforced at runtime.

exception UnicodeEncodeError

   인코딩 중에 유니코드 관련 에러가 일어나면 발생합니다.
   "UnicodeError" 의 서브 클래스입니다.

exception UnicodeDecodeError

   디코딩 중에 유니코드 관련 에러가 일어나면 발생합니다.
   "UnicodeError" 의 서브 클래스입니다.

exception UnicodeTranslateError

   번역 중에 유니코드 관련 에러가 일어나면 발생합니다. "UnicodeError"
   의 서브 클래스입니다.

exception ValueError

   연산이나 함수가 올바른 형이지만 부적절한 값을 가진 인자를 받았고,
   상황이 "IndexError" 처럼 더 구체적인 예외로 설명되지 않는 경우 발생
   합니다.

exception ZeroDivisionError

   나누기 또는 모듈로 연산의 두 번째 인자가 0일 때 발생합니다. 연관된
   값은 피연산자의 형과 연산을 나타내는 문자열입니다.

다음 예외는 이전 버전과의 호환성을 위해 유지됩니다; 파이썬 3.3부터는
"OSError" 의 별칭입니다.

exception EnvironmentError

exception IOError

exception WindowsError

   윈도우에서만 사용할 수 있습니다.


OS 예외
-------

다음의 예외는 "OSError" 의 서브 클래스이며, 시스템 에러 코드에 따라 발
생합니다.

exception BlockingIOError

   비 블록 동작으로 설정된 객체(가령 소켓)에 블록이 필요한 연산이 수행
   되면 발생합니다. "errno" "EAGAIN", "EALREADY", "EWOULDBLOCK",
   "EINPROGRESS" 에 해당합니다.

   "OSError" 의 것 외에도, "BlockingIOError" 는 어트리뷰트를 하나 더
   가질 수 있습니다:

   characters_written

      An integer containing the number of **bytes** written to the
      stream before it blocked. This attribute is available when using
      the buffered I/O classes from the "io" module.

exception ChildProcessError

   자식 프로세스에 대한 작업이 실패할 때 발생합니다. "errno" "ECHILD"
   에 해당합니다.

exception ConnectionError

   연결 관련 문제에 대한 베이스 클래스입니다.

   서브 클래스는 "BrokenPipeError", "ConnectionAbortedError",
   "ConnectionRefusedError" 및 "ConnectionResetError" 입니다.

exception BrokenPipeError

   "ConnectionError" 의 서브 클래스로서, 다른 쪽 끝이 닫힌 파이프에 쓰
   려고 하거나, 쓰기가 종료된 소켓에 쓰려고 할 때 발생합니다. "errno"
   "EPIPE" 와 "ESHUTDOWN" 에 해당합니다.

exception ConnectionAbortedError

   "ConnectionError" 의 서브 클래스로서, 연결 시도가 상대방에 의해 중
   단(abort)될 때 발생합니다. "errno" "ECONNABORTED" 에 해당합니다.

exception ConnectionRefusedError

   "ConnectionError" 의 서브 클래스로서, 연결 시도가 상대방에 의해 거
   부(refuse)될 때 발생합니다. "errno" "ECONNREFUSED" 에 해당합니다.

exception ConnectionResetError

   "ConnectionError" 의 서브 클래스로서, 연결이 상대방에 의해 강제 종
   료(reset)될 때 발생합니다. "errno" "ECONNRESET" 에 해당합니다.

exception FileExistsError

   이미 존재하는 파일이나 디렉터리를 만들려고 할 때 발생합니다.
   "errno" "EEXIST" 에 해당합니다.

exception FileNotFoundError

   파일이나 디렉터리가 요청되었지만 존재하지 않을 때 발생합니다.
   "errno" "ENOENT" 에 해당합니다.

exception InterruptedError

   시스템 호출이 들어오는 시그널에 의해 중단될 때 발생합니다. "errno"
   "EINTR" 에 해당합니다.

   버전 3.5에서 변경: 이제 파이썬은 시스템 호출이 시그널에 의해 중단될
   때, 시그널 처리기가 예외를 일으키는 경우를 제외하고 (이유는 **PEP
   475** 를 참조하세요), "InterruptedError" 를 일으키는 대신 시스템 호
   출을 재시도합니다.

exception IsADirectoryError

   디렉터리에 파일 연산(가령 "os.remove()")이 요청되었을 때 발생합니다
   . "errno" "EISDIR" 에 해당합니다.

exception NotADirectoryError

   디렉터리가 아닌 것에 디렉터리 연산(가령 "os.listdir()")이 요청되었
   을 때 발생합니다. 대부분의 POSIX 플랫폼에서, 연산이 디렉터리가 아닌
   파일을 디렉터리인 것처럼 열거나 탐색하려고 할 때도 발생합니다.
   "errno" "ENOTDIR" 에 해당합니다.

exception PermissionError

   적절한 접근권 (가령 파일 시스템 권한) 없이 연산을 실행하려고 할 때
   발생합니다. "errno" "EACCES", "EPERM" 및 "ENOTCAPABLE" 에 해당합니
   다.

   버전 3.11.1에서 변경: WASI's "ENOTCAPABLE" is now mapped to
   "PermissionError".

exception ProcessLookupError

   주어진 프로세스가 존재하지 않을 때 발생합니다. "errno" "ESRCH" 에
   해당합니다.

exception TimeoutError

   시스템 함수가 시스템 수준에서 시간 초과 될 때 발생합니다. "errno"
   "ETIMEDOUT" 에 해당합니다.

Added in version 3.3: 위의 모든 "OSError" 서브 클래스가 추가되었습니다
.

더 보기: **PEP 3151** - OS 및 IO 예외 계층 구조 재작업


경고
====

다음 예외는 경고 범주로 사용됩니다; 자세한 정보는 경고 범주 설명서를
보십시오.

exception Warning

   경고 범주의 베이스 클래스입니다.

exception UserWarning

   사용자 코드에 의해 만들어지는 경고의 베이스 클래스입니다.

exception DeprecationWarning

   폐지된 기능에 대한 경고의 베이스 클래스인데, 그 경고가 다른 파이썬
   개발자를 대상으로 하는 경우입니다.

   "__main__" 모듈을 제외하고, 기본 경고 필터에 의해 무시됩니다 (**PEP
   565**). 파이썬 개발 모드를 활성화하면 이 경고가 표시됩니다.

   The deprecation policy is described in **PEP 387**.

exception PendingDeprecationWarning

   더는 사용되지 않고 장래에 폐지될 예정이지만, 지금 당장 폐지되지는
   않은 기능에 관한 경고의 베이스 클래스입니다.

   앞으로 있을 수도 있는 폐지에 관한 경고는 일반적이지 않기 때문에, 이
   클래스는 거의 사용되지 않습니다. 이미 활성화된 폐지에는
   "DeprecationWarning"을 선호합니다.

   기본 경고 필터에 의해 무시됩니다. 파이썬 개발 모드를 활성화하면 이
   경고가 표시됩니다.

   The deprecation policy is described in **PEP 387**.

exception SyntaxWarning

   모호한 문법에 대한 경고의 베이스 클래스입니다.

   This warning is typically emitted when compiling Python source
   code, and usually won't be reported when running already compiled
   code.

exception RuntimeWarning

   모호한 실행 시간 동작에 대한 경고의 베이스 클래스입니다.

exception FutureWarning

   폐지된 기능에 대한 경고의 베이스 클래스인데, 그 경고가 파이썬으로
   작성된 응용 프로그램의 최종 사용자를 대상으로 하는 경우입니다.

exception ImportWarning

   모듈 임포트에 있을 수 있는 실수에 대한 경고의 베이스 클래스입니다.

   기본 경고 필터에 의해 무시됩니다. 파이썬 개발 모드를 활성화하면 이
   경고가 표시됩니다.

exception UnicodeWarning

   유니코드와 관련된 경고의 베이스 클래스입니다.

exception EncodingWarning

   인코딩과 관련된 경고의 베이스 클래스입니다.

   See Opt-in EncodingWarning for details.

   Added in version 3.10.

exception BytesWarning

   "bytes" 및 "bytearray" 와 관련된 경고의 베이스 클래스입니다.

exception ResourceWarning

   자원 사용과 관련된 경고의 베이스 클래스입니다.

   기본 경고 필터에 의해 무시됩니다. 파이썬 개발 모드를 활성화하면 이
   경고가 표시됩니다.

   Added in version 3.2.


예외 그룹
=========

The following are used when it is necessary to raise multiple
unrelated exceptions. They are part of the exception hierarchy so they
can be handled with "except" like all other exceptions. In addition,
they are recognised by "except*", which matches their subgroups based
on the types of the contained exceptions.

exception ExceptionGroup(msg, excs)

exception BaseExceptionGroup(msg, excs)

   Both of these exception types wrap the exceptions in the sequence
   "excs". The "msg" parameter must be a string. The difference
   between the two classes is that "BaseExceptionGroup" extends
   "BaseException" and it can wrap any exception, while
   "ExceptionGroup" extends "Exception" and it can only wrap
   subclasses of "Exception". This design is so that "except
   Exception" catches an "ExceptionGroup" but not
   "BaseExceptionGroup".

   The "BaseExceptionGroup" constructor returns an "ExceptionGroup"
   rather than a "BaseExceptionGroup" if all contained exceptions are
   "Exception" instances, so it can be used to make the selection
   automatic. The "ExceptionGroup" constructor, on the other hand,
   raises a "TypeError" if any contained exception is not an
   "Exception" subclass.

   message

      The "msg" argument to the constructor. This is a read-only
      attribute.

   exceptions

      A tuple of the exceptions in the "excs" sequence given to the
      constructor. This is a read-only attribute.

   subgroup(condition)

      Returns an exception group that contains only the exceptions
      from the current group that match *condition*, or "None" if the
      result is empty.

      The condition can be an exception type or tuple of exception
      types, in which case each exception is checked for a match using
      the same check that is used in an "except" clause.  The
      condition can also be a callable (other than a type object) that
      accepts an exception as its single argument and returns true for
      the exceptions that should be in the subgroup.

      The nesting structure of the current exception is preserved in
      the result, as are the values of its "message", "__traceback__",
      "__cause__", "__context__" and "__notes__" fields. Empty nested
      groups are omitted from the result.

      The condition is checked for all exceptions in the nested
      exception group, including the top-level and any nested
      exception groups. If the condition is true for such an exception
      group, it is included in the result in full.

      Added in version 3.13: "condition" can be any callable which is
      not a type object.

   split(condition)

      Like "subgroup()", but returns the pair "(match, rest)" where
      "match" is "subgroup(condition)" and "rest" is the remaining
      non-matching part.

   derive(excs)

      Returns an exception group with the same "message", but which
      wraps the exceptions in "excs".

      This method is used by "subgroup()" and "split()", which are
      used in various contexts to break up an exception group. A
      subclass needs to override it in order to make "subgroup()" and
      "split()" return instances of the subclass rather than
      "ExceptionGroup".

      "subgroup()" and "split()" copy the "__traceback__",
      "__cause__", "__context__" and "__notes__" fields from the
      original exception group to the one returned by "derive()", so
      these fields do not need to be updated by "derive()".

         >>> class MyGroup(ExceptionGroup):
         ...     def derive(self, excs):
         ...         return MyGroup(self.message, excs)
         ...
         >>> e = MyGroup("eg", [ValueError(1), TypeError(2)])
         >>> e.add_note("a note")
         >>> e.__context__ = Exception("context")
         >>> e.__cause__ = Exception("cause")
         >>> try:
         ...    raise e
         ... except Exception as e:
         ...    exc = e
         ...
         >>> match, rest = exc.split(ValueError)
         >>> exc, exc.__context__, exc.__cause__, exc.__notes__
         (MyGroup('eg', [ValueError(1), TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])
         >>> match, match.__context__, match.__cause__, match.__notes__
         (MyGroup('eg', [ValueError(1)]), Exception('context'), Exception('cause'), ['a note'])
         >>> rest, rest.__context__, rest.__cause__, rest.__notes__
         (MyGroup('eg', [TypeError(2)]), Exception('context'), Exception('cause'), ['a note'])
         >>> exc.__traceback__ is match.__traceback__ is rest.__traceback__
         True

   Note that "BaseExceptionGroup" defines "__new__()", so subclasses
   that need a different constructor signature need to override that
   rather than "__init__()". For example, the following defines an
   exception group subclass which accepts an exit_code and constructs
   the group's message from it.

      class Errors(ExceptionGroup):
         def __new__(cls, errors, exit_code):
            self = super().__new__(Errors, f"exit code: {exit_code}", errors)
            self.exit_code = exit_code
            return self

         def derive(self, excs):
            return Errors(excs, self.exit_code)

   Like "ExceptionGroup", any subclass of "BaseExceptionGroup" which
   is also a subclass of "Exception" can only wrap instances of
   "Exception".

   Added in version 3.11.


예외 계층 구조
==============

내장 예외의 클래스 계층 구조는 다음과 같습니다:

   BaseException
    ├── BaseExceptionGroup
    ├── GeneratorExit
    ├── KeyboardInterrupt
    ├── SystemExit
    └── Exception
         ├── ArithmeticError
         │    ├── FloatingPointError
         │    ├── OverflowError
         │    └── ZeroDivisionError
         ├── AssertionError
         ├── AttributeError
         ├── BufferError
         ├── EOFError
         ├── ExceptionGroup [BaseExceptionGroup]
         ├── ImportError
         │    └── ModuleNotFoundError
         ├── LookupError
         │    ├── IndexError
         │    └── KeyError
         ├── MemoryError
         ├── NameError
         │    └── UnboundLocalError
         ├── OSError
         │    ├── BlockingIOError
         │    ├── ChildProcessError
         │    ├── ConnectionError
         │    │    ├── BrokenPipeError
         │    │    ├── ConnectionAbortedError
         │    │    ├── ConnectionRefusedError
         │    │    └── ConnectionResetError
         │    ├── FileExistsError
         │    ├── FileNotFoundError
         │    ├── InterruptedError
         │    ├── IsADirectoryError
         │    ├── NotADirectoryError
         │    ├── PermissionError
         │    ├── ProcessLookupError
         │    └── TimeoutError
         ├── ReferenceError
         ├── RuntimeError
         │    ├── NotImplementedError
         │    ├── PythonFinalizationError
         │    └── RecursionError
         ├── StopAsyncIteration
         ├── StopIteration
         ├── SyntaxError
         │    └── IndentationError
         │         └── TabError
         ├── SystemError
         ├── TypeError
         ├── ValueError
         │    └── UnicodeError
         │         ├── UnicodeDecodeError
         │         ├── UnicodeEncodeError
         │         └── UnicodeTranslateError
         └── Warning
              ├── BytesWarning
              ├── DeprecationWarning
              ├── EncodingWarning
              ├── FutureWarning
              ├── ImportWarning
              ├── PendingDeprecationWarning
              ├── ResourceWarning
              ├── RuntimeWarning
              ├── SyntaxWarning
              ├── UnicodeWarning
              └── UserWarning
