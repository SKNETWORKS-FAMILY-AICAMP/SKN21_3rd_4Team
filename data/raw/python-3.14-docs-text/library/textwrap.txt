"textwrap" --- 텍스트 래핑과 채우기
***********************************

**소스 코드:** Lib/textwrap.py

======================================================================

"textwrap" 모듈은 모든 작업을 수행하는 클래스인 "TextWrapper"뿐만 아니
라 몇 가지 편리 함수도 제공합니다. 한두 개의 텍스트 문자열을 래핑
(wrapping)하거나 채운(filling)다면, 편리 함수로도 충분해야 합니다; 그
렇지 않으면 효율을 위해 "TextWrapper" 인스턴스를 사용해야 합니다.

textwrap.wrap(text, width=70, *, initial_indent='', subsequent_indent='', expand_tabs=True, replace_whitespace=True, fix_sentence_endings=False, break_long_words=True, drop_whitespace=True, break_on_hyphens=True, tabsize=8, max_lines=None, placeholder=' [...]')

   *text*(문자열)에 있는 단일 문단을 래핑해서 모든 줄의 길이가 최대
   *width* 자가 되도록 합니다. 최종 줄 바꿈이 없는 출력 줄의 리스트를
   반환합니다.

   선택적 키워드 인자는 아래에 설명된 "TextWrapper"의 인스턴스 어트리
   뷰트에 해당합니다.

   "wrap()" 작동 방식에 대한 자세한 내용은 "TextWrapper.wrap()" 메서드
   를 참조하십시오.

textwrap.fill(text, width=70, *, initial_indent='', subsequent_indent='', expand_tabs=True, replace_whitespace=True, fix_sentence_endings=False, break_long_words=True, drop_whitespace=True, break_on_hyphens=True, tabsize=8, max_lines=None, placeholder=' [...]')

   *text*에 있는 단일 문단을 래핑하고, 래핑 된 문단을 포함하는 단일 문
   자열을 반환합니다. "fill()"은 다음의 줄임 표현입니다

      "\n".join(wrap(text, ...))

   특히, "fill()"은 "wrap()"과 같은 키워드 인자를 받아들입니다.

textwrap.shorten(text, width, *, fix_sentence_endings=False, break_long_words=True, break_on_hyphens=True, placeholder=' [...]')

   주어진 *width*에 맞게 주어진 *text*를 축약하거나 자릅니다.

   먼저 *text*에 있는 공백이 축약됩니다 (모든 공백이 단일 스페이스로
   치환됩니다). 결과가 *width*에 맞으면 반환됩니다. 그렇지 않으면, 나
   머지 단어와 *placeholder*가 *width* 내에 맞도록 충분한 단어가 끝에
   서 삭제됩니다:

      >>> textwrap.shorten("Hello  world!", width=12)
      'Hello world!'
      >>> textwrap.shorten("Hello  world!", width=11)
      'Hello [...]'
      >>> textwrap.shorten("Hello world", width=10, placeholder="...")
      'Hello...'

   선택적 키워드 인자는 아래에 설명된 "TextWrapper"의 인스턴스 어트리
   뷰트에 해당합니다. 텍스트가 "TextWrapper" "fill()" 함수에 전달되기
   전에 공백이 축약되므로, "tabsize", "expand_tabs", "drop_whitespace"
   및 "replace_whitespace" 값을 변경하는 것은 아무 효과가 없음에 유의
   하십시오.

   Added in version 3.4.

textwrap.dedent(text)

   *text*의 모든 줄에서 같은 선행 공백을 제거합니다.

   이것은 삼중 따옴표로 묶은 문자열을 소스 코드에서 여전히 들여쓰기 된
   형태로 제시하면서, 디스플레이의 왼쪽 가장자리에 맞추는 데 사용할 수
   있습니다.

   탭과 공백은 모두 공백으로 처리되지만, 이들이 같지 않음에 유의하십시
   오: ""  hello""와 ""\thello"" 줄에는 공통 선행 공백이 없는 것으로
   간주합니다.

   공백만 포함하는 줄은 입력에서 무시되고 출력에서 단일 개행 문자로 정
   규화됩니다.

   예를 들면:

      def test():
          # 빈 줄을 피하려고 첫 줄을 \ 로 끝냅니다!
          s = '''\
          hello
            world
          '''
          print(repr(s))          # '    hello\n      world\n    ' 를 인쇄합니다
          print(repr(dedent(s)))  # 'hello\n  world\n' 를 인쇄합니다

textwrap.indent(text, prefix, predicate=None)

   *text*에서 선택된 줄의 시작 부분에 *prefix*를 추가합니다.

   "text.splitlines(True)"를 호출하여 줄을 분할합니다.

   기본적으로, *prefix*는 공백으로만 구성되지 않는 모든 줄(마지막 줄
   포함)에 추가됩니다.

   예를 들면:

      >>> s = 'hello\n\n \nworld'
      >>> indent(s, '  ')
      '  hello\n\n \n  world'

   선택적 *predicate* 인자는 어떤 줄을 들여쓰기할지 제어하는 데 사용될
   수 있습니다. 예를 들어, 빈 줄과 공백만 있는 줄에도 *prefix*를 추가
   하기는 쉽습니다:

      >>> print(indent(s, '+ ', lambda line: True))
      + hello
      +
      +
      + world

   Added in version 3.3.

"wrap()", "fill()" 및 "shorten()"은 "TextWrapper" 인스턴스를 만들고 그
것의 단일 메서드를 호출하여 작동합니다. 이 인스턴스는 재사용되지 않기
때문에, "wrap()" 및/또는 "fill()"을 사용하여 많은 텍스트 문자열을 처리
하는 응용 프로그램의 경우, 여러분 자신의 "TextWrapper" 객체를 만드는
것이 더 효율적일 수 있습니다.

텍스트는 공백과 하이픈이 있는 단어의 하이픈 바로 뒤에서 래핑하는 것을
선호합니다; "TextWrapper.break_long_words"가 거짓으로 설정되어 있지 않
으면 그 후에만 긴 단어를 분할합니다.

class textwrap.TextWrapper(**kwargs)

   "TextWrapper" 생성자는 여러 개의 선택적 키워드 인자를 받아들입니다.
   각 키워드 인자는 인스턴스 어트리뷰트에 해당합니다, 그래서 예를 들면

      wrapper = TextWrapper(initial_indent="* ")

   는 다음과 같습니다

      wrapper = TextWrapper()
      wrapper.initial_indent = "* "

   같은 "TextWrapper" 객체를 여러 번 재사용 할 수 있으며, 사용 도중 인
   스턴스 어트리뷰트에 직접 대입하여 옵션을 변경할 수 있습니다.

   "TextWrapper" 인스턴스 어트리뷰트(와 생성자에 대한 키워드 인자)는
   다음과 같습니다:

   width

      (기본값: "70") 래핑 된 줄의 최대 길이. 입력 텍스트에 "width"보다
      긴 개별 단어가 없는 한, "TextWrapper"는 "width" 문자보다 긴 출력
      줄이 없음을 보장합니다.

   expand_tabs

      (기본값: "True") 참이면, *text*의 모든 탭 문자가 *text*의
      "expandtabs()" 메서드를 사용하여 스페이스로 확장됩니다.

   tabsize

      (기본값: "8") "expand_tabs"가 참이면, *text*의 모든 탭 문자는 현
      재 열과 주어진 탭 크기에 따라 0개 이상의 스페이스로 확장됩니다.

      Added in version 3.3.

   replace_whitespace

      (기본값: "True") 참이면, 탭 확장 후 래핑 전에, "wrap()" 메서드는
      각 공백 문자를 단일 스페이스로 치환합니다. 치환되는 공백 문자는
      다음과 같습니다: 탭, 줄 바꿈, 세로 탭, 폼 피드 및 캐리지 리턴
      ("'\t\n\v\f\r'").

      참고:

        "expand_tabs"가 거짓이고 "replace_whitespace"가 참이면, 각 탭
        문자는 단일 스페이스로 치환되는데, 탭 확장과는 *다릅니다*.

      참고:

        "replace_whitespace"가 거짓이면, 줄 중간에 줄 바꿈이 나타나서
        이상한 결과가 발생할 수 있습니다. 이러한 이유로, 텍스트는
        ("str.splitlines()"나 유사한 것을 사용해서) 문단으로 분할한 후
        에 별도로 래핑해야 합니다.

   drop_whitespace

      (기본값: "True") 참이면, 모든 줄의 처음과 끝의 공백(래핑 이후 들
      여쓰기 전)이 삭제됩니다. 문단 시작 부분의 공백은 공백이 아닌 것
      이 뒤에 오면 삭제되지 않습니다. 삭제되는 공백이 줄 전체를 차지하
      면, 줄 전체가 삭제됩니다.

   initial_indent

      (기본값: "''") 래핑 된 출력의 첫 번째 줄 앞에 추가될 문자열입니
      다. 첫 번째 줄의 길이 계산에 포함됩니다. 빈 문자열은 들여 쓰지
      않습니다.

   subsequent_indent

      (기본값: "''") 첫 줄을 제외한 래핑 된 출력의 모든 줄 앞에 추가될
      문자열입니다. 첫 번째 줄을 제외한 각 줄의 길이 계산에 포함됩니다
      .

   fix_sentence_endings

      (기본값: "False") 참이면, "TextWrapper"는 문장의 끝을 감지하고
      문장이 항상 정확히 두 개의 스페이스로 분리되도록 만들려고 합니다
      . 이것은 일반적으로 고정 폭 글꼴의 텍스트에 적합합니다. 그러나,
      문장 감지 알고리즘은 불완전합니다: 문장 끝은 "'.'", "'!'" 또는
      "'?'" 중 하나가 뒤에 오고, "'"'"나 ""'"" 중 하나가 뒤따르는 것도
      가능, 그 뒤에 스페이스가 오는 소문자로 구성된다고 가정합니다. 이
      알고리즘의 한가지 문제는 다음에 나오는 "Dr." 와

         [...] Dr. Frankenstein's monster [...]

      다음에 나오는 "Spot." 사이의 차이점을 탐지할 수 없다는 것입니다

         [...] See Spot. See Spot run [...]

      "fix_sentence_endings"는 기본적으로 거짓입니다.

      문장 감지 알고리즘은 "소문자" 의 정의에 "string.lowercase"에 의
      존하고, 같은 줄에서 문장을 분리하기 위해 마침표 뒤에 두 개의 스
      페이스를 사용하는 규칙을 따르므로, 영어 텍스트에만 적용됩니다.

   break_long_words

      (기본값: "True") 참이면, "width"보다 긴 줄이 없도록 하기 위해,
      "width"보다 긴 단어를 분할합니다. 거짓이면, 긴 단어가 깨지지 않
      으며, 일부 줄이 "width"보다 길 수 있습니다. ("width"를 초과하는
      양을 최소화하기 위해 긴 단어는 독립된 줄에 넣습니다.)

   break_on_hyphens

      (기본값: "True") 참이면, 래핑이, 영어에서의 관례대로, 공백과 복
      합 단어의 하이픈 바로 뒤에서 발생합니다. 거짓이면, 공백만을 줄
      바꿈을 위한 좋은 장소로 간주하지만, 진정한 분할되지 않는 단어를
      원한다면 "break_long_words"를 거짓으로 설정해야 합니다. 이전 버
      전의 기본 동작은 항상 하이픈으로 연결된 단어를 분리 할 수 있게
      하는 것이었습니다.

   max_lines

      (기본값: "None") "None"이 아니면, 출력은 최대 *max_lines* 줄을
      포함하고, *placeholder*가 출력 끝에 나타납니다.

      Added in version 3.4.

   placeholder

      (기본값: "' [...]'") 잘렸을 때 출력 텍스트의 끝에 표시할 문자열.

      Added in version 3.4.

   "TextWrapper"는 모듈 수준 편리 함수와 유사한 몇 가지 공용 메서드도
   제공합니다:

   wrap(text)

      *text*(문자열)에 있는 한 문단을 모든 줄의 길이가 최대 "width" 자
      가 되도록 래핑합니다. 모든 래핑 옵션은 "TextWrapper" 인스턴스의
      인스턴스 어트리뷰트에서 가져옵니다. 최종 줄 바꿈이 없는 출력 줄
      의 리스트를 반환합니다. 래핑 된 출력에 내용이 없으면 반환된 리스
      트는 비어 있습니다.

   fill(text)

      *text*에 있는 단일 문단을 래핑하고, 래핑 된 문단을 포함하는 단일
      문자열을 반환합니다.
