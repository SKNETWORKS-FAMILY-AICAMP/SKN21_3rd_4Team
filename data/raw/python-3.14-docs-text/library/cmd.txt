"cmd" --- 줄 지향 명령 인터프리터 지원
**************************************

**소스 코드:** Lib/cmd.py

======================================================================

"Cmd" 클래스는 줄 지향 명령 인터프리터를 작성하기 위한 간단한 프레임워
크를 제공합니다. 이것들은 종종 테스트 하네스(test harnesses), 관리 도
구 및 나중에 더 복잡한 인터페이스로 포장될 프로토타입에 유용합니다.

class cmd.Cmd(completekey='tab', stdin=None, stdout=None)

   "Cmd" 인스턴스나 서브 클래스 인스턴스는 줄 지향 인터프리터 프레임워
   크입니다. "Cmd" 자체를 인스턴스로 만들 이유는 없습니다; 그보다는,
   "Cmd"의 메서드를 상속하고 액션 메서드를 캡슐화하기 위해 여러분 스스
   로 정의한 인터프리터 클래스의 슈퍼 클래스로 유용합니다.

   선택적 인자 *completekey*는 완성 키(completion key)의 "readline" 이
   름입니다; 기본값은 "Tab"입니다. *completekey*가 "None"이 아니고
   "readline"을 사용할 수 있으면, 명령 완성이 자동으로 수행됩니다.

   The default, "'tab'", is treated specially, so that it refers to
   the "Tab" key on every "readline.backend". Specifically, if
   "readline.backend" is "editline", "Cmd" will use "'^I'" instead of
   "'tab'". Note that other values are not treated this way, and might
   only work with a specific backend.

   선택적 인자 *stdin*과 *stdout*은 Cmd 인스턴스나 서브 클래스 인스턴
   스가 입출력에 사용할 입력과 출력 파일 객체를 지정합니다. 지정하지
   않으면, 기본적으로 "sys.stdin"과 "sys.stdout"이 됩니다.

   지정된 *stdin*을 사용하려면, 인스턴스의 "use_rawinput" 어트리뷰트를
   "False"로 설정해야 합니다, 그렇지 않으면 *stdin*이 무시됩니다.

   버전 3.13에서 변경: "completekey='tab'" is replaced by "'^I'" for
   "editline".


Cmd 객체
========

"Cmd" 인스턴스에는 다음과 같은 메서드가 있습니다:

Cmd.cmdloop(intro=None)

   반복해서 프롬프트를 제시하고, 입력을 받아들이고, 수신된 입력에서 초
   기 접두사를 구문 분석하고, 줄의 나머지 부분을 인자로 전달해서 액션
   메서드를 호출합니다.

   선택적 인자는 첫 번째 프롬프트 전에 제시할 배너나 소개 문자열입니다
   (이것은 "intro" 클래스 어트리뷰트를 재정의합니다).

   "readline" 모듈이 로드되면, 입력은 자동으로 **bash**와 유사한 히스
   토리 목록 편집을 상속합니다 (예를 들어, "Control"-"P"는 직전 명령으
   로 돌아가고(scroll back), "Control"-"N"은 다음 명령으로 이동하고
   (forward), "Control"-"F"는 커서를 비파괴적으로 오른쪽으로 이동하고,
   "Control"-"B"는 커서를 비파괴적으로 왼쪽으로 이동하고, 등등).

   입력의 파일 끝(end-of-file)은 문자열 "'EOF'"로 전달됩니다.

   인터프리터 인스턴스는 메서드 "do_foo()"가 있을 때만 명령 이름 "foo"
   를 인식합니다. 특수한 경우로, 문자 "'?'"로 시작하는 줄은 메서드
   "do_help()"를 호출합니다. 또 다른 특수한 경우로, 문자 "'!'"로 시작
   하는 줄은 메서드 "do_shell()"을 (해당 메서드가 정의되었다면) 호출합
   니다.

   이 메서드는 "postcmd()" 메서드가 참값을 반환할 때 반환합니다.
   "postcmd()"에 대한 *stop* 인자는 명령의 해당 "do_*()" 메서드에서 반
   환되는 값입니다.

   완성(completion)이 활성화되면, 명령 완성이 자동으로 수행되고, 명령
   인자의 완성은 인자 *text*, *line*, *begidx* 및 *endidx*로
   "complete_foo()"를 호출하여 수행됩니다. *text*는 일치시키려는 문자
   열 접두사입니다: 반환된 모든 일치는 이 문자열로 시작해야 합니다.
   *line*은 선행 공백이 제거된 현재 입력 줄이며, *begidx*와 *endidx*는
   접두사 텍스트의 시작과 끝 인덱스로, 인자의 위치에 따라 다른 완성을
   제공하는 데 사용될 수 있습니다.

Cmd.do_help(arg)

   "Cmd"의 모든 서브 클래스는 미리 정의된 "do_help()"를 상속합니다. 인
   자 "'bar'"로 호출되면, 이 메서드는 해당 메서드 "help_bar()"를 호출
   하고, 존재하지 않으면 "do_bar()"의 독스트링이 있다면 인쇄합니다. 인
   자가 없으면, "do_help()"는 사용 가능한 모든 도움말 주제(즉, 해당
   "help_*()" 메서드가 있거나 독스트링이 있는 모든 명령)을 나열하고,
   설명이 없는 명령도 나열합니다.

Cmd.onecmd(str)

   프롬프트에 대한 응답으로 입력된 것처럼 인자를 해석합니다. 재정의될
   수도 있지만, 일반적으로 그럴 필요가 없어야 합니다; 유용한 실행 훅에
   대해서는 "precmd()"와 "postcmd()" 메서드를 참조하십시오. 반환 값은
   인터프리터의 명령 해석이 중지되어야 하는지를 나타내는 플래그입니다.
   명령 *str*을 위한 "do_*()" 메서드가 있으면, 해당 메서드의 반환 값이
   반환되고, 그렇지 않으면 "default()" 메서드의 반환 값이 반환됩니다.

Cmd.emptyline()

   프롬프트에 응답하여 빈 줄을 입력할 때 호출되는 메서드. 이 메서드를
   재정의하지 않으면, 입력된 마지막 비어 있지 않은 명령을 반복합니다.

Cmd.default(line)

   명령 접두사가 인식되지 않을 때 입력 줄로 호출되는 메서드. 이 메서드
   를 재정의하지 않으면, 에러 메시지를 인쇄하고 반환합니다.

Cmd.completedefault(text, line, begidx, endidx)

   명령 별 "complete_*()" 메서드가 없을 때 입력 줄을 완성하기 위해 호
   출되는 메서드. 기본적으로, 빈 리스트를 반환합니다.

Cmd.columnize(list, displaywidth=80)

   Method called to display a list of strings as a compact set of
   columns. Each column is only as wide as necessary. Columns are
   separated by two spaces for readability.

Cmd.precmd(line)

   명령 줄 *line*을 해석하기 직전에, 하지만 입력 프롬프트가 생성되고
   제시된 후에 실행되는 훅 메서드. 이 메서드는 "Cmd"에서는 스텁(stub)
   입니다; 서브 클래스에 의해 재정의되기 위해 존재합니다. 반환 값은
   "onecmd()" 메서드에 의해 실행될 명령으로 사용됩니다; "precmd()" 구
   현은 명령을 다시 쓰거나 단순히 *line*을 변경하지 않고 반환 할 수 있
   습니다.

Cmd.postcmd(stop, line)

   명령 호출이 완료된 직후에 실행되는 훅 메서드. 이 메서는 "Cmd"에서는
   스텁(stub)입니다; 서브 클래스에 의해 재정의되기 위해 존재합니다.
   *line*은 실행된 명령 줄이고, *stop*은 "postcmd()"를 호출한 후 실행
   이 종료될지를 나타내는 플래그입니다; 이것은 "onecmd()" 메서드의 반
   환 값입니다. 이 메서드의 반환 값은 *stop*에 해당하는 내부 플래그의
   새 값으로 사용됩니다; 거짓을 반환하면 해석이 계속됩니다.

Cmd.preloop()

   "cmdloop()"가 호출될 때 한 번 실행되는 훅 메서드. 이 메서드는 "Cmd"
   에서는 스텁(stub)입니다; 서브 클래스에 의해 재정의되기 위해 존재합
   니다.

Cmd.postloop()

   "cmdloop()"가 반환하려고 할 때 한 번 실행되는 훅 메서드. 이 메서드
   는 "Cmd"에서는 스텁(stub)입니다; 서브 클래스에 의해 재정의되기 위해
   존재합니다.

"Cmd" 서브 클래스의 인스턴스에는 몇 가지 공용 인스턴스 변수가 있습니다
:

Cmd.prompt

   입력을 요청하는 프롬프트.

Cmd.identchars

   명령 접두사에 허용되는 문자들의 문자열.

Cmd.lastcmd

   비어 있지 않은 마지막 명령 접두사.

Cmd.cmdqueue

   계류 중인 입력 줄의 리스트. cmdqueue 리스트는 새로운 입력이 필요할
   때 "cmdloop()"에서 점검됩니다; 비어 있지 않으면, 프롬프트에서 입력
   한 것처럼 해당 요소가 순서대로 처리됩니다.

Cmd.intro

   소개나 배너로 제시할 문자열. "cmdloop()" 메서드에 인자를 제공하여
   재정의할 수 있습니다.

Cmd.doc_header

   도움말 출력에 설명된 명령 섹션이 있을 때 제시할 헤더입니다.

Cmd.misc_header

   도움말 출력에 기타 도움말 주제에 대한 섹션이 있을 때 제시할 헤더 (
   즉, 해당 "do_*()" 메서드가 없는 "help_*()" 메서드가 있을 때).

Cmd.undoc_header

   도움말 출력에 설명되지 않은 명령에 대한 섹션이 있을 때 제시할 헤더
   (즉, 해당 "help_*()" 메서드가 없는 "do_*()" 메서드가 있을 때).

Cmd.ruler

   도움말 메시지 헤더 아래에 구분선을 그리는 데 사용되는 문자입니다.
   비어 있으면, 눈금자 선이 그려지지 않습니다. 기본값은 "'='"입니다.

Cmd.use_rawinput

   기본값이 참인 플래그. 참이면, "cmdloop()"는 "input()"을 사용하여 프
   롬프트를 표시하고 다음 명령을 읽습니다; 거짓이면,
   "sys.stdout.write()"와 "sys.stdin.readline()"이 사용됩니다. (이는
   지원하는 시스템에서 "readline"를 임포트 함으로써, 인터프리터가
   **Emacs**와 유사한 줄 편집과 명령 히스토리 키 입력을 자동으로 지원
   한다는 의미입니다.)


Cmd 예
======

"cmd" 모듈은 주로 사용자가 대화식으로 프로그램을 사용할 수 있도록 하는
사용자 정의 셸을 만드는 데 유용합니다.

이 섹션에서는 "turtle" 모듈의 몇 가지 명령을 중심으로 셸을 작성하는 방
법에 대한 간단한 예를 제공합니다.

"forward()"와 같은 기본 turtle 명령은 "do_forward()"라는 메서드로
"Cmd" 서브 클래스에 추가됩니다. 인자는 숫자로 변환되어 turtle 모듈로
전달됩니다. 독스트링은 셸에서 제공하는 도움말 유틸리티에서 사용됩니다.

이 예제에는 "precmd()" 메서드로 구현된 기초적인 녹화와 재생 기능도 포
함되는데, 이 메서드는 입력을 소문자로 변환하고 명령을 파일에 쓰는 역할
을 합니다. "do_playback()" 메서드는 파일을 읽고 즉시 재생하기 위해 녹
화된 명령을 "cmdqueue"에 추가합니다:

   import cmd, sys
   from turtle import *

   class TurtleShell(cmd.Cmd):
       intro = 'Welcome to the turtle shell.   Type help or ? to list commands.\n'
       prompt = '(turtle) '
       file = None

       # ----- basic turtle commands -----
       def do_forward(self, arg):
           'Move the turtle forward by the specified distance:  FORWARD 10'
           forward(*parse(arg))
       def do_right(self, arg):
           'Turn turtle right by given number of degrees:  RIGHT 20'
           right(*parse(arg))
       def do_left(self, arg):
           'Turn turtle left by given number of degrees:  LEFT 90'
           left(*parse(arg))
       def do_goto(self, arg):
           'Move turtle to an absolute position with changing orientation.  GOTO 100 200'
           goto(*parse(arg))
       def do_home(self, arg):
           'Return turtle to the home position:  HOME'
           home()
       def do_circle(self, arg):
           'Draw circle with given radius an options extent and steps:  CIRCLE 50'
           circle(*parse(arg))
       def do_position(self, arg):
           'Print the current turtle position:  POSITION'
           print('Current position is %d %d\n' % position())
       def do_heading(self, arg):
           'Print the current turtle heading in degrees:  HEADING'
           print('Current heading is %d\n' % (heading(),))
       def do_color(self, arg):
           'Set the color:  COLOR BLUE'
           color(arg.lower())
       def do_undo(self, arg):
           'Undo (repeatedly) the last turtle action(s):  UNDO'
       def do_reset(self, arg):
           'Clear the screen and return turtle to center:  RESET'
           reset()
       def do_bye(self, arg):
           'Stop recording, close the turtle window, and exit:  BYE'
           print('Thank you for using Turtle')
           self.close()
           bye()
           return True

       # ----- record and playback -----
       def do_record(self, arg):
           'Save future commands to filename:  RECORD rose.cmd'
           self.file = open(arg, 'w')
       def do_playback(self, arg):
           'Playback commands from a file:  PLAYBACK rose.cmd'
           self.close()
           with open(arg) as f:
               self.cmdqueue.extend(f.read().splitlines())
       def precmd(self, line):
           line = line.lower()
           if self.file and 'playback' not in line:
               print(line, file=self.file)
           return line
       def close(self):
           if self.file:
               self.file.close()
               self.file = None

   def parse(arg):
       'Convert a series of zero or more numbers to an argument tuple'
       return tuple(map(int, arg.split()))

   if __name__ == '__main__':
       TurtleShell().cmdloop()

다음은 도움말 기능과, 명령을 반복하기 위해 빈 줄을 사용하는 방법과, 간
단한 녹화와 재생기능을 보여주기 위해 turtle 셀을 사용한 예제 세션입니
다:

   Welcome to the turtle shell.   Type help or ? to list commands.

   (turtle) ?

   Documented commands (type help <topic>):
   ========================================
   bye     color    goto     home  playback  record  right
   circle  forward  heading  left  position  reset   undo

   (turtle) help forward
   Move the turtle forward by the specified distance:  FORWARD 10
   (turtle) record spiral.cmd
   (turtle) position
   Current position is 0 0

   (turtle) heading
   Current heading is 0

   (turtle) reset
   (turtle) circle 20
   (turtle) right 30
   (turtle) circle 40
   (turtle) right 30
   (turtle) circle 60
   (turtle) right 30
   (turtle) circle 80
   (turtle) right 30
   (turtle) circle 100
   (turtle) right 30
   (turtle) circle 120
   (turtle) right 30
   (turtle) circle 120
   (turtle) heading
   Current heading is 180

   (turtle) forward 100
   (turtle)
   (turtle) right 90
   (turtle) forward 100
   (turtle)
   (turtle) right 90
   (turtle) forward 400
   (turtle) right 90
   (turtle) forward 500
   (turtle) right 90
   (turtle) forward 400
   (turtle) right 90
   (turtle) forward 300
   (turtle) playback spiral.cmd
   Current position is 0 0

   Current heading is 0

   Current heading is 180

   (turtle) bye
   Thank you for using Turtle
