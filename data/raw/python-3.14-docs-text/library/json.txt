"json" --- JSON 인코더와 디코더
*******************************

**소스 코드:** Lib/json/__init__.py

======================================================================

**RFC 7159**(**RFC 4627**을 대체합니다)와 ECMA-404로 규정되는 JSON
(JavaScript Object Notation)은 JavaScript 객체 리터럴 문법에서 영감을
얻은 경량 데이터 교환 형식입니다 (JavaScript [1]의 엄격한 부분집합은
아닙니다).

참고:

  The term "object" in the context of JSON processing in Python can be
  ambiguous. All values in Python are objects. In JSON, an object
  refers to any data wrapped in curly braces, similar to a Python
  dictionary.

경고:

  Be cautious when parsing JSON data from untrusted sources. A
  malicious JSON string may cause the decoder to consume considerable
  CPU and memory resources. Limiting the size of data to be parsed is
  recommended.

This module exposes an API familiar to users of the standard library
"marshal" and "pickle" modules.

기본 파이썬 객체 계층 구조 인코딩:

   >>> import json
   >>> json.dumps(['foo', {'bar': ('baz', None, 1.0, 2)}])
   '["foo", {"bar": ["baz", null, 1.0, 2]}]'
   >>> print(json.dumps("\"foo\bar"))
   "\"foo\bar"
   >>> print(json.dumps('\u1234'))
   "\u1234"
   >>> print(json.dumps('\\'))
   "\\"
   >>> print(json.dumps({"c": 0, "b": 0, "a": 0}, sort_keys=True))
   {"a": 0, "b": 0, "c": 0}
   >>> from io import StringIO
   >>> io = StringIO()
   >>> json.dump(['streaming API'], io)
   >>> io.getvalue()
   '["streaming API"]'

간결한 인코딩:

   >>> import json
   >>> json.dumps([1, 2, 3, {'4': 5, '6': 7}], separators=(',', ':'))
   '[1,2,3,{"4":5,"6":7}]'

예쁜 인쇄:

   >>> import json
   >>> print(json.dumps({'6': 7, '4': 5}, sort_keys=True, indent=4))
   {
       "4": 5,
       "6": 7
   }

Customizing JSON object encoding:

   >>> import json
   >>> def custom_json(obj):
   ...     if isinstance(obj, complex):
   ...         return {'__complex__': True, 'real': obj.real, 'imag': obj.imag}
   ...     raise TypeError(f'Cannot serialize object of {type(obj)}')
   ...
   >>> json.dumps(1 + 2j, default=custom_json)
   '{"__complex__": true, "real": 1.0, "imag": 2.0}'

JSON 디코딩:

   >>> import json
   >>> json.loads('["foo", {"bar":["baz", null, 1.0, 2]}]')
   ['foo', {'bar': ['baz', None, 1.0, 2]}]
   >>> json.loads('"\\"foo\\bar"')
   '"foo\x08ar'
   >>> from io import StringIO
   >>> io = StringIO('["streaming API"]')
   >>> json.load(io)
   ['streaming API']

Customizing JSON object decoding:

   >>> import json
   >>> def as_complex(dct):
   ...     if '__complex__' in dct:
   ...         return complex(dct['real'], dct['imag'])
   ...     return dct
   ...
   >>> json.loads('{"__complex__": true, "real": 1, "imag": 2}',
   ...     object_hook=as_complex)
   (1+2j)
   >>> import decimal
   >>> json.loads('1.1', parse_float=decimal.Decimal)
   Decimal('1.1')

"JSONEncoder" 확장하기:

   >>> import json
   >>> class ComplexEncoder(json.JSONEncoder):
   ...     def default(self, obj):
   ...         if isinstance(obj, complex):
   ...             return [obj.real, obj.imag]
   ...         # 베이스 클래스의 default 메서드가 TypeError를 발생 시키도록 합니다
   ...         return super().default(obj)
   ...
   >>> json.dumps(2 + 1j, cls=ComplexEncoder)
   '[2.0, 1.0]'
   >>> ComplexEncoder().encode(2 + 1j)
   '[2.0, 1.0]'
   >>> list(ComplexEncoder().iterencode(2 + 1j))
   ['[2.0', ', 1.0', ']']

Using "json" from the shell to validate and pretty-print:

   $ echo '{"json":"obj"}' | python -m json
   {
       "json": "obj"
   }
   $ echo '{1.2:3.4}' | python -m json
   Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

자세한 설명은 Command-line interface를 참조하십시오.

참고:

  JSON은 YAML 1.2의 부분 집합입니다. 이 모듈의 기본 설정(특히 기본
  *separators* 값)으로 생성된 JSON은 YAML 1.0과 1.1의 부분 집합이기도
  합니다. 따라서 이 모듈을 YAML 직렬화기로 사용할 수도 있습니다.

참고:

  이 모듈의 인코더와 디코더는 기본적으로 입력과 출력 순서를 유지합니다
  . 하부 컨테이너에 순서가 없을 때만 순서가 손실됩니다.


기본 사용법
===========

json.dump(obj, fp, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)

   이 파이썬-to-JSON 변환표를 사용하여 *obj*를 JSON 형식 스트림으로
   *fp*(".write()"를 지원하는 *파일류 객체*)로 직렬화합니다.

   참고:

     "pickle"과 "marshal"과 달리, JSON은 프레임 프로토콜이 아니므로 같
     은 *fp*를 사용하여 "dump()"를 반복 호출하여 여러 객체를 직렬화하
     려고 하면 잘못된 JSON 파일이 생성됩니다.

   매개변수:
      * **obj** (*object*) -- 직렬화될 파이썬 객체.

      * **fp** (*file-like object*) -- *obj*가 직렬화될 파일류 객체.
        "json" 모듈은 항상 "bytes" 객체가 아니라 "str" 객체를 생성합니
        다, 따라서 "fp.write()"는 "str" 입력을 지원해야 합니다.

      * **skipkeys** (*bool*) -- "True"면, 기본형("str", "int",
        "float", "bool", "None")이 아닌 키는 "TypeError"를 발생시키는
        대신 건너뜁니다. 기본값 "False".

      * **ensure_ascii** (*bool*) -- If "True" (the default), the
        output is guaranteed to have all incoming non-ASCII and non-
        printable characters escaped. If "False", all characters will
        be outputted as-is, except for the characters that must be
        escaped: quotation mark, reverse solidus, and the control
        characters U+0000 through U+001F.

      * **check_circular** (*bool*) -- "False"면, 컨테이너형에 대한 순
        환 참조 검사를 건너뛰고 순환 참조는 "RecursionError"를 일으키
        게 됩니다 (또는 더 나빠질 수 있습니다). 기본값 "True".

      * **allow_nan** (*bool*) -- "False"면, JSON 사양을 엄격히 준수하
        여, 범위를 벗어난 "float" 값("nan", "inf", "-inf")을 직렬화하
        면 "ValueError"를 일으킵니다. *allow_nan*이 "True"(기본값)면,
        JavaScript의 대응 물("NaN", "Infinity", "-Infinity")이 사용됩
        니다.

      * **cls** (a "JSONEncoder" subclass) -- If set, a custom JSON
        encoder with the "default()" method overridden, for
        serializing into custom datatypes. If "None" (the default),
        "JSONEncoder" is used.

      * **indent** (*int** | **str** | **None*) -- If a positive
        integer or string, JSON array elements and object members will
        be pretty-printed with that indent level. A positive integer
        indents that many spaces per level; a string (such as ""\t"")
        is used to indent each level. If zero, negative, or """" (the
        empty string), only newlines are inserted. If "None" (the
        default), the most compact representation is used.

      * **separators** (*tuple** | **None*) -- 2-튜플:
        "(item_separator, key_separator)". "None" (기본값) 이면,
        *separators*의 기본값은 *indent*가 "None"이면 "(', ', ': ')"이
        고, 그렇지 않으면 "(',', ': ')"입니다. 가장 간결한 JSON 을 얻
        으려면, "(',', ':')"를 지정하여 공백을 제거해야 합니다.

      * **default** (*callable* | None) -- 달리 직렬화할 수 없는 객체
        에 대해 호출되는 함수. 객체의 JSON 인코딩 가능한 버전을 반환하
        거나 "TypeError"를 발생시켜야 합니다. "None"(기본값)이면,
        "TypeError"가 발생합니다.

      * **sort_keys** (*bool*) -- If "True", dictionaries will be
        outputted sorted by key. Default "False".

   버전 3.2에서 변경: *indent*에 정수뿐만 아니라 문자열을 허용합니다.

   버전 3.4에서 변경: *indent*가 "None"이 아니면, "(',', ': ')"를 기본
   값으로 사용합니다.

   버전 3.6에서 변경: 모든 선택적 매개 변수는 이제 키워드-전용입니다.

json.dumps(obj, *, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, cls=None, indent=None, separators=None, default=None, sort_keys=False, **kw)

   이 변환표를 사용하여 *obj*를 JSON 형식의 "str"로 직렬화합니다. 인자
   는 "dump()"에서와 같은 의미입니다.

   참고:

     JSON의 키/값 쌍에 있는 키는 항상 "str" 형입니다. 딕셔너리를 JSON
     으로 변환하면, 딕셔너리의 모든 키가 문자열로 강제 변환됩니다. 이
     것의 결과로, 딕셔너리를 JSON으로 변환한 다음 다시 딕셔너리로 변환
     하면, 딕셔너리가 원래의 것과 같지 않을 수 있습니다. 즉, x에 비 문
     자열 키가 있으면 "loads(dumps(x)) != x"입니다.

json.load(fp, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)

   JSON-to-파이썬 변환표를 사용하여 *fp*를 파이썬 객체로 역 직렬화합니
   다.

   매개변수:
      * **fp** (*file-like object*) -- 역 직렬화될 JSON 문서를 포함하
        는 ".read()"를 지원하는 *텍스트 파일*이나 *바이너리 파일*.

      * **cls** (a "JSONDecoder" subclass) -- If set, a custom JSON
        decoder. Additional keyword arguments to "load()" will be
        passed to the constructor of *cls*. If "None" (the default),
        "JSONDecoder" is used.

      * **object_hook** (*callable* | None) -- If set, a function that
        is called with the result of any JSON object literal decoded
        (a "dict"). The return value of this function will be used
        instead of the "dict". This feature can be used to implement
        custom decoders, for example JSON-RPC class hinting. Default
        "None".

      * **object_pairs_hook** (*callable* | None) -- If set, a
        function that is called with the result of any JSON object
        literal decoded with an ordered list of pairs. The return
        value of this function will be used instead of the "dict".
        This feature can be used to implement custom decoders. If
        *object_hook* is also set, *object_pairs_hook* takes priority.
        Default "None".

      * **parse_float** (*callable* | None) -- 설정되면, 디코딩될 모든
        JSON float의 문자열로 호출되는 함수. "None"(기본값)이면, 이것
        은 "float(num_str)"와 동등합니다. JSON float를 사용자 정의 데
        이터형으로 구문 분석하는 데 사용될 수 있습니다, 예를 들어
        "decimal.Decimal".

      * **parse_int** (*callable* | None) -- 설정되면, 디코딩될 모든
        JSON int의 문자열로 호출되는 함수. "None"(기본값)이면, 이것은
        "int(num_str)"와 동등합니다. JSON 정수를 사용자 정의 데이터형
        으로 구문 분석하는 데 사용될 수 있습니다, 예를 들어 "float".

      * **parse_constant** (*callable* | None) -- 설정되면, 다음과 같
        은 문자열 중 하나로 호출되는 함수: "'-Infinity'", "'Infinity'"
        또는 "'NaN'". 잘못된 JSON 숫자를 만날 때 예외를 발생시키는 데
        사용할 수 있습니다. 기본값 "None".

   예외 발생:
      * **JSONDecodeError** -- 역 직렬화되는 데이터가 유효한 JSON 문서
        가 아닐 때.

      * **UnicodeDecodeError** -- When the data being deserialized
        does not contain UTF-8, UTF-16 or UTF-32 encoded data.

   버전 3.1에서 변경:

   * 선택적 *object_pairs_hook* 매개 변수가 추가되었습니다.

   * *parse_constant*는 더는 'null', 'true', 'false'에 대해 호출되지
     않습니다.

   버전 3.6에서 변경:

   * 모든 선택적 매개 변수는 이제 키워드-전용입니다.

   * *fp*는 이제 *바이너리 파일*이 될 수 있습니다. 입력 인코딩은
     UTF-8, UTF-16 또는 UTF-32 여야 합니다.

   버전 3.11에서 변경: The default *parse_int* of "int()" now limits
   the maximum length of the integer string via the interpreter's
   integer string conversion length limitation to help avoid denial of
   service attacks.

json.loads(s, *, cls=None, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, object_pairs_hook=None, **kw)

   "load()"와 동일하지만, 파일류 객체를 역 질렬화하는 대신, 이 변환표
   를 사용하여 *s*(JSON 문서를 포함하는 "str", "bytes" 또는
   "bytearray" 인스턴스)를 파이썬 객체로 역 직렬화합니다.

   버전 3.6에서 변경: *s*는 이제 "bytes"나 "bytearray" 형일 수 있습니
   다. 입력 인코딩은 UTF-8, UTF-16 또는 UTF-32 여야 합니다.

   버전 3.9에서 변경: 키워드 인자 *encoding*이 제거되었습니다.


인코더와 디코더
===============

class json.JSONDecoder(*, object_hook=None, parse_float=None, parse_int=None, parse_constant=None, strict=True, object_pairs_hook=None)

   간단한 JSON 디코더.

   기본적으로 디코딩할 때 다음과 같은 변환을 수행합니다:

   +-----------------+---------------------+
   | JSON            | 파이썬              |
   |=================|=====================|
   | 오브젝트        | dict                |
   | (object)        |                     |
   +-----------------+---------------------+
   | 배열(array)     | list                |
   +-----------------+---------------------+
   | 문자열(string)  | str                 |
   +-----------------+---------------------+
   | 숫자 (정수)     | int                 |
   +-----------------+---------------------+
   | 숫자 (실수)     | float               |
   +-----------------+---------------------+
   | true            | True                |
   +-----------------+---------------------+
   | false           | False               |
   +-----------------+---------------------+
   | null            | None                |
   +-----------------+---------------------+

   또한, "NaN", "Infinity" 및 "-Infinity"를 해당 "float" 값으로 이해합
   니다. 이 값은 JSON 명세에 속하지 않습니다.

   *object_hook*은 지정되면, 모든 JSON 오브젝트의 디코딩된 결과로 호출
   될 선택적 함수이고, 반환 값을 주어진 "dict" 대신 사용합니다. 사용자
   정의 역 직렬화를 제공하는 데 사용할 수 있습니다 (예를 들어, JSON-
   RPC 클래스 힌팅을 지원하기 위해).

   *object_pairs_hook*은 모든 JSON 오브젝트가 쌍의 순서 있는 목록으로
   디코딩된 결과로 호출될 선택적 함수입니다. "dict" 대신
   *object_pairs_hook*의 반환 값이 사용됩니다. 이 기능은 사용자 정의
   디코더를 구현하는 데 사용할 수 있습니다. *object_hook*도 정의되어
   있으면, *object_pairs_hook*이 우선순위를 갖습니다.

   버전 3.1에서 변경: *object_pairs_hook*에 대한 지원이 추가되었습니다
   .

   *parse_float*는 디코딩될 모든 JSON float의 문자열로 호출될 선택적
   함수입니다. 기본적으로, 이것은 "float(num_str)"와 동등합니다. JSON
   float에 대해 다른 데이터형이나 구문 분석기를 사용하고자 할 때 사용
   될 수 있습니다 (예를 들어, "decimal.Decimal").

   *parse_int*는 디코딩될 모든 JSON int의 문자열로 호출될 선택적 함수
   입니다. 기본적으로 이것은 "int(num_str)"와 동등합니다. JSON 정수에
   대해 다른 데이터형이나 구문 분석기를 사용하고자 할 때 사용될 수 있
   습니다 (예를 들어 "float").

   *parse_constant*는 다음과 같은 문자열 중 하나로 호출될 선택적 함수
   입니다: "'-Infinity'", "'Infinity'", "'NaN'". 잘못된 JSON 숫자를 만
   날 때 예외를 발생시키는 데 사용할 수 있습니다.

   *strict*가 거짓이면 ("True"가 기본값입니다), 문자열 안에 제어 문자
   가 허용됩니다. 이 문맥에서 제어 문자는 0--31 범위의 문자 코드를 가
   진 것들인데, "'\t'" (탭), "'\n'", "'\r'" 및 "'\0'"을 포함합니다.

   역 직렬화되는 데이터가 유효한 JSON 문서가 아니면, "JSONDecodeError"
   가 발생합니다.

   버전 3.6에서 변경: 모든 매개 변수가 이제 키워드-전용입니다.

   decode(s)

      *s*(JSON 문서가 포함된 "str" 인스턴스)의 파이썬 표현을 반환합니
      다.

      주어진 JSON 문서가 유효하지 않으면 "JSONDecodeError"가 발생합니
      다.

   raw_decode(s)

      *s*(JSON 문서로 시작하는 "str")에서 JSON 문서를 디코딩하고, 파이
      썬 표현과 문서가 끝난 *s*에서의 인덱스로 구성된 2-튜플을 반환합
      니다.

      끝에 여분의 데이터가 있을 수 있는 문자열에서 JSON 문서를 디코딩
      하는 데 사용할 수 있습니다.

class json.JSONEncoder(*, skipkeys=False, ensure_ascii=True, check_circular=True, allow_nan=True, sort_keys=False, indent=None, separators=None, default=None)

   파이썬 데이터 구조를 위한 확장 가능한 JSON 인코더

   기본적으로 다음 객체와 형을 지원합니다.:

   +------------------------------------------+-----------------+
   | 파이썬                                   | JSON            |
   |==========================================|=================|
   | dict                                     | 오브젝트        |
   |                                          | (object)        |
   +------------------------------------------+-----------------+
   | list, tuple                              | 배열(array)     |
   +------------------------------------------+-----------------+
   | str                                      | 문자열(string)  |
   +------------------------------------------+-----------------+
   | int, float, int와 float에서 파생된 열거  | 숫자(number)    |
   | 형                                       |                 |
   +------------------------------------------+-----------------+
   | True                                     | true            |
   +------------------------------------------+-----------------+
   | False                                    | false           |
   +------------------------------------------+-----------------+
   | None                                     | null            |
   +------------------------------------------+-----------------+

   버전 3.4에서 변경: int와 float 파생 Enum 클래스에 대한 지원이 추가
   되었습니다.

   다른 객체를 인식하도록 확장하려면, 서브 클래스를 만들고, 가능하면
   "o"에 대한 직렬화 가능 객체를 반환하고, 그렇지 않으면 ("TypeError"
   를 발생시키기 위해) 슈퍼 클래스 구현을 호출하는 다른 메서드로
   "default()" 메서드를 구현합니다.

   *skipkeys*가 거짓(기본값)이면, "str", "int", "float", "bool" 또는
   "None"이 아닌 키를 인코딩하려고 시도할 때 "TypeError"가 발생합니다.
   *skipkeys*가 참이면 이러한 항목은 단순히 건너뜁니다.

   If *ensure_ascii* is true (the default), the output is guaranteed
   to have all incoming non-ASCII and non-printable characters
   escaped. If *ensure_ascii* is false, all characters will be output
   as-is, except for the characters that must be escaped: quotation
   mark, reverse solidus, and the control characters U+0000 through
   U+001F.

   *check_circular*가 참(기본값)이면, 리스트, 딕셔너리 및 사용자 정의
   객체는 무한 재귀 ("RecursionError"를 유발할 수 있습니다)를 방지하기
   위해 인코딩 중에 순환 참조를 검사합니다. 그렇지 않으면, 그러한 검사
   가 수행되지 않습니다.

   *allow_nan*이 참(기본값)이면, "NaN", "Infinity" 및 "-Infinity"는 그
   자체로 인코딩됩니다. 이 동작은 JSON 사양을 따르지 않지만, 대부분의
   JavaScript 기반 인코더 및 디코더와 일치합니다. 그렇지 않으면, 그러
   한 float를 인코딩하는 것은 "ValueError"가 됩니다.

   *sort_keys*가 참(기본값: "False")이면, 딕셔너리의 출력이 키로 정렬
   됩니다; JSON 직렬화를 이전과 비교할 수 있도록 해서 회귀 테스트에 유
   용합니다.

   *indent*가 음이 아닌 정수나 문자열이면, JSON 배열 요소와 오브젝트
   멤버가 해당 들여쓰기 수준으로 예쁘게 인쇄됩니다. 0, 음수 또는 """"
   의 들여쓰기 수준은 줄 넘김만 삽입합니다. "None"(기본값)은 가장 간결
   한(compact) 표현을 선택합니다. 양의 정수 indent를 사용하면, 수준 당
   그만큼의 스페이스로 들여쓰기합니다. *indent*가 문자열이면 (가령
   ""\t""), 각 수준을 들려 쓰는 데 그 문자열을 사용합니다.

   버전 3.2에서 변경: *indent*에 정수뿐만 아니라 문자열을 허용합니다.

   지정되면, *separators*는 "(item_separator, key_separator)" 튜플이어
   야 합니다. 기본값은 *indent*가 "None"이면 "(', ', ': ')"이고, 그렇
   지 않으면 "(',', ': ')"입니다. 가장 간결한 JSON 표현을 얻으려면,
   "(',', ':')"를 지정하여 공백을 제거해야 합니다.

   버전 3.4에서 변경: *indent*가 "None"이 아니면, "(',', ': ')"를 기본
   값으로 사용합니다.

   지정되면, *default*는 달리 직렬화할 수 없는 객체에 대해 호출되는 함
   수여야 합니다. 객체의 JSON 인코딩 가능한 버전을 반환하거나
   "TypeError"를 발생시켜야 합니다. 지정하지 않으면, "TypeError"가 발
   생합니다.

   버전 3.6에서 변경: 모든 매개 변수가 이제 키워드-전용입니다.

   default(o)

      *o*의 직렬화 가능 객체를 반환하거나 ("TypeError"를 발생시키기 위
      해서) 베이스 구현을 호출하도록 서브 클래스에 이 메서드를 구현하
      십시오.

      예를 들어, 임의의 이터레이터를 지원하려면, 다음과 같이
      "default()"를 구현할 수 있습니다:

         def default(self, o):
            try:
                iterable = iter(o)
            except TypeError:
                pass
            else:
                return list(iterable)
            # 베이스 클래스의 default 메서드가 TypeError를 발생시키도록 합시다
            return super().default(o)

   encode(o)

      파이썬 데이터 구조 *o*의 JSON 문자열 표현을 반환합니다. 예를 들
      면:

         >>> json.JSONEncoder().encode({"foo": ["bar", "baz"]})
         '{"foo": ["bar", "baz"]}'

   iterencode(o)

      주어진 객체 *o*를 인코딩하고, 준비될 때마다 각 문자열 표현을 산
      출(yield)합니다. 예를 들면:

         for chunk in json.JSONEncoder().iterencode(bigobject):
             mysocket.write(chunk)


예외
====

exception json.JSONDecodeError(msg, doc, pos)

   다음 추가 어트리뷰트가 있는 "ValueError"의 서브 클래스:

   msg

      형식 없는 에러 메시지.

   doc

      구문 분석 중인 JSON 문서.

   pos

      구문 분석에 실패한 위치의 시작 부분을 나타내는 *doc*의 인덱스.

   lineno

      *pos*에 해당하는 줄.

   colno

      *pos*에 해당하는 열.

   Added in version 3.5.


표준 준수와 상호 운용성
=======================

JSON 형식은 **RFC 7159**와 ECMA-404에 의해 지정됩니다. 이 절에서는 이
모듈의 RFC 준수 수준에 대해 자세히 설명합니다. 단순화를 위해,
"JSONEncoder" 및 "JSONDecoder" 서브 클래스와 명시적으로 언급되지 않은
매개 변수는 고려되지 않습니다.

유효한 JavaScript이지만 유효한 JSON이 아닌 확장을 구현함으로써, 이 모
듈은 엄격한 방식으로 RFC를 준수하지는 않습니다. 특히:

* 무한대와 NaN 숫자 값이 받아들여지고 출력됩니다;

* 오브젝트 내에서 반복되는 이름이 허용되고, 마지막 이름-값 쌍의 값만
  사용됩니다.

RFC가 RFC를 준수하는 구문 분석기가 RFC를 준수하지 않는 입력 텍스트를
받아들이도록 허용하기 때문에, 이 모듈의 역 직렬화기는 기본 설정에서 기
술적으로 RFC를 준수합니다.


문자 인코딩
-----------

RFC는 UTF-8, UTF-16 또는 UTF-32를 사용하여 JSON을 표현할 것을 요구하고
, 최대 상호 운용성을 위해 권장되는 기본값은 UTF-8입니다.

As permitted, though not required, by the RFC, this module's
serializer sets *ensure_ascii=True* by default, thus escaping the
output so that the resulting strings only contain printable ASCII
characters.

*ensure_ascii* 매개 변수 외에도, 이 모듈은 파이썬 객체와 "유니코드 문
자열" 사이의 변환으로 엄격하게 정의되어 있으므로, 문자 인코딩 문제를
직접 다루지 않습니다.

RFC는 JSON 텍스트의 시작 부분에 바이트 순서 표시(BOM)를 추가하는 것을
금지하고 있으며, 이 모듈의 직렬화기는 BOM을 출력에 추가하지 않습니다.
RFC는 JSON 역 직렬화기가 입력에서 초기 BOM을 무시하는 것을 허용하지만
요구하지는 않습니다. 이 모듈의 역 직렬화기는 초기 BOM이 있을 때
"ValueError"를 발생시킵니다.

RFC는 유효한 유니코드 문자에 해당하지 않는 바이트 시퀀스(예를 들어, 쌍
을 이루지 않은 UTF-16 대리 코드(unpaired UTF-16 surrogates))가 포함된
JSON 문자열을 명시적으로 금지하지 않지만, 상호 운용성 문제를 일으킬 수
있다고 지적하고 있습니다. 기본적으로, 이 모듈은 이러한 시퀀스의 코드
포인트를 받아들이고 (원래 "str"에 있을 때) 출력합니다.


무한대와 NaN 숫자 값
--------------------

RFC는 무한대나 NaN 숫자 값의 표현을 허용하지 않습니다. 그런데도, 기본
적으로, 이 모듈은 유효한 JSON 숫자 리터럴 값인 것처럼 "Infinity",
"-Infinity" 및 "NaN"을 받아들이고 출력합니다:

   >>> # 이 호출 중 어느 것도 예외를 발생시키지 않지만, 결과는 유효한 JSON이 아닙니다
   >>> json.dumps(float('-inf'))
   '-Infinity'
   >>> json.dumps(float('nan'))
   'NaN'
   >>> # 역 직렬화 때도 마찬가지입니다
   >>> json.loads('-Infinity')
   -inf
   >>> json.loads('NaN')
   nan

직렬화기에서, *allow_nan* 매개 변수를 사용하여 이 동작을 변경할 수 있
습니다. 역 직렬화기에서, *parse_constant* 매개 변수를 사용하여 이 동작
을 변경할 수 있습니다.


오브젝트 내에서 반복된 이름
---------------------------

RFC는 JSON 오브젝트 내에서 이름이 고유해야 한다고 지정하지만, JSON 오
브젝트 내에서 반복되는 이름을 처리하는 방법을 지정하지는 않습니다. 기
본적으로, 이 모듈은 예외를 발생시키지 않습니다; 대신, 주어진 이름에 대
한 마지막 이름-값 쌍을 제외한 모든 것을 무시합니다:

   >>> weird_json = '{"x": 1, "x": 2, "x": 3}'
   >>> json.loads(weird_json)
   {'x': 3}

*object_pairs_hook* 매개 변수는 이 동작을 변경하는 데 사용할 수 있습니
다.


오브젝트나 배열이 아닌 최상윗값
-------------------------------

폐지된 **RFC 4627**에 의해 지정된 이전 버전의 JSON은 JSON 텍스트의 최
상윗값이 JSON 오브젝트나 배열(파이썬 "dict"나 "list")이어야 하고, JSON
null, 불리언, 숫자 또는 문자열 값이 될 수 없다고 요구합니다. **RFC
7159**는 그 제한을 제거했으며, 이 모듈은 직렬화기와 역 직렬화기에서 이
러한 제한을 구현하지 않으며, 그런 적도 없습니다.

이와 관계없이, 최대한의 상호 운용성을 위해, 여러분은 자발적으로 제한을
준수하기를 원할 수 있습니다.


구현 제약 사항
--------------

일부 JSON 역 직렬화기 구현은 다음과 같은 것들에 대한 제한을 설정할 수
있습니다:

* 받아들인 JSON 텍스트의 크기

* JSON 오브젝트와 배열의 최대 중첩 수준

* JSON 숫자의 범위와 정밀도

* JSON 문자열의 내용과 최대 길이

이 모듈은 관련 파이썬 데이터형 자체나 파이썬 인터프리터 자체의 한계 외
에는 어떤 제한도 가하지 않습니다.

JSON으로 직렬화할 때, 여러분의 JSON을 사용할 응용 프로그램에 있는 이러
한 제한 사항에 주의하십시오. 특히, JSON 숫자가 IEEE 754 배정도 숫자로
역 직렬화되는 것이 일반적이고, 그래서 그 표현의 범위와 정밀도 제한이
적용됩니다. 이것은 매우 큰 규모의 파이썬 "int" 값을 직렬화하거나,
"decimal.Decimal"과 같은 "색다른" 숫자 형의 인스턴스를 직렬화할 때 특
히 중요합니다.


Command-line interface
======================

**소스 코드:** Lib/json/tool.py

======================================================================

The "json" module can be invoked as a script via "python -m json" to
validate and pretty-print JSON objects. The "json.tool" submodule
implements this interface.

선택적 "infile"과 "outfile" 인자가 지정되지 않으면, 각각 "sys.stdin"과
"sys.stdout"이 사용됩니다:

   $ echo '{"json": "obj"}' | python -m json
   {
       "json": "obj"
   }
   $ echo '{1.2:3.4}' | python -m json
   Expecting property name enclosed in double quotes: line 1 column 2 (char 1)

버전 3.5에서 변경: 출력은 이제 입력과 같은 순서입니다. 딕셔너리의 출력
을 키에 대해 알파벳 순으로 정렬하려면 "--sort-keys" 옵션을 사용하십시
오.

버전 3.14에서 변경: The "json" module may now be directly executed as
"python -m json". For backwards compatibility, invoking the CLI as
"python -m json.tool" remains supported.


Command-line options
--------------------

infile

   유효성을 검사하거나 예쁘게 인쇄할 JSON 파일:

      $ python -m json mp_films.json
      [
          {
              "title": "And Now for Something Completely Different",
              "year": 1971
          },
          {
              "title": "Monty Python and the Holy Grail",
              "year": 1975
          }
      ]

   *infile*이 지정되지 않으면, "sys.stdin"에서 읽습니다.

outfile

   *infile*의 출력을 지정된 *outfile*에 씁니다. 그렇지 않으면,
   "sys.stdout"에 씁니다.

--sort-keys

   딕셔너리의 출력을 키에 대해 알파벳 순으로 정렬합니다.

   Added in version 3.5.

--no-ensure-ascii

   비 ASCII 문자의 이스케이프를 비활성화합니다. 자세한 내용은
   "json.dumps()"를 참조하십시오.

   Added in version 3.9.

--json-lines

   모든 입력 행을 별도의 JSON 객체로 구문 분석합니다.

   Added in version 3.8.

--indent, --tab, --no-indent, --compact

   공백 제어를 위한 상호 배타적 옵션.

   Added in version 3.9.

-h, --help

   도움말 메시지를 표시합니다.

-[ 각주 ]-

[1] the errata for RFC 7159에서 언급했듯이, JSON은 문자열에
    U+2028(LINE SEPARATOR)과 U+2029(PARAGRAPH SEPARATOR) 문자를 허용하
    지만, JavaScript(ECMAScript Edition 5.1 기준)는 허용하지 않습니다.
