"optparse" --- 명령 줄 옵션용 구문 분석기
*****************************************

**소스 코드:** Lib/optparse.py

======================================================================


Choosing an argument parsing library
====================================

The standard library includes three argument parsing libraries:

* "getopt": a module that closely mirrors the procedural C "getopt"
  API. Included in the standard library since before the initial
  Python 1.0 release.

* "optparse": a declarative replacement for "getopt" that provides
  equivalent functionality without requiring each application to
  implement its own procedural option parsing logic. Included in the
  standard library since the Python 2.3 release.

* "argparse": a more opinionated alternative to "optparse" that
  provides more functionality by default, at the expense of reduced
  application flexibility in controlling exactly how arguments are
  processed. Included in the standard library since the Python 2.7 and
  Python 3.2 releases.

In the absence of more specific argument parsing design constraints,
"argparse" is the recommended choice for implementing command line
applications, as it offers the highest level of baseline functionality
with the least application level code.

"getopt" is retained almost entirely for backwards compatibility
reasons. However, it also serves a niche use case as a tool for
prototyping and testing command line argument handling in
"getopt"-based C applications.

"optparse" should be considered as an alternative to "argparse" in the
following cases:

* an application is already using "optparse" and doesn't want to risk
  the subtle behavioural changes that may arise when migrating to
  "argparse"

* the application requires additional control over the way options and
  positional parameters are interleaved on the command line (including
  the ability to disable the interleaving feature completely)

* the application requires additional control over the incremental
  parsing of command line elements (while "argparse" does support
  this, the exact way it works in practice is undesirable for some use
  cases)

* the application requires additional control over the handling of
  options which accept parameter values that may start with "-" (such
  as delegated options to be passed to invoked subprocesses)

* the application requires some other command line parameter
  processing behavior which "argparse" does not support, but which can
  be implemented in terms of the lower level interface offered by
  "optparse"

These considerations also mean that "optparse" is likely to provide a
better foundation for library authors writing third party command line
argument processing libraries.

As a concrete example, consider the following two command line
argument parsing configurations, the first using "optparse", and the
second using "argparse":

   import optparse

   if __name__ == '__main__':
       parser = optparse.OptionParser()
       parser.add_option('-o', '--output')
       parser.add_option('-v', dest='verbose', action='store_true')
       opts, args = parser.parse_args()
       process(args, output=opts.output, verbose=opts.verbose)

   import argparse

   if __name__ == '__main__':
       parser = argparse.ArgumentParser()
       parser.add_argument('-o', '--output')
       parser.add_argument('-v', dest='verbose', action='store_true')
       parser.add_argument('rest', nargs='*')
       args = parser.parse_args()
       process(args.rest, output=args.output, verbose=args.verbose)

The most obvious difference is that in the "optparse" version, the
non-option arguments are processed separately by the application after
the option processing is complete. In the "argparse" version,
positional arguments are declared and processed in the same way as the
named options.

However, the "argparse" version will also handle some parameter
combination differently from the way the "optparse" version would
handle them. For example (amongst other differences):

* supplying "-o -v" gives "output="-v"" and "verbose=False" when using
  "optparse", but a usage error with "argparse" (complaining that no
  value has been supplied for "-o/--output", since "-v" is interpreted
  as meaning the verbosity flag)

* similarly, supplying "-o --" gives "output="--"" and "args=()" when
  using "optparse", but a usage error with "argparse" (also
  complaining that no value has been supplied for "-o/--output", since
  "--" is interpreted as terminating the option processing and
  treating all remaining values as positional arguments)

* supplying "-o=foo" gives "output="=foo"" when using "optparse", but
  gives "output="foo"" with "argparse" (since "=" is special cased as
  an alternative separator for option parameter values)

Whether these differing behaviors in the "argparse" version are
considered desirable or a problem will depend on the specific command
line application use case.

더 보기:

  click is a third party argument processing library (originally based
  on "optparse"), which allows command line applications to be
  developed as a set of decorated command implementation functions.

  Other third party libraries, such as typer or msgspec-click, allow
  command line interfaces to be specified in ways that more
  effectively integrate with static checking of Python type
  annotations.


Introduction
============

"optparse"는 최소한의 기능을 제공하는 "getopt" 모듈보다 명령 줄 옵션을
구문 분석하기 위한 더 편리하고 유연하며 강력한 라이브러리입니다.
"optparse"는 더 선언적인 스타일의 명령 줄 구문 분석을 사용합니다:
"OptionParser"의 인스턴스를 만들고, 옵션으로 채우고, 명령 줄을 구문 분
석합니다. "optparse"를 사용하면 사용자가 전통적인 GNU/POSIX 문법으로
옵션을 지정할 수 있으며, 추가로 사용법과 도움말 메시지를 생성할 수 있
습니다.

다음은 간단한 스크립트에서 "optparse"를 사용하는 예입니다:

   from optparse import OptionParser
   ...
   parser = OptionParser()
   parser.add_option("-f", "--file", dest="filename",
                     help="write report to FILE", metavar="FILE")
   parser.add_option("-q", "--quiet",
                     action="store_false", dest="verbose", default=True,
                     help="don't print status messages to stdout")

   (options, args) = parser.parse_args()

이 몇 줄의 코드로, 스크립트 사용자는 이제 명령 줄에서 "일반적인 작업"
을 수행 할 수 있습니다, 예를 들면:

   <yourscript> --file=outfile -q

명령 줄을 구문 분석할 때, "optparse"는 사용자가 제공한 명령 줄 값을 기
반으로 "parse_args()"에서 반환한 "options" 객체의 어트리뷰트를 설정합
니다. 이 명령 줄 구문 분석에서 "parse_args()"가 반환되면,
"options.filename"은 ""outfile""이 되고 "options.verbose"는 "False"가
됩니다. "optparse"는 긴 옵션과 짧은 옵션을 모두 지원하고, 짧은 옵션을
함께 병합하도록 하며, 다양한 방법으로 옵션을 인자와 연관시킬 수 있습니
다. 따라서 다음 명령 줄은 모두 위의 예와 동등합니다:

   <yourscript> -f outfile --quiet
   <yourscript> --quiet --file outfile
   <yourscript> -q -foutfile
   <yourscript> -qfoutfile

또한, 사용자는 다음 중 하나를 실행할 수 있습니다

   <yourscript> -h
   <yourscript> --help

그러면 "optparse"는 스크립트 옵션에 대한 간략한 요약을 인쇄합니다:

   Usage: <yourscript> [options]

   Options:
     -h, --help            show this help message and exit
     -f FILE, --file=FILE  write report to FILE
     -q, --quiet           don't print status messages to stdout

여기서 *yourscript*의 값은 (일반적으로 "sys.argv[0]"에서) 실행 시간에
결정됩니다.


배경
====

"optparse"는 C 개발자가 사용할 수 있는 "getopt()" 함수 계열이 정립한
관례를 따르는 간결한 명령 줄 인터페이스를 갖는 프로그램을 만들 수 있도
록 명시적으로 설계되었습니다. 이를 위해, 유닉스에서 전통적으로 사용되
는 가장 일반적인 명령 줄 문법과 의미 체계만 지원합니다. 이러한 관례에
익숙하지 않으면, 이 섹션을 읽는 것으로 익히게 될 것입니다.


용어
----

인자(argument)
   명령 줄에 입력하고, 셸에서 "execl()"이나 "execv()"로 전달한 문자열.
   파이썬에서, 인자는 "sys.argv[1:]"의 요소입니다 ("sys.argv[0]"은 실
   행 중인 프로그램의 이름입니다). 유닉스 셸은 "워드(word)"라는 용어도
   사용합니다.

   때때로 "sys.argv[1:]" 이외의 인자 리스트로 대체하는 것이 바람직해서
   , "인자"를 ""sys.argv[1:]"이나 "sys.argv[1:]"의 대체로 제공된 다른
   리스트의 요소"로 읽어야 합니다.

옵션(option)
   프로그램 실행을 안내하거나 사용자 정의하기 위해 추가 정보를 제공하
   는 데 사용되는 인자. 옵션에 대한 다양한 문법이 있습니다; 전통적인
   유닉스 문법은 하이픈 ("-") 뒤에 단일 문자가 옵니다, 예를 들어 "-x"
   나 "-F". 또한, 전통적인 유닉스 문법은 여러 옵션을 단일 인자로 병합
   할 수 있도록 합니다, 예를 들어 "-x -F"는 "-xF"와 동등합니다. GNU 프
   로젝트는 하이픈으로 구분된 일련의 단어가 뒤따르는 "--"를 도입했습니
   다, 예를 들어 "--file"이나 "--dry-run". 이들이 "optparse"에서 제공
   하는 유일한 두 가지 옵션 문법입니다.

   세상에 등장했던 다른 옵션 문법은 다음과 같습니다:

   * 몇 개의 문자가 뒤따르는 하이픈, 예를 들어 "-pf" (이것은 하나의 인
     자로 병합된 여러 옵션과 같은 것이 *아닙니다*)

   * 전체 단어가 뒤따르는 하이픈, 예를 들어 "-file" (기술적으로 이전
     문법과 동등하지만, 일반적으로 같은 프로그램에서 등장하지 않습니다
     )

   * 단일 문자나 몇 개의 문자 또는 단어가 뒤따르는 더하기 기호, 예를
     들어 "+f", "+rgb"

   * 단일 문자나 몇 개의 문자 또는 단어가 뒤따르는 슬래시, 예를 들어
     "/f", "/file"

   이러한 옵션 문법들은 "optparse"에서 지원되지 않으며, 앞으로도 지원
   되지 않을 것입니다. 이것은 의도적입니다: 처음 세 가지는 모든 환경에
   서 표준이 아니며, 마지막은 윈도우나 특정 레거시 플랫폼(예를 들어
   VMS, MS-DOS)을 대상으로 하는 경우에만 의미가 있습니다.

옵션 인자(option argument)
   옵션 뒤에 오는 인자는 해당 옵션과 밀접하게 연관되어 있으며, 해당 옵
   션이 있으면 인자 목록에서 사용됩니다. "optparse"를 사용하면, 옵션
   인자가 해당 옵션과 별도의 인자로 있을 수 있습니다:

      -f foo
      --file foo

   또는 같은 인자에 포함될 수 있습니다:

      -ffoo
      --file=foo

   일반적으로, 주어진 옵션은 인자를 취하거나 취하지 않습니다. 많은 사
   람이 "선택적 옵션 인자" 기능을 원합니다. 즉, 일부 옵션은 있다면 인
   자를 취하고 그렇지 않으면 취하지 않습니다. 이것은 구문 분석을 모호
   하게 만들기 때문에 다소 논란의 여지가 있습니다: "-a"가 선택적 인자
   를 취하고 "-b"가 완전히 다른 옵션이면 "-ab"를 어떻게 해석합니까? 이
   러한 모호성 때문에, "optparse"는 이 기능을 지원하지 않습니다.

위치 인자(positional argument)
   옵션이 구문 분석된 후, 즉 옵션과 해당 인자가 구문 분석되고 인자 목
   록에서 제거된 후 인자 목록에 남은 것.

필수 옵션(required option)
   명령 줄에서 제공해야 하는 옵션; "필수 옵션"이라는 문구는 영어에서
   모순된다는 점에 유의하십시오. "optparse"는 필수 옵션을 구현하는 것
   을 방해하지 않지만, 그다지 도움을 주지도 않습니다.

예를 들어, 다음 가상 명령 줄을 고려하십시오:

   prog -v --report report.txt foo bar

"-v"와 "--report"는 둘 다 옵션입니다. "--report"가 하나의 인자를 취한
다고 가정하면, "report.txt"는 옵션 인자입니다. "foo"와 "bar"는 위치 인
자입니다.


옵션은 무엇을 위한 것입니까?
----------------------------

옵션은 프로그램 실행을 조정하거나 사용자 정의하기 위한 추가 정보를 제
공하는 데 사용됩니다. 명확하지 않은 경우, 옵션은 일반적으로 *선택적*입
니다. 프로그램은 어떤 옵션도 없이 잘 실행될 수 있어야 합니다. (유닉스
나 GNU 도구 집합에서 임의의 프로그램을 선택하십시오. 옵션 없이도 실행
될 수 있으며 여전히 의미가 있습니까? 주요 예외는 "find", "tar" 및 "dd"
입니다 --- 모두 비표준 문법과 혼란스러운 인터페이스 때문에 올바로 비판
을 받은 돌연변이 괴짜입니다.)

많은 사람이 프로그램에 "필수 옵션"이 있기를 원합니다. 생각해보십시오.
필수라면, 그것은 *선택적(optional)이 아닙니다*! 당신의 프로그램이 성공
적으로 실행하기 위해 절대적으로 필요한 정보가 있다면, 그것이 바로 위치
인자의 목적입니다.

좋은 명령 줄 인터페이스 설계의 예로, 파일 복사를 위한 겸손한 "cp" 유틸
리티를 고려하십시오. 대상과 하나 이상의 소스를 제공하지 않고 파일을 복
사하는 것은 의미가 없습니다. 따라서, 인자 없이 실행하면 "cp"가 실패합
니다. 그러나 옵션이 전혀 필수로 요구하지 않는 유연하고 유용한 문법을
갖습니다:

   cp SOURCE DEST
   cp SOURCE ... DEST-DIR

그것만으로도 꽤 멀리 갈 수 있습니다. 대부분의 "cp" 구현은 파일이 복사
되는 방식을 정확하게 조정할 수 있는 여러 옵션을 제공합니다: 모드 및 수
정 시간을 보존하고, 심볼릭 링크를 따르지 않고, 기존 파일을 건드리기 전
에 물을 수 있습니다. 하지만 이 중 어느 것도 한 파일을 다른 파일로 복사
하거나 여러 파일을 다른 디렉터리로 복사하는 "cp"의 핵심 임무를 방해하
지 않습니다.


위치 인자는 무엇을 위한 것입니까?
---------------------------------

위치 인자는 프로그램이 실행하기 위해 절대적으로 필요로하는 정보를 위한
것입니다.

좋은 사용자 인터페이스에는 가능한 한 적은 절대 요구 사항이 있어야 합니
다. 프로그램을 성공적으로 실행하기 위해 17개의 개별 정보를 요구한다면,
사용자로부터 해당 정보를 *어떻게* 얻는지는 중요하지 않습니다---대부분
의 사람은 프로그램을 성공적으로 실행하기 전에 포기하고 떠납니다. 이것
은 사용자 인터페이스가 명령 줄이든, 구성 파일이든, GUI이든 상관없이 적
용됩니다: 사용자에게 그렇게 많은 요구를 하면, 대부분은 단순히 포기할
것입니다.

요컨대, 사용자가 절대적으로 제공해야 하는 정보의 양을 최소화하십시오
---가능할 때마다 합리적인 기본값을 사용하십시오. 물론, 프로그램을 합리
적으로 유연하게 만들고 싶기도 합니다. 그것이 바로 옵션이 있는 이유입니
다. 다시 말하지만, 구성 파일의 항목인지, GUI의 "기본 설정" 대화 상자에
있는 위젯인지, 명령 줄 옵션인지는 중요하지 않습니다---구현하는 옵션이
많을수록, 프로그램이 더 유연해지고, 구현은 더 복잡해집니다. 물론 유연
성이 너무 많으면 단점도 있습니다; 너무 많은 옵션은 사용자를 압도하고
코드 유지 관리를 훨씬 더 어렵게 만들 수 있습니다.


자습서
======

"optparse"는 매우 유연하고 강력하지만, 대부분의 경우 사용하기도 간단합
니다. 이 섹션에서는 모든 "optparse" 기반 프로그램에 공통적인 코드 패턴
을 다룹니다.

먼저, OptionParser 클래스를 임포트 해야 합니다; 그런 다음 메인 프로그
램의 초기에, OptionParser 인스턴스를 만듭니다:

   from optparse import OptionParser
   ...
   parser = OptionParser()

그런 다음 옵션 정의를 시작할 수 있습니다. 기본 문법은 다음과 같습니다:

   parser.add_option(opt_str, ...,
                     attr=value, ...)

각 옵션에는 "-f"나 "--file"과 같은 하나 이상의 옵션 문자열이 있고, 명
령 줄에서 해당 옵션을 발견했을 때 "optparse"가 기대하는 것과 수행 할
작업을 알려주는 여러 옵션 어트리뷰트가 있습니다.

일반적으로, 각 옵션에는 하나의 짧은 옵션 문자열과 하나의 긴 옵션 문자
열이 있습니다, 예를 들어:

   parser.add_option("-f", "--file", ...)

전체적으로 적어도 하나의 옵션 문자열이 있는 한 원하는 만큼 짧은 옵션
문자열과 긴 옵션 문자열을 (없는 것도 포함합니다) 자유롭게 정의 할 수
있습니다.

"OptionParser.add_option()"에 전달된 옵션 문자열은 해당 호출에 의해 정
의된 옵션에 대한 레이블입니다. 간결함을 위해, 명령 줄에서 *옵션을 만난
다*를 자주 언급할 것입니다; 실제로는, "optparse"가 *옵션 문자열*을 만
나고 이것으로 옵션을 찾습니다.

일단 모든 옵션이 정의되면, "optparse"가 프로그램의 명령 줄을 구문 분석
하도록 지시합니다:

   (options, args) = parser.parse_args()

(원한다면, 사용자 정의 인자 리스트를 "parse_args()"에 전달할 수 있지만
, 거의 필요하지 않습니다: 기본적으로 "sys.argv[1:]"을 사용합니다.)

"parse_args()"는 두 가지 값을 반환합니다:

* "options", 모든 옵션에 대한 값을 포함하는 객체---예를 들어 "--file"
  이 단일 문자열 인자를 취하면, "options.file"은 사용자가 제공한 파일
  명이거나, 사용자가 해당 옵션을 제공하지 않으면 "None"입니다.

* "args", 옵션 구문 분석 후 남은 위치 인자 리스트

이 자습서 섹션에서는 가장 중요한 4가지 옵션 어트리뷰트만 다룹니다:
"action", "type", "dest" (destination) 및 "help"만 다룹니다. 이 중,
"action"이 가장 기본입니다.


옵션 액션의 이해
----------------

액션은 명령 줄에서 옵션을 발견할 때 수행 할 작업을 "optparse"에 알려줍
니다. "optparse"에 하드 코딩된 고정된 액션 집합이 있습니다; 새로운 액
션 추가는 섹션 optparse 확장하기에서 다루는 고급 주제입니다. 대부분의
액션은 "optparse"에게 어떤 변수에 값을 저장하도록 지시합니다---예를 들
어, 명령 줄에서 문자열을 취해서 "options"의 어트리뷰트에 저장합니다.

옵션 액션을 지정하지 않으면, "optparse"의 기본값은 "store"입니다.


store 액션
----------

가장 일반적인 옵션 액션은 "store"로, "optparse"에게 다음 인자(또는 현
재 인자의 나머지)를 취하고, 올바른 형인지 확인한 다음, 선택한 대상에
저장하도록 지시합니다.

예를 들면:

   parser.add_option("-f", "--file",
                     action="store", type="string", dest="filename")

이제 가짜 명령 줄을 만들고 "optparse"에게 구문 분석을 요청합시다:

   args = ["-f", "foo.txt"]
   (options, args) = parser.parse_args(args)

"optparse"가 옵션 문자열 "-f"를 보면, 다음 인자인 "foo.txt"를 소비하고
, "options.filename"에 저장합니다. 따라서, 이 "parse_args()" 호출 후,
"options.filename"은 ""foo.txt""입니다.

"optparse"에서 지원하는 다른 옵션 형은 "int"와 "float"입니다. 정수 인
자를 기대하는 옵션은 다음과 같습니다:

   parser.add_option("-n", type="int", dest="num")

이 옵션에는 긴 옵션 문자열이 없는데, 완벽하게 허용됩니다. 또한, 기본값
이 "store"이기 때문에 명시적인 액션이 없습니다.

다른 가짜 명령 줄을 구문 분석해 봅시다. 이번에는, 옵션 인자를 옵션 바
로 다음에 붙일 것입니다: "-n42"(하나의 인자)는 "-n 42"(두 개의 인자)와
동등하므로, 다음 코드는

   (options, args) = parser.parse_args(["-n42"])
   print(options.num)

"42"를 인쇄합니다.

형을 지정하지 않으면, "optparse"는 "string"을 가정합니다. 기본 액션이
"store"라는 사실과 결합하면, 첫 번째 예제를 훨씬 더 짧게 만들 수 있습
니다:

   parser.add_option("-f", "--file", dest="filename")

대상을 제공하지 않으면, "optparse"는 옵션 문자열에서 합리적인 기본값을
추측합니다: 첫 번째 긴 옵션 문자열이 "--foo-bar"이면 기본 대상은
"foo_bar"입니다. 긴 옵션 문자열이 없으면, "optparse"는 첫 번째 짧은 옵
션 문자열을 찾습니다: "-f"의 기본 대상은 "f"입니다.

"optparse"는 내장 "complex" 형도 포함합니다. 형 추가는 섹션 optparse
확장하기에서 다룹니다.


불리언 (플래그) 옵션 처리하기
-----------------------------

플래그 옵션(특정 옵션이 발견되면 변수를 참이나 거짓으로 설정합니다)은
매우 흔합니다. "optparse"는 "store_true"와 "store_false"의 두 가지 별
도의 액션으로 지원합니다. 예를 들어, "-v"로 켜고 "-q"로 끄는 "verbose"
플래그가 있을 수 있습니다:

   parser.add_option("-v", action="store_true", dest="verbose")
   parser.add_option("-q", action="store_false", dest="verbose")

여기에 대상이 같은 두 가지 옵션이 있는데, 완벽하게 괜찮습니다. (단지
기본값을 설정할 때 약간 주의해야 함을 뜻합니다---아래를 참조하십시오.)

"optparse"가 명령 줄에서 "-v"를 만나면, "options.verbose"를 "True"로
설정합니다; "-q"를 만나면 "options.verbose"는 "False"로 설정됩니다.


다른 액션들
-----------

"optparse"에서 지원하는 다른 액션은 다음과 같습니다:

""store_const""
   store a constant value, pre-set via "Option.const"

""append""
   이 옵션의 인자를 리스트에 추가합니다

""count""
   카운터를 1씩 증가시킵니다

""callback""
   지정된 함수를 호출합니다

이들은 섹션 레퍼런스 지침서와 섹션 옵션 콜백에서 다룹니다.


기본값
------

위의 모든 예에는 특정 명령 줄 옵션을 볼 때 일부 변수 ("대상
(destination)") 설정이 수반됩니다. 이러한 옵션이 나타나지 않으면 어떻
게 될까요? 기본값을 제공하지 않아서, 모두 "None"으로 설정됩니다. 이것
은 일반적으로 괜찮지만, 때로는 더 많은 제어가 필요합니다. "optparse"는
각 대상에 대한 기본값을 제공할 수 있도록 하는데, 명령 줄이 구문 분석되
기 전에 대입됩니다.

먼저, verbose/quiet 예를 고려하십시오. "-q"가 나타나지 않는 한
"optparse"가 "verbose"를 "True"로 설정하도록 하려면, 다음과 같이 할 수
있습니다:

   parser.add_option("-v", action="store_true", dest="verbose", default=True)
   parser.add_option("-q", action="store_false", dest="verbose")

기본값은 특정 옵션이 아닌 *대상(destination)*에 적용되고, 이 두 옵션은
같은 대상을 갖기 때문에, 다음과 정확히 동등합니다:

   parser.add_option("-v", action="store_true", dest="verbose")
   parser.add_option("-q", action="store_false", dest="verbose", default=True)

이걸 생각해봅시다:

   parser.add_option("-v", action="store_true", dest="verbose", default=False)
   parser.add_option("-q", action="store_false", dest="verbose", default=True)

다시, "verbose"의 기본값은 "True"입니다: 특정 대상에 대해 제공되는 마
지막 기본값이 사용되는 값입니다.

기본값을 지정하는 더 명확한 방법은 OptionParser의 "set_defaults()" 메
서드인데, "parse_args()"를 호출하기 전에 언제든지 호출할 수 있습니다:

   parser.set_defaults(verbose=True)
   parser.add_option(...)
   (options, args) = parser.parse_args()

이전과 마찬가지로, 주어진 옵션 대상에 대해 지정된 마지막 값이 사용됩니
다. 명확성을 위해, 둘 다가 아닌 한 가지 방법을 사용하여 기본값을 설정
하십시오.


도움말 생성하기
---------------

도움말과 사용법 텍스트를 자동으로 생성하는 "optparse"의 기능은 사용자
친화적인 명령 줄 인터페이스를 만드는 데 유용합니다. 각 옵션에 대해
"help" 값을 제공하고, 선택적으로 전체 프로그램에 대한 짧은 사용법 메시
지를 제공하기만 하면 됩니다. 다음은 사용자에게 친숙한 (문서화된) 옵션
으로 채워진 OptionParser입니다:

   usage = "usage: %prog [options] arg1 arg2"
   parser = OptionParser(usage=usage)
   parser.add_option("-v", "--verbose",
                     action="store_true", dest="verbose", default=True,
                     help="make lots of noise [default]")
   parser.add_option("-q", "--quiet",
                     action="store_false", dest="verbose",
                     help="be vewwy quiet (I'm hunting wabbits)")
   parser.add_option("-f", "--filename",
                     metavar="FILE", help="write output to FILE")
   parser.add_option("-m", "--mode",
                     default="intermediate",
                     help="interaction mode: novice, intermediate, "
                          "or expert [default: %default]")

"optparse"가 명령 줄에서 "-h"나 "--help"를 만나거나,
"parser.print_help()"를 호출하면, 다음을 표준 출력에 인쇄합니다:

   Usage: <yourscript> [options] arg1 arg2

   Options:
     -h, --help            show this help message and exit
     -v, --verbose         make lots of noise [default]
     -q, --quiet           be vewwy quiet (I'm hunting wabbits)
     -f FILE, --filename=FILE
                           write output to FILE
     -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                           expert [default: intermediate]

(도움말 출력이 help 옵션으로 트리거 되면, "optparse"가 도움말 텍스트를
인쇄한 후 종료합니다.)

여기에는 "optparse"가 최상의 도움말 메시지를 생성하는 데 도움이 되는
많은 것들이 있습니다:

* 스크립트는 자체 사용법 메시지를 정의합니다:

     usage = "usage: %prog [options] arg1 arg2"

  "optparse"는 사용법 문자열의 "%prog"를 현재 프로그램의 이름, 즉
  "os.path.basename(sys.argv[0])"으로 확장합니다. 확장된 문자열은 자세
  한 옵션 도움말 앞에 인쇄됩니다.

  사용법 문자열을 제공하지 않으면, "optparse"는 단순하지만, 합리적인
  기본값을 사용합니다: ""Usage: %prog [options]"", 이는 스크립트가 위
  치 인자를 취하지 않는다면 괜찮습니다.

* 모든 옵션은 도움말 문자열을 정의하고, 줄 바꿈에 대해 걱정하지 않습니
  다---"optparse"는 줄 바꿈을 처리하고 도움말 출력을 보기 좋게 만듭니
  다.

* 값을 취하는 옵션은 자동으로 생성된 도움말 메시지에 이 사실을 나타냅
  니다, 예를 들어 "mode" 옵션의 경우:

     -m MODE, --mode=MODE

  여기서, "MODE"를 메타 변수(meta-variable)라고 합니다: 사용자가
  "-m"/"--mode"에 제공할 것으로 기대되는 인자를 나타냅니다. 기본적으로
  , "optparse"는 대상 변수 이름을 대문자로 변환하고 이를 메타 변수에
  사용합니다. 때로는, 이것이 여러분이 원하는 것이 아닙니다---예를 들어
  , "--filename" 옵션은 명시적으로 "metavar="FILE""을 설정하여 다음과
  같은 자동 생성 옵션 설명을 생성합니다:

     -f FILE, --filename=FILE

  이것은 공간을 절약하는 것 이상으로 중요합니다: 수동으로 작성된 도움
  말 텍스트는 메타 변수 "FILE"을 사용하여 반 형식 구문 "-f FILE"과 비
  형식적 의미 설명 "write output to FILE" 사이에 연결이 있다는 단서를
  사용자에게 알려줍니다. 이는 최종 사용자에게 도움말 텍스트를 훨씬 더
  명확하고 유용하게 만드는 간단하지만, 효과적인 방법입니다.

* 기본값이 있는 옵션은 도움말 문자열에 "%default"를 포함할 수 있습니다
  ---"optparse"는 이를 옵션 기본값의 "str()"로 대체합니다. 옵션에 기본
  값이 없으면 (또는 기본값이 "None"이면), "%default"는 "none"으로 확장
  됩니다.


옵션 그룹화하기
~~~~~~~~~~~~~~~

많은 옵션을 다룰 때, 더 나은 도움말 출력을 위해 이러한 옵션을 그룹화하
는 것이 편리합니다. "OptionParser"에는 여러 옵션 그룹이 포함될 수 있으
며 각 그룹에는 여러 옵션이 포함될 수 있습니다.

옵션 그룹은 클래스 "OptionGroup"을 사용하여 얻습니다:

class optparse.OptionGroup(parser, title, description=None)

   여기서

   * parser는 그룹이 삽입될 "OptionParser" 인스턴스입니다

   * title은 그룹 제목입니다

   * description(선택 사항)은 그룹에 대한 자세한 설명입니다

"OptionGroup"은 ("OptionParser" 처럼) "OptionContainer"에서 상속되므로
"add_option()" 메서드를 사용하여 그룹에 옵션을 추가할 수 있습니다.

일단 모든 옵션이 선언되면, "OptionParser" 메서드 "add_option_group()"
을 사용하여 그룹이 이전에 정의된 구문 분석기에 추가됩니다.

이전 섹션에서 정의한 구문 분석기로 계속 진행하면, 구문 분석기에
"OptionGroup"을 쉽게 추가할 수 있습니다:

   group = OptionGroup(parser, "Dangerous Options",
                       "Caution: use these options at your own risk.  "
                       "It is believed that some of them bite.")
   group.add_option("-g", action="store_true", help="Group option.")
   parser.add_option_group(group)

그러면 다음과 같은 도움말이 출력됩니다:

   Usage: <yourscript> [options] arg1 arg2

   Options:
     -h, --help            show this help message and exit
     -v, --verbose         make lots of noise [default]
     -q, --quiet           be vewwy quiet (I'm hunting wabbits)
     -f FILE, --filename=FILE
                           write output to FILE
     -m MODE, --mode=MODE  interaction mode: novice, intermediate, or
                           expert [default: intermediate]

     Dangerous Options:
       Caution: use these options at your own risk.  It is believed that some
       of them bite.

       -g                  Group option.

좀 더 완전한 예는 둘 이상의 그룹을 수반할 수 있습니다: 여전히 이전 예
를 확장합니다:

   group = OptionGroup(parser, "Dangerous Options",
                       "Caution: use these options at your own risk.  "
                       "It is believed that some of them bite.")
   group.add_option("-g", action="store_true", help="Group option.")
   parser.add_option_group(group)

   group = OptionGroup(parser, "Debug Options")
   group.add_option("-d", "--debug", action="store_true",
                    help="Print debug information")
   group.add_option("-s", "--sql", action="store_true",
                    help="Print all SQL statements executed")
   group.add_option("-e", action="store_true", help="Print every action done")
   parser.add_option_group(group)

다음과 같은 출력을 줍니다:

   Usage: <yourscript> [options] arg1 arg2

   Options:
     -h, --help            show this help message and exit
     -v, --verbose         make lots of noise [default]
     -q, --quiet           be vewwy quiet (I'm hunting wabbits)
     -f FILE, --filename=FILE
                           write output to FILE
     -m MODE, --mode=MODE  interaction mode: novice, intermediate, or expert
                           [default: intermediate]

     Dangerous Options:
       Caution: use these options at your own risk.  It is believed that some
       of them bite.

       -g                  Group option.

     Debug Options:
       -d, --debug         Print debug information
       -s, --sql           Print all SQL statements executed
       -e                  Print every action done

특히 옵션 그룹을 프로그래밍 방식으로 작업할 때, 또 다른 흥미로운 메서
드는 다음과 같습니다:

OptionParser.get_option_group(opt_str)

   짧거나 긴 옵션 문자열 *opt_str*(예를 들어 "'-o'"나 "'--option'")이
   속한 "OptionGroup"을 반환합니다. 그러한 "OptionGroup"이 없으면,
   "None"을 반환합니다.


버전 문자열 인쇄하기
--------------------

간단한 사용법 문자열과 유사하게, "optparse"는 프로그램의 버전 문자열을
인쇄 할 수도 있습니다. OptionParser에 "version" 인자로 문자열을 제공해
야 합니다:

   parser = OptionParser(usage="%prog [-f] [-q]", version="%prog 1.0")

"%prog"는 "usage"에서처럼 확장됩니다. 그 외에도, "version"은 원하는 무
엇이든 포함할 수 있습니다. 이를 제공하면, "optparse"는 자동으로 구문
분석기에 "--version" 옵션을 추가합니다. 명령 줄에서 이 옵션을 발견하면
, ("%prog"를 대체하여) "version" 문자열을 확장하고, stdout에 인쇄한 다
음, 종료합니다.

예를 들어, 스크립트가 "/usr/bin/foo"로 호출되면:

   $ /usr/bin/foo --version
   foo 1.0

다음 두 가지 메서드를 사용하여 "version" 문자열을 인쇄하고 가져올 수
있습니다:

OptionParser.print_version(file=None)

   현재 프로그램의 버전 메시지("self.version")를 *file*(기본값은 표준
   출력)로 인쇄합니다. "print_usage()"와 마찬가지로, "self.version"에
   등장하는 "%prog"는 현재 프로그램의 이름으로 대체됩니다.
   "self.version"이 비어 있거나 정의되지 않았으면 아무 작업도 수행하지
   않습니다.

OptionParser.get_version()

   "print_version()"과 같지만 인쇄하는 대신 버전 문자열을 반환합니다.


"optparse"가 에러를 처리하는 방법
---------------------------------

"optparse"가 걱정해야 할 에러에는 두 가지가 있습니다: 프로그래머 에러
와 사용자 에러. 프로그래머 에러는 일반적으로
"OptionParser.add_option()"에 대한 잘못된 호출입니다, 예를 들어 잘못된
옵션 문자열, 알 수 없는 옵션 어트리뷰트, 누락된 옵션 어트리뷰트 등. 이
러한 에러는 일반적인 방식으로 처리됩니다: 예외("optparse.OptionError"
나 "TypeError")를 발생시키고 프로그램이 충돌하도록 합니다.

사용자 에러를 처리하는 것은 훨씬 더 중요합니다, 코드가 아무리 안정적이
더라도 발생하는 것이 보장되기 때문입니다. "optparse"는 잘못된 옵션 인
자 ("-n"이 정수 인자를 취할 때 "-n 4x" 전달), 누락된 인자("-n"이 모든
형의 인자를 취할 때, 명령 줄 끝의 "-n")와 같은 일부 사용자 에러를 자동
으로 감지할 수 있습니다. 또한, "OptionParser.error()"를 호출하여 응용
프로그램 정의 에러 조건을 알릴 수 있습니다:

   (options, args) = parser.parse_args()
   ...
   if options.a and options.b:
       parser.error("options -a and -b are mutually exclusive")

두 경우 모두, "optparse"는 같은 방식으로 에러를 처리합니다: 프로그램의
사용법 메시지와 에러 메시지를 표준 에러에 인쇄하고 에러 상태 2로 종료
합니다.

사용자가 정수를 취하는 옵션에 "4x"를 전달하는 위의 첫 번째 예를 고려하
십시오:

   $ /usr/bin/foo -n 4x
   Usage: foo [options]

   foo: error: option -n: invalid integer value: '4x'

또는 사용자가 값을 전혀 전달하지 못하는 경우:

   $ /usr/bin/foo -n
   Usage: foo [options]

   foo: error: -n option requires an argument

"optparse"-생성 에러 메시지는 항상 에러와 관련된 옵션을 언급하도록 주
의를 기울입니다; 응용 프로그램 코드에서 "OptionParser.error()"를 호출
할 때도 그래야 합니다.

"optparse"의 기본 에러 처리 동작이 여러분의 요구에 맞지 않으면,
OptionParser를 서브 클래스 화하고 "exit()" 및/또는 "error()" 메서드를
재정의해야 합니다.


모두 합치기
-----------

일반적으로 "optparse" 기반 스크립트는 다음과 같습니다:

   from optparse import OptionParser
   ...
   def main():
       usage = "usage: %prog [options] arg"
       parser = OptionParser(usage)
       parser.add_option("-f", "--file", dest="filename",
                         help="read data from FILENAME")
       parser.add_option("-v", "--verbose",
                         action="store_true", dest="verbose")
       parser.add_option("-q", "--quiet",
                         action="store_false", dest="verbose")
       ...
       (options, args) = parser.parse_args()
       if len(args) != 1:
           parser.error("incorrect number of arguments")
       if options.verbose:
           print("reading %s..." % options.filename)
       ...

   if __name__ == "__main__":
       main()


레퍼런스 지침서
===============


구문 분석기 만들기
------------------

"optparse"를 사용하는 첫 번째 단계는 OptionParser 인스턴스를 만드는 것
입니다.

class optparse.OptionParser(...)

   OptionParser 생성자에는 필수 인자가 없지만, 여러 선택적 키워드 인자
   가 있습니다. 이들을 항상 키워드 인자로 전달해야 합니다, 즉, 인자가
   선언된 순서에 의존하지 마십시오.

   "usage" (기본값: ""%prog [options]"")
      프로그램이 잘못 실행되거나 도움말(help) 옵션을 사용할 때 인쇄할
      사용법 요약. "optparse"가 사용법 문자열을 인쇄할 때, "%prog"를
      "os.path.basename(sys.argv[0])"(또는 해당 키워드 인자를 전달한
      경우 "prog")으로 확장합니다. 사용법 메시지를 표시하지 않으려면,
      특수 값 "optparse.SUPPRESS_USAGE"를 전달하십시오.

   "option_list" (기본값: "[]")
      구문 분석기를 채울 Option 객체 리스트. "option_list"의 옵션은
      "standard_option_list"(OptionParser 서브 클래스에서 설정할 수 있
      는 클래스 어트리뷰트)의 모든 옵션 뒤에 추가되지만, 모든 버전
      (version) 또는 도움말(help) 옵션 앞에 추가됩니다. 폐지되었습니다
      ; 대신 구문 분석기를 만든 후 "add_option()"을 사용하십시오.

   "option_class" (기본값: optparse.Option)
      "add_option()"에서 구문 분석기에 옵션을 추가할 때 사용할 클래스.

   "version" (기본값: "None")
      사용자가 버전(version) 옵션을 제공할 때 인쇄 할 버전 문자열.
      "version"에 참값을 제공하면, "optparse"는 단일 옵션 문자열 "--
      version"으로 버전 옵션을 자동으로 추가합니다. 하위 문자열
      "%prog"는 "usage"와 마찬가지로 확장됩니다.

   "conflict_handler" (기본값: ""error"")
      충돌하는 옵션 문자열이 있는 옵션이 구문 분석기에 추가될 때 수행
      할 작업을 지정합니다; 섹션 옵션 간의 충돌을 참조하십시오.

   "description" (기본값: "None")
      프로그램에 대한 간략한 개요를 제공하는 텍스트 단락. "optparse"는
      현재 터미널 너비에 맞게 이 단락을 다시 포맷하고 사용자가 도움말
      을 요청할 때 인쇄합니다 ("usage" 이후, 옵션 목록 이전).

   "formatter" (기본값: 새 "IndentedHelpFormatter")
      도움말 텍스트를 인쇄하는 데 사용될 optparse.HelpFormatter의 인스
      턴스. "optparse"는 이 목적으로 두 개의 구상 클래스를 제공합니다:
      IndentedHelpFormatter 와 TitledHelpFormatter.

   "add_help_option" (기본값: "True")
      참이면, "optparse"는 구문 분석기에 도움말 옵션(옵션 문자열 "-h"
      와 "--help")을 추가합니다.

   "prog"
      "usage"와 "version"에서 "%prog"를 확장할 때
      "os.path.basename(sys.argv[0])" 대신 사용할 문자열.

   "epilog" (기본값: "None")
      옵션 도움말 다음에 인쇄할 도움말 텍스트 단락.


구문 분석기 채우기
------------------

구문 분석기를 옵션으로 채우는 방법에는 여러 가지가 있습니다. 선호되는
방법은 섹션 자습서에 표시된 대로, "OptionParser.add_option()"을 사용하
는 것입니다. "add_option()"은 다음 두 가지 방법의 하나로 호출 할 수 있
습니다:

* ("make_option()"에서 반환되는 것과 같은) Option 인스턴스를 전달합니
  다

* "make_option()"(즉, Option 생성자)에 허용되는 위치와 키워드 인자의
  조합을 전달합니다, 그러면 Option 인스턴스를 만듭니다

다른 대안은 다음과 같이 미리 생성된 Option 인스턴스 리스트를
OptionParser 생성자에 전달하는 것입니다:

   option_list = [
       make_option("-f", "--filename",
                   action="store", type="string", dest="filename"),
       make_option("-q", "--quiet",
                   action="store_false", dest="verbose"),
       ]
   parser = OptionParser(option_list=option_list)

("make_option()"은 Option 인스턴스를 만들기 위한 팩토리 함수입니다; 현
재는 Option 생성자의 별칭입니다. "optparse"의 향후 버전은 Option을 여
러 클래스로 나눌 수 있으며, "make_option()"은 인스턴스 화할 올바른 클
래스를 선택할 것입니다. Option을 직접 인스턴스 화하지 마십시오.)


옵션 정의하기
-------------

각 Option 인스턴스는 동의어 명령 줄 옵션 문자열 집합을 나타냅니다, 예
를 들어 "-f"와 "--file". 짧거나 긴 옵션 문자열을 얼마든지 지정할 수 있
지만, 전체적으로 옵션 문자열을 적어도 하나 지정해야 합니다.

"Option" 인스턴스를 만드는 규범적 방법은 "OptionParser"의
"add_option()" 메서드를 사용하는 것입니다.

OptionParser.add_option(option)
OptionParser.add_option(*opt_str, attr=value, ...)

   짧은 옵션 문자열로만 옵션을 정의하려면:

      parser.add_option("-f", attr=value, ...)

   그리고 긴 옵션 문자열로만 옵션을 정의하려면:

      parser.add_option("--foo", attr=value, ...)

   키워드 인자는 새 Option 객체의 어트리뷰트를 정의합니다. 가장 중요한
   옵션 어트리뷰트는 "action"이며, 전체적으로 어떤 어트리뷰트가 관련성
   이 있거나 필요한지를 결정합니다. 관련 없는 옵션 어트리뷰트를 전달하
   거나, 필수 어트리뷰트를 전달하지 못하면, "optparse"는 실수를 설명하
   는 "OptionError" 예외를 발생시킵니다.

   옵션의 *action*은 명령 줄에서 이 옵션을 만날 때 "optparse"가 수행하
   는 작업을 결정합니다. "optparse"에 하드 코딩된 표준 옵션 액션은 다
   음과 같습니다:

   ""store""
      이 옵션의 인자를 저장합니다 (기본값)

   ""store_const""
      store a constant value, pre-set via "Option.const"

   ""store_true""
      "True"를 저장합니다

   ""store_false""
      "False"를 저장합니다

   ""append""
      이 옵션의 인자를 리스트에 추가합니다

   ""append_const""
      리스트에 상숫값을 추가합니다, "Option.const"로 사전 설정

   ""count""
      카운터를 1씩 증가시킵니다

   ""callback""
      지정된 함수를 호출합니다

   ""help""
      모든 옵션과 해당 설명을 포함하는 사용법 메시지를 인쇄합니다

   (액션을 제공하지 않으면, 기본값은 ""store""입니다. 이 액션의 경우,
   "type"과 "dest" 옵션 어트리뷰트도 제공할 수 있습니다; 표준 옵션 액
   션을 참조하십시오.)

보시다시피, 대부분의 액션은 값을 어딘가에 저장하거나 갱신하는 것을 수
반합니다. "optparse"는 항상 이를 위해 일반적으로
"options"("optparse.Values"의 인스턴스)라고 하는 특수 객체를 만듭니다.

class optparse.Values

   An object holding parsed argument names and values as attributes.
   Normally created by calling when calling
   "OptionParser.parse_args()", and can be overridden by a custom
   subclass passed to the *values* argument of
   "OptionParser.parse_args()" (as described in 인자 구문 분석하기).

옵션 인자(및 기타 다양한 값)는 "dest" (destination) 옵션 어트리뷰트에
따라, 이 객체의 어트리뷰트로 저장됩니다.

예를 들어, 다음과 같이 호출할 때

   parser.parse_args()

"optparse"가 하는 첫 번째 작업 중 하나는 "options" 객체를 만드는 것입
니다:

   options = Values()

이 구문 분석기의 옵션 중 하나가 다음과 같이 정의되었으면:

   parser.add_option("-f", "--file", action="store", type="string", dest="filename")

그리고 구문 분석 중인 명령 줄에는 다음 중 하나가 포함되면:

   -ffoo
   -f foo
   --file=foo
   --file foo

"optparse"는 이 옵션을 볼 때 다음과 동등한 일을 합니다

   options.filename = "foo"

"type"과 "dest" 옵션 어트리뷰트는 "action"만큼 중요하지만, "action"은
*모든* 옵션에 적합한 유일한 어트리뷰트입니다.


옵션 어트리뷰트
---------------

class optparse.Option

   A single command line argument, with various attributes passed by
   keyword to the constructor. Normally created with
   "OptionParser.add_option()" rather than directly, and can be
   overridden by a custom class via the *option_class* argument to
   "OptionParser".

다음 옵션 어트리뷰트는 "OptionParser.add_option()"에 키워드 인자로 전
달될 수 있습니다. 특정 옵션과 관련이 없는 옵션 어트리뷰트를 전달하거나
, 필수 옵션 어트리뷰트를 전달하지 못하면 "optparse"는 "OptionError"를
발생시킵니다.

Option.action

   (기본값: ""store"")

   이 옵션이 명령 줄에서 보일 때 "optparse"의 동작을 결정합니다; 사용
   가능한 옵션은 여기에 설명되어 있습니다.

Option.type

   (기본값: ""string"")

   이 옵션이 기대하는 인자 형 (예를 들어, ""string""이나 ""int""); 사
   용 가능한 옵션 형은 여기에 설명되어 있습니다.

Option.dest

   (기본값: 옵션 문자열에서 파생됩니다)

   옵션의 액션이 어딘가에 값을 쓰거나 수정하는 것을 의미하면, 이것은
   "optparse"에게 어디에 쓸 것인지 알려줍니다: "dest"는 명령 줄을 구문
   분석할 때 "optparse"가 빌드하는 "options" 객체의 어트리뷰트의 이름
   을 정합니다.

Option.default

   옵션이 명령 줄에서 보이지 않으면 이 옵션의 대상에 사용할 값.
   "OptionParser.set_defaults()"도 참조하십시오.

Option.nargs

   (기본값: 1)

   이 옵션이 보일 때 소비되어야 하는 "type" 형의 인자 수입니다. > 1 이
   면, "optparse"는 값의 튜플을 "dest"에 저장합니다.

Option.const

   상숫값을 저장하는 액션의 경우, 저장할 상숫값.

Option.choices

   ""choice"" 형 옵션의 경우, 사용자가 이 중에서 선택할 수 있는 문자열
   리스트.

Option.callback

   액션 ""callback""이 있는 옵션의 경우, 이 옵션이 보일 때 호출 할 콜
   러블. 콜러블에 전달된 인자에 대한 자세한 내용은 섹션 옵션 콜백을 참
   조하십시오.

Option.callback_args
Option.callback_kwargs

   4개의 표준 콜백 인자 다음에 "callback"에 전달할 추가 위치와 키워드
   인자.

Option.help

   사용자가 "help" 옵션을 제공한 (가령 "--help") 후 사용 가능한 모든
   옵션을 나열할 때 이 옵션에 대해 인쇄할 도움말 텍스트. 도움말 텍스트
   가 제공되지 않으면, 옵션이 도움말 텍스트 없이 나열됩니다. 이 옵션을
   숨기려면, 특수 값 "optparse.SUPPRESS_HELP"를 사용하십시오.

Option.metavar

   (기본값: 옵션 문자열에서 파생됩니다)

   도움말 텍스트를 인쇄할 때 사용할 옵션 인자를 나타냅니다. 예제는 섹
   션 자습서를 참조하십시오.


표준 옵션 액션
--------------

다양한 옵션 액션은 모두 요구 사항과 효과가 약간 다릅니다. 대부분의 액
션에는 "optparse"의 동작을 안내하기 위해 지정할 수 있는 몇 가지 연관된
옵션 어트리뷰트가 있습니다; 일부는 해당 액션을 사용하는 모든 옵션에 대
해 지정해야 하는 필수 어트리뷰트가 있습니다.

* ""store"" [연관된 옵션: "type", "dest", "nargs", "choices"]

  옵션 뒤에 인자가 와야 하며, 인자는 "type"에 따라 값으로 변환되고,
  "dest"에 저장됩니다. "nargs" > 1 이면, 명령 줄에서 여러 인자가 소비
  됩니다; 모두 "type"에 따라 변환되고 "dest"에 튜플로 저장됩니다. 표준
  옵션 형 섹션을 참조하십시오.

  "choices"가 제공되면 (문자열 리스트나 튜플), 형의 기본값은
  ""choice""입니다.

  "type"이 제공되지 않으면, 기본값은 ""string""입니다.

  "dest"가 제공되지 않으면, "optparse"는 첫 번째 긴 옵션 문자열에서 대
  상을 파생합니다 (예를 들어, "--foo-bar"는 "foo_bar"를 암시합니다).
  긴 옵션 문자열이 없으면, "optparse"는 첫 번째 짧은 옵션 문자열에서
  대상을 파생합니다 (예를 들어, "-f"는 "f"를 암시합니다).

  예:

     parser.add_option("-f")
     parser.add_option("-p", type="float", nargs=3, dest="point")

  다음과 같은 명령 줄을 구문 분석할 때

     -f foo.txt -p 1 -3.5 4 -fbar.txt

  "optparse"는 다음과 같이 설정합니다

     options.f = "foo.txt"
     options.point = (1.0, -3.5, 4.0)
     options.f = "bar.txt"

* ""store_const"" [필수 옵션: "const"; 연관된 옵션: "dest"]

  값 "const"는 "dest"에 저장됩니다.

  예:

     parser.add_option("-q", "--quiet",
                       action="store_const", const=0, dest="verbose")
     parser.add_option("-v", "--verbose",
                       action="store_const", const=1, dest="verbose")
     parser.add_option("--noisy",
                       action="store_const", const=2, dest="verbose")

  "--noisy"가 보이면, "optparse"는 다음과 같이 설정합니다

     options.verbose = 2

* ""store_true"" [연관된 옵션: "dest"]

  "True"를 "dest"에 저장하는 ""store_const""의 특별한 경우.

* ""store_false"" [연관된 옵션: "dest"]

  ""store_true""와 비슷하지만, "False"를 저장합니다.

  예:

     parser.add_option("--clobber", action="store_true", dest="clobber")
     parser.add_option("--no-clobber", action="store_false", dest="clobber")

* ""append"" [연관된 옵션: "type", "dest", "nargs", "choices"]

  옵션 다음에는 "dest"의 리스트에 추가되는 인자가 와야 합니다. "dest"
  의 기본값이 제공되지 않으면, "optparse"가 명령 줄에서 이 옵션을 처음
  발견할 때 빈 리스트가 자동으로 만들어집니다. "nargs" > 1 이면, 여러
  인자가 소비되며, "nargs" 길이의 튜플이 "dest"에 추가됩니다.

  "type"과 "dest"의 기본값은 ""store"" 액션의 경우와 같습니다.

  예:

     parser.add_option("-t", "--tracks", action="append", type="int")

  "-t3"가 명령 줄에 보이면, "optparse"는 다음과 동등한 것을 수행합니다
  :

     options.tracks = []
     options.tracks.append(int("3"))

  잠시 후, "--tracks=4"가 보이면, 다음을 수행합니다:

     options.tracks.append(int("4"))

  "append" 액션은 옵션의 현재 값에 대해 "append" 메서드를 호출합니다.
  이는 지정된 모든 기본값에 "append" 메서드가 있어야 함을 의미합니다.
  또한, 기본값이 비어 있지 않으면, 기본 요소가 옵션의 구문 분석된 값에
  존재하며, 명령 줄의 모든 값이 기본값 뒤에 추가됨을 의미합니다:

     >>> parser.add_option("--files", action="append", default=['~/.mypkg/defaults'])
     >>> opts, args = parser.parse_args(['--files', 'overrides.mypkg'])
     >>> opts.files
     ['~/.mypkg/defaults', 'overrides.mypkg']

* ""append_const"" [필수 옵션: "const"; 연관된 옵션: "dest"]

  ""store_const""와 비슷하지만, "const" 값이 "dest"에 추가됩니다;
  ""append""와 마찬가지로, "dest"의 기본값은 "None"이며, 옵션이 처음
  발견될 때 빈 리스트가 자동으로 만들어집니다.

* ""count"" [연관된 옵션: "dest"]

  "dest"에 저장된 정수를 증가시킵니다. 기본값이 제공되지 않으면,
  "dest"는 처음으로 증가하기 전에 0으로 설정됩니다.

  예:

     parser.add_option("-v", action="count", dest="verbosity")

  "-v"가 명령 줄에서 처음 보이면, "optparse"는 다음과 동등한 작업을 수
  행합니다:

     options.verbosity = 0
     options.verbosity += 1

  이후에 "-v"가 나타날 때마다 다음과 같이 합니다

     options.verbosity += 1

* ""callback"" [필수 옵션: "callback"; 연관된 옵션: "type", "nargs",
  "callback_args", "callback_kwargs"]

  "callback"으로 지정된 함수를 호출합니다, 이 함수는 다음과 같이 호출
  됩니다

     func(option, opt_str, value, parser, *args, **kwargs)

  자세한 내용은 섹션 옵션 콜백을 참조하십시오.

* ""help""

  현재 옵션 구문 분석기의 모든 옵션에 대한 전체 도움말 메시지를 인쇄합
  니다. 도움말 메시지는 OptionParser의 생성자에 전달된 "usage" 문자열
  과 모든 옵션에 전달된 "help" 문자열로 구성됩니다.

  옵션에 "help" 문자열이 제공되지 않아도, 도움말 메시지에 나열됩니다.
  옵션을 완전히 생략하려면, 특수 값 "optparse.SUPPRESS_HELP"를 사용하
  십시오.

  "optparse"는 모든 OptionParser에 "help" 옵션을 자동으로 추가하므로,
  일반적으로 만들 필요가 없습니다.

  예:

     from optparse import OptionParser, SUPPRESS_HELP

     # 일반적으로, 도움말 옵션은 자동으로 추가되지만, add_help_option 인자를
     # 사용하여 억제할 수 있습니다
     parser = OptionParser(add_help_option=False)

     parser.add_option("-h", "--help", action="help")
     parser.add_option("-v", action="store_true", dest="verbose",
                       help="Be moderately verbose")
     parser.add_option("--file", dest="filename",
                       help="Input file to read data from")
     parser.add_option("--secret", help=SUPPRESS_HELP)

  "optparse"가 명령 줄에서 "-h"나 "--help"를 보면, 다음 도움말 메시지
  와 같은 내용을 stdout에 인쇄합니다 ("sys.argv[0]"이 ""foo.py""라고
  가정합니다):

     Usage: foo.py [options]

     Options:
       -h, --help        Show this help message and exit
       -v                Be moderately verbose
       --file=FILENAME   Input file to read data from

  도움말 메시지를 인쇄한 후, "optparse"는 "sys.exit(0)"으로 프로세스를
  종료합니다.

* ""version""

  OptionParser에 제공된 버전 번호를 stdout에 인쇄하고 종료합니다. 버전
  번호는 실제로 OptionParser의 "print_version()" 메서드에 의해 포맷되
  고 인쇄됩니다. 일반적으로 "version" 인자가 OptionParser 생성자에 제
  공되는 경우에만 의미가 있습니다. "help" 옵션과 마찬가지로,
  "optparse"는 필요할 때 자동으로 추가하기 때문에, "version" 옵션을 거
  의 만들지 않습니다.


표준 옵션 형
------------

"optparse"에는 다섯 가지 내장 옵션 형이 있습니다: ""string"", ""int"",
""choice"", ""float"" 및 ""complex"". 새로운 옵션 형을 추가해야 하면,
섹션 optparse 확장하기를 참조하십시오.

문자열 옵션에 대한 인자는 어떤 방식으로도 검사되거나 변환되지 않습니다
: 명령 줄의 텍스트는 있는 그대로 대상에 저장(또는 콜백에 전달)됩니다.

정수 인자(""int"" 형)는 다음과 같이 구문 분석됩니다:

* 숫자가 "0x"로 시작하면, 16진수로 구문 분석됩니다

* 숫자가 "0"으로 시작하면, 8진수로 구문 분석됩니다

* 숫자가 "0b"로 시작하면, 이진수로 구문 분석됩니다

* 그렇지 않으면, 숫자는 10진수로 구문 분석됩니다

변환은 적절한 진수(2, 8, 10 또는 16)로 "int()"를 호출하여 수행됩니다.
이것이 실패하면, 더 유용한 에러 메시지를 제공하기는 하지만, "optparse"
도 마찬가지로 실패합니다.

""float""와 ""complex"" 옵션 인자는 유사한 에러 처리로 "float()"와
"complex()"로 직접 변환됩니다.

""choice"" 옵션은 ""string"" 옵션의 서브 형입니다. "choices" 옵션 어트
리뷰트(문자열 시퀀스)는 허용되는 옵션 인자 집합을 정의합니다.
"optparse.check_choice()"는 사용자가 제공한 옵션 인자를 이 마스터 리스
트와 비교하고 유효하지 않은 문자열이 주어지면 "OptionValueError" 를 발
생시킵니다.


인자 구문 분석하기
------------------

OptionParser를 만들고 채우는 것의 요점은 "parse_args()" 메서드를 호출
하는 것입니다.

OptionParser.parse_args(args=None, values=None)

   Parse the command-line options found in *args*.

   입력 매개 변수는

   "args"
      처리할 인자의 리스트 (기본값: "sys.argv[1:]")

   "values"
      옵션 인자를 저장할 "Values" 객체 (기본값: "Values"의 새 인스턴스
      ) -- 기존 객체를 제공하면, 옵션 기본값이 초기화되지 않습니다.

   그리고 반환 값은 쌍 "(options, args)"이고

   "options"
      *values*로 전달된 것과 같은 객체, 또는 "optparse"가 만든
      "optparse.Values" 인스턴스

   "args"
      모든 옵션이 처리된 후 남은 위치 인자

가장 일반적인 사용법은 두 키워드 인자 중 어느 것도 제공하지 않는 것입
니다. "values"를 제공하면, 반복된 "setattr()" 호출(옵션 대상에 저장된
모든 옵션 인자에 대해 대략 하나씩)로 수정되고, "parse_args()"에서 반환
됩니다.

"parse_args()"가 인자 리스트에서 에러를 만나면, 적절한 최종 사용자 에
러 메시지와 함께 OptionParser의 "error()" 메서드를 호출합니다. 이는 궁
극적으로 종료 상태 2(명령 줄 에러에 대한 전통적인 유닉스 종료 상태)로
프로세스를 종료합니다.


옵션 구문 분석기를 조회하고 조작하기
------------------------------------

옵션 구문 분석기의 기본 동작은 약간 사용자 정의 할 수 있으며, 옵션 구
문 분석기를 들여다보고 거기에 무엇이 있는지 볼 수도 있습니다.
OptionParser는 다음과 같은 몇 가지 메서드를 제공합니다:

OptionParser.disable_interspersed_args()

   첫 번째 옵션이 아닌 것에서 중지하도록 구문 분석을 설정합니다. 예를
   들어 "-a"와 "-b"가 모두 인자를 취하지 않는 간단한 옵션이면,
   "optparse"는 일반적으로 다음 문법을 허용합니다:

      prog -a arg1 -b arg2

   그리고 다음과 동등하게 취급합니다

      prog -a -b arg1 arg2

   이 기능을 비활성화하려면, "disable_interspersed_args()"를 호출하십
   시오. 이렇게 하면 옵션 구문 분석이 첫 번째 옵션이 아닌 인자에서 중
   지되는, 전통적인 유닉스 문법이 복원됩니다.

   자체 옵션이 있는 다른 명령을 실행하는 명령 프로세서가 있고 이러한
   옵션이 혼동되지 않도록 하려면 이것을 사용하십시오. 예를 들어, 각 명
   령에는 다른 옵션 집합이 있을 수 있습니다.

OptionParser.enable_interspersed_args()

   첫 번째 옵션이 아닌 것에서 구문 분석이 중지되지 않도록 설정하여, 명
   령 인자와 스위치를 분산시킬 수 있도록 합니다. 이것이 기본 동작입니
   다.

OptionParser.get_option(opt_str)

   옵션 문자열 *opt_str*을 갖는 Option 인스턴스를 반환합니다, 또는 해
   당 옵션 문자열을 갖는 옵션이 없으면 "None"을 반환합니다.

OptionParser.has_option(opt_str)

   OptionParser에 옵션 문자열 *opt_str*을 갖는 옵션이 있으면 "True"를
   반환합니다 (예를 들어, "-q"나 "--verbose").

OptionParser.remove_option(opt_str)

   "OptionParser"에 *opt_str*에 해당하는 옵션이 있으면, 해당 옵션이 제
   거됩니다. 해당 옵션이 다른 옵션 문자열을 제공하면, 해당 옵션 문자열
   은 모두 유효하지 않게 됩니다. 이 "OptionParser"에 속하는 옵션에서
   *opt_str*이 등장하지 않으면, "ValueError"를 발생시킵니다.


옵션 간의 충돌
--------------

주의하지 않으면, 충돌하는 옵션 문자열을 갖는 옵션을 정의하기 쉽습니다:

   parser.add_option("-n", "--dry-run", ...)
   ...
   parser.add_option("-n", "--noisy", ...)

(일부 표준 옵션을 사용하여 자체 OptionParser 서브 클래스를 정의한 경우
특히 그렇습니다.)

옵션을 추가할 때마다, "optparse"는 기존 옵션과의 충돌을 확인합니다. 발
견되면, 현재 충돌 처리 메커니즘을 호출합니다. 충돌 처리 메커니즘을 설
정할 수 있는데, 생성자에서:

   parser = OptionParser(..., conflict_handler=handler)

또는 별도의 호출로 가능합니다:

   parser.set_conflict_handler(handler)

사용 가능한 충돌 처리기는 다음과 같습니다:

   ""error"" (기본값)
      옵션 충돌이 프로그래밍 에러라고 가정하고 "OptionConflictError"
      를 발생시킵니다

   ""resolve""
      옵션 충돌을 지능적으로 해결합니다 (아래를 참조하십시오)

예를 들어, 충돌을 지능적으로 해결하고 "OptionParser"를 정의하고 충돌하
는 옵션을 추가해 보겠습니다:

   parser = OptionParser(conflict_handler="resolve")
   parser.add_option("-n", "--dry-run", ..., help="do no harm")
   parser.add_option("-n", "--noisy", ..., help="be noisy")

이 시점에서, "optparse"는 이전에 추가된 옵션이 이미 "-n" 옵션 문자열을
사용하고 있음을 감지합니다. "conflict_handler"가 ""resolve""이므로, 이
전 옵션의 옵션 문자열 리스트에서 "-n"을 제거하여 상황을 해결합니다. 이
제 "--dry-run"은 사용자가 해당 옵션을 활성화하는 유일한 방법입니다. 사
용자가 help를 요청하면, 도움말 메시지에 이것이 반영됩니다:

   Options:
     --dry-run     do no harm
     ...
     -n, --noisy   be noisy

남아있는 옵션이 없을 때까지 이전에 추가된 옵션에 대한 옵션 문자열을 제
거 할 수 있고, 사용자는 명령 줄에서 해당 옵션을 호출할 방법이 없을 가
능성이 있습니다. 이 경우, "optparse"는 해당 옵션을 완전히 제거해서, 도
움말 텍스트나 다른 곳에 표시되지 않습니다. 기존 OptionParser를 계속 사
용해서:

   parser.add_option("--dry-run", ..., help="new dry-run option")

이 시점에서, 원래 "-n"/"--dry-run" 옵션에 더는 액세스할 수 없어서,
"optparse"는 해당 옵션을 제거하고, 다음 도움말 텍스트를 남깁니다:

   Options:
     ...
     -n, --noisy   be noisy
     --dry-run     new dry-run option


정리
----

OptionParser 인스턴스에는 여러 순환 참조가 있습니다. 이것은 파이썬의
가비지 수거기에선 문제가 되지 않지만, 작업이 끝나면 OptionParser에서
"destroy()"를 호출하여 순환 참조를 명시적으로 끊을 수 있습니다. 이것은
OptionParser에서 큰 객체 그래프에 도달할 수 있는 장기 실행 응용 프로그
램에서 특히 유용합니다.


기타 메서드
-----------

OptionParser는 몇 가지 다른 공용 메서드를 지원합니다:

OptionParser.set_usage(usage)

   "usage" 생성자 키워드 인자에 대해 위에서 설명한 규칙에 따라 사용법
   문자열을 설정합니다. "None"을 전달하면 기본 사용법 문자열이 설정됩
   니다; 사용법 메시지를 억제하려면 "optparse.SUPPRESS_USAGE"를 사용하
   십시오.

OptionParser.print_usage(file=None)

   현재 프로그램의 사용법 메시지("self.usage")를 *file*(기본값 stdout)
   로 인쇄합니다. "self.usage"에 등장하는 문자열 "%prog"는 현재 프로그
   램의 이름으로 대체됩니다. "self.usage"가 비어 있거나 정의되지 않았
   으면 아무 작업도 수행하지 않습니다.

OptionParser.get_usage()

   "print_usage()"와 같지만 인쇄하는 대신 사용법 문자열을 반환합니다.

OptionParser.set_defaults(dest=value, ...)

   한 번에 여러 옵션 대상에 대한 기본값을 설정합니다. 여러 옵션이 같은
   대상을 공유 할 수 있기 때문에, "set_defaults()"를 사용하여 옵션의
   기본값을 설정하는 것이 좋습니다. 예를 들어, 여러 "mode" 옵션이 모두
   같은 대상을 설정하면, 그중 하나가 기본값을 설정할 수 있으며 마지막
   옵션이 이깁니다:

      parser.add_option("--advanced", action="store_const",
                        dest="mode", const="advanced",
                        default="novice")    # 아래에서 재정의됩니다
      parser.add_option("--novice", action="store_const",
                        dest="mode", const="novice",
                        default="advanced")  # 위의 설정을 재정의합니다

   이러한 혼동을 피하려면, "set_defaults()"를 사용하십시오:

      parser.set_defaults(mode="advanced")
      parser.add_option("--advanced", action="store_const",
                        dest="mode", const="advanced")
      parser.add_option("--novice", action="store_const",
                        dest="mode", const="novice")


옵션 콜백
=========

"optparse"의 내장 액션과 형이 여러분의 필요에 충분하지 않으면, 두 가지
선택이 있습니다: "optparse"를 확장하거나 콜백 옵션을 정의합니다.
"optparse"를 확장하는 것이 더 일반적이지만, 많은 간단한 경우에는 과합
니다. 종종 간단한 콜백만 있으면 됩니다.

콜백 옵션을 정의하는 두 단계가 있습니다:

* ""callback"" 액션을 사용하여 옵션 자체를 정의합니다

* 콜백을 작성합니다; 이것은 아래에 설명된 대로, 최소한 4개의 인자를 취
  하는 함수(또는 메서드)입니다


콜백 옵션 정의하기
------------------

항상 그렇듯이, 콜백 옵션을 정의하는 가장 쉬운 방법은
"OptionParser.add_option()" 메서드를 사용하는 것입니다. "action"과 별
도로 지정해야 하는 유일한 옵션 어트리뷰트는 호출할 함수인 "callback"입
니다:

   parser.add_option("-c", action="callback", callback=my_callback)

"callback"은 함수(또는 다른 콜러블 객체)이므로, 이 콜백 옵션을 만들 때
"my_callback()"을 이미 정의했어야 합니다. 이 간단한 경우, "optparse"는
"-c"가 인자를 취하는지조차 알지 못합니다. 이는 일반적으로 옵션이 인자
를 받지 않음을 의미합니다---명령 줄에 "-c"가 있다는 것만 알 필요가 있
습니다. 그러나 일부 상황에서는, 콜백이 임의의 수의 명령 줄 인자를 소비
하도록 할 수 있습니다. 콜백 작성이 까다로워지는 곳입니다: 이 섹션의 뒷
부분에서 다룹니다.

"optparse"는 항상 4개의 특정 인자를 콜백에 전달하며, "callback_args"와
"callback_kwargs"를 통해 지정하는 경우에만 추가 인자를 전달합니다. 따
라서 최소 콜백 함수 서명은 다음과 같습니다:

   def my_callback(option, opt, value, parser):

콜백에 대한 네 가지 인자가 아래에 설명되어 있습니다.

콜백 옵션을 정의할 때 제공할 수 있는 몇 가지 다른 옵션 어트리뷰트가 있
습니다:

"type"
   일반적인 의미를 갖습니다: ""store""나 ""append"" 액션과 마찬가지로,
   "optparse"에게 하나의 인자를 소비하고 이를 "type"으로 변환하도록 지
   시합니다. 그러나 "optparse"는 변환된 값을 어딘가에 저장하는 대신 콜
   백 함수에 전달합니다.

"nargs"
   역시 일반적인 의미를 갖습니다: 제공되고 > 1 이면, "optparse"는
   "nargs" 인자를 소비하며 각 인자는 "type"으로 변환 가능해야 합니다.
   그런 다음 변환된 값의 튜플을 콜백에 전달합니다.

"callback_args"
   콜백에 전달할 추가 위치 인자의 튜플

"callback_kwargs"
   콜백에 전달할 추가 키워드 인자의 딕셔너리


콜백이 호출되는 방법
--------------------

모든 콜백은 다음과 같이 호출됩니다:

   func(option, opt_str, value, parser, *args, **kwargs)

여기서

"option"
   콜백을 호출하는 Option 인스턴스입니다

"opt_str"
   콜백을 트리거 하는 명령 줄에 나타나는 옵션 문자열입니다. (축약된 긴
   옵션이 사용되면, "opt_str"은 완전한, 규범적인 옵션 문자열이 됩니다
   ---예를 들어 사용자가 "--foobar"의 약어로 명령 줄에 "--foo"를 입력
   하면, "opt_str"은 ""--foobar""가 됩니다.)

"value"
   명령 줄에 나타난 이 옵션에 대한 인자입니다. "optparse"는 "type"이
   설정되었을 때만 인자를 기대합니다; "value"의 형은 옵션의 형이 암시
   하는 형입니다. 이 옵션의 "type"이 "None"(기대하는 인자 없음)이면,
   "value"는 "None"이 됩니다. "nargs" > 1 이면, "value"는 적절한 형의
   값의 튜플이 됩니다.

"parser"
   모든 것을 구동하는 OptionParser 인스턴스입니다, 인스턴스 어트리뷰트
   를 통해 다른 흥미로운 데이터에 액세스 할 수 있어서 주로 유용합니다:

   "parser.largs"
      남은 인자의 현재 리스트, 즉, 소비되었지만 옵션이나 옵션 인자가
      아닌 인자. 예를 들어 더 많은 인자를 추가하여, "parser.largs"를
      자유롭게 수정하십시오. (이 리스트는 "parse_args()"의 두 번째 반
      환 값인 "args"가 됩니다.)

   "parser.rargs"
      나머지 인자의 현재 리스트, 즉, "opt_str"과 "value"(해당한다면)가
      제거되고, 그 뒤에 오는 인자만 그대로 남아 있습니다. 예를 들어 더
      많은 인자를 소비하여, "parser.rargs"를 자유롭게 수정하십시오.

   "parser.values"
      옵션값이 기본적으로 저장되는 객체 (optparse.OptionValues의 인스
      턴스). 이를 통해 콜백은 옵션값을 저장하기 위해 나머지 "optparse"
      와 같은 메커니즘을 사용할 수 있습니다; 전역이나 클로저를 엉망으
      로 만들 필요가 없습니다. 명령 줄에서 이미 발견된 모든 옵션의 값
      에 액세스하거나 수정할 수도 있습니다.

"args"
   "callback_args" 옵션 어트리뷰트를 통해 제공되는 임의의 위치 인자의
   튜플입니다.

"kwargs"
   "callback_kwargs"를 통해 제공된 임의의 키워드 인자의 딕셔너리입니다
   .


콜백에서 에러 발생시키기
------------------------

옵션이나 인자에 문제가 있으면 콜백 함수는 "OptionValueError" 를 발생시
켜야 합니다. "optparse"는 이것을 포착하고 프로그램을 종료하고, stderr
에 여러분이 제공하는 에러 메시지를 인쇄합니다. 메시지는 명확하고 간결
하며 정확해야 하며 잘못된 옵션을 언급해야 합니다. 그렇지 않으면, 사용
자는 자신이 무엇을 잘못했는지 파악하는 데 어려움을 겪을 것입니다.


콜백 예제 1: 간단한 콜백
------------------------

다음은 인자를 취하지 않고, 단순히 옵션이 발견되었음을 기록하는 콜백 옵
션의 예입니다:

   def record_foo_seen(option, opt_str, value, parser):
       parser.values.saw_foo = True

   parser.add_option("--foo", action="callback", callback=record_foo_seen)

물론 ""store_true"" 액션으로 그렇게 할 수 있습니다.


콜백 예제 2: 옵션 순서 확인
---------------------------

여기에 약간 더 흥미로운 예가 있습니다: "-a"가 발견되었다는 사실을 기록
하지만, 명령 줄에서 "-b" 뒤에 오면 폭발합니다.

   def check_order(option, opt_str, value, parser):
       if parser.values.b:
           raise OptionValueError("can't use -a after -b")
       parser.values.a = 1
   ...
   parser.add_option("-a", action="callback", callback=check_order)
   parser.add_option("-b", action="store_true", dest="b")


콜백 예제 3: 옵션 순서 확인 (일반화)
------------------------------------

이 콜백을 몇 가지 유사한 옵션에 다시 사용하려면 (플래그를 설정하지만,
"-b"가 이미 보였으면 폭발함), 약간의 작업이 필요합니다: 에러 메시지와
설정하는 플래그를 일반화해야 합니다.

   def check_order(option, opt_str, value, parser):
       if parser.values.b:
           raise OptionValueError("can't use %s after -b" % opt_str)
       setattr(parser.values, option.dest, 1)
   ...
   parser.add_option("-a", action="callback", callback=check_order, dest='a')
   parser.add_option("-b", action="store_true", dest="b")
   parser.add_option("-c", action="callback", callback=check_order, dest='c')


콜백 예제 4: 임의 조건 확인
---------------------------

물론, 여기에 어떤 조건도 넣을 수 있습니다---이미 정의된 옵션의 값을 확
인하는 데 국한되지 않습니다. 예를 들어, 만월일 때 호출해서는 안 되는
옵션이 있으면, 다음과 같이 하면 됩니다:

   def check_moon(option, opt_str, value, parser):
       if is_moon_full():
           raise OptionValueError("%s option invalid when moon is full"
                                  % opt_str)
       setattr(parser.values, option.dest, 1)
   ...
   parser.add_option("--foo",
                     action="callback", callback=check_moon, dest="foo")

("is_moon_full()"의 정의는 독자를 위한 연습 문제로 남겨 둡니다.)


콜백 예제 5: 고정 인자
----------------------

고정된 수의 인자를 사용하는 콜백 옵션을 정의하면 상황이 약간 더 흥미로
워집니다. 콜백 옵션이 인자를 받도록 지정하는 것은 ""store""나
""append"" 옵션을 정의하는 것과 유사합니다: "type"을 정의하면, 옵션은
해당 형으로 변환 할 수 있어야 하는 하나의 인자를 취합니다; "nargs"를
추가로 정의하면, 옵션은 "nargs" 인자를 취합니다.

다음은 표준 ""store"" 액션을 흉내 내는 예입니다:

   def store_value(option, opt_str, value, parser):
       setattr(parser.values, option.dest, value)
   ...
   parser.add_option("--foo",
                     action="callback", callback=store_value,
                     type="int", nargs=3, dest="foo")

"optparse"가 3개의 인자를 소비하고 이를 정수로 변환하는 작업을 처리함
에 유의하십시오; 여러분이 해야 할 일은 그것들을 저장하는 것뿐입니다. (
또는 무엇이든; 분명히 이 예제에서는 콜백이 필요하지 않습니다.)


콜백 예제 6: 가변 인자
----------------------

가변적인 수의 인자를 취하는 옵션을 원할 때 상황이 복잡해집니다. 이 경
우, "optparse"는 이것을 위한 내장 기능을 제공하지 않아서 콜백을 작성해
야 합니다. 그리고 "optparse"가 일반적으로 처리하는 전통적인 유닉스 명
령 줄 구문 분석의 복잡한 문제를 여러분이 처리해야 합니다. 특히, 콜백은
날(bare) "--"와 "-" 인자에 대한 전통적인 규칙을 구현해야 합니다:

* "--"나 "-"는 옵션 인자가 될 수 있습니다

* 날 "--" (어떤 옵션에 대한 인자가 아닌 경우): 명령 줄 처리를 중단하고
  "--"를 버립니다

* 날 "-" (어떤 옵션에 대한 인자가 아닌 경우): 명령 줄 처리를 중지하지
  만 "-"는 유지합니다 ("parser.largs"에 추가합니다)

가변적인 수의 인자를 취하는 옵션을 원한다면, 몇 가지 미묘하고 까다로운
문제가 있습니다. 여러분이 선택하는 정확한 구현은 여러분이 여러분의 응
용 프로그램을 위해 취하고자 하는 절충을 기반으로 할 것입니다 (이것이
"optparse"가 이런 종류의 것을 직접 지원하지 않는 이유입니다).

그런데도, 가변 인자가 있는 옵션에 대한 콜백에는 가시가 있습니다:

   def vararg_callback(option, opt_str, value, parser):
       assert value is None
       value = []

       def floatable(str):
           try:
               float(str)
               return True
           except ValueError:
               return False

       for arg in parser.rargs:
           # --foo 와 같은 옵션에서 멈춥니다
           if arg[:2] == "--" and len(arg) > 2:
               break
           # -a 에서 멈추지만, -3 이나 -3.0 에서는 멈추지 않습니다
           if arg[:1] == "-" and len(arg) > 1 and not floatable(arg):
               break
           value.append(arg)

       del parser.rargs[:len(value)]
       setattr(parser.values, option.dest, value)

   ...
   parser.add_option("-c", "--callback", dest="vararg_attr",
                     action="callback", callback=vararg_callback)


"optparse" 확장하기
===================

"optparse"가 명령 줄 옵션을 해석하는 방법의 두 가지 주요 제어 요소는
각 옵션의 액션과 형이므로, 확장 방향은 새 액션과 새 형을 추가하는 것입
니다.


새로운 형 추가하기
------------------

새로운 형을 추가하려면, "optparse"의 "Option" 클래스의 여러분 자신의
서브 클래스를 정의해야 합니다. 이 클래스에는 "optparse"의 형을 정의하
는 몇 가지 어트리뷰트가 있습니다: "TYPES"와 "TYPE_CHECKER".

Option.TYPES

   형 이름의 튜플; 여러분의 서브 클래스에서, 표준 튜플을 기반으로 하는
   새 튜플 "TYPES"를 정의하십시오.

Option.TYPE_CHECKER

   형 이름을 형 검사 함수에 매핑하는 딕셔너리. 형 검사 함수는 다음과
   같은 서명을 갖습니다:

      def check_mytype(option, opt, value)

   여기서 "option"은 "Option" 인스턴스이고, "opt"는 옵션 문자열(예를
   들어, "-f")이며, "value"는 검사되고 원하는 형으로 변환되어야 하는
   명령 줄의 문자열입니다. "check_mytype()"은 가상의 형 "mytype"의 객
   체를 반환해야 합니다. 형 검사 함수가 반환한 값은
   "OptionParser.parse_args()"에서 반환한 OptionValues 인스턴스에 포함
   되거나 "value" 매개 변수로 콜백에 전달됩니다.

   형 검사 함수는 문제가 발생하면 "OptionValueError" 를 발생시켜야 합
   니다. "OptionValueError" 는 "OptionParser"의 "error()" 메서드에 있
   는 그대로 전달되는 단일 문자열 인자를 취하며, 이는 차례로 프로그램
   이름과 문자열 ""error:""를 앞에 붙이고 프로세스를 종료하기 전에 모
   든 것을 stderr에 인쇄합니다.

다음은 명령 줄에서 파이썬 스타일 복소수를 구문 분석하기 위해
""complex"" 옵션 형을 추가하는 것을 보여주는 우스꽝스러운 예입니다.
("optparse" 1.3은 복소수에 대한 기본 지원을 추가했기 때문에 전보다 훨
씬 우스꽝스럽지만, 신경 쓰지 마십시오.)

첫째, 필요한 임포트:

   from copy import copy
   from optparse import Option, OptionValueError

나중에 (Option 서브 클래스의 "TYPE_CHECKER" 클래스 어트리뷰트에서) 참
조되므로, 형 검사기를 먼저 정의해야 합니다:

   def check_complex(option, opt, value):
       try:
           return complex(value)
       except ValueError:
           raise OptionValueError(
               "option %s: invalid complex value: %r" % (opt, value))

마지막으로, Option 서브 클래스:

   class MyOption (Option):
       TYPES = Option.TYPES + ("complex",)
       TYPE_CHECKER = copy(Option.TYPE_CHECKER)
       TYPE_CHECKER["complex"] = check_complex

("Option.TYPE_CHECKER"의 "copy()"를 만들지 않았다면, "optparse"의
Option 클래스의 "TYPE_CHECKER" 어트리뷰트를 수정하게 될 것입니다. 이것
은 파이썬이기 때문에, 좋은 태도와 상식을 제외하고는 아무것도 이렇게 하
는 것을 막을 수 없습니다.)

이것이 전부입니다! 이제 OptionParser가 Option 대신 MyOption을 사용하도
록 지시해야 한다는 점을 제외하고는, 다른 "optparse" 기반 스크립트와 마
찬가지로 새 옵션 형을 사용하는 스크립트를 작성할 수 있습니다:

   parser = OptionParser(option_class=MyOption)
   parser.add_option("-c", type="complex")

또는, 여러분 자신만의 옵션 목록을 만들어 OptionParser에 전달할 수 있습
니다; 위의 방법으로 "add_option()"을 사용하지 않으면, OptionParser에
사용할 옵션 클래스를 알려줄 필요가 없습니다:

   option_list = [MyOption("-c", action="store", type="complex", dest="c")]
   parser = OptionParser(option_list=option_list)


새로운 액션 추가하기
--------------------

"optparse"에는 액션에 대한 몇 가지 분류가 있음을 이해해야 해서, 새 액
션을 추가하는 것은 약간 까다롭습니다:

"저장" 액션
   "optparse"가 현재 OptionValues 인스턴스의 어트리뷰트에 값을 저장하
   는 결과를 주는 액션; 이러한 옵션을 사용하려면 Option 생성자에
   "dest" 어트리뷰트를 제공해야 합니다.

"형이 있는" 액션
   명령 줄에서 값을 취하고 이것이 특정 형일 것으로 기대하는 액션; 또는
   , 특정 형으로 변환할 수 있는 문자열. 이러한 옵션을 사용하려면
   Option 생성자에 "type" 어트리뷰트를 제공해야 합니다.

이들은 겹치는 집합입니다: 일부 기본 "저장" 액션은 ""store"",
""store_const"", ""append"" 및 ""count""이고, 기본 "형이 있는" 액션은
""store"", ""append"" 및 ""callback""입니다.

액션을 추가할 때, Option의 다음 클래스 어트리뷰트 중 하나 이상에 나열
하여 분류해야 합니다 (모두 문자열 리스트입니다):

Option.ACTIONS

   모든 액션은 ACTIONS에 나열되어야 합니다.

Option.STORE_ACTIONS

   "저장" 액션이 여기에 추가로 나열됩니다.

Option.TYPED_ACTIONS

   "형이 있는" 액션이 여기에 추가로 나열됩니다.

Option.ALWAYS_TYPED_ACTIONS

   항상 형을 취하는 액션(즉, 옵션이 항상 값을 취하는 액션)이 여기에 추
   가로 나열됩니다. 이것의 유일한 효과는 "optparse"가
   "ALWAYS_TYPED_ACTIONS"에 액션이 나열되는 명시적인 형이 없는 옵션에
   기본형인 ""string""을 대입한다는 것입니다.

새 액션을 실제로 구현하려면, Option의 "take_action()" 메서드를 재정의
하고 액션을 인식하는 케이스를 추가해야 합니다.

예를 들어, ""extend"" 액션을 추가해 보겠습니다. 이것은 표준 ""append""
액션과 유사하지만, 명령 줄에서 단일 값을 취해서 기존 리스트에 추가하는
대신, ""extend""는 단일 쉼표로 구분된 문자열에서 여러 값을 취해서 기존
리스트를 확장합니다. 즉, "--names"가 ""string"" 형의 ""extend"" 옵션이
면, 다음과 같은 명령 줄은

   --names=foo,bar --names blah --names ding,dong

다음과 같은 리스트를 만듭니다

   ["foo", "bar", "blah", "ding", "dong"]

다시 Option의 서브 클래스를 정의합니다:

   class MyOption(Option):

       ACTIONS = Option.ACTIONS + ("extend",)
       STORE_ACTIONS = Option.STORE_ACTIONS + ("extend",)
       TYPED_ACTIONS = Option.TYPED_ACTIONS + ("extend",)
       ALWAYS_TYPED_ACTIONS = Option.ALWAYS_TYPED_ACTIONS + ("extend",)

       def take_action(self, action, dest, opt, value, values, parser):
           if action == "extend":
               lvalue = value.split(",")
               values.ensure_value(dest, []).extend(lvalue)
           else:
               Option.take_action(
                   self, action, dest, opt, value, values, parser)

참고할만한 특징:

* ""extend""는 명령 줄에서 값을 기대하기도 하고 그 값을 어딘가에 저장
  하기도 하므로, "STORE_ACTIONS"와 "TYPED_ACTIONS" 모두에 들어갑니다.

* "optparse"가 기본형 ""string""을 ""extend"" 액션에 대입하도록 하기
  위해, "ALWAYS_TYPED_ACTIONS"에도 ""extend"" 액션을 넣습니다.

* "MyOption.take_action()"은 이 하나의 새로운 액션만 구현하고, 표준
  "optparse" 액션을 위해 제어를 "Option.take_action()"으로 되돌립니다.

* "values"는 매우 유용한 "ensure_value()" 메서드를 제공하는
  optparse_parser.Values 클래스의 인스턴스입니다. "ensure_value()"는
  본질적으로 안전밸브가 있는 "getattr()"입니다; 다음과 같이 호출됩니다

     values.ensure_value(attr, value)

  "values"의 "attr" 어트리뷰트가 존재하지 않거나 "None"이면,
  ensure_value()는 먼저 이를 "value"로 설정한 다음, "value"를 반환합니
  다. 이것은 ""extend"", ""append"" 및 ""count""와 같은 액션에 매우 편
  리합니다. 이 액션들은 모두 변수에 데이터를 누적하고 해당 변수가 특정
  형(처음 두 개는 리스트, 마지막은 정수)이 될 것으로 기대합니다.
  "ensure_value()"를 사용한다는 것은 액션을 사용하는 스크립트가 문제의
  옵션 대상에 대한 기본값 설정에 대해 걱정할 필요가 없음을 의미합니다;
  기본값을 "None"으로 그대로 둘 수 있으며 "ensure_value()"는 필요할 때
  올바르게 처리합니다.


예외
====

exception optparse.OptionError

   Raised if an "Option" instance is created with invalid or
   inconsistent arguments.

exception optparse.OptionConflictError

   Raised if conflicting options are added to an "OptionParser".

exception optparse.OptionValueError

   Raised if an invalid option value is encountered on the command
   line.

exception optparse.BadOptionError

   명령줄에서 잘못된 옵션이 전달되면 발생합니다.

exception optparse.AmbiguousOptionError

   Raised if an ambiguous option is passed on the command line.
