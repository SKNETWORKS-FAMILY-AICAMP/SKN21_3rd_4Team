"xml.dom" --- 문서 객체 모델 API
********************************

**소스 코드:** Lib/xml/dom/__init__.py

======================================================================

문서 객체 모델(Document Object Model), 또는 "DOM"은 XML 문서를 액세스
하고 수정하기 위한 W3C(World Wide Web Consortium)의 교차 언어 API입니
다. DOM 구현은 XML 문서를 트리 구조로 나타내거나, 클라이언트 코드가 이
러한 구조를 처음부터 구축 할 수 있도록 합니다. 그런 다음 잘 알려진 인
터페이스를 제공하는 객체 집합을 통해 구조에 액세스 할 수 있습니다.

DOM은 무작위 액세스 응용 프로그램에 매우 유용합니다. SAX에서는 한 번에
한 조각의 문서만 볼 수 있습니다. 하나의 SAX 요소를 보고 있는 동안, 다
른 SAX 요소에 액세스할 수 없습니다. 텍스트 노드를 보고 있으면, 이것을
포함하는 요소에 액세스할 수 없습니다. SAX 응용 프로그램을 작성할 때는,
문서에서의 프로그램의 위치를 자신의 코드 어딘가에서 추적해야 합니다.
SAX는 여러분을 위해 대신해주지 않습니다. 또한, XML 문서를 미리 보아야
한다면, 운이 다했다고 보아야 합니다.

트리에 액세스할 수 없는 이벤트 중심 모델에서는 일부 응용 프로그램이 불
가능합니다. 물론 SAX 이벤트에서 트리를 직접 만들 수는 있지만, DOM을 사
용하면 그런 코드를 작성하지 않아도 됩니다. DOM은 XML 데이터의 표준 트
리 표현입니다.

문서 객체 모델은 W3C에 의해 단계적으로 또는 그들의 용어로는 "수준"으로
정의됩니다. API의 파이썬 매핑은 실질적으로 DOM 수준 2 권장 사항을 기반
으로 합니다.

DOM 응용 프로그램은 일반적으로 일부 XML을 DOM으로 구문 분석하는 것으로
시작합니다. 이것을 달성하는 방법은 DOM 수준 1은 전혀 다루지 않으며, 수
준 2는 제한된 개선만을 제공합니다: "Document" 생성 메서드에 대한 액세
스를 제공하는 "DOMImplementation" 객체 클래스가 있습니다만, 구현에 독
립적인 방법으로 XML 판독기(reader)/기록기(writer)/Document 구축기
(builder)를 액세스하는 방법이 없습니다. 기존 "Document" 객체 없이 이러
한 메서드에 액세스할 수 있는 잘 정의된 방법도 없습니다. 파이썬에서, 각
DOM 구현은 "getDOMImplementation()" 함수를 제공합니다. DOM 수준 3은 판
독기(reader)에 대한 인터페이스를 정의하는 로드/저장 명세를 추가하지만,
아직 파이썬 표준 라이브러리에서는 사용할 수 없습니다.

일단 DOM 문서 객체가 있으면, 프로퍼티와 메서드를 통해 XML 문서의 일부
에 액세스 할 수 있습니다. 이러한 프로퍼티는 DOM 명세에 정의되어 있습니
다; 레퍼런스 설명서의 이 부분은 파이썬이 명세를 해석하는 방법을 설명합
니다.

W3C에서 제공하는 명세는 Java, ECMAScript 및 OMG IDL 용 DOM API를 정의
합니다. 여기에 정의된 파이썬 매핑은 대부분 명세의 IDL 버전을 기반으로
하지만, 엄격한 준수는 필요하지 않습니다 (구현은 IDL의 엄격한 매핑을 자
유롭게 지원할 수 있습니다). 매핑 요구 사항에 대한 자세한 내용은 규격
준수 절을 참조하십시오.

더 보기:

  Document Object Model (DOM) Level 2 Specification
     파이썬 DOM API의 기반이 되는 W3C 권장 사항.

  Document Object Model (DOM) Level 1 Specification
     "xml.dom.minidom"이 지원하는 DOM에 대한 W3C 권장 사항.

  Python Language Mapping Specification
     OMG IDL에서 파이썬으로의 매핑을 지정합니다.


모듈 내용
=========

"xml.dom"에는 다음 함수가 포함되어 있습니다:

xml.dom.registerDOMImplementation(name, factory)

   *factory* 함수를 *name*이라는 이름으로 등록합니다. 팩토리(factory)
   함수는 "DOMImplementation" 인터페이스를 구현하는 객체를 반환해야 합
   니다. 팩토리 함수는 호출 때마다 같은 객체를 반환하거나 특정 구현에
   적합하다면 새 객체를 반환할 수 있습니다 (예를 들어, 해당 구현이 일
   부 사용자 정의를 지원하는 경우).

xml.dom.getDOMImplementation(name=None, features=())

   적절한 DOM 구현을 반환합니다. *name*은 잘 알려진 DOM 구현의 모듈 이
   름이거나, "None"입니다. "None"이 아니면, 해당 모듈을 임포트하고 성
   공하면 "DOMImplementation" 객체를 반환합니다. 이름이 지정되지 않고,
   환경 변수 "PYTHON_DOM"이 설정되면, 이 변수를 구현을 찾는 데 사용합
   니다.

   이름을 지정하지 않으면, 사용 가능한 구현을 검사하여 필요한 기능 집
   합이 있는 구현을 찾습니다. 구현을 찾을 수 없으면, "ImportError"를
   발생시킵니다. 기능 목록은 사용 가능한 "DOMImplementation" 객체의
   "hasFeature()" 메서드로 전달되는 "(feature, version)" 쌍의 시퀀스여
   야 합니다.

몇 가지 편의 상수도 제공됩니다:

xml.dom.EMPTY_NAMESPACE

   이름 공간이 DOM의 노드와 연결되어 있지 않음을 나타내는 데 사용되는
   값. 이것은 일반적으로 노드의 "namespaceURI"에서 발견되거나, 이름 공
   간별 메서드에 대한 *namespaceURI* 매개 변수로 사용됩니다.

xml.dom.XML_NAMESPACE

   예약된 접두어 "xml"과 연관된 이름 공간 URI, Namespaces in XML에서
   정의됩니다 (4절).

xml.dom.XMLNS_NAMESPACE

   이름 공간 선언의 이름 공간 URI, Document Object Model (DOM) Level 2
   Core Specification에서 정의됩니다 (1.1.8 절).

xml.dom.XHTML_NAMESPACE

   XHTML 이름 공간의 URI, XHTML 1.0: The Extensible HyperText Markup
   Language에서 정의됩니다 (3.1.1 절).

또한, "xml.dom"에는 베이스 "Node" 클래스와 DOM 예외 클래스가 포함됩니
다. 이 모듈에서 제공하는 "Node" 클래스는 DOM 명세에 정의된 메서드나 어
트리뷰트를 구현하지 않습니다; 구상(concrete) DOM 구현이 이를 제공해야
합니다. 이 모듈의 일부로 제공되는 "Node" 클래스는 구상 "Node" 객체의
"nodeType" 어트리뷰트에 사용되는 상수를 제공합니다; 그것들은 DOM 명세
를 준수하기 위해 모듈 수준이 아니라 클래스 내에 위치합니다.


DOM의 객체
==========

DOM에 대한 결정적인 문서는 W3C의 DOM 명세입니다.

DOM 어트리뷰트는 간단한 문자열 대신 노드로 조작될 수도 있음에 유의하십
시오. 하지만 그렇게 해야만 하는 경우는 매우 드물어서, 이 사용법은 아직
문서화되지 않았습니다.

+----------------------------------+-------------------------------------+-----------------------------------+
| 인터페이스                       | 절                                  | 목적                              |
|==================================|=====================================|===================================|
| "DOMImplementation"              | DOMImplementation 객체              | 하부 구현에 대한 인터페이스.      |
+----------------------------------+-------------------------------------+-----------------------------------+
| "Node"                           | Node 객체                           | 문서에 있는 대부분 객체에 대한 베 |
|                                  |                                     | 이스 인터페이스.                  |
+----------------------------------+-------------------------------------+-----------------------------------+
| "NodeList"                       | NodeList 객체                       | 노드의 시퀀스를 위한 인터페이스.  |
+----------------------------------+-------------------------------------+-----------------------------------+
| "DocumentType"                   | DocumentType 객체                   | 문서를 처리하는 데 필요한 선언에  |
|                                  |                                     | 대한 정보.                        |
+----------------------------------+-------------------------------------+-----------------------------------+
| "Document"                       | Document 객체                       | 전체 문서를 나타내는 객체.        |
+----------------------------------+-------------------------------------+-----------------------------------+
| "Element"                        | Element 객체                        | 문서 계층의 엘리먼트 노드.        |
+----------------------------------+-------------------------------------+-----------------------------------+
| "Attr"                           | Attr 객체                           | 엘리먼트 노드의 어트리뷰트 값 노  |
|                                  |                                     | 드                                |
+----------------------------------+-------------------------------------+-----------------------------------+
| "Comment"                        | Comment 객체                        | 소스 문서에 있는 주석의 표현.     |
+----------------------------------+-------------------------------------+-----------------------------------+
| "Text"                           | Text와 CDATASection 객체            | 문서의 텍스트 내용을 포함하는 노  |
|                                  |                                     | 드.                               |
+----------------------------------+-------------------------------------+-----------------------------------+
| "ProcessingInstruction"          | ProcessingInstruction 객체          | 처리 명령어 표현.                 |
+----------------------------------+-------------------------------------+-----------------------------------+

추가 절에서 파이썬에서 DOM 작업을 위해 정의된 예외에 관해 설명합니다.


DOMImplementation 객체
----------------------

"DOMImplementation" 인터페이스는 응용 프로그램이 사용 중인 DOM에서 특
정 기능의 가용성을 판별할 방법을 제공합니다. DOM 수준 2는
"DOMImplementation"을 사용하여 새로운 "Document"와 "DocumentType" 객체
를 만드는 기능을 추가했습니다.

DOMImplementation.hasFeature(feature, version)

   문자열 *feature*와 *version* 쌍으로 식별되는 기능이 구현되었으면
   "True"를 반환합니다.

DOMImplementation.createDocument(namespaceUri, qualifiedName, doctype)

   지정된 *namespaceUri*와 *qualifiedName*을 가진 자식 "Element" 객체
   를 포함하는 새 "Document" 객체(DOM의 루트)를 반환합니다. *doctype*
   은 "createDocumentType()"으로 만든 "DocumentType" 객체거나 "None"이
   어야 합니다. 파이썬 DOM API에서, "Element" 자식이 만들어지지 않음을
   표시하기 위해 처음 두 인자는 "None"일 수 있습니다.

DOMImplementation.createDocumentType(qualifiedName, publicId, systemId)

   XML 문서 형 선언에 포함된 정보를 나타내는, 지정된 *qualifiedName*,
   *publicId* 및 *systemId* 문자열을 캡슐화하는 새 "DocumentType" 객체
   를 반환합니다.


Node 객체
---------

XML 문서의 모든 구성 요소는 "Node"의 서브 클래스입니다.

Node.nodeType

   노드 형을 나타내는 정수. 형의 기호 상수는 "Node" 객체에 있습니다:
   "ELEMENT_NODE", "ATTRIBUTE_NODE", "TEXT_NODE",
   "CDATA_SECTION_NODE", "ENTITY_NODE", "PROCESSING_INSTRUCTION_NODE",
   "COMMENT_NODE", "DOCUMENT_NODE", "DOCUMENT_TYPE_NODE",
   "NOTATION_NODE". 이것은 읽기 전용 어트리뷰트입니다.

Node.parentNode

   현재 노드의 부모, 또는 문서 노드의 경우 "None". 값은 항상 "Node" 객
   체나 "None"입니다. "Element" 노드의 경우, 이것은 부모 엘리먼트가 되
   는데, 루트 엘리먼트는 예외로, 이때는 "Document" 객체가 됩니다.
   "Attr" 노드의 경우, 항상 "None"입니다. 이것은 읽기 전용 어트리뷰트
   입니다.

Node.attributes

   어트리뷰트 객체의 "NamedNodeMap". 엘리먼트에만 실제 값이 있습니다;
   다른 것은 이 어트리뷰트에서 "None"을 제공합니다. 이것은 읽기 전용
   어트리뷰트입니다.

Node.previousSibling

   같은 부모를 갖고 이 노드 바로 앞에 있는 노드. 예를 들어 *self* 엘리
   먼트의 시작 태그 바로 앞에 오는 종료 태그의 엘리먼트. 물론, XML 문
   서는 단순히 엘리먼트만으로 구성되지 않기 때문에, 이전 형제(previous
   sibling)는 텍스트, 주석 또는 뭔가 다른 것이 될 수 있습니다. 이 노드
   가 부모의 첫 번째 자식이면, 이 어트리뷰트는 "None"입니다. 이것은 읽
   기 전용 어트리뷰트입니다.

Node.nextSibling

   같은 부모를 갖고 이 노드 바로 뒤에 나오는 노드. "previousSibling"도
   참조하십시오. 이것이 부모의 마지막 자식이면, 이 어트리뷰트는 "None"
   입니다. 이것은 읽기 전용 어트리뷰트입니다.

Node.childNodes

   이 노드에 포함된 노드의 리스트. 이것은 읽기 전용 어트리뷰트입니다.

Node.firstChild

   노드의 첫 번째 자식 (있다면), 또는 "None". 이것은 읽기 전용 어트리
   뷰트입니다.

Node.lastChild

   노드의 마지막 자식 (있다면), 또는 "None". 이것은 읽기 전용 어트리뷰
   트입니다.

Node.localName

   콜론이 있으면 그 뒤에 오는 "tagName"의 부분, 그렇지 않으면 전체
   "tagName". 값은 문자열입니다.

Node.prefix

   콜론이 있으면 그 앞에 오는 "tagName"의 부분, 그렇지 않으면 빈 문자
   열. 값은 문자열이나 "None"입니다.

Node.namespaceURI

   엘리먼트 이름과 연관된 이름 공간. 이것은 문자열이나 "None"입니다.
   이것은 읽기 전용 어트리뷰트입니다.

Node.nodeName

   이는 각 노드 형마다 다른 의미입니다; 자세한 내용은 DOM 명세를 참조
   하십시오. 여기서 얻는 정보를 항상 다른 프로퍼티에서 얻을 수 있습니
   다, 가령 엘리먼트의 "tagName" 프로퍼티나 어트리뷰트의 "name" 프로퍼
   티. 모든 노드 형에서, 이 어트리뷰트의 값은 문자열이나 "None"입니다.
   이것은 읽기 전용 어트리뷰트입니다.

Node.nodeValue

   이는 각 노드 형마다 다른 의미입니다; 자세한 내용은 DOM 명세를 참조
   하십시오. 상황은 "nodeName"과 유사합니다. 값은 문자열이나 "None"입
   니다.

Node.hasAttributes()

   노드에 어트리뷰트가 있으면 "True"를 반환합니다.

Node.hasChildNodes()

   노드에 자식 노드가 있으면 "True"를 반환합니다.

Node.isSameNode(other)

   *other*가 이 노드와 같은 노드를 가리키면 "True"를 반환합니다. 이것
   은 모든 종류의 프락시 구조를 사용하는 DOM 구현에서 특히 유용합니다
   (여러 객체가 같은 노드를 가리킬 수 있기 때문입니다).

   참고:

     이것은 여전히 "작업 초안" 단계에 있는 제안된 DOM 수준 3 API를 기
     반으로 하지만, 이 특정 인터페이스는 논란의 여지가 없는 것으로 보
     입니다. W3C의 변경 사항이 파이썬 DOM 인터페이스에서 이 메서드에
     반드시 영향을 미치는 것은 아닙니다 (이를 위한 새 W3C API도 지원되
     기는 하겠지만).

Node.appendChild(newChild)

   자식 리스트의 끝에 이 노드의 새 자식 노드를 추가하고, *newChild*를
   반환합니다. 노드가 이미 트리에 있으면, 먼저 제거됩니다.

Node.insertBefore(newChild, refChild)

   기존 자식 앞에 새 자식 노드를 삽입합니다. *refChild*가 이 노드의 자
   식이어야 합니다; 그렇지 않으면 "ValueError"가 발생합니다.
   *newChild*가 반환됩니다. *refChild*가 "None"이면, 자식 리스트의 끝
   에 *newChild*를 삽입합니다.

Node.removeChild(oldChild)

   자식 노드를 제거합니다. *oldChild*는 이 노드의 자식이어야 합니다;
   그렇지 않으면, "ValueError"가 발생합니다. 성공하면 *oldChild*가 반
   환됩니다. *oldChild*가 더는 사용되지 않으면, 그것의 "unlink()" 메서
   드를 호출해야 합니다.

Node.replaceChild(newChild, oldChild)

   기존 노드를 새 노드로 교체합니다. *oldChild*는 이 노드의 자식이어야
   합니다. 그렇지 않으면, "ValueError"가 발생합니다.

Node.normalize()

   모든 텍스트 스트레치(stretch)가 단일 "Text" 인스턴스로 저장되도록,
   인접한 텍스트 노드를 결합합니다. 이는 많은 응용 프로그램에서 DOM 트
   리의 텍스트 처리를 단순화합니다.

Node.cloneNode(deep)

   이 노드를 복제합니다. *deep*을 설정하면 모든 자식 노드도 복제됩니다
   . 복제를 반환합니다.


NodeList 객체
-------------

"NodeList"는 노드의 시퀀스를 나타냅니다. 이러한 객체는 DOM Core 권장
사항에서 두 가지 방식으로 사용됩니다: "Element" 객체는 자식 노드의 리
스트를 제공하고, "Node"의 "getElementsByTagName()"과
"getElementsByTagNameNS()" 메서드는 이 인터페이스를 사용하여 조회 결과
를 나타냅니다.

DOM 수준 2 권장 사항은 이러한 객체에 대해 하나의 메서드와 하나의 어트
리뷰트를 정의합니다:

NodeList.item(i)

   시퀀스의 *i* 번째 항목(있다면)이나 "None"을 반환합니다. 인덱스 *i*
   는 0보다 작거나 시퀀스의 길이보다 크거나 같을 수 없습니다.

NodeList.length

   시퀀스의 노드 수.

또한, 파이썬 DOM 인터페이스는 "NodeList" 객체를 파이썬 시퀀스로 사용할
수 있도록 몇 가지 추가 지원을 요구합니다. 모든 "NodeList" 구현에는
"__len__()"과 "__getitem__()"에 대한 지원이 포함되어야 합니다; 이를 통
해 "for" 문에서 "NodeList"를 이터레이트할 수 있고, "len()" 내장 함수를
적절히 지원할 수 있습니다.

DOM 구현이 문서 수정을 지원하면, "NodeList" 구현은 "__setitem__()"과
"__delitem__()" 메서드도 지원해야 합니다.


DocumentType 객체
-----------------

문서에 의해 선언된 표기법과 엔티티에 대한 정보(구문 분석기가 사용하고
정보를 제공할 수 있으면 외부 부분 집합(external subset)을 포함하는)는
"DocumentType" 객체에서 사용 가능합니다. 문서의 "DocumentType"은
"Document" 객체의 "doctype" 어트리뷰트에서 사용 가능합니다; 문서에
"DOCTYPE" 선언이 없으면, 문서의 "doctype" 어트리뷰트는 이 인터페이스의
인스턴스 대신 "None"으로 설정됩니다.

"DocumentType"은 "Node"의 특수화(specialization)이고 다음 어트리뷰트를
추가합니다:

DocumentType.publicId

   문서 형 정의의 외부 부분 집합(external subset)에 대한 공용 식별자.
   문자열이나 "None"입니다.

DocumentType.systemId

   문서 형 정의의 외부 부분 집합(external subset)에 대한 시스템 식별자
   . 문자열로 표현된 URI이거나 "None"입니다.

DocumentType.internalSubset

   문서에서 완전한 내부 부분 집합(internal subset)을 제공하는 문자열.
   부분 집합을 묶는 대괄호는 포함되지 않습니다. 문서에 내부 부분 집합
   이 없으면 "None"이어야 합니다.

DocumentType.name

   "DOCTYPE" 선언에 제공된 루트 엘리먼트의 이름 (있다면).

DocumentType.entities

   외부 엔티티의 정의를 제공하는 "NamedNodeMap"입니다. 엔티티 이름이
   두 번 이상 정의되면, 첫 번째 정의 만 제공됩니다 (XML 권장 사항에 따
   라 다른 정의는 무시됩니다). 구문 분석기가 정보를 제공하지 않거나 정
   의된 엔티티가 없으면 "None"일 수 있습니다.

DocumentType.notations

   표기법의 정의를 제공하는 "NamedNodeMap"입니다. 표기법 이름이 두 번
   이상 정의되면, 첫 번째 정의 만 제공됩니다 (XML 권장 사항에 따라 다
   른 정의는 무시됩니다). 구문 분석기가 정보를 제공하지 않거나 정의된
   표기법이 없으면 "None"일 수 있습니다.


Document 객체
-------------

"Document"는 구성 엘리먼트, 어트리뷰트, 처리 명령어, 주석 등을 포함한
전체 XML 문서를 나타냅니다. "Node"의 프로퍼티를 상속한다는 점을 기억하
십시오.

Document.documentElement

   문서의 유일한 루트 엘리먼트.

Document.createElement(tagName)

   새 엘리먼트 노드를 만들고 반환합니다. 엘리먼트는 만들어질 때 문서에
   삽입되지 않습니다. "insertBefore()"나 "appendChild()"와 같은 다른
   메서드 중 하나를 사용하여 명시적으로 삽입해야 합니다.

Document.createElementNS(namespaceURI, tagName)

   이름 공간을 사용하여 새 엘리먼트를 만들고 반환합니다. *tagName*은
   접두사를 가질 수 있습니다. 엘리먼트는 만들어질 때 문서에 삽입되지
   않습니다. "insertBefore()"나 "appendChild()"와 같은 다른 메서드 중
   하나를 사용하여 명시적으로 삽입해야 합니다.

Document.createTextNode(data)

   매개 변수로 전달된 data를 포함하는 텍스트 노드를 만들고 반환합니다.
   다른 생성 메서드와 마찬가지로 이 메서드는 노드를 트리에 삽입하지 않
   습니다.

Document.createComment(data)

   매개 변수로 전달된 data를 포함하는 주석 노드를 만들고 반환합니다.
   다른 생성 메서드와 마찬가지로 이 메서드는 노드를 트리에 삽입하지 않
   습니다.

Document.createProcessingInstruction(target, data)

   매개 변수로 전달된 *target*과 *data*를 포함하는 처리 명령어 노드를
   만들고 반환합니다. 다른 생성 메서드와 마찬가지로 이 메서드는 노드를
   트리에 삽입하지 않습니다.

Document.createAttribute(name)

   어트리뷰트 노드를 만들고 반환합니다. 이 메서드는 어트리뷰틀 노드를
   특정 엘리먼트와 연관시키지 않습니다. 새로 만들어진 어트리뷰트 인스
   턴스를 사용하려면 적절한 "Element" 객체에서 "setAttributeNode()"를
   사용해야 합니다.

Document.createAttributeNS(namespaceURI, qualifiedName)

   이름 공간을 사용하여 어트리뷰트 노드를 만들고 반환합니다. *tagName*
   은 접두사를 가질 수 있습니다. 이 메서드는 어트리뷰트 노드를 특정 엘
   리먼트와 연관시키지 않습니다. 새로 만들어진 어트리뷰트 인스턴스를
   사용하려면 적절한 "Element" 객체에서 "setAttributeNode()"를 사용해
   야합니다.

Document.getElementsByTagName(tagName)

   특정 엘리먼트 형 이름을 가진 모든 자손(직계 자식, 자식의 자식 등)을
   검색합니다.

Document.getElementsByTagNameNS(namespaceURI, localName)

   특정 이름 공간 URI와 지역 이름(localname)을 사용하여 모든 자손(직계
   자식, 자식의 자식 등)을 검색합니다. 지역 이름은 접두사 다음에 나오
   는 이름 공간의 일부입니다.


Element 객체
------------

"Element"는 "Node"의 서브 클래스이므로, 모든 어트리뷰트를 상속합니다.

Element.tagName

   엘리먼트 형 이름. 이름 공간을 사용하는 문서에서는 콜론을 포함할 수
   있습니다. 값은 문자열입니다.

Element.getElementsByTagName(tagName)

   "Document" 클래스의 동등한 메서드와 같습니다.

Element.getElementsByTagNameNS(namespaceURI, localName)

   "Document" 클래스의 동등한 메서드와 같습니다.

Element.hasAttribute(name)

   엘리먼트에 *name*이라는 이름의 어트리뷰트가 있으면 "True"를 반환합
   니다.

Element.hasAttributeNS(namespaceURI, localName)

   엘리먼트에 *namespaceURI*와 *localName*으로 이름이 지정된 어트리뷰
   트가 있으면 "True"를 반환합니다.

Element.getAttribute(name)

   *name*이라는 이름의 어트리뷰트의 값을 문자열로 반환합니다. 그러한
   어트리뷰트가 없으면, 어트리뷰트에 값이 없는 것처럼 빈 문자열이 반환
   됩니다.

Element.getAttributeNode(attrname)

   *attrname*이라는 이름의 어트리뷰트에 대한 "Attr" 노드를 반환합니다.

Element.getAttributeNS(namespaceURI, localName)

   *namespaceURI*와 *localName*으로 이름이 지정된 어트리뷰트의 값을 문
   자열로 반환합니다. 그러한 어트리뷰트가 없으면, 어트리뷰트에 값이 없
   는 것처럼 빈 문자열이 반환됩니다.

Element.getAttributeNodeNS(namespaceURI, localName)

   *namespaceURI*와 *localName*으로 주어진 어트리뷰트의 값을 노드로 반
   환합니다.

Element.removeAttribute(name)

   이름(name)으로 어트리뷰트를 제거합니다. 일치하는 어트리뷰트가 없으
   면 "NotFoundErr"가 발생합니다.

Element.removeAttributeNode(oldAttr)

   존재하면, 어트리뷰트 목록에서 *oldAttr*를 제거하고 반환합니다.
   *oldAttr*가 없으면 "NotFoundErr"가 발생합니다.

Element.removeAttributeNS(namespaceURI, localName)

   이름으로 어트리뷰트를 제거합니다. qname이 아닌 localName을 사용함에
   유의하십시오. 일치하는 어트리뷰트가 없어도 예외가 발생하지 않습니다
   .

Element.setAttribute(name, value)

   문자열로 어트리뷰트 값을 설정합니다.

Element.setAttributeNode(newAttr)

   엘리먼트에 새 어트리뷰트 노드를 추가합니다. "name" 어트리뷰트가 일
   치할 때 필요하면 기존 어트리뷰트를 대체합니다. 대체가 발생하면, 이
   전 어트리뷰트 노드가 반환됩니다. *newAttr*가 이미 사용 중이면
   "InuseAttributeErr"가 발생합니다.

Element.setAttributeNodeNS(newAttr)

   엘리먼트에 새 어트리뷰트 노드를 추가합니다. "namespaceURI"와
   "localName" 어트리뷰트가 일치할 때 필요하면 기존 어트리뷰트를 대체
   합니다. 대체가 발생하면 이전 어트리뷰트 노드가 반환됩니다.
   *newAttr*가 이미 사용 중이면 "InuseAttributeErr"가 발생합니다.

Element.setAttributeNS(namespaceURI, qname, value)

   문자열로 *namespaceURI*와 *qname*으로 지정된 어트리뷰트 값을 설정합
   니다. qname은 전체 어트리뷰트 이름임에 유의하십시오. 이것은 위와 다
   릅니다.


Attr 객체
---------

"Attr"은 "Node"를 상속하므로, 모든 어트리뷰트를 상속합니다.

Attr.name

   어트리뷰트 이름. 이름 공간을 사용하는 문서에서는 콜론을 포함할 수
   있습니다.

Attr.localName

   콜론이 있으면 그 뒤에 오는 이름의 일부, 그렇지 않으면 전체 이름. 이
   것은 읽기 전용 어트리뷰트입니다.

Attr.prefix

   콜론이 있으면 그 앞에 오는 이름의 일부, 그렇지 않으면 빈 문자열.

Attr.value

   어트리뷰트의 텍스트 값. 이것은 "nodeValue" 어트리뷰트의 동의어입니
   다.


NamedNodeMap 객체
-----------------

"NamedNodeMap"은 "Node"를 상속하지 *않습니다*.

NamedNodeMap.length

   어트리뷰트 목록의 길이입니다.

NamedNodeMap.item(index)

   특정 인덱스에 있는 어트리뷰트를 반환합니다. 어트리뷰트를 얻는 순서
   는 임의적이지만 DOM 수명 동안 일관적입니다. 각 항목은 어트리뷰트 노
   드입니다. "value" 어트리뷰트로 값을 얻으십시오.

이 클래스에 더 많은 매핑 동작을 제공하는 실험적인 메서드도 있습니다.
이를 사용하거나 "Element" 객체에서 표준화된 "getAttribute*()" 메서드
집합을 사용할 수 있습니다.


Comment 객체
------------

"Comment"는 XML 문서의 주석을 나타냅니다. "Node"의 서브 클래스이지만,
자식 노드를 가질 수 없습니다.

Comment.data

   주석의 내용을 제공하는 문자열. 이 어트리뷰트는 선행 "<!-""-"와 후행
   "-""->" 사이의 모든 문자를 포함하지만, 이들을 포함하지는 않습니다.


Text와 CDATASection 객체
------------------------

"Text" 인터페이스는 XML 문서의 텍스트를 나타냅니다. 구문 분석기와 DOM
구현이 DOM의 XML 확장을 지원하면, CDATA로 표시된 섹션으로 묶인 텍스트
부분은 "CDATASection" 객체에 저장됩니다. 이 두 인터페이스는 같지만,
"nodeType" 어트리뷰트에서 다른 값을 제공합니다.

이 인터페이스는 "Node" 인터페이스를 확장합니다. 자식 노드를 가질 수 없
습니다.

Text.data

   문자열로 표현된 텍스트 노드의 내용.

참고:

  "CDATASection" 노드의 사용이 그 노드가 완전한 CDATA 표시 섹션을 표현
  한다고 나타내는 것은 아닙니다, 단지 노드의 내용이 CDATA 섹션의 일부
  임을 나타낼 뿐입니다. 단일 CDATA 섹션은 문서 트리에서 둘 이상의 노드
  로 표현될 수 있습니다. 인접한 두 개의 "CDATASection" 노드가 다른
  CDATA 표시 섹션을 나타내는지를 확인할 방법은 없습니다.


ProcessingInstruction 객체
--------------------------

XML 문서의 처리 명령어를 나타냅니다; 이것은 "Node" 인터페이스를 상속하
며 자식 노드를 가질 수 없습니다.

ProcessingInstruction.target

   첫 번째 공백 문자까지의 처리 명령어의 내용. 이것은 읽기 전용 어트리
   뷰트입니다.

ProcessingInstruction.data

   첫 번째 공백 문자 다음에 오는 처리 명령어의 내용.


예외
----

DOM 수준 2 권장 사항은 단일 예외 "DOMException"과 응용 프로그램이 어떤
종류의 에러가 발생했는지 판별하도록 하는 여러 상수를 정의합니다.
"DOMException" 인스턴스에는 구체적인 예외에 적절한 값을 제공하는
"code" 어트리뷰트가 있습니다.

파이썬 DOM 인터페이스는 상수를 제공하지만, 동시에 예외 집합을 확장하여
DOM에 의해 정의된 각 예외 코드마다 구체적인 예외가 존재하도록 합니다.
구현 시 적절한 구체적인 예외를 발생시켜야 하며, 각 예외는 "code" 속성
으로 적절한 값을 제공합니다.

exception xml.dom.DOMException

   모든 구체적인 DOM 예외에 사용되는 베이스 예외 클래스. 이 예외 클래
   스는 직접 인스턴스 화할 수 없습니다.

exception xml.dom.DomstringSizeErr

   지정된 텍스트 범위가 문자열에 맞지 않을 때 발생합니다. 이것은 파이
   썬 DOM 구현에서 사용되는 것으로 알려지지 않았지만, 파이썬으로 작성
   되지 않은 DOM 구현에서 수신될 수 있습니다.

exception xml.dom.HierarchyRequestErr

   노드 형이 허용하지 않는 곳에 노드를 삽입하려고 할 때 발생합니다.

exception xml.dom.IndexSizeErr

   메서드의 인덱스(index)나 크기(size) 매개 변수가 음수이거나 허용된
   값을 초과할 때 발생합니다.

exception xml.dom.InuseAttributeErr

   문서의 다른 곳에 이미 존재하는 "Attr" 노드를 삽입하려고 할 때 발생
   합니다.

exception xml.dom.InvalidAccessErr

   하부 객체에서 매개 변수나 연산이 지원되지 않으면 발생합니다.

exception xml.dom.InvalidCharacterErr

   이 예외는 문자열 매개 변수에 XML 1.0 권장 사항에서 사용 중인 컨텍스
   트에서 허용되지 않는 문자가 포함될 때 발생합니다. 예를 들어, 엘리먼
   트 형 이름에 스페이스가 있는 "Element" 노드를 만들려고 하면 이 에러
   가 발생합니다.

exception xml.dom.InvalidModificationErr

   노드 형을 수정하려고 할 때 발생합니다.

exception xml.dom.InvalidStateErr

   정의되지 않았거나 더는 사용할 수 없는 객체를 사용하려고 할 때 발생
   합니다.

exception xml.dom.NamespaceErr

   Namespaces in XML 권장 사항에서 허용되지 않는 방식으로 객체를 변경
   하려고 시도하면 이 예외가 발생합니다.

exception xml.dom.NotFoundErr

   참조된 컨텍스트에 노드가 존재하지 않을 때 발생하는 예외. 예를 들어,
   "NamedNodeMap.removeNamedItem()"은 전달된 노드가 맵에 존재하지 않으
   면 이것을 발생시킵니다.

exception xml.dom.NotSupportedErr

   구현이 요청된 형의 객체나 연산을 지원하지 않을 때 발생합니다.

exception xml.dom.NoDataAllowedErr

   데이터를 지원하지 않는 노드에 데이터가 지정되면 발생합니다.

exception xml.dom.NoModificationAllowedErr

   수정이 허용되지 않는 객체(가령 읽기 전용 노드)를 수정하려고 하면 발
   생합니다.

exception xml.dom.SyntaxErr

   유효하지 않거나 잘못된 문자열이 지정될 때 발생합니다.

exception xml.dom.WrongDocumentErr

   노드가 현재 속한 것과 다른 문서에 삽입되고 구현이 한 문서에서 다른
   문서로 노드 이전을 지원하지 않을 때 발생합니다.

DOM 권장 사항에 정의된 예외 코드는 이 테이블에 따라 위에서 설명한 예외
에 매핑됩니다:

+----------------------------------------+-----------------------------------+
| 상수                                   | 예외                              |
|========================================|===================================|
| "DOMSTRING_SIZE_ERR"                   | "DomstringSizeErr"                |
+----------------------------------------+-----------------------------------+
| "HIERARCHY_REQUEST_ERR"                | "HierarchyRequestErr"             |
+----------------------------------------+-----------------------------------+
| "INDEX_SIZE_ERR"                       | "IndexSizeErr"                    |
+----------------------------------------+-----------------------------------+
| "INUSE_ATTRIBUTE_ERR"                  | "InuseAttributeErr"               |
+----------------------------------------+-----------------------------------+
| "INVALID_ACCESS_ERR"                   | "InvalidAccessErr"                |
+----------------------------------------+-----------------------------------+
| "INVALID_CHARACTER_ERR"                | "InvalidCharacterErr"             |
+----------------------------------------+-----------------------------------+
| "INVALID_MODIFICATION_ERR"             | "InvalidModificationErr"          |
+----------------------------------------+-----------------------------------+
| "INVALID_STATE_ERR"                    | "InvalidStateErr"                 |
+----------------------------------------+-----------------------------------+
| "NAMESPACE_ERR"                        | "NamespaceErr"                    |
+----------------------------------------+-----------------------------------+
| "NOT_FOUND_ERR"                        | "NotFoundErr"                     |
+----------------------------------------+-----------------------------------+
| "NOT_SUPPORTED_ERR"                    | "NotSupportedErr"                 |
+----------------------------------------+-----------------------------------+
| "NO_DATA_ALLOWED_ERR"                  | "NoDataAllowedErr"                |
+----------------------------------------+-----------------------------------+
| "NO_MODIFICATION_ALLOWED_ERR"          | "NoModificationAllowedErr"        |
+----------------------------------------+-----------------------------------+
| "SYNTAX_ERR"                           | "SyntaxErr"                       |
+----------------------------------------+-----------------------------------+
| "WRONG_DOCUMENT_ERR"                   | "WrongDocumentErr"                |
+----------------------------------------+-----------------------------------+


규격 준수
=========

이 섹션에서는 규격 준수 요구 사항과 파이썬 DOM API, W3C DOM 권장 사항
및 파이썬의 OMG IDL 매핑 간의 관계에 관해 설명합니다.


형 매핑
-------

DOM 명세에 사용된 IDL 형은 다음 표에 따라 파이썬 형에 매핑됩니다.

+--------------------+---------------------------------------------+
| IDL 형             | 파이썬 형                                   |
|====================|=============================================|
| "boolean"          | "bool" 또는 "int"                           |
+--------------------+---------------------------------------------+
| "int"              | "int"                                       |
+--------------------+---------------------------------------------+
| "long int"         | "int"                                       |
+--------------------+---------------------------------------------+
| "unsigned int"     | "int"                                       |
+--------------------+---------------------------------------------+
| "DOMString"        | "str" 또는 "bytes"                          |
+--------------------+---------------------------------------------+
| "null"             | "None"                                      |
+--------------------+---------------------------------------------+


접근자 메서드
-------------

OMG IDL에서 파이썬으로의 매핑은 Java 매핑과 거의 같은 방식으로 IDL
"attribute" 선언에 대한 접근자 함수를 정의합니다. 다음과 같은 IDL 선언
매핑은:

   readonly attribute string someValue;
            attribute string anotherValue;

세 개의 접근자 함수를 산출합니다: "someValue"를 위한 "get" 메서드
("_get_someValue()")와 "anotherValue"를 위한 "get"과 "set" 메서드
("_get_anotherValue()"와 "_set_anotherValue()"). 특히, 매핑은 IDL 어트
리뷰트가 일반 파이썬 어트리뷰트로 액세스할 수 있도록 요구하지 않습니다
: "object.someValue"는 작동할 필요 *없으며*, "AttributeError"를 발생시
킬 수 있습니다.

그러나, 파이썬 DOM API는 일반 어트리뷰트 액세스가 동작하도록 *요구합니
다*. 이것은 파이썬 IDL 컴파일러에 의해 생성된 일반적인 서로게이트가 작
동하지 않을 수 있으며, DOM 객체가 CORBA를 통해 액세스되는 경우 래퍼 객
체가 클라이언트에 필요할 수 있음을 의미합니다. CORBA DOM 클라이언트에
대해 추가적인 고려가 필요하지만, 파이썬에서 CORBA를 통해 DOM을 사용한
경험이 있는 구현자들은 이것을 문제라고 보지 않습니다. "readonly"로 선
언된 어트리뷰트는 모든 DOM 구현에서 쓰기 액세스를 제한하지 않을 수 있
습니다.

파이썬 DOM API에서는, 접근자 함수가 필요하지 않습니다. 제공되면, 파이
썬 IDL 매핑으로 정의된 형식을 취해야 하지만, 어트리뷰트를 파이썬에서
직접 액세스할 수 있어서 이러한 메서드들은 불필요한 것으로 간주합니다.
"readonly" 어트리뷰트에 "set" 접근자를 제공해서는 안 됩니다.

IDL 정의는 W3C DOM API의 요구 사항을 완전히 담지 않습니다. 가령
"getElementsByTagName()"의 반환 값과 같은 특정 객체가 "살아있다(live)"
는 개념과 같은 것을 표현하지 못합니다. 파이썬 DOM API는 구현이 이러한
요구 사항을 강제하도록 요구하지 않습니다.
