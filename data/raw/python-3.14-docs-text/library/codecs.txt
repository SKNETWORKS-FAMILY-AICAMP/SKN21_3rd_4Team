"codecs" --- 코덱 레지스트리와 베이스 클래스
********************************************

**소스 코드:** Lib/codecs.py

======================================================================

이 모듈은 표준 파이썬 코덱(인코더와 디코더)의 베이스 클래스를 정의하고
, 코덱과 에러 처리 조회 프로세스를 관리하는 내부 파이썬 코덱 레지스트
리에 대한 액세스를 제공합니다. 대부분의 표준 코덱은 텍스트를 바이트열
로 인코딩하는 (그리고 바이트열을 텍스트로 디코딩하는) *텍스트 인코딩*
이지만, 텍스트를 텍스트로 인코딩하고 바이트열을 바이트열로 인코딩하는
코덱도 제공됩니다. 사용자 정의 코덱은 임의 형 간에 인코딩과 디코딩 할
수 있지만, 일부 모듈 기능은 *텍스트 인코딩*이나 "bytes"로 인코딩하는
코덱과 함께 사용하도록 특별히 제한됩니다.

이 모듈은 임의의 코덱으로 인코딩과 디코딩하는 다음 함수를 정의합니다:

codecs.encode(obj, encoding='utf-8', errors='strict')

   *encoding*을 위해 등록된 코덱을 사용하여 *obj*를 인코딩합니다.

   원하는 에러 처리 방식을 설정하기 위해 *errors*가 주어질 수 있습니다
   . 기본 에러 처리기는 "'strict'"이며 인코딩 에러가 "ValueError"(또는
   "UnicodeEncodeError" 와 같은 더 많은 코덱 관련 서브 클래스)를 발생
   시킨다는 뜻입니다. 코덱 에러 처리에 대한 자세한 내용은 코덱 베이스
   클래스를 참조하십시오.

codecs.decode(obj, encoding='utf-8', errors='strict')

   *encoding*을 위해 등록된 코덱을 사용하여 *obj*를 디코딩합니다.

   원하는 에러 처리 방식을 설정하기 위해 *errors*가 주어질 수 있습니다
   . 기본 에러 처리기는 "'strict'"이며 디코딩 에러가 "ValueError" (또
   는 "UnicodeDecodeError" 와 같은 더 많은 코덱 관련 서브 클래스)를 발
   생시킨다는 뜻입니다. 코덱 에러 처리에 대한 자세한 내용은 코덱 베이
   스 클래스를 참조하십시오.

codecs.charmap_build(string)

   Return a mapping suitable for encoding with a custom single-byte
   encoding. Given a "str" *string* of up to 256 characters
   representing a decoding table, returns either a compact internal
   mapping object "EncodingMap" or a "dictionary" mapping character
   ordinals to byte values. Raises a "TypeError" on invalid input.

각 코덱에 대한 자세한 내용도 직접 확인할 수 있습니다:

codecs.lookup(encoding, /)

   파이썬 코덱 레지스트리에서 코덱 정보를 조회하고 아래 정의된
   "CodecInfo" 객체를 반환합니다.

   인코딩은 먼저 레지스트리 캐시에서 조회됩니다. 찾을 수 없으면, 등록
   된 검색 함수 리스트를 탐색합니다. "CodecInfo" 객체가 없으면,
   "LookupError"가 발생합니다. 그렇지 않으면, "CodecInfo" 객체가 캐시
   에 저장되고 호출자에게 반환됩니다.

class codecs.CodecInfo(encode, decode, streamreader=None, streamwriter=None, incrementalencoder=None, incrementaldecoder=None, name=None)

   코덱 레지스트리를 조회할 때의 코덱 세부 정보. 생성자 인자는 같은 이
   름의 어트리뷰트에 저장됩니다:

   name

      인코딩의 이름.

   encode
   decode

      상태 없는 인코딩과 디코딩 함수. 이들은 코덱 인스턴스의
      "encode()"와 "decode()" 메서드와 같은 인터페이스를 갖는 함수나
      메서드여야 합니다 (코덱 인터페이스를 참조하십시오). 함수나 메서
      드는 상태 없는 모드로 작동할 것으로 기대됩니다.

   incrementalencoder
   incrementaldecoder

      증분형 인코더와 디코더 클래스 또는 팩토리 함수. 이들은 각각 베이
      스 클래스 "IncrementalEncoder"와 "IncrementalDecoder"가 정의하는
      인터페이스를 제공해야 합니다. 증분 코덱은 상태를 유지할 수 있습
      니다.

   streamwriter
   streamreader

      스트림 기록기와 판독기 클래스 또는 팩토리 함수. 이들은 각각 베이
      스 클래스 "StreamWriter"와 "StreamReader"가 정의하는 인터페이스
      를 제공해야 합니다. 스트림 코덱은 상태를 유지할 수 있습니다.

다양한 코덱 구성 요소에 대한 액세스를 단순화하기 위해, 이 모듈은 코덱
조회에 "lookup()"을 사용하는 다음과 같은 추가 함수를 제공합니다:

codecs.getencoder(encoding)

   주어진 인코딩에 대한 코덱을 찾아서 해당 인코더 함수를 반환합니다.

   인코딩을 찾을 수 없는 경우 "LookupError"를 발생시킵니다.

codecs.getdecoder(encoding)

   주어진 인코딩에 대한 코덱을 찾아서 해당 디코더 함수를 반환합니다.

   인코딩을 찾을 수 없는 경우 "LookupError"를 발생시킵니다.

codecs.getincrementalencoder(encoding)

   주어진 인코딩에 대한 코덱을 찾아서 증분 인코더 클래스나 팩토리 함수
   를 반환합니다.

   인코딩을 찾을 수 없거나 코덱이 증분 인코더를 지원하지 않는 경우
   "LookupError"를 발생시킵니다.

codecs.getincrementaldecoder(encoding)

   주어진 인코딩에 대한 코덱을 찾아서 증분 디코더 클래스나 팩토리 함수
   를 반환합니다.

   인코딩을 찾을 수 없거나 코덱이 증분 디코더를 지원하지 않는 경우
   "LookupError"를 발생시킵니다.

codecs.getreader(encoding)

   주어진 인코딩의 코덱을 찾아서 "StreamReader" 클래스나 팩토리 함수를
   반환합니다.

   인코딩을 찾을 수 없는 경우 "LookupError"를 발생시킵니다.

codecs.getwriter(encoding)

   주어진 인코딩의 코덱을 찾아서 "StreamWriter" 클래스나 팩토리 함수를
   반환합니다.

   인코딩을 찾을 수 없는 경우 "LookupError"를 발생시킵니다.

적합한 코덱 검색 함수를 등록하여 사용자 정의 코덱을 사용할 수 있도록
합니다:

codecs.register(search_function, /)

   코덱 검색 함수를 등록합니다. 검색 함수는 모두 소문자로 이루어지고
   하이픈과 스페이스를 언더스코어로 변환한 인코딩 이름인 하나의 인자를
   취하고, "CodecInfo" 객체를 반환해야 합니다. 검색 함수가 주어진 인코
   딩을 찾지 못하면, "None"을 반환해야 합니다.

   버전 3.9에서 변경: Hyphens and spaces are converted to underscore.

codecs.unregister(search_function, /)

   Unregister a codec search function and clear the registry's cache.
   If the search function is not registered, do nothing.

   Added in version 3.10.

내장 "open()"과 관련 "io" 모듈은 인코딩된 텍스트 파일 작업에 권장되는
접근 방법이지만, 이 모듈은 바이너리 파일로 작업할 때 더 넓은 범위의 코
덱을 사용할 수 있도록 하는 추가 유틸리티 함수와 클래스를 제공합니다:

codecs.open(filename, mode='r', encoding=None, errors='strict', buffering=-1)

   주어진 *mode*를 사용하여 인코딩된 파일을 열고 투명한 인코딩/디코딩
   을 제공하는 "StreamReaderWriter" 의 인스턴스를 반환합니다. 기본 파
   일 모드는 "'r'"이고, 파일을 읽기 모드로 연다는 뜻입니다.

   참고:

     *encoding*이 "None"이 아니면, 하부 인코딩된 파일은 항상 바이너리
     모드로 열립니다. 읽기와 쓰기 시 "'\n'"의 자동 변환이 수행되지 않
     습니다. *mode* 인자는 내장 "open()" 함수에 허용되는 모든 바이너리
     모드일 수 있습니다; "'b'"가 자동으로 추가됩니다.

   *encoding*은 파일에 사용될 인코딩을 지정합니다. 바이트열에서 인코딩
   하고 바이트열로 디코딩하는 모든 인코딩이 허용되며, 파일 메서드가 지
   원하는 데이터형은 사용된 코덱에 따라 다릅니다.

   에러 처리를 정의하기 위해 *errors*가 제공될 수 있습니다. 기본값은
   "'strict'"이고 인코딩 에러가 발생하면 "ValueError"가 발생합니다.

   *buffering*은 내장 "open()" 함수에서와 같은 의미입니다. 기본값은 -1
   이며 기본 버퍼 크기가 사용됨을 의미합니다.

   버전 3.11에서 변경: The "'U'" mode has been removed.

   버전 3.14부터 폐지됨: "codecs.open()" has been superseded by
   "open()".

codecs.EncodedFile(file, data_encoding, file_encoding=None, errors='strict')

   투명한 트랜스코딩을 제공하는 *file*의 래핑 된 버전인
   "StreamRecoder" 인스턴스를 반환합니다. 래핑 된 버전이 닫힐 때 원본
   파일이 닫힙니다.

   래핑 된 파일에 기록된 데이터는 주어진 *data_encoding*에 따라 디코딩
   된 다음 *file_encoding*을 사용하여 바이트열로 원본 파일에 기록됩니
   다. 원본 파일에서 읽은 바이트열은 *file_encoding*에 따라 디코딩되며
   , 결과는 *data_encoding*을 사용하여 인코딩됩니다.

   *file_encoding*이 제공되지 않으면, 기본값은 *data_encoding*입니다.

   에러 처리를 정의하기 위해 *errors*가 제공될 수 있습니다. 기본값은
   "'strict'"이며, 인코딩 에러가 발생하면 "ValueError"가 발생합니다.

codecs.iterencode(iterator, encoding, errors='strict', **kwargs)

   Uses an incremental encoder to iteratively encode the input
   provided by *iterator*. *iterator* must yield "str" objects. This
   function is a *generator*. The *errors* argument (as well as any
   other keyword argument) is passed through to the incremental
   encoder.

   이 함수를 사용하려면 코덱에서 인코딩할 텍스트 "str" 객체를 허용해야
   합니다. 따라서 "base64_codec"과 같은 바이트열-바이트열 인코더는 지
   원하지 않습니다.

codecs.iterdecode(iterator, encoding, errors='strict', **kwargs)

   Uses an incremental decoder to iteratively decode the input
   provided by *iterator*. *iterator* must yield "bytes" objects. This
   function is a *generator*. The *errors* argument (as well as any
   other keyword argument) is passed through to the incremental
   decoder.

   이 함수를 사용하려면 코덱에서 디코딩할 "bytes" 객체를 허용해야 합니
   다. 따라서 "rot_13"이 "iterencode()"로 동등하게 사용될 수 있지만,
   "rot_13"과 같은 텍스트-텍스트 인코더는 지원하지 않습니다.

codecs.readbuffer_encode(buffer, errors=None, /)

   Return a "tuple" containing the raw bytes of *buffer*, a buffer-
   compatible object or "str" (encoded to UTF-8 before processing),
   and their length in bytes.

   The *errors* argument is ignored.

      >>> codecs.readbuffer_encode(b"Zito")
      (b'Zito', 4)

이 모듈은 또한 플랫폼 종속 파일을 읽고 쓰는 데 유용한 다음 상수를 제공
합니다:

codecs.BOM
codecs.BOM_BE
codecs.BOM_LE
codecs.BOM_UTF8
codecs.BOM_UTF16
codecs.BOM_UTF16_BE
codecs.BOM_UTF16_LE
codecs.BOM_UTF32
codecs.BOM_UTF32_BE
codecs.BOM_UTF32_LE

   이 상수는 여러 인코딩에서 유니코드 바이트 순서 표시(BOM)인 다양한
   바이트 시퀀스를 정의합니다. UTF-16과 UTF-32 데이터 스트림에서 사용
   된 바이트 순서를 나타내는 데 사용되며, UTF-8에서 유니코드 서명으로
   사용됩니다. "BOM_UTF16"은 플랫폼의 네이티브 바이트 순서에 따라
   "BOM_UTF16_BE"나 "BOM_UTF16_LE"이며, "BOM"은 "BOM_UTF16"의 별칭,
   "BOM_LE"는 "BOM_UTF16_LE"의 별칭, "BOM_BE"는 "BOM_UTF16_BE"의 별칭
   입니다. 다른 것은 UTF-8과 UTF-32 인코딩에서 BOM을 나타냅니다.


코덱 베이스 클래스
==================

"codecs" 모듈은 코덱 객체로 작업하기 위한 인터페이스를 정의하는 베이스
클래스 집합을 정의하며, 사용자 정의 코덱 구현의 기초로 사용될 수도 있
습니다.

각 코덱은 파이썬에서 코덱으로 사용할 수 있도록 네 가지 인터페이스를 정
의해야 합니다: 상태 없는 인코더, 상태 없는 디코더, 스트림 판독기 및 스
트림 기록기. 스트림 판독기와 기록기는 일반적으로 상태 없는 인코더/디코
더를 재사용하여 파일 프로토콜을 구현합니다. 코덱 작성자는 코덱에서 인
코딩과 디코딩 에러를 처리하는 방법도 정의해야 합니다.


에러 처리기
-----------

에러 처리를 단순화하고 표준화하기 위해, 코덱은 *errors* 문자열 인자를
받아들여 다른 에러 처리 체계를 구현할 수 있습니다:

>>> 'German ß, ♬'.encode(encoding='ascii', errors='backslashreplace')
b'German \\xdf, \\u266c'
>>> 'German ß, ♬'.encode(encoding='ascii', errors='xmlcharrefreplace')
b'German &#223;, &#9836;'

다음 에러 처리기는 모든 파이썬 표준 인코딩과 함께 사용할 수 있습니다:

+---------------------------+-------------------------------------------------+
| 값                        | 의미                                            |
|===========================|=================================================|
| "'strict'"                | "UnicodeError"(또는 서브 클래스)를 발생시킵니다 |
|                           | , 이것이 기본값입니다. "strict_errors()"에서 구 |
|                           | 현되었습니다.                                   |
+---------------------------+-------------------------------------------------+
| "'ignore'"                | 잘못된 데이터를 무시하고 추가 통지 없이 계속 진 |
|                           | 행합니다. "ignore_errors()"에서 구현되었습니다. |
+---------------------------+-------------------------------------------------+
| "'replace'"               | 교체 마커로 교체합니다. 인코딩 시, "?" (ASCII   |
|                           | 문자) 를 사용합니다. 디 코딩 시, "�" (U+FFFD,   |
|                           | 공식 REPLACEMENT CHARACTER) 를 사용합니다.      |
|                           | "replace_errors()"에서 구현되었습니다.          |
+---------------------------+-------------------------------------------------+
| "'backslashreplace'"      | Replace with backslashed escape sequences. On   |
|                           | encoding, use hexadecimal form of Unicode code  |
|                           | point with formats "\x*hh*" "\u*xxxx*"          |
|                           | "\U*xxxxxxxx*". On decoding, use hexadecimal    |
|                           | form of byte value with format "\x*hh*".        |
|                           | Implemented in "backslashreplace_errors()".     |
+---------------------------+-------------------------------------------------+
| "'surrogateescape'"       | 디코딩 시, 바이트를 "U+DC80"에서 "U+DCFF" 범위  |
|                           | 의 개별 서로게이트 코드 (surrogate code)로 바꿉 |
|                           | 니다. 이 코드는 데이터를 인코딩할 때            |
|                           | "'surrogateescape'" 에러 처리기가 사용되면 같은 |
|                           | 바이트로 다시 변환됩니 다. (자세한 내용은 **PEP |
|                           | 383**을 참조하십시오.)                          |
+---------------------------+-------------------------------------------------+

다음 에러 처리기는 인코딩에만  적용됩니다 (*텍스트 인코딩* 내):

+---------------------------+-------------------------------------------------+
| 값                        | 의미                                            |
|===========================|=================================================|
| "'xmlcharrefreplace'"     | "&#*num*;" 포맷의 유니코드 코드 포인트의 십진수 |
|                           | 형식인 XML/HTML 숫자 문자 참조로 교체합니다.    |
|                           | "xmlcharrefreplace_errors()"에서 구현되었습니   |
|                           | 다.                                             |
+---------------------------+-------------------------------------------------+
| "'namereplace'"           | "\N{...}" 이스케이프 시퀀스로 교체합니다, 중괄  |
|                           | 호 안에 나타나는 것은 유 니코드 문자 데이터베이 |
|                           | 스의 이름(Name) 속성입니다.                     |
|                           | "namereplace_errors()"에서 구현되었습니다.      |
+---------------------------+-------------------------------------------------+

또한, 다음 에러 처리기는 지정된 코덱에만 적용됩니다:

+---------------------+--------------------------+---------------------------------------------+
| 값                  | 코덱                     | 의미                                        |
|=====================|==========================|=============================================|
| "'surrogatepass'"   | utf-8, utf-16, utf-32,   | 서로게이트 코드 포인트 ("U+D800" -          |
|                     | utf-16-be, utf-16-le,    | "U+DFFF") 를 일반 코드 포인트로 인 코딩 및  |
|                     | utf-32-be, utf-32-le     | 디코딩하도록 허용합니다. 그렇지 않으면 이   |
|                     |                          | 코덱들은 "str"에 있 는 서로게이트 코드 포인 |
|                     |                          | 트의 존재를 에러로 취급합니다.              |
+---------------------+--------------------------+---------------------------------------------+

Added in version 3.1: "'surrogateescape'"와 "'surrogatepass'" 에러 처
리기.

버전 3.4에서 변경: "'surrogatepass'" 에러 처리기는 이제 utf-16* 와
utf-32* 코덱에서 작동합니다.

Added in version 3.5: "'namereplace'" 에러 처리기.

버전 3.5에서 변경: "'backslashreplace'" 에러 처리기는 이제 디코딩과 변
환(translating)에서 작동합니다.

새 이름으로 에러 처리기를 등록하여 허용되는 값 집합을 확장할 수 있습니
다:

codecs.register_error(name, error_handler, /)

   에러 처리 함수 *error_handler*를 *name*이라는 이름으로 등록합니다.
   *error_handler* 인자는 *name*이 errors 매개 변수로 지정될 때, 인코
   딩과 디코딩 중에 에러가 있으면 호출됩니다.

   인코딩의 경우, 에러 위치에 대한 정보가 포함된 "UnicodeEncodeError"
   인스턴스와 함께 *error_handler*가 호출됩니다. 에러 처리기는 이 예외
   나 다른 예외를 발생시키거나, 입력의 인코딩할 수 없는 부분의 대체 값
   과 인코딩을 계속할 위치를 담은 튜플을 반환해야 합니다. 대체 값은
   "str"이나 "bytes"일 수 있습니다. 대체 값이 바이트열이면, 인코더는
   이를 단순히 출력 버퍼에 복사합니다. 대체 값이 문자열이면, 인코더는
   대체 값을 인코딩합니다. 지정된 위치에서 원래 입력으로 인코딩이 계속
   됩니다. 음수 위칫값은 입력 문자열의 끝을 기준으로 처리됩니다. 결과
   위치가 범위를 벗어나면 "IndexError"가 발생합니다.

   "UnicodeDecodeError" 나 "UnicodeTranslateError" 가 처리기로 전달되
   고 에러 처리기의 대체 값을 출력에 직접 넣는다는 점을 제외하면, 디코
   딩과 변환(translating)은 비슷하게 작동합니다.

이전에 등록된 에러 처리기(표준 에러 처리기를 포함하여)는 이름으로 조회
할 수 있습니다:

codecs.lookup_error(name, /)

   *name*이라는 이름으로 이전에 등록된 에러 처리기를 반환합니다.

   처리기를 찾을 수 없으면 "LookupError"를 발생시킵니다.

다음과 같은 표준 에러 처리기가 모듈 수준 함수로 제공됩니다:

codecs.strict_errors(exception)

   "'strict'" 에러 처리를 구현합니다.

   각 인코딩이나 디코딩 에러는 "UnicodeError"를 발생시킵니다.

codecs.ignore_errors(exception)

   "'ignore'" 에러 처리를 구현합니다.

   잘못된 형식의 데이터는 무시됩니다; 추가 통지 없이 인코딩이나 디코딩
   이 계속됩니다.

codecs.replace_errors(exception)

   "'replace'" 에러 처리를 구현합니다.

   Substitutes "?" (ASCII character) for encoding errors or "�"
   (U+FFFD, the official REPLACEMENT CHARACTER) for decoding errors.

codecs.backslashreplace_errors(exception)

   "'backslashreplace'" 에러 처리를 구현합니다.

   Malformed data is replaced by a backslashed escape sequence. On
   encoding, use the hexadecimal form of Unicode code point with
   formats "\x*hh*" "\u*xxxx*" "\U*xxxxxxxx*". On decoding, use the
   hexadecimal form of byte value with format "\x*hh*".

   버전 3.5에서 변경: 디코딩과 변환(translating)에서 작동합니다.

codecs.xmlcharrefreplace_errors(exception)

   "'xmlcharrefreplace'" 에러 처리를 구현합니다 (*텍스트 인코딩*으로
   인코딩하는 경우에만 해당).

   인코드할 수 없는 문자는 "&#*num*;" 포맷의 유니코드 코드 포인트의 십
   진수 형식인 적절한 XML/HTML 숫자 문자 참조로 대체됩니다.

codecs.namereplace_errors(exception)

   "'namereplace'" 에러 처리를 구현합니다 (*텍스트 인코딩*으로 인코딩
   하는 경우에만 해당).

   인코드할 수 없는 문자는 "\N{...}" 이스케이프 시퀀스로 대체됩니다.
   중괄호 안에 나타나는 문자 집합은 유니코드 문자 데이터베이스의 이름
   (Name) 속성입니다. 예를 들어, 독일어 소문자 "'ß'"는 바이트 시퀀스
   "\N{LATIN SMALL LETTER SHARP S}"로 변환됩니다.

   Added in version 3.5.


상태 없는 인코딩과 디코딩
-------------------------

기본 "Codec" 클래스는 다음과 같은 메서드를 정의하는데, 상태 없는 인코
더와 디코더의 함수 인터페이스를 정의하기도 합니다:

class codecs.Codec

   encode(input, errors='strict')

      객체 *input*을 인코딩하고 튜플(출력 객체, 소비한 길이)을 반환합
      니다. 예를 들어, *텍스트 인코딩*은 특정 문자 집합 인코딩 (예를
      들어, "cp1252"나 "iso-8859-1")을 사용하여 문자열 객체를 바이트열
      객체로 변환합니다.

      *errors* 인자는 적용할 에러 처리를 정의합니다. 기본값은
      "'strict'" 처리입니다.

      이 메서드는 "Codec" 인스턴스에 상태를 저장하지 않을 수 있습니다.
      인코딩 효율을 높이기 위해 상태를 유지해야 하는 코덱에서는
      "StreamWriter"를 사용하십시오.

      인코더는 길이가 0인 입력을 처리하고 이 상황에서는 출력 객체 형의
      빈 객체를 반환할 수 있어야 합니다.

   decode(input, errors='strict')

      객체 *input*을 디코딩하고 튜플 (출력 객체, 소비한 길이)를 반환합
      니다. 예를 들어, *텍스트 인코딩*의 경우, 디코딩은 특정 문자 집합
      인코딩을 사용하여 인코딩된 바이트열 객체를 문자열 객체로 변환합
      니다.

      텍스트 인코딩과 바이트열-바이트열 코덱의 경우, *input*은 바이트
      열 객체이거나 읽기 전용 버퍼 인터페이스를 제공하는 객체여야 합니
      다 -- 예를 들어, 버퍼 객체와 및 메모리 맵핑 파일.

      *errors* 인자는 적용할 에러 처리를 정의합니다. 기본값은
      "'strict'" 처리입니다.

      이 메서드는 "Codec" 인스턴스에 상태를 저장하지 않을 수 있습니다.
      디코딩 효율을 높이기 위해 상태를 유지해야 하는 코덱에서는
      "StreamReader"를 사용하십시오.

      디코더는 길이가 0인 입력을 처리하고 이 상황에서 출력 객체 형의
      빈 객체를 반환할 수 있어야 합니다.


증분 인코딩과 디코딩
--------------------

"IncrementalEncoder"와 "IncrementalDecoder" 클래스는 증분 인코딩과 디
코딩을 위한 기본 인터페이스를 제공합니다. 입력을 인코딩/디코딩하는 것
이 상태 없는 인코더/디코더 함수를 한 번 호출하는 것이 아니라, 증분 인
코더/디코더의 "encode()"/"decode()" 메서드를 여러 번 호출하여 수행됩니
다. 증분 인코더/디코더는 메서드 호출 중에 인코딩/디코딩 프로세스를 추
적합니다.

"encode()"/"decode()" 메서드에 대한 호출의 연결된 출력은 모든 단일 입
력을 하나로 결합하여 상태 없는 인코더/디코더로 인코딩/디코딩되는 것과
같습니다.


IncrementalEncoder 객체
~~~~~~~~~~~~~~~~~~~~~~~

"IncrementalEncoder" 클래스는 여러 단계로 입력을 인코딩하는 데 사용됩
니다. 파이썬 코덱 레지스트리와 호환되도록 모든 증분 인코더가 정의해야
하는 다음 메서드를 정의합니다.

class codecs.IncrementalEncoder(errors='strict')

   "IncrementalEncoder" 인스턴스의 생성자.

   모든 증분 인코더는 이 생성자 인터페이스를 제공해야 합니다. 추가 키
   워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자만
   파이썬 코덱 레지스트리에서 사용됩니다.

   "IncrementalEncoder"는 *errors* 키워드 인자를 제공하여 다른 에러 처
   리 체계를 구현할 수 있습니다. 가능한 값은 에러 처리기를 참조하십시
   오.

   *errors* 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트
   에 대입하면 "IncrementalEncoder" 객체의 수명 동안 다른 에러 처리 전
   략 간에 전환할 수 있습니다.

   encode(object, final=False)

      *object*를 (인코더의 현재 상태를 고려하여) 인코딩하고 결과 인코
      딩된 객체를 반환합니다. 이것이 "encode()"에 대한 마지막 호출이면
      *final*은 참이어야 합니다 (기본값은 거짓).

   reset()

      인코더를 초기 상태로 재설정합니다. 출력은 버려집니다: 인코더를
      재설정하고 출력을 얻으려면, 필요하면 빈 바이트열이나 텍스트 문자
      열을 전달하여, ".encode(object, final=True)"를 호출하십시오.

   getstate()

      인코더의 현재 상태를 반환하는데, 정수여야 합니다. 구현은 "0"이
      가장 흔한 상태가 되도록 해야 합니다. (정수보다 복잡한 상태는 상
      태를 마샬링/피클링하고 결과 문자열의 바이트열을 정수로 인코딩하
      여 정수로 변환할 수 있습니다.)

   setstate(state)

      인코더 상태를 *state*로 설정합니다. *state*는 "getstate()"가 반
      환한 인코더 상태여야 합니다.


IncrementalDecoder 객체
~~~~~~~~~~~~~~~~~~~~~~~

"IncrementalDecoder" 클래스는 여러 단계로 입력을 디코딩하는 데 사용됩
니다. 파이썬 코덱 레지스트리와 호환되도록 모든 증분 디코더에서 정의해
야 하는 다음 메서드를 정의합니다.

class codecs.IncrementalDecoder(errors='strict')

   "IncrementalDecoder" 인스턴스의 생성자.

   모든 증분 디코더는 이 생성자 인터페이스를 제공해야 합니다. 추가 키
   워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자만
   파이썬 코덱 레지스트리에서 사용됩니다.

   "IncrementalDecoder"는 *errors* 키워드 인자를 제공하여 다른 에러 처
   리 체계를 구현할 수 있습니다. 가능한 값은 에러 처리기를 참조하십시
   오.

   *errors* 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트
   에 대입하면 "IncrementalDecoder" 객체의 수명 동안 다른 에러 처리 전
   략 간에 전환할 수 있습니다.

   decode(object, final=False)

      *object*를 디코딩하고 (디코더의 현재 상태를 고려하여) 결과 디코
      딩된 객체를 반환합니다. 이것이 "decode()"에 대한 마지막 호출이면
      *final*은 참이어야 합니다 (기본값은 거짓). *final*이 참이면 디코
      더는 입력을 완전히 디코딩해야 하며 모든 버퍼를 플러시 해야 합니
      다. 이것이 가능하지 않으면 (예를 들어 입력 끝의 불완전한 바이트
      시퀀스로 인해), 상태 없는 경우와 같이 에러 처리를 시작해야 합니
      다 (예외가 발생시킬 수 있습니다).

   reset()

      디코더를 초기 상태로 재설정합니다.

   getstate()

      디코더의 현재 상태를 반환합니다. 두 항목이 있는 튜플이어야 하며,
      첫 번째는 여전히 디코딩되지 않은 입력을 포함하는 버퍼여야 합니다
      . 두 번째는 정수여야 하며 추가 상태 정보일 수 있습니다. (구현은
      "0"이 가장 흔한 추가 상태 정보가 되도록 해야 합니다.) 이 추가 상
      태 정보가 "0"이면, 입력 버퍼가 없고 추가 상태 정보가 "0"인 상태
      로 디코더를 설정할 수 있어서, 이전에 버퍼링 된 입력을 디코더에
      공급하면 출력을 생성하지 않고 이전 상태로 되돌아갈 수 있어야 합
      니다. (정수보다 복잡한 추가 상태 정보는 정보를 마샬링/피클링하고
      결과 문자열의 바이트를 정수로 인코딩하여 정수로 변환할 수 있습니
      다.)

   setstate(state)

      디코더의 상태를 *state*로 설정합니다. *state*는 "getstate()"가
      반환한 디코더 상태여야 합니다.


스트림 인코딩과 디코딩
----------------------

"StreamWriter"와 "StreamReader" 클래스는 새로운 인코딩 서브 모듈을 매
우 쉽게 구현하는 데 사용할 수 있는 범용 작업 인터페이스를 제공합니다.
이를 수행하는 방법에 대한 예는 "encodings.utf_8"을 참조하십시오.


StreamWriter 객체
~~~~~~~~~~~~~~~~~

"StreamWriter" 클래스는 "Codec"의 서브 클래스이며 파이썬 코덱 레지스트
리와 호환되도록 모든 스트림 기록기가 정의해야 하는 다음 메서드를 정의
합니다.

class codecs.StreamWriter(stream, errors='strict')

   "StreamWriter" 인스턴스의 생성자.

   모든 스트림 기록기는 이 생성자 인터페이스를 제공해야 합니다. 추가
   키워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자
   만 파이썬 코덱 레지스트리에서 사용됩니다.

   *stream* 인자는 특정 코덱에 적합하도록 텍스트나 바이너리 데이터를
   쓰기 위해 열린 파일류 객체여야 합니다.

   "StreamWriter"는 *errors* 키워드 인자를 제공하여 다른 에러 처리 체
   계를 구현할 수 있습니다. 하부 스트림 코덱이 지원할 수 있는 표준 에
   러 처리기에 대해서는 에러 처리기를 참조하십시오.

   *errors* 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트
   에 대입하면 "StreamWriter" 객체의 수명 동안 다른 에러 처리 전략 간
   에 전환할 수 있습니다.

   write(object)

      스트림에 인코딩된 객체의 내용을 씁니다.

   writelines(list)

      이어붙인 문자열의 이터러블을 스트림에 씁니다 ("write()" 메서드를
      재사용할 수 있습니다). 무한하거나 아주 큰 이터러블은 지원되지 않
      습니다. 표준 바이트열-바이트열 코덱은 이 메서드를 지원하지 않습
      니다.

   reset()

      내부 상태를 유지하는 데 사용되는 코덱 버퍼를 재설정합니다.

      이 메서드를 호출하면 출력의 데이터가 깨끗한 상태가 되어 상태를
      복구하기 위해 전체 스트림을 다시 스캔하지 않고도 새로운 최신 데
      이터를 추가할 수 있도록 합니다.

위의 메서드 외에도, "StreamWriter"는 하부 스트림에서 온 다른 모든 메서
드와 어트리뷰트를 상속해야 합니다.


StreamReader 객체
~~~~~~~~~~~~~~~~~

"StreamReader" 클래스는 "Codec"의 서브 클래스이며 파이썬 코덱 레지스트
리와 호환되도록 모든 스트림 판독기가 정의해야 하는 다음 메서드를 정의
합니다.

class codecs.StreamReader(stream, errors='strict')

   "StreamReader" 인스턴스의 생성자.

   모든 스트림 판독기는 이 생성자 인터페이스를 제공해야 합니다. 추가
   키워드 인자를 자유롭게 추가할 수 있지만, 여기에 정의된 키워드 인자
   만 파이썬 코덱 레지스트리에서 사용됩니다.

   *stream* 인자는 특정 코덱에 적합하게 텍스트나 바이너리 데이터를 읽
   기 위해 열린 파일류 객체여야 합니다.

   "StreamReader"는 *errors* 키워드 인자를 제공하여 다른 에러 처리 체
   계를 구현할 수 있습니다. 하부 스트림 코덱이 지원할 수 있는 표준 에
   러 처리기에 대해서는 에러 처리기를 참조하십시오.

   *errors* 인자는 같은 이름의 어트리뷰트에 대입됩니다. 이 어트리뷰트
   에 대입하면 "StreamReader" 객체의 수명 동안 다른 에러 처리 전략 간
   에 전환할 수 있습니다.

   *errors* 인자에 허용되는 값 집합은 "register_error()"로 확장될 수
   있습니다.

   read(size=-1, chars=-1, firstline=False)

      스트림에서 데이터를 디코딩하고 결과 객체를 반환합니다.

      *chars* 인자는 반환할 디코딩 된 코드 포인트나 바이트의 수를 나타
      냅니다. "read()" 메서드는 요청된 것보다 더 많은 데이터를 반환하
      지 않지만, 사용 가능한 것이 충분하지 않으면 더 적게 반환할 수 있
      습니다.

      *size* 인자는 디코딩을 위해 읽을 인코딩 된 바이트나 코드 포인트
      의 대략적인 최대 수를 나타냅니다. 디코더는 이 설정을 적절하게 수
      정할 수 있습니다. 기본값 -1은 가능한 한 많이 읽고 디코딩함을 나
      타냅니다. 이 매개 변수는 커다란 파일을 한 번에 디코딩하지 않도록
      하기 위한 것입니다.

      *firstline* 플래그는 이후 줄에 디코딩 에러가 있으면 첫 번째 줄만
      반환해도 충분함을 나타냅니다.

      이 메서드는 탐욕스러운(greedy) 읽기 전략을 사용해야 합니다. 즉,
      인코딩 정의와 주어진 size 내에서 허용되는 만큼 많은 데이터를 읽
      어야 합니다. 예를 들어 스트림에 선택적 인코딩 종료나 상태 마커가
      있으면, 이것도 읽어야 합니다.

   readline(size=None, keepends=True)

      입력 스트림에서 한 줄을 읽고 디코딩된 데이터를 반환합니다.

      주어지면, *size*는 스트림의 "read()" 메서드에 size 인자로 전달됩
      니다.

      *keepends*가 거짓이면 줄 종료가 반환된 줄에서 제거됩니다.

   readlines(sizehint=None, keepends=True)

      입력 스트림에서 사용 가능한 모든 줄을 읽고 줄의 리스트로 반환합
      니다.

      줄 종료는 코덱의 "decode()" 메서드를 사용하여 구현되며
      *keepends*가 참이면 리스트 항목에 포함됩니다.

      주어지면, *sizehint*는 스트림의 "read()" 메서드에 *size* 인자로
      전달됩니다.

   reset()

      내부 상태를 유지하는 데 사용되는 코덱 버퍼를 재설정합니다.

      스트림 위치 변경이 발생하지 않아야 함에 유의하십시오. 이 메서드
      는 주로 디코딩 에러에서 복구할 수 있도록 하기 위한 것입니다.

위의 메서드 외에도 "StreamReader"는 하부 스트림에서 다른 모든 메서드와
어트리뷰트를 상속해야 합니다.


StreamReaderWriter 객체
~~~~~~~~~~~~~~~~~~~~~~~

"StreamReaderWriter" 는 읽기와 쓰기 모드 모두에서 작동하는 스트림을 래
핑하도록 하는 편의 클래스입니다.

"lookup()" 함수가 반환한 팩토리 함수를 사용하여 인스턴스를 구성할 수
있도록 설계되었습니다.

class codecs.StreamReaderWriter(stream, Reader, Writer, errors='strict')

   "StreamReaderWriter" 인스턴스를 만듭니다. *stream*은 파일류 객체여
   야 합니다. *Reader*와 *Writer*는 각각 "StreamReader"와
   "StreamWriter" 인터페이스를 제공하는 팩토리 함수나 클래스여야 합니
   다. 에러 처리는 스트림 판독기와 기록기에 정의된 것과 같은 방식으로
   수행됩니다.

"StreamReaderWriter" 인스턴스는 "StreamReader"와 "StreamWriter" 클래스
가 결합한 인터페이스를 정의합니다. 하부 스트림에서 다른 모든 메서드와
어트리뷰트를 상속합니다.


StreamRecoder 객체
~~~~~~~~~~~~~~~~~~

"StreamRecoder"는 한 인코딩에서 다른 인코딩으로 데이터를 변환하는데,
이는 때때로 다른 인코딩 환경을 다룰 때 유용합니다.

"lookup()" 함수가 반환한 팩토리 함수를 사용하여 인스턴스를 구성할 수
있도록 설계되었습니다.

class codecs.StreamRecoder(stream, encode, decode, Reader, Writer, errors='strict')

   양방향 변환을 구현하는 "StreamRecoder" 인스턴스를 만듭니다:
   *encode*와 *decode*는 프런트 엔드에 작동합니다 - "read()"와
   "write()"를 호출하는 코드가 보는 데이터, 반면에 *Reader*와 *Writer*
   는 백 엔드에 작동합니다 - *stream*의 데이터.

   이러한 객체를 사용하여 투명한 트랜스코딩을 수행 할 수 있습니다, 예
   를 들어, Latin-1 에서 UTF-8로 또는 그 반대로.

   *stream* 인자는 파일류 객체여야 합니다.

   *encode*와 *decode* 인자는 "Codec" 인터페이스를 준수해야 합니다.
   *Reader*와 *Writer*는 각각 "StreamReader"와 "StreamWriter" 인터페이
   스의 객체를 제공하는 팩토리 함수나 클래스여야 합니다.

   에러 처리는 스트림 판독기와 기록기에 정의된 것과 같은 방식으로 수행
   됩니다.

"StreamRecoder" 인스턴스는 "StreamReader"와 "StreamWriter" 클래스가 결
합한 인터페이스를 정의합니다. 하부 스트림에서 다른 모든 메서드와 어트
리뷰트를 상속합니다.


인코딩과 유니코드
=================

문자열은 "U+0000"--"U+10FFFF" 범위의 코드 포인트 시퀀스로 내부적으로
저장됩니다. (구현에 대한 자세한 내용은 **PEP 393**을 참조하십시오.) 일
단 문자열 객체가 CPU와 메모리 외부에서 사용되면, 엔디안(endianness)과
이러한 배열이 바이트열로 저장되는 방식이 문제가 됩니다. 다른 코덱과 마
찬가지로, 문자열을 바이트 시퀀스로 직렬화하는 것을 *인코딩*이라고 하며
, 바이트 시퀀스에서 문자열을 다시 만드는 것을 *디코딩*이라고 합니다.
다양한 텍스트 직렬화 코덱이 있으며, 이를 집합적으로 *텍스트 인코딩*이
라고 합니다.

가장 간단한 텍스트 인코딩("'latin-1'" 또는 "'iso-8859-1'"이라고 합니다
)은 코드 포인트 0--255를 바이트 "0x0"--"0xff"로 매핑합니다. 이것은
"U+00FF" 위의 코드 포인트를 포함하는 문자열 객체는 이 코덱으로 인코딩
할 수 없음을 뜻합니다. 그렇게 하면 다음과 유사한 "UnicodeEncodeError"
가 발생합니다 (에러 메시지의 세부 사항은 다를 수 있습니다):
"UnicodeEncodeError: 'latin-1' codec can't encode character '\u1234'
in position 3: ordinal not in range(256)".

모든 유니코드 코드 포인트의 다른 부분 집합과 이러한 코드 포인트가 바이
트 "0x0"--"0xff"에 매핑되는 방식을 선택하는 또 다른 인코딩 그룹(소위
charmap 인코딩)이 있습니다. 이 작업을 수행하는 방법을 보려면 간단히 예
를 들어 "encodings/cp1252.py"(윈도우에서 주로 사용되는 인코딩)를 열어
보십시오. 어떤 문자가 어떤 바이트 값에 매핑되는지를 나타내는 256개의
문자로 구성된 문자열 상수가 있습니다.

All of these encodings can only encode 256 of the 1114112 code points
defined in Unicode. A simple and straightforward way that can store
each Unicode code point, is to store each code point as four
consecutive bytes. There are two possibilities: store the bytes in big
endian or in little endian order. These two encodings are called
"UTF-32-BE" and "UTF-32-LE" respectively. Their disadvantage is that
if, for example, you use "UTF-32-BE" on a little endian machine you
will always have to swap bytes on encoding and decoding. Python's
"UTF-16" and "UTF-32" codecs avoid this problem by using the
platform's native byte order when no BOM is present. Python follows
prevailing platform practice, so native-endian data round-trips
without redundant byte swapping, even though the Unicode Standard
defaults to big-endian when the byte order is unspecified. When these
bytes are read by a CPU with a different endianness, the bytes have to
be swapped. To be able to detect the endianness of a "UTF-16" or
"UTF-32" byte sequence, a BOM ("Byte Order Mark") is used. This is the
Unicode character "U+FEFF". This character can be prepended to every
"UTF-16" or "UTF-32" byte sequence. The byte swapped version of this
character ("0xFFFE") is an illegal character that may not appear in a
Unicode text. When the first character of a "UTF-16" or "UTF-32" byte
sequence is "U+FFFE", the bytes have to be swapped on decoding.

Unfortunately the character "U+FEFF" had a second purpose as a "ZERO
WIDTH NO-BREAK SPACE": a character that has no width and doesn't allow
a word to be split. It can e.g. be used to give hints to a ligature
algorithm. With Unicode 4.0 using "U+FEFF" as a "ZERO WIDTH NO-BREAK
SPACE" has been deprecated (with "U+2060" ("WORD JOINER") assuming
this role). Nevertheless Unicode software still must be able to handle
"U+FEFF" in both roles: as a BOM it's a device to determine the
storage layout of the encoded bytes, and vanishes once the byte
sequence has been decoded into a string; as a "ZERO WIDTH NO-BREAK
SPACE" it's a normal character that will be decoded like any other.

유니코드 문자의 전체 범위를 인코딩 할 수 있는 또 다른 인코딩이 있습니
다: UTF-8. UTF-8은 8비트 인코딩입니다. UTF-8에서는 바이트 순서에 관한
문제가 없음을 의미합니다. UTF-8 바이트 시퀀스의 각 바이트는 두 부분으
로 구성됩니다: 마커 비트(최상위 비트)와 페이로드 비트. 마커 비트는 0에
서 4개의 "1" 비트와 그 뒤에 "0"비트가 오는 시퀀스입니다. 유니코드 문자
는 다음과 같이 인코딩됩니다 (x는 페이로드 비트이며, 이어 붙이면 유니코
드 문자가 됩니다):

+-------------------------------------+------------------------------------------------+
| 범위                                | 인코딩                                         |
|=====================================|================================================|
| "U-00000000" ... "U-0000007F"       | 0xxxxxxx                                       |
+-------------------------------------+------------------------------------------------+
| "U-00000080" ... "U-000007FF"       | 110xxxxx 10xxxxxx                              |
+-------------------------------------+------------------------------------------------+
| "U-00000800" ... "U-0000FFFF"       | 1110xxxx 10xxxxxx 10xxxxxx                     |
+-------------------------------------+------------------------------------------------+
| "U-00010000" ... "U-0010FFFF"       | 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx            |
+-------------------------------------+------------------------------------------------+

유니코드 문자의 최하위 비트는 가장 오른쪽에 있는 x 비트입니다.

UTF-8은 8비트 인코딩이라서 BOM이 필요하지 않으며 디코딩된 문자열의 모
든 "U+FEFF" 문자(첫 번째 문자라 할지라도)는 "ZERO WIDTH NO-BREAK
SPACE"로 처리됩니다.

외부 정보 없이 문자열 인코딩에 사용된 인코딩을 신뢰성 있게 결정하는 것
은 불가능합니다. 각 charmap 인코딩은 모든 임의의 바이트 시퀀스를 디코
딩 할 수 있습니다. 그러나 UTF-8에서는 그렇지 않습니다, UTF-8 바이트 시
퀀스는 임의의 바이트 시퀀스를 허용하지 않는 구조를 갖기 때문입니다.
UTF-8 인코딩 감지의 신뢰성을 높이기 위해, Microsoft는 메모장(Notepad)
프로그램을 위해 UTF-8의 변형을 발명했습니다 (파이썬에서 ""utf-8-sig""
라고 부릅니다): 유니코드 문자를 파일에 쓰기 전에, UTF-8 인코딩된 BOM(
다음과 같은 바이트 시퀀스로 표시됩니다: "0xef", "0xbb", "0xbf")이 기록
됩니다. 모든 charmap 인코딩된 파일이 이러한 바이트 값으로 시작한다는
것은 다소 불가능하기 때문에 (예를 들어 iso-8859-1 에서 다음과 같은 것
으로 매핑됩니다

      LATIN SMALL LETTER I WITH DIAERESIS
      RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
      INVERTED QUESTION MARK

), 바이트 시퀀스에서 "utf-8-sig" 인코딩을 정확하게 추측할 수 있는 가능
성을 높입니다. 따라서 여기서 BOM은 바이트 시퀀스를 생성하는 데 사용되
는 바이트 순서를 결정할 수 있도록 하는데 사용되지는 않지만, 인코딩을
추측하는 데 도움이 되는 서명으로 사용됩니다. 인코딩할 때 utf-8-sig 코
덱은 "0xef", "0xbb", "0xbf"를 파일의 처음 3바이트로 기록합니다. 디코딩
할 때 "utf-8-sig"는 파일에서 처음 3바이트에 등장하면 이 3바이트를 건너
뜁니다. UTF-8에서는, BOM 사용을 권장하지 않으며 일반적으로 피해야 합니
다.


표준 인코딩
===========

Python comes with a number of codecs built-in, either implemented as C
functions or with dictionaries as mapping tables. The following table
lists the codecs by name, together with a few common aliases, and the
languages for which the encoding is likely used. Neither the list of
aliases nor the list of languages is meant to be exhaustive. Notice
that spelling alternatives that only differ in case or use a hyphen
instead of an underscore are also valid aliases because they are
equivalent when normalized by "normalize_encoding()". For example,
"'utf-8'" is a valid alias for the "'utf_8'" codec.

참고:

  The below table lists the most common aliases, for a complete list
  refer to the source aliases.py file.

On Windows, "cpXXX" codecs are available for all code pages. But only
codecs listed in the following table are guarantead to exist on other
platforms.

일부 공통 인코딩은 코덱 조회 메커니즘을 우회하여 성능을 향상할 수 있습
니다. 이러한 최적화 기회는 CPython에서만 제한된 (대소 문자를 구분하는)
별칭 집합에 대해서 인식됩니다:  utf-8, utf8, latin-1, latin1,
iso-8859-1, iso8859-1, mbcs (윈도우 전용), ascii, us-ascii, utf-16,
utf16, utf-32, utf32 및 대시 대신 밑줄을 사용한 것들. 이러한 인코딩에
대체 대안 별칭을 사용하면 실행 속도가 느려질 수 있습니다.

버전 3.6에서 변경: us-ascii에서 최적화 기회가 인식됩니다.

많은 문자 집합이 같은 언어를 지원합니다. 개별 문자(예를 들어 EURO SIGN
지원 여부)와 코드 위치에 문자를 대입하는 것에서 다릅니다. 특히 유럽 언
어의 경우, 일반적으로 다음과 같은 변형이 있습니다:

* ISO 8859 코드 집합

* Microsoft 윈도우 코드 페이지, 일반적으로 8859 코드 집합에서 파생되지
  만, 제어 문자를 추가 그래픽 문자로 대체합니다

* IBM EBCDIC 코드 페이지

* IBM PC 코드 페이지, ASCII와 호환됩니다

+-------------------+----------------------------------+----------------------------------+
| 코덱              | 별칭                             | 언어                             |
|===================|==================================|==================================|
| ascii             | 646, us-ascii                    | 영어                             |
+-------------------+----------------------------------+----------------------------------+
| big5              | big5-tw, csbig5                  | 중국어 번체                      |
+-------------------+----------------------------------+----------------------------------+
| big5hkscs         | big5-hkscs, hkscs                | 중국어 번체                      |
+-------------------+----------------------------------+----------------------------------+
| cp037             | IBM037, IBM039                   | 영어                             |
+-------------------+----------------------------------+----------------------------------+
| cp273             | 273, IBM273, csIBM273            | 독일어  Added in version 3.4.    |
+-------------------+----------------------------------+----------------------------------+
| cp424             | EBCDIC-CP-HE, IBM424             | 히브리어                         |
+-------------------+----------------------------------+----------------------------------+
| cp437             | 437, IBM437                      | 영어                             |
+-------------------+----------------------------------+----------------------------------+
| cp500             | EBCDIC-CP-BE, EBCDIC-CP-CH,      | 서유럽어                         |
|                   | IBM500                           |                                  |
+-------------------+----------------------------------+----------------------------------+
| cp720             |                                  | 아랍어                           |
+-------------------+----------------------------------+----------------------------------+
| cp737             |                                  | 그리스어                         |
+-------------------+----------------------------------+----------------------------------+
| cp775             | IBM775                           | 발트어                           |
+-------------------+----------------------------------+----------------------------------+
| cp850             | 850, IBM850                      | 서유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| cp852             | 852, IBM852                      | 중부와 동유럽어                  |
+-------------------+----------------------------------+----------------------------------+
| cp855             | 855, IBM855                      | 벨라루스어, 불가리아어, 마케도니 |
|                   |                                  | 아어, 러시아어, 세르비아어       |
+-------------------+----------------------------------+----------------------------------+
| cp856             |                                  | 히브리어                         |
+-------------------+----------------------------------+----------------------------------+
| cp857             | 857, IBM857                      | 터키어                           |
+-------------------+----------------------------------+----------------------------------+
| cp858             | 858, IBM858                      | 서유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| cp860             | 860, IBM860                      | 포르투갈어                       |
+-------------------+----------------------------------+----------------------------------+
| cp861             | 861, CP-IS, IBM861               | 아이슬란드어                     |
+-------------------+----------------------------------+----------------------------------+
| cp862             | 862, IBM862                      | 히브리어                         |
+-------------------+----------------------------------+----------------------------------+
| cp863             | 863, IBM863                      | 캐나다어                         |
+-------------------+----------------------------------+----------------------------------+
| cp864             | IBM864                           | 아랍어                           |
+-------------------+----------------------------------+----------------------------------+
| cp865             | 865, IBM865                      | 덴마크어, 노르웨이어             |
+-------------------+----------------------------------+----------------------------------+
| cp866             | 866, IBM866                      | 러시아어                         |
+-------------------+----------------------------------+----------------------------------+
| cp869             | 869, CP-GR, IBM869               | 그리스어                         |
+-------------------+----------------------------------+----------------------------------+
| cp874             |                                  | 태국어                           |
+-------------------+----------------------------------+----------------------------------+
| cp875             |                                  | 그리스어                         |
+-------------------+----------------------------------+----------------------------------+
| cp932             | 932, ms932, mskanji, ms-kanji,   | 일본어                           |
|                   | windows-31j                      |                                  |
+-------------------+----------------------------------+----------------------------------+
| cp949             | 949, ms949, uhc                  | 한국어                           |
+-------------------+----------------------------------+----------------------------------+
| cp950             | 950, ms950                       | 중국어 번체                      |
+-------------------+----------------------------------+----------------------------------+
| cp1006            |                                  | 우르두어                         |
+-------------------+----------------------------------+----------------------------------+
| cp1026            | ibm1026                          | 터키어                           |
+-------------------+----------------------------------+----------------------------------+
| cp1125            | 1125, ibm1125, cp866u, ruscii    | 우크라이나어  Added in version   |
|                   |                                  | 3.4.                             |
+-------------------+----------------------------------+----------------------------------+
| cp1140            | ibm1140                          | 서유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| cp1250            | windows-1250                     | 중부와 동유럽어                  |
+-------------------+----------------------------------+----------------------------------+
| cp1251            | windows-1251                     | 벨라루스어, 불가리아어, 마케도니 |
|                   |                                  | 아어, 러시아어, 세르비아어       |
+-------------------+----------------------------------+----------------------------------+
| cp1252            | windows-1252                     | 서유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| cp1253            | windows-1253                     | 그리스어                         |
+-------------------+----------------------------------+----------------------------------+
| cp1254            | windows-1254                     | 터키어                           |
+-------------------+----------------------------------+----------------------------------+
| cp1255            | windows-1255                     | 히브리어                         |
+-------------------+----------------------------------+----------------------------------+
| cp1256            | windows-1256                     | 아랍어                           |
+-------------------+----------------------------------+----------------------------------+
| cp1257            | windows-1257                     | 발트어                           |
+-------------------+----------------------------------+----------------------------------+
| cp1258            | windows-1258                     | 베트남어                         |
+-------------------+----------------------------------+----------------------------------+
| euc_jp            | eucjp, ujis, u-jis               | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| euc_jis_2004      | jisx0213, eucjis2004             | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| euc_jisx0213      | eucjisx0213                      | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| euc_kr            | euckr, korean, ksc5601,          | 한국어                           |
|                   | ks_c-5601, ks_c-5601-1987,       |                                  |
|                   | ksx1001, ks_x-1001               |                                  |
+-------------------+----------------------------------+----------------------------------+
| gb2312            | chinese, csiso58gb231280, euc-   | 중국어 간체                      |
|                   | cn, euccn, eucgb2312-cn,         |                                  |
|                   | gb2312-1980, gb2312-80, iso-     |                                  |
|                   | ir-58                            |                                  |
+-------------------+----------------------------------+----------------------------------+
| gbk               | 936, cp936, ms936                | 통합 중국어                      |
+-------------------+----------------------------------+----------------------------------+
| gb18030           | gb18030-2000                     | 통합 중국어                      |
+-------------------+----------------------------------+----------------------------------+
| hz                | hzgb, hz-gb, hz-gb-2312          | 중국어 간체                      |
+-------------------+----------------------------------+----------------------------------+
| iso2022_jp        | csiso2022jp, iso2022jp,          | 일본어                           |
|                   | iso-2022-jp                      |                                  |
+-------------------+----------------------------------+----------------------------------+
| iso2022_jp_1      | iso2022jp-1, iso-2022-jp-1       | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| iso2022_jp_2      | iso2022jp-2, iso-2022-jp-2       | 일본어, 한국어, 중국어 간체, 서  |
|                   |                                  | 유럽어, 그리스어                 |
+-------------------+----------------------------------+----------------------------------+
| iso2022_jp_2004   | iso2022jp-2004, iso-2022-jp-2004 | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| iso2022_jp_3      | iso2022jp-3, iso-2022-jp-3       | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| iso2022_jp_ext    | iso2022jp-ext, iso-2022-jp-ext   | 일본어                           |
+-------------------+----------------------------------+----------------------------------+
| iso2022_kr        | csiso2022kr, iso2022kr,          | 한국어                           |
|                   | iso-2022-kr                      |                                  |
+-------------------+----------------------------------+----------------------------------+
| latin_1           | iso-8859-1, iso8859-1, 8859,     | 서유럽어                         |
|                   | cp819, latin, latin1, L1         |                                  |
+-------------------+----------------------------------+----------------------------------+
| iso8859_2         | iso-8859-2, latin2, L2           | 중부와 동유럽어                  |
+-------------------+----------------------------------+----------------------------------+
| iso8859_3         | iso-8859-3, latin3, L3           | 에스페란토어, 몰타어             |
+-------------------+----------------------------------+----------------------------------+
| iso8859_4         | iso-8859-4, latin4, L4           | Northern Europe                  |
+-------------------+----------------------------------+----------------------------------+
| iso8859_5         | iso-8859-5, cyrillic             | 벨라루스어, 불가리아어, 마케도니 |
|                   |                                  | 아어, 러시아어, 세르비아어       |
+-------------------+----------------------------------+----------------------------------+
| iso8859_6         | iso-8859-6, arabic               | 아랍어                           |
+-------------------+----------------------------------+----------------------------------+
| iso8859_7         | iso-8859-7, greek, greek8        | 그리스어                         |
+-------------------+----------------------------------+----------------------------------+
| iso8859_8         | iso-8859-8, hebrew               | 히브리어                         |
+-------------------+----------------------------------+----------------------------------+
| iso8859_9         | iso-8859-9, latin5, L5           | 터키어                           |
+-------------------+----------------------------------+----------------------------------+
| iso8859_10        | iso-8859-10, latin6, L6          | 북유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| iso8859_11        | iso-8859-11, thai                | 태국어                           |
+-------------------+----------------------------------+----------------------------------+
| iso8859_13        | iso-8859-13, latin7, L7          | 발트어                           |
+-------------------+----------------------------------+----------------------------------+
| iso8859_14        | iso-8859-14, latin8, L8          | 켈틱어                           |
+-------------------+----------------------------------+----------------------------------+
| iso8859_15        | iso-8859-15, latin9, L9          | 서유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| iso8859_16        | iso-8859-16, latin10, L10        | 남유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| johab             | cp1361, ms1361                   | 한국어                           |
+-------------------+----------------------------------+----------------------------------+
| koi8_r            |                                  | 러시아어                         |
+-------------------+----------------------------------+----------------------------------+
| koi8_t            |                                  | 타지크어  Added in version 3.5.  |
+-------------------+----------------------------------+----------------------------------+
| koi8_u            |                                  | 우크라이나어                     |
+-------------------+----------------------------------+----------------------------------+
| kz1048            | kz_1048, strk1048_2002, rk1048   | 카자흐어  Added in version 3.5.  |
+-------------------+----------------------------------+----------------------------------+
| mac_cyrillic      | maccyrillic                      | 벨라루스어, 불가리아어, 마케도니 |
|                   |                                  | 아어, 러시아어, 세르비아어       |
+-------------------+----------------------------------+----------------------------------+
| mac_greek         | macgreek                         | 그리스어                         |
+-------------------+----------------------------------+----------------------------------+
| mac_iceland       | maciceland                       | 아이슬란드어                     |
+-------------------+----------------------------------+----------------------------------+
| mac_latin2        | maclatin2, maccentraleurope,     | 중부와 동유럽어                  |
|                   | mac_centeuro                     |                                  |
+-------------------+----------------------------------+----------------------------------+
| mac_roman         | macroman, macintosh              | 서유럽어                         |
+-------------------+----------------------------------+----------------------------------+
| mac_turkish       | macturkish                       | 터키어                           |
+-------------------+----------------------------------+----------------------------------+
| ptcp154           | csptcp154, pt154, cp154,         | 카자흐어                         |
|                   | cyrillic-asian                   |                                  |
+-------------------+----------------------------------+----------------------------------+
| shift_jis         | csshiftjis, shiftjis, sjis,      | 일본어                           |
|                   | s_jis                            |                                  |
+-------------------+----------------------------------+----------------------------------+
| shift_jis_2004    | shiftjis2004, sjis_2004,         | 일본어                           |
|                   | sjis2004                         |                                  |
+-------------------+----------------------------------+----------------------------------+
| shift_jisx0213    | shiftjisx0213, sjisx0213,        | 일본어                           |
|                   | s_jisx0213                       |                                  |
+-------------------+----------------------------------+----------------------------------+
| utf_32            | U32, utf32                       | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_32_be         | UTF-32BE                         | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_32_le         | UTF-32LE                         | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_16            | U16, utf16                       | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_16_be         | UTF-16BE                         | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_16_le         | UTF-16LE                         | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_7             | U7, unicode-1-1-utf-7            | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_8             | U8, UTF, utf8, cp65001           | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+
| utf_8_sig         |                                  | 모든 언어                        |
+-------------------+----------------------------------+----------------------------------+

버전 3.4에서 변경: utf-16* 과 utf-32* 인코더는 더는 서로게이트 코드 포
인트("U+D800"--"U+DFFF")를 인코딩할 수 없습니다. utf-32* 디코더는 더는
서로게이트 코드 포인트에 해당하는 바이트 시퀀스를 디코딩하지 않습니다.

버전 3.8에서 변경: "cp65001"은 이제 "utf_8"의 별칭입니다.

버전 3.14에서 변경: On Windows, "cpXXX" codecs are now available for
all code pages.


파이썬 특정 인코딩
==================

사전 정의된 많은 코덱이 파이썬에만 해당하여, 코덱 이름은 파이썬 외부에
서 의미가 없습니다. 예상되는 입력과 출력형에 따라 아래 표에 나열되어
있습니다 (텍스트 인코딩은 코덱의 가장 일반적인 사용 사례이지만, 하부
코덱 인프라는 단지 텍스트 인코딩이 아닌 임의의 데이터 변환을 지원합니
다). 비대칭 코덱의 경우, 언급된 의미는 인코딩 방향을 설명합니다.


텍스트 인코딩
-------------

다음 코덱은 유니코드 텍스트 인코딩과 유사하게, "str"에서 "bytes"로의
인코딩과 *바이트열류 객체*에서 "str"로의 디코딩을 제공합니다.

+----------------------+-----------+-----------------------------+
| 코덱                 | 별칭      | 의미                        |
|======================|===========|=============================|
| idna                 |           | **RFC 3490**을 구현합니다.  |
|                      |           | "encodings.idna"도 참조하십 |
|                      |           | 시오. "errors='strict'"만   |
|                      |           | 지원됩니다.                 |
+----------------------+-----------+-----------------------------+
| mbcs                 | ansi,     | 윈도우 전용: ANSI 코드 페이 |
|                      | dbcs      | 지(CP_ACP)에 따라 피연산자  |
|                      |           | 를 인코딩합니다.            |
+----------------------+-----------+-----------------------------+
| oem                  |           | 윈도우 전용: OEM 코드 페이  |
|                      |           | 지(CP_OEMCP)에 따라 피연산  |
|                      |           | 자를 인코딩합니다.  Added   |
|                      |           | in version 3.6.             |
+----------------------+-----------+-----------------------------+
| palmos               |           | PalmOS 3.5의 인코딩.        |
+----------------------+-----------+-----------------------------+
| punycode             |           | **RFC 3492**를 구현합니다.  |
|                      |           | 상태 있는 코덱은 지원되지   |
|                      |           | 않습니다.                   |
+----------------------+-----------+-----------------------------+
| raw_unicode_escape   |           | 다른 코드 포인트를 위해     |
|                      |           | "\u*XXXX*"와 "\U*XXXXXXXX*" |
|                      |           | 를 사용하는 Latin-1 인코딩. |
|                      |           | 기존 역 슬래시는 어떤 방식  |
|                      |           | 으로도 이스케이프 되지 않습 |
|                      |           | 니다. 파 이썬 피클 프로토콜 |
|                      |           | 에서 사용됩니다.            |
+----------------------+-----------+-----------------------------+
| undefined            |           | This Codec should only be   |
|                      |           | used for testing purposes.  |
|                      |           | 모든 변환에 대해 예외를 발  |
|                      |           | 생시킵니다, 빈 문자열조차.  |
|                      |           | 에러 처리기는 무 시됩니다.  |
+----------------------+-----------+-----------------------------+
| unicode_escape       |           | 따옴표가 이스케이프 되지 않 |
|                      |           | 는 것을 제외하고, ASCII로   |
|                      |           | 인코딩된 파이썬 소스 코드에 |
|                      |           | 서 유니코드 리터럴 내용으로 |
|                      |           | 적합한 인코딩. Latin-1 소스 |
|                      |           | 코 드에서 디코딩합니다. 파  |
|                      |           | 이썬 소스 코드는 실제로는   |
|                      |           | 기본적으로 UTF-8을 사 용합  |
|                      |           | 니다.                       |
+----------------------+-----------+-----------------------------+

버전 3.8에서 변경: "unicode_internal" 코덱이 제거되었습니다.


바이너리 변환
-------------

다음 코덱은 바이너리 변환을 제공합니다: *바이트열류 객체*에서 "bytes"
로의 매핑.  ("str" 출력만 생성하는) "bytes.decode()"에서는 지원되지 않
습니다.

+------------------------+--------------------+--------------------------------+--------------------------------+
| 코덱                   | 별칭               | 의미                           | 인코더 / 디코더                |
|========================|====================|================================|================================|
| base64_codec [1]       | base64, base_64    | 피연산자를 여러 줄 MIME base64 | "base64.encodebytes()" /       |
|                        |                    | 로 변환합니다 (결과에는 항상   | "base64.decodebytes()"         |
|                        |                    | 후행 "'\n'" 이 포함됩니다).    |                                |
|                        |                    | 버전 3.4에서 변경: 인코딩과 디 |                                |
|                        |                    | 코딩을 위해 모든 *바이트열류   |                                |
|                        |                    | 객체*를 입 력으로 받아들입니다 |                                |
|                        |                    | .                              |                                |
+------------------------+--------------------+--------------------------------+--------------------------------+
| bz2_codec              | bz2                | bz2를 사용하여 피연산자를 압축 | "bz2.compress()" /             |
|                        |                    | 합니다.                        | "bz2.decompress()"             |
+------------------------+--------------------+--------------------------------+--------------------------------+
| hex_codec              | hex                | 바이트 당 두 자리 숫자를 사용  | "binascii.b2a_hex()" /         |
|                        |                    | 하여, 피연산자를 16진 표현으로 | "binascii.a2b_hex()"           |
|                        |                    | 변환합니다 .                   |                                |
+------------------------+--------------------+--------------------------------+--------------------------------+
| quopri_codec           | quopri,            | 피연산자를 MIME quoted         | "quotetabs=True"를 사용한      |
|                        | quotedprintable,   | printable로 변환합니다.        | "quopri.encode()" /            |
|                        | quoted_printable   |                                | "quopri.decode()"              |
+------------------------+--------------------+--------------------------------+--------------------------------+
| uu_codec               | uu                 | uuencode를 사용하여 피연산자를 |                                |
|                        |                    | 변환합니다.                    |                                |
+------------------------+--------------------+--------------------------------+--------------------------------+
| zlib_codec             | zip, zlib          | gzip을 사용하여 피연산자를 압  | "zlib.compress()" /            |
|                        |                    | 축합니다.                      | "zlib.decompress()"            |
+------------------------+--------------------+--------------------------------+--------------------------------+

[1] "'base64_codec'"는 *바이트열류 객체* 외에도 디코딩을 위해 ASCII만
    있는 "str" 인스턴스도 허용합니다.

Added in version 3.2: 바이너리 변환의 복원.

버전 3.4에서 변경: 바이너리 변환에 대한 별칭의 복원.


Standalone Codec Functions
--------------------------

The following functions provide encoding and decoding functionality
similar to codecs, but are not available as named codecs through
"codecs.encode()" or "codecs.decode()". They are used internally (for
example, by "pickle") and behave similarly to the "string_escape"
codec that was removed in Python 3.

codecs.escape_encode(input, errors=None)

   Encode *input* using escape sequences. Similar to how "repr()" on
   bytes produces escaped byte values.

   *input* must be a "bytes" object.

   Returns a tuple "(output, length)" where *output* is a "bytes"
   object and *length* is the number of bytes consumed.

codecs.escape_decode(input, errors=None)

   Decode *input* from escape sequences back to the original bytes.

   *input* must be a *bytes-like object*.

   Returns a tuple "(output, length)" where *output* is a "bytes"
   object and *length* is the number of bytes consumed.


텍스트 변환
-----------

다음 코덱은 텍스트 변환을 제공합니다: "str"에서 "str"로의 매핑.
("bytes" 출력만 생성하는) "str.encode()"에서는 지원되지 않습니다.

+----------------------+-----------+-----------------------------+
| 코덱                 | 별칭      | 의미                        |
|======================|===========|=============================|
| rot_13               | rot13     | 피연산자의 시저 암호        |
|                      |           | (Caesar-cypher) 암호화를 반 |
|                      |           | 환합니다.                   |
+----------------------+-----------+-----------------------------+

Added in version 3.2: "rot_13" 텍스트 변환 복원.

버전 3.4에서 변경: "rot13" 별칭 복원.


"encodings" --- Encodings package
=================================

This module implements the following functions:

encodings.normalize_encoding(encoding)

   Normalize encoding name *encoding*.

   Normalization works as follows: all non-alphanumeric characters
   except the dot used for Python package names are collapsed and
   replaced with a single underscore, leading and trailing underscores
   are removed. For example, "'  -;#'" becomes "'_'".

   Note that *encoding* should be ASCII only.

참고:

  The following functions should not be used directly, except for
  testing purposes; "codecs.lookup()" should be used instead.

encodings.search_function(encoding)

   Search for the codec module corresponding to the given encoding
   name *encoding*.

   This function first normalizes the *encoding* using
   "normalize_encoding()", then looks for a corresponding alias. It
   attempts to import a codec module from the encodings package using
   either the alias or the normalized name. If the module is found and
   defines a valid "getregentry()" function that returns a
   "codecs.CodecInfo" object, the codec is cached and returned.

   If the codec module defines a "getaliases()" function any returned
   aliases are registered for future use.

encodings.win32_code_page_search_function(encoding)

   Search for a Windows code page encoding *encoding* of the form
   "cpXXXX".

   If the code page is valid and supported, return a
   "codecs.CodecInfo" object for it.

   가용성: Windows.

   Added in version 3.14.

This module implements the following exception:

exception encodings.CodecRegistryError

   Raised when a codec is invalid or incompatible.


"encodings.idna" --- 응용 프로그램에서의 국제화된 도메인 이름
=============================================================

이 모듈은 **RFC 3490**(Internationalized Domain Names in Applications)
과 **RFC 3492**(Nameprep: A Stringprep Profile for Internationalized
Domain Names (IDN))를 구현합니다. "punycode" 인코딩과 "stringprep"을
기반으로 합니다.

If you need the IDNA 2008 standard from **RFC 5891** and **RFC 5895**,
use the third-party idna module.

이 RFC는 함께 도메인 이름에서 비 ASCII 문자를 지원하는 프로토콜을 정의
합니다. 비 ASCII 문자(가령 "www.Alliancefrançaise.nu")를 포함하는 도메
인 이름은 ASCII 호환 인코딩(ACE, 가령 "www.xn--alliancefranaise-
npb.nu")으로 변환됩니다. 그런 다음 도메인 이름의 ACE 형식은 DNS 조회,
HTTP *Host* 필드 등과 같이 프로토콜에 의해 임의의 문자가 허용되지 않는
모든 위치에서 사용됩니다. 이 변환은 응용 프로그램에서 수행됩니다; 가능
하다면 사용자에게 보이지 않습니다: 응용 프로그램은 전송 시에 유니코드
도메인 레이블을 투명하게 IDNA로 변환하고, 사용자에게 표시하기 전에 ACE
레이블을 다시 유니코드로 변환해야 합니다.

파이썬은 여러 가지 방식으로 이 변환을 지원합니다: "idna" 코덱은 유니코
드와 ACE 간의 변환을 수행하여, **RFC 3490의 섹션 3.1**에 정의된 구분
문자를 기반으로 입력 문자열을 레이블로 분리하고 필요에 따라 각 레이블
을 ACE로 변환하고, 반대로 입력 바이트 문자열을 "." 구분 기호를 기반으
로 레이블로 분리하고 모든 ACE 레이블을 유니코드로 변환합니다. 또한,
"socket" 모듈은 유니코드 호스트 이름을 투명하게 ACE로 변환하므로, 응용
프로그램이 호스트 이름을 소켓 모듈로 전달할 때 호스트 이름 자체를 변환
할 필요가 없습니다. 이에 더해, "http.client"와 "ftplib"와 같은, 함수
매개 변수로 호스트 이름이 있는 모듈은 유니코드 호스트 이름을 받아들입
니다 ("http.client"는 해당 필드를 전송한다면 *Host* 필드에 IDNA 호스트
이름을 투명하게 전송합니다).

회선에서 호스트 이름을 수신할 때 (가령 역 이름 조회(reverse name
lookup)에서), 유니코드로 자동 변환되지 않습니다: 이러한 호스트 이름을
사용자에게 제시하려는 응용 프로그램은 유니코드로 디코딩해야 합니다.

또한 모듈 "encodings.idna"는 nameprep 절차를 구현합니다. 이는 국제 도
메인 이름의 대소 문자를 구분하지 않고 유사한 문자를 통합하기 위해 호스
트 이름에 대해 특정 정규화를 수행합니다. 원한다면 nameprep 함수를 직접
사용할 수 있습니다.

encodings.idna.nameprep(label)

   *label*의 nameprep 된 버전을 반환합니다. 구현은 현재 쿼리 문자열을
   가정하므로, "AllowUnassigned"는 참입니다.

encodings.idna.ToASCII(label)

   **RFC 3490**에 지정된 대로 레이블을 ASCII로 변환합니다.
   "UseSTD3ASCIIRules"는 거짓으로 가정합니다.

encodings.idna.ToUnicode(label)

   **RFC 3490**에 지정된 대로 레이블을 유니코드로 변환합니다.


"encodings.mbcs" --- 윈도우 ANSI 코드 페이지
============================================

이 모듈은 ANSI 코드 페이지(CP_ACP)를 구현합니다.

가용성: Windows.

버전 3.2에서 변경: 3.2 이전에는, *errors* 인자가 무시되었습니다; 인코
딩에는 항상 "'replace'"가 사용되고, 디코딩에는 항상 "'ignore'"가 사용
되었습니다.

버전 3.3에서 변경: 모든 에러 처리기를 지원합니다.


"encodings.utf_8_sig" --- BOM 서명이 있는 UTF-8 코덱
====================================================

이 모듈은 UTF-8 코덱의 변형을 구현합니다. 인코딩 시, UTF-8로 인코딩된
BOM을 UTF-8로 인코딩된 바이트열 앞에 붙입니다. 상태 있는 인코더의 경우
이 작업은 한 번만 수행됩니다 (바이트 스트림에 대한 첫 번째 쓰기 시).
디코딩 시, 데이터 시작에 있는 선택적 UTF-8 인코딩된 BOM을 건너뜁니다.
