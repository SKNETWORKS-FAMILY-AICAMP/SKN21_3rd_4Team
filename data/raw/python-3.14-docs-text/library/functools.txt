"functools" --- 고차 함수와 콜러블 객체에 대한 연산
***************************************************

**소스 코드:** Lib/functools.py

======================================================================

"functools" 모듈은 고차 함수를 위한 것입니다: 다른 함수에 작용하거나
다른 함수를 반환하는 함수. 일반적으로, 모든 콜러블 객체는 이 모듈의 목
적상 함수로 취급될 수 있습니다.

"functools" 모듈은 다음 함수를 정의합니다:

@functools.cache(user_function)

   단순하고 가벼운 무제한 함수 캐시. 때때로 "memoize"라고도 합니다.

   "lru_cache(maxsize=None)"와 같은 것을 반환하여, 함수 인자의 딕셔너
   리 조회 주위로 얇은 래퍼를 만듭니다. 이전 값을 제거할 필요가 없어서
   , 크기 제한이 있는 "lru_cache()"보다 작고 빠릅니다.

   예를 들면:

      @cache
      def factorial(n):
          return n * factorial(n-1) if n else 1

      >>> factorial(10)   # no previously cached result, makes 11 recursive calls
      3628800
      >>> factorial(5)    # no new calls, just returns the cached result
      120
      >>> factorial(12)   # two new recursive calls, factorial(10) is cached
      479001600

   The cache is threadsafe so that the wrapped function can be used in
   multiple threads.  This means that the underlying data structure
   will remain coherent during concurrent updates.

   It is possible for the wrapped function to be called more than once
   if another thread makes an additional call before the initial call
   has been completed and cached.

   Added in version 3.9.

@functools.cached_property(func)

   클래스의 메서드를 값이 한 번 계산된 다음 인스턴스 수명 동안 일반 어
   트리뷰트로 캐시 되는 프로퍼티로 변환합니다. "property()"와 유사하고
   , 캐싱이 추가되었습니다. 비싸게 계산되고 그 외에는 사실상 불변인 인
   스턴스의 프로퍼티에 유용합니다.

   예:

      class DataSet:

          def __init__(self, sequence_of_numbers):
              self._data = tuple(sequence_of_numbers)

          @cached_property
          def stdev(self):
              return statistics.stdev(self._data)

   "cached_property()"의 메커니즘은 "property()"와 다소 다릅니다. 일반
   프로퍼티는 setter가 정의되지 않은 경우 어트리뷰트 쓰기를 차단합니다
   . 이와는 달리, *cached_property*는 쓰기를 허용합니다.

   *cached_property* 데코레이터는 조회 시에만, 같은 이름의 어트리뷰트
   가 존재하지 않을 때만 실행됩니다. 실행되면, *cached_property*는 같
   은 이름의 어트리뷰트에 기록합니다. 후속 어트리뷰트 읽기와 쓰기는
   *cached_property* 메서드보다 우선하며 일반 어트리뷰트처럼 작동합니
   다.

   캐시 된 값은 어트리뷰트를 삭제하여 지울 수 있습니다. 이렇게 하면
   *cached_property* 메서드가 다시 실행됩니다.

   The *cached_property* does not prevent a possible race condition in
   multi-threaded usage. The getter function could run more than once
   on the same instance, with the latest run setting the cached value.
   If the cached property is idempotent or otherwise not harmful to
   run more than once on an instance, this is fine. If synchronization
   is needed, implement the necessary locking inside the decorated
   getter function or around the cached property access.

   이 데코레이터는 **PEP 412** 키 공유 딕셔너리의 작동을 방해함에 유의
   하십시오. 이는 인스턴스 딕셔너리가 평소보다 더 많은 공간을 차지할
   수 있음을 의미합니다.

   또한, 이 데코레이터는 각 인스턴스의 "__dict__" 어트리뷰트가 가변 매
   핑일 것을 요구합니다. 이는 메타 클래스(형 인스턴스의 "__dict__" 어
   트리뷰트가 클래스 이름 공간에 대한 읽기 전용 프락시이기 때문에)와
   "__dict__"를 정의된 슬롯 중 하나로 포함하지 않고 "__slots__"를 지정
   하는 것(이러한 클래스는 "__dict__" 어트리뷰트를 전혀 제공하지 않기
   때문에)과 같은 일부 형에서 작동하지 않음을 의미합니다.

   가변 매핑을 사용할 수 없거나 공간 효율적인 키 공유가 필요하면,
   "lru_cache()" 위에 "property()"를 쌓아서 "cached_property()"와 유사
   한 효과를 얻을 수도 있습니다. 이것이 "cached_property()"와 어떻게
   다른지에 관한 자세한 내용은 How do I cache method calls?을 찹조하세
   요.

   Added in version 3.8.

   버전 3.12에서 변경: Prior to Python 3.12, "cached_property"
   included an undocumented lock to ensure that in multi-threaded
   usage the getter function was guaranteed to run only once per
   instance. However, the lock was per-property, not per-instance,
   which could result in unacceptably high lock contention. In Python
   3.12+ this locking is removed.

functools.cmp_to_key(func)

   구식 비교 함수를 *키 함수*로 변환합니다. ("sorted()", "min()",
   "max()", "heapq.nlargest()", "heapq.nsmallest()",
   "itertools.groupby()"와 같은) 키 함수를 받아들이는 도구와 함께 사용
   됩니다. 이 함수는 주로 비교 함수 사용을 지원하는 파이썬 2에서 변환
   되는 프로그램의 전이 도구로 사용됩니다.

   비교 함수는 두 개의 인자를 받아들이고, 그들을 비교하여, 작으면 음수
   , 같으면 0, 크면 양수를 반환하는 콜러블입니다. 키 함수는 하나의 인
   자를 받아들이고 정렬 키로 사용할 다른 값을 반환하는 콜러블입니다.

   예:

      sorted(iterable, key=cmp_to_key(locale.strcoll))  # 로케일을 고려한 정렬 순서

   정렬 예제와 간략한 정렬 자습서는 정렬 기법를 참조하십시오.

   Added in version 3.2.

@functools.lru_cache(user_function)
@functools.lru_cache(maxsize=128, typed=False)

   가장 최근의 *maxsize* 호출까지 저장하는 기억하는(memoizing) 콜러블
   함수를 감싸는 데코레이터. 비싸거나 I/O 병목 함수가 같은 인자로 주기
   적으로 호출될 때 시간을 절약할 수 있습니다.

   The cache is threadsafe so that the wrapped function can be used in
   multiple threads.  This means that the underlying data structure
   will remain coherent during concurrent updates.

   It is possible for the wrapped function to be called more than once
   if another thread makes an additional call before the initial call
   has been completed and cached.

   결과를 캐시 하는 데 딕셔너리가 사용되기 때문에, 함수에 대한 위치와
   키워드 인자는 *해시 가능*해야 합니다.

   서도 다른 인자 패턴은 별도의 캐시 항목을 갖는 별개의 호출로 간주할
   수 있습니다. 예를 들어, "f(a=1, b=2)"와 "f(b=2, a=1)"은 키워드 인자
   순서가 다르며 두 개의 개별 캐시 항목을 가질 수 있습니다.

   *user_function*이 지정되면, 콜러블이어야 합니다. 이는 *lru_cache*
   데코레이터를 사용자 함수에 직접 적용 할 수 있도록 하며, *maxsize*를
   기본값 128로 유지합니다:

      @lru_cache
      def count_vowels(sentence):
          return sum(sentence.count(vowel) for vowel in 'AEIOUaeiou')

   *maxsize*가 "None"으로 설정되면, LRU 기능이 비활성화되고 캐시가 제
   한 없이 커질 수 있습니다.

   If *typed* is set to true, function arguments of different types
   will be cached separately.  If *typed* is false, the implementation
   will usually regard them as equivalent calls and only cache a
   single result. (Some types such as *str* and *int* may be cached
   separately even when *typed* is false.)

   Note, type specificity applies only to the function's immediate
   arguments rather than their contents.  The scalar arguments,
   "Decimal(42)" and "Fraction(42)" are be treated as distinct calls
   with distinct results. In contrast, the tuple arguments "('answer',
   Decimal(42))" and "('answer', Fraction(42))" are treated as
   equivalent.

   래핑 된 함수는 *maxsize*와 *typed*의 값을 표시하는 새 "dict"를 반환
   하는 "cache_parameters()" 함수로 인스트루먼트 됩니다. 이것은 정보
   제공만을 위한 것입니다. 값을 변경해도 효과가 없습니다.

   To help measure the effectiveness of the cache and tune the
   *maxsize* parameter, the wrapped function is instrumented with a
   "cache_info()" function that returns a *named tuple* showing
   *hits*, *misses*, *maxsize* and *currsize*.

   The decorator also provides a "cache_clear()" function for clearing
   or invalidating the cache.

   원래의 하부 함수는 "__wrapped__" 어트리뷰트를 통해 액세스 할 수 있
   습니다. 이것은 인트로스펙션, 캐시 우회 또는 다른 캐시로 함수를 다시
   래핑하는 데 유용합니다.

   The cache keeps references to the arguments and return values until
   they age out of the cache or until the cache is cleared.

   If a method is cached, the "self" instance argument is included in
   the cache.  See How do I cache method calls?

   LRU (least recently used) 캐시는 가장 최근 호출이 향후 호출에 대한
   최상의 예측일 때 가장 잘 작동합니다 (예를 들어, 뉴스 서버에서 가장
   인기 있는 기사는 매일 바뀌는 경향이 있습니다). 캐시의 크기 제한은
   웹 서버와 같은 오래 실행되는 프로세스에서 제한 없이 캐시가 커지지
   않도록 합니다.

   일반적으로, LRU 캐시는 이전에 계산된 값을 재사용하려고 할 때만 사용
   해야 합니다. 따라서, 부작용이 있는 함수, 각 호출에서 고유한 가변 객
   체를 만들어야 하는 함수 (가령 제너레이터와 비동기 함수), time()이나
   random()과 같은 비순수(impure) 함수를 캐시 하는 것은 의미가 없습니
   다.

   정적 웹 콘텐츠를 위한 LRU 캐시의 예:

      @lru_cache(maxsize=32)
      def get_pep(num):
          'PEP(Python Enhancement Proposal) 텍스트를 가져옵니다'
          resource = f'https://peps.python.org/pep-{num:04d}'
          try:
              with urllib.request.urlopen(resource) as s:
                  return s.read()
          except urllib.error.HTTPError:
              return 'Not Found'

      >>> for n in 8, 290, 308, 320, 8, 218, 320, 279, 289, 320, 9991:
      ...     pep = get_pep(n)
      ...     print(n, len(pep))

      >>> get_pep.cache_info()
      CacheInfo(hits=3, misses=8, maxsize=32, currsize=8)

   동적 프로그래밍(dynamic programming) 기법을 구현하기 위해 캐시를 사
   용하여 피보나치 수를 효율적으로 계산하는 예:

      @lru_cache(maxsize=None)
      def fib(n):
          if n < 2:
              return n
          return fib(n-1) + fib(n-2)

      >>> [fib(n) for n in range(16)]
      [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610]

      >>> fib.cache_info()
      CacheInfo(hits=28, misses=16, maxsize=None, currsize=16)

   Added in version 3.2.

   버전 3.3에서 변경: *typed* 옵션을 추가했습니다.

   버전 3.8에서 변경: *user_function* 옵션을 추가했습니다.

   버전 3.9에서 변경: "cache_parameters()" 함수를 추가했습니다

@functools.total_ordering

   하나 이상의 풍부한 비교(rich comparison) 순서 메서드를 정의하는 클
   래스를 주면, 이 클래스 데코레이터가 나머지를 제공합니다. 가능한 모
   든 풍부한 비교 연산을 지정하는 데 드는 노력이 단순화됩니다:

   The class must define one of "__lt__()", "__le__()", "__gt__()", or
   "__ge__()". In addition, the class should supply an "__eq__()"
   method.

   예를 들면:

      @total_ordering
      class Student:
          def _is_valid_operand(self, other):
              return (hasattr(other, "lastname") and
                      hasattr(other, "firstname"))
          def __eq__(self, other):
              if not self._is_valid_operand(other):
                  return NotImplemented
              return ((self.lastname.lower(), self.firstname.lower()) ==
                      (other.lastname.lower(), other.firstname.lower()))
          def __lt__(self, other):
              if not self._is_valid_operand(other):
                  return NotImplemented
              return ((self.lastname.lower(), self.firstname.lower()) <
                      (other.lastname.lower(), other.firstname.lower()))

   참고:

     이 데코레이터를 사용하면 올바르게 동작하는 전 순서(totally
     ordered) 형을 쉽게 만들 수 있지만, 파생된 비교 메서드에서 실행 속
     도가 느려지고 스택 트레이스가 더 복잡해지는 대가를 지불합니다. 성
     능 벤치마킹이 이것이 특정 응용 프로그램의 병목임을 가리키면, 6가
     지의 풍부한 비교 메서드를 모두 구현하여 속도를 쉽게 높일 수 있습
     니다.

   참고:

     This decorator makes no attempt to override methods that have
     been declared in the class *or its superclasses*. Meaning that if
     a superclass defines a comparison operator, *total_ordering* will
     not implement it again, even if the original method is abstract.

   Added in version 3.2.

   버전 3.4에서 변경: 인식할 수 없는 형에 대해 하부 비교 함수에서
   "NotImplemented"를 반환하는 것이 이제 지원됩니다.

functools.Placeholder

   A singleton object used as a sentinel to reserve a place for
   positional arguments when calling "partial()" and
   "partialmethod()".

   Added in version 3.14.

functools.partial(func, /, *args, **keywords)

   호출될 때 위치 인자 *args*와 키워드 인자 *keywords*로 호출된 *func*
   처럼 동작하는 새 partial 객체를 반환합니다. 더 많은 인자가 호출에
   제공되면, *args*에 추가됩니다. 추가 키워드 인자가 제공되면,
   *keywords*를 확장하고 대체합니다. 대략 다음과 동등합니다:

      def partial(func, /, *args, **keywords):
          def newfunc(*more_args, **more_keywords):
              return func(*args, *more_args, **(keywords | more_keywords))
          newfunc.func = func
          newfunc.args = args
          newfunc.keywords = keywords
          return newfunc

   The "partial()" function is used for partial function application
   which "freezes" some portion of a function's arguments and/or
   keywords resulting in a new object with a simplified signature.
   For example, "partial()" can be used to create a callable that
   behaves like the "int()" function where the *base* argument
   defaults to "2":

      >>> basetwo = partial(int, base=2)
      >>> basetwo.__doc__ = 'Convert base 2 string to an int.'
      >>> basetwo('10010')
      18

   If "Placeholder" sentinels are present in *args*, they will be
   filled first when "partial()" is called. This makes it possible to
   pre-fill any positional argument with a call to "partial()";
   without "Placeholder", only the chosen number of leading positional
   arguments can be pre-filled.

   If any "Placeholder" sentinels are present, all must be filled at
   call time:

      >>> say_to_world = partial(print, Placeholder, Placeholder, "world!")
      >>> say_to_world('Hello', 'dear')
      Hello dear world!

   Calling "say_to_world('Hello')" raises a "TypeError", because only
   one positional argument is provided, but there are two placeholders
   that must be filled in.

   If "partial()" is applied to an existing "partial()" object,
   "Placeholder" sentinels of the input object are filled in with new
   positional arguments. A placeholder can be retained by inserting a
   new "Placeholder" sentinel to the place held by a previous
   "Placeholder":

      >>> from functools import partial, Placeholder as _
      >>> remove = partial(str.replace, _, _, '')
      >>> message = 'Hello, dear dear world!'
      >>> remove(message, ' dear')
      'Hello, world!'
      >>> remove_dear = partial(remove, _, ' dear')
      >>> remove_dear(message)
      'Hello, world!'
      >>> remove_first_dear = partial(remove_dear, _, 1)
      >>> remove_first_dear(message)
      'Hello, dear world!'

   "Placeholder" cannot be passed to "partial()" as a keyword
   argument.

   버전 3.14에서 변경: Added support for "Placeholder" in positional
   arguments.

class functools.partialmethod(func, /, *args, **keywords)

   직접 호출하기보다는 메서드 정의로 사용되도록 설계된 것을 제외하고는
   "partial"과 같이 동작하는 새 "partialmethod" 디스크립터를 반환합니
   다.

   *func*는 *디스크립터*나 콜러블이어야 합니다 (일반 함수처럼 둘 모두
   인 객체는 디스크립터로 처리됩니다).

   When *func* is a descriptor (such as a normal Python function,
   "classmethod()", "staticmethod()", "abstractmethod()" or another
   instance of "partialmethod"), calls to "__get__" are delegated to
   the underlying descriptor, and an appropriate partial object
   returned as the result.

   *func*가 디스크립터가 아닌 콜러블이면, 적절한 연결된 메서드가 동적
   으로 만들어집니다. 이것은 메서드로 사용될 때 일반 파이썬 함수처럼
   작동합니다: "partialmethod" 생성자에 제공된 *args*와 *keywords*보다
   도 전에 *self* 인자가 첫 번째 위치 인자로 삽입됩니다.

   예:

      >>> class Cell:
      ...     def __init__(self):
      ...         self._alive = False
      ...     @property
      ...     def alive(self):
      ...         return self._alive
      ...     def set_state(self, state):
      ...         self._alive = bool(state)
      ...     set_alive = partialmethod(set_state, True)
      ...     set_dead = partialmethod(set_state, False)
      ...
      >>> c = Cell()
      >>> c.alive
      False
      >>> c.set_alive()
      >>> c.alive
      True

   Added in version 3.4.

functools.reduce(function, iterable, /[, initial])

   두 인자의 *function*을 왼쪽에서 오른쪽으로 *iterable*의 항목에 누적
   적으로 적용해서, 이터러블을 단일 값으로 줄입니다. 예를 들어,
   "reduce(lambda x, y: x+y, [1, 2, 3, 4, 5])"는 "((((1+2)+3)+4)+5)"를
   계산합니다. 왼쪽 인자 *x*는 누적값이고 오른쪽 인자 *y*는 *iterable*
   에서 온 갱신 값입니다. 선택적 *initial*가 있으면, 계산에서 이터러블
   의 항목 앞에 배치되고, 이터러블이 비어있을 때 기본값의 역할을 합니
   다. *initial*가 제공되지 않고 *iterable*에 하나의 항목만 포함되면,
   첫 번째 항목이 반환됩니다.

   대략 다음과 동등합니다:

      initial_missing = object()

      def reduce(function, iterable, /, initial=initial_missing):
          it = iter(iterable)
          if initial is initial_missing:
              value = next(it)
          else:
              value = initial
          for element in it:
              value = function(value, element)
          return value

   모든 중간값을 산출하는 이터레이터는 "itertools.accumulate()"를 참조
   하십시오.

   버전 3.14에서 변경: *initial* is now supported as a keyword
   argument.

@functools.singledispatch

   함수를 *싱글 디스패치* *제네릭 함수*로 변환합니다.

   제네릭 함수를 정의하려면, "@singledispatch" 데코레이터로 데코레이트
   하십시오. "@singledispatch"를 사용해서 함수를 정의할 때, 디스패치는
   첫 번째 인자의 형으로 일어남에 유의하십시오:

      >>> from functools import singledispatch
      >>> @singledispatch
      ... def fun(arg, verbose=False):
      ...     if verbose:
      ...         print("Let me just say,", end=" ")
      ...     print(arg)

   To add overloaded implementations to the function, use the
   "register()" attribute of the generic function, which can be used
   as a decorator.  For functions annotated with types, the decorator
   will infer the type of the first argument automatically:

      >>> @fun.register
      ... def _(arg: int, verbose=False):
      ...     if verbose:
      ...         print("Strength in numbers, eh?", end=" ")
      ...     print(arg)
      ...
      >>> @fun.register
      ... def _(arg: list, verbose=False):
      ...     if verbose:
      ...         print("Enumerate this:")
      ...     for i, elem in enumerate(arg):
      ...         print(i, elem)

   "typing.Union" can also be used:

      >>> @fun.register
      ... def _(arg: int | float, verbose=False):
      ...     if verbose:
      ...         print("Strength in numbers, eh?", end=" ")
      ...     print(arg)
      ...
      >>> from typing import Union
      >>> @fun.register
      ... def _(arg: Union[list, set], verbose=False):
      ...     if verbose:
      ...         print("Enumerate this:")
      ...     for i, elem in enumerate(arg):
      ...         print(i, elem)
      ...

   형 어노테이션을 사용하지 않는 코드의 경우, 적절한 형 인자를 데코레
   이터 자체에 명시적으로 전달할 수 있습니다:

      >>> @fun.register(complex)
      ... def _(arg, verbose=False):
      ...     if verbose:
      ...         print("Better than complicated.", end=" ")
      ...     print(arg.real, arg.imag)
      ...

   For code that dispatches on a collections type (e.g., "list"), but
   wants to typehint the items of the collection (e.g., "list[int]"),
   the dispatch type should be passed explicitly to the decorator
   itself with the typehint going into the function definition:

      >>> @fun.register(list)
      ... def _(arg: list[int], verbose=False):
      ...     if verbose:
      ...         print("Enumerate this:")
      ...     for i, elem in enumerate(arg):
      ...         print(i, elem)

   참고:

     At runtime the function will dispatch on an instance of a list
     regardless of the type contained within the list i.e. "[1,2,3]"
     will be dispatched the same as "["foo", "bar", "baz"]". The
     annotation provided in this example is for static type checkers
     only and has no runtime impact.

   To enable registering *lambdas* and pre-existing functions, the
   "register()" attribute can also be used in a functional form:

      >>> def nothing(arg, verbose=False):
      ...     print("Nothing.")
      ...
      >>> fun.register(type(None), nothing)

   The "register()" attribute returns the undecorated function. This
   enables decorator stacking, "pickling", and the creation of unit
   tests for each variant independently:

      >>> @fun.register(float)
      ... @fun.register(Decimal)
      ... def fun_num(arg, verbose=False):
      ...     if verbose:
      ...         print("Half of your number:", end=" ")
      ...     print(arg / 2)
      ...
      >>> fun_num is fun
      False

   호출되면, 제네릭 함수는 첫 번째 인자의 형에 따라 디스패치 합니다:

      >>> fun("Hello, world.")
      Hello, world.
      >>> fun("test.", verbose=True)
      Let me just say, test.
      >>> fun(42, verbose=True)
      Strength in numbers, eh? 42
      >>> fun(['spam', 'spam', 'eggs', 'spam'], verbose=True)
      Enumerate this:
      0 spam
      1 spam
      2 eggs
      3 spam
      >>> fun(None)
      Nothing.
      >>> fun(1.23)
      0.615

   특정 형에 대해 등록된 구현이 없으면, 더 일반적인 구현을 찾는 데 메
   서드 결정 순서가 사용됩니다. "@singledispatch"로 데코레이트 된 원래
   함수는 베이스 "object" 형으로 등록되어서, 더 나은 구현이 발견되지
   않으면 사용됩니다.

   구현이 *추상 베이스 클래스*에 등록되면, 베이스 클래스의 가상 서브
   클래스는 그 구현으로 디스패치 됩니다:

      >>> from collections.abc import Mapping
      >>> @fun.register
      ... def _(arg: Mapping, verbose=False):
      ...     if verbose:
      ...         print("Keys & Values")
      ...     for key, value in arg.items():
      ...         print(key, "=>", value)
      ...
      >>> fun({"a": "b"})
      a => b

   제네릭 함수가 주어진 형에 대해 어떤 구현을 선택하는지 확인하려면
   "dispatch()" 어트리뷰트를 사용하십시오:

      >>> fun.dispatch(float)
      <function fun_num at 0x1035a2840>
      >>> fun.dispatch(dict)    # 참고: 기본 구현
      <function fun at 0x103fe0000>

   등록된 모든 구현에 액세스하려면, 읽기 전용 "registry" 어트리뷰트를
   사용하십시오:

      >>> fun.registry.keys()
      dict_keys([<class 'NoneType'>, <class 'int'>, <class 'object'>,
                <class 'decimal.Decimal'>, <class 'list'>,
                <class 'float'>])
      >>> fun.registry[float]
      <function fun_num at 0x1035a2840>
      >>> fun.registry[object]
      <function fun at 0x103fe0000>

   Added in version 3.4.

   버전 3.7에서 변경: The "register()" attribute now supports using
   type annotations.

   버전 3.11에서 변경: The "register()" attribute now supports
   "typing.Union" as a type annotation.

class functools.singledispatchmethod(func)

   메서드를 *싱글 디스패치* *제네릭 함수*로 변환합니다.

   To define a generic method, decorate it with the
   "@singledispatchmethod" decorator. When defining a method using
   "@singledispatchmethod", note that the dispatch happens on the type
   of the first non-*self* or non-*cls* argument:

      class Negator:
          @singledispatchmethod
          def neg(self, arg):
              raise NotImplementedError("Cannot negate a")

          @neg.register
          def _(self, arg: int):
              return -arg

          @neg.register
          def _(self, arg: bool):
              return not arg

   "@singledispatchmethod" supports nesting with other decorators such
   as "@classmethod". Note that to allow for "dispatcher.register",
   "singledispatchmethod" must be the *outer most* decorator. Here is
   the "Negator" class with the "neg" methods bound to the class,
   rather than an instance of the class:

      class Negator:
          @singledispatchmethod
          @classmethod
          def neg(cls, arg):
              raise NotImplementedError("Cannot negate a")

          @neg.register
          @classmethod
          def _(cls, arg: int):
              return -arg

          @neg.register
          @classmethod
          def _(cls, arg: bool):
              return not arg

   The same pattern can be used for other similar decorators:
   "@staticmethod", "@abstractmethod", and others.

   Added in version 3.8.

functools.update_wrapper(wrapper, wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)

   *wrapped* 함수처럼 보이도록 *wrapper* 함수를 갱신합니다. 선택적 인
   자는 원래 함수의 어떤 어트리뷰트가 wrapper 함수의 일치하는 어트리뷰
   트에 직접 대입되고 wrapper 함수의 어떤 어트리뷰트가 원래 함수의 해
   당 어트리뷰트로 갱신되는지 지정하는 튜플입니다. 이 인자들의 기본값
   은 모듈 수준 상수 "WRAPPER_ASSIGNMENTS"(wrapper 함수의
   "__module__", "__name__", "__qualname__", "__annotations__",
   "__type_params__" 및 "__doc__" 독스트링에 대입합니다)와
   "WRAPPER_UPDATES"(wrapper 함수의 "__dict__", 즉 인스턴스 딕셔너리를
   갱신합니다)입니다.

   내부 검사와 기타 목적(예를 들어 "lru_cache()"와 같은 캐싱 데코레이
   터 우회)을 위해 원래 함수에 액세스 할 수 있도록, 이 함수는 래핑 되
   는 함수를 가리키는 "__wrapped__" 어트리뷰트를 wrapper에 자동으로 추
   가합니다.

   이 함수의 주요 용도는 데코레이트 된 함수를 래핑하고 wrapper를 반환
   하는 *데코레이터* 함수에서 사용하는 것입니다. wrapper 함수가 갱신되
   지 않으면, 반환된 함수의 메타 데이터는 원래 함수 정의가 아닌
   wrapper 정의를 반영하게 되어 일반적으로 도움이 되지 않습니다.

   "update_wrapper()"는 함수 이외의 콜러블과 함께 사용할 수 있습니다.
   래핑 되는 객체에서 누락된 *assigned*나 *updated*로 이름 지정된 어트
   리뷰트는 무시됩니다 (즉, 이 함수는 wrapper 함수에서 그 어트리뷰트를
   설정하려고 시도하지 않습니다). wrapper 함수 자체에 *updated*에 이름
   지정된 어트리뷰트가 없으면 여전히 "AttributeError"가 발생합니다.

   버전 3.2에서 변경: The "__wrapped__" attribute is now automatically
   added. The "__annotations__" attribute is now copied by default.
   Missing attributes no longer trigger an "AttributeError".

   버전 3.4에서 변경: "__wrapped__" 어트리뷰트는 이제 해당 함수가
   "__wrapped__" 어트리뷰트를 정의한 경우에도 항상 래핑 된 함수를 참조
   합니다. (bpo-17482를 참조하십시오)

   버전 3.12에서 변경: The "__type_params__" attribute is now copied
   by default.

@functools.wraps(wrapped, assigned=WRAPPER_ASSIGNMENTS, updated=WRAPPER_UPDATES)

   래퍼 함수를 정의할 때 함수 데코레이터로 "update_wrapper()"를 호출하
   기 위한 편의 함수입니다. "partial(update_wrapper, wrapped=wrapped,
   assigned=assigned, updated=updated)"와 동등합니다. 예를 들면:

      >>> from functools import wraps
      >>> def my_decorator(f):
      ...     @wraps(f)
      ...     def wrapper(*args, **kwds):
      ...         print('Calling decorated function')
      ...         return f(*args, **kwds)
      ...     return wrapper
      ...
      >>> @my_decorator
      ... def example():
      ...     """Docstring"""
      ...     print('Called example function')
      ...
      >>> example()
      Calling decorated function
      Called example function
      >>> example.__name__
      'example'
      >>> example.__doc__
      'Docstring'

   Without the use of this decorator factory, the name of the example
   function would have been "'wrapper'", and the docstring of the
   original "example()" would have been lost.


"partial" 객체
==============

"partial" 객체는 "partial()"이 만든 콜러블 객체입니다. 세 가지 읽기 전
용 어트리뷰트가 있습니다:

partial.func

   콜러블 객체나 함수. "partial" 객체에 대한 호출은 새로운 인자와 키워
   드와 함께 "func"로 전달됩니다.

partial.args

   "partial" 객체 호출에 제공되는 위치 인자 앞에 추가될 가장 왼쪽 위치
   인자들입니다.

partial.keywords

   "partial" 객체가 호출될 때 제공될 키워드 인자들입니다.

"partial" objects are like function objects in that they are callable,
weak referenceable, and can have attributes.  There are some important
differences.  For instance, the "__name__" and "__doc__" attributes
are not created automatically.
