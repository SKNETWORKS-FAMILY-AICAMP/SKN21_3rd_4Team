"string" --- 일반적인 문자열 연산
*********************************

**Source code:** Lib/string/__init__.py

======================================================================

더 보기:

  텍스트 시퀀스 형 --- str

  문자열 메서드


문자열 상수
===========

이 모듈에 정의된 상수는 다음과 같습니다:

string.ascii_letters

   아래에 나오는 "ascii_lowercase"와 "ascii_uppercase" 상수를 이어붙인
   것입니다. 이 값은 로케일에 의존적이지 않습니다.

string.ascii_lowercase

   소문자 "'abcdefghijklmnopqrstuvwxyz'". 이 값은 로케일에 의존적이지
   않고 변경되지 않습니다.

string.ascii_uppercase

   대문자 "'ABCDEFGHIJKLMNOPQRSTUVWXYZ'". 이 값은 로케일에 의존적이지
   않고 변경되지 않습니다.

string.digits

   문자열 "'0123456789'".

string.hexdigits

   문자열 "'0123456789abcdefABCDEF'".

string.octdigits

   문자열 "'01234567'".

string.punctuation

   "C" 로케일에서 구두점 문자로 간주하는 ASCII 문자의 문자열:
   "!"#$%&'()*+,-./:;<=>?@[\]^_`{|}~".

string.printable

   파이썬이 인쇄할 수 있는 것으로 간주하는 ASCII 문자의 문자열.
   "digits", "ascii_letters", "punctuation", "whitespace" 의 조합입니
   다.

   참고:

     By design, "string.printable.isprintable()" returns "False". In
     particular, "string.printable" is not printable in the POSIX
     sense (see *LC_CTYPE*).

string.whitespace

   공백으로 간주하는 모든 ASCII 문자를 포함하는 문자열. 여기에는 스페
   이스, 탭, 줄 바꿈, 캐리지 리턴, 세로 탭 및 폼 피드 문자가 포함됩니
   다.


사용자 지정 문자열 포매팅
=========================

내장 문자열 클래스는 **PEP 3101** 에 설명된 "format()" 메서드를 통해
복잡한 변수 치환 및 값 포매팅을 수행할 수 있는 기능을 제공합니다.
"string" 모듈의 "Formatter" 클래스는 내장 "format()" 메서드와 같은 구
현을 사용하여 자신만의 문자열 포매팅 동작을 만들고 사용자 정의할 수 있
게 합니다.

class string.Formatter

   "Formatter" 클래스에는 다음과 같은 공개 메서드가 있습니다:

   format(format_string, /, *args, **kwargs)

      기본 API 메서드입니다. 포맷 문자열과 임의의 위치 및 키워드 인자
      의 집합을 받아들입니다. 이것은 "vformat()" 을 호출하는 래퍼일 뿐
      입니다.

      버전 3.7에서 변경: 포맷 문자열 인자는 이제 위치 전용입니다.

   vformat(format_string, args, kwargs)

      이 함수는 실제 포맷 작업을 수행합니다. "*args" 와 "**kwargs" 문
      법을 사용하여 딕셔너리를 개별적인 인자로 언 패킹한 후 다시 패킹
      하는 대신 미리 정의된 인자 딕셔너리를 전달하고자 하는 경우를 위
      해 별도의 함수로 노출합니다. "vformat()" 은 포맷 문자열을 문자
      데이터와 치환 필드로 분리하는 작업을 수행합니다. 아래에 설명된
      다양한 메서드를 호출합니다.

   이에 더해, "Formatter" 는 서브 클래스에 의해 대체될 목적으로 많은
   메서드를 정의합니다:

   parse(format_string)

      format_string을 루핑하면서 튜플 (*literal_text*, *field_name*,
      *format_spec*, *conversion*) 의 이터러블을 반환합니다. 이것은
      "vformat()" 이 문자열을 리터럴 텍스트와 치환 필드로 나누는 데 사
      용합니다.

      The values in the tuple conceptually represent a span of literal
      text followed by a single replacement field.  If there is no
      literal text (which can happen if two replacement fields occur
      consecutively), then *literal_text* will be a zero-length
      string.  If there is no replacement field, then the values of
      *field_name*, *format_spec* and *conversion* will be "None". The
      value of *field_name* is unmodified and auto-numbering of non-
      numbered positional fields is done by "vformat()".

   get_field(field_name, args, kwargs)

      Given *field_name*, convert it to an object to be formatted.
      Auto-numbering of *field_name* returned from "parse()" is done
      by "vformat()" before calling this method.  Returns a tuple
      (obj, used_key). The default version takes strings of the form
      defined in **PEP 3101**, such as "0[name]" or "label.title".
      *args* and *kwargs* are as passed in to "vformat()". The return
      value *used_key* has the same meaning as the *key* parameter to
      "get_value()".

   get_value(key, args, kwargs)

      지정된 필드의 값을 가져옵니다. *key* 인자는 정수 또는 문자열입니
      다. 정수의 경우, *args* 에 있는 위치 인자의 인덱스를 나타냅니다;
      문자열인 경우, *kwargs* 에 있는 이름있는 인자를 나타냅니다.

      *args* 매개 변수는 "vformat()" 의 위치 인자 목록으로 설정되고,
      *kwargs* 매개 변수는 키워드 인자 딕셔너리로 설정됩니다.

      복합 필드 이름의 경우, 이러한 함수는 필드 이름의 첫 번째 구성 요
      소에 대해서만 호출됩니다; 후속 구성 요소는 일반 어트리뷰트 및 인
      덱싱 연산을 통해 처리됩니다.

      그래서 예를 들어, 필드 표현식 '0.name' 은 "get_value()" 가 *key*
      인자 0으로 호출되도록 합니다. "name" 어트리뷰트는 "get_value()"
      가 반환한 후에 내장 "getattr()" 함수를 호출하여 조회합니다.

      인덱스 또는 키워드가 존재하지 않는 항목을 참조하면, "IndexError"
      나 "KeyError" 가 발생합니다.

   check_unused_args(used_args, args, kwargs)

      원하는 경우 사용하지 않는 인자를 검사하도록 구현합니다. 이 함수
      에 대한 인자는 포맷 문자열에서 참조되는 모든 인자 키의 집합과 (
      위치 인자의 경우 정수, 이름있는 인자의 경우 문자열), vformat 으
      로 전달된 *args* 와 *kwargs* 에 대한 참조입니다. 사용되지 않은
      인자의 집합은 이 매개 변수들로 계산할 수 있습니다.
      "check_unused_args()" 는 검사가 실패할 경우 예외를 발생시킬 것으
      로 가정합니다.

   format_field(value, format_spec)

      "format_field()" 는 단순히 전역 "format()" 내장 함수를 호출합니
      다. 서브 클래스가 재정의할 수 있도록 메서드가 제공됩니다.

   convert_field(value, conversion)

      ("get_field()" 가 반환한) 값(value)을 ("parse()" 메서드가 반환하
      는 튜플에 있는 것과 같은) 주어진 변환 유형(conversion)으로 변환
      합니다. 기본 버전은 's' (str), 'r' (repr) 및 'a' (ascii) 변환 유
      형을 인식합니다.


포맷 문자열 문법
================

The "str.format()" method and the "Formatter" class share the same
syntax for format strings (although in the case of "Formatter",
subclasses can define their own format string syntax).  The syntax is
related to that of formatted string literals and template string
literals, but it is less sophisticated and, in particular, does not
support arbitrary expressions in interpolations.

포맷 문자열에는 중괄호 "{}" 로 둘러싸인 "치환 필드" 가 들어 있습니다.
중괄호 안에 포함되지 않은 것은 리터럴 텍스트로 간주하며 변경되지 않고
그대로 출력으로 복사됩니다. 리터럴 텍스트에 중괄호를 포함해야 하는 경
우, 중복으로 이스케이프 할 수 있습니다: "{{" 와 "}}".

치환 필드의 문법은 다음과 같습니다:

   replacement_field: "{" [field_name] ["!" conversion] [":" format_spec] "}"
   field_name:        arg_name ("." attribute_name | "[" element_index "]")*
   arg_name:          [identifier | digit+]
   attribute_name:    identifier
   element_index:     digit+ | index_string
   index_string:      <any source character except "]"> +
   conversion:        "r" | "s" | "a"
   format_spec:       format-spec:format_spec

덜 형식적인 용어로, 치환 필드는 *field_name* 으로 시작할 수 있는데, 값
이 포맷되어 출력에 치환 필드 대신 삽입될 객체를 지정합니다.
*field_name* 다음에는 선택적으로 느낌표 "'!'" 가 앞에 오는
*conversion* 필드와 콜론 "':'" 이 앞에 오는 *format_spec* 이 옵니다.
이 값은 치환 값에 대해 기본값이 아닌 포맷을 지정합니다.

포맷 명세 미니 언어 섹션을 참고하십시오.

*field_name* 자체는 숫자나 키워드인 *arg_name* 으로 시작합니다. 숫자면
위치 인자를 나타내고, 키워드면 이름이 있는 키워드 인자를 나타냅니다.
*arg_name*은 문자열에 "str.isdecimal()"을 호출했을 때 참을 반환한다면
숫자로 취급됩니다. 포맷 문자열의 숫자 arg_name이 0, 1, 2, ... 순으로
나열되는 경우, (일부가 아니라) 전부 생략 할 수 있으며 숫자 0, 1, 2,
...이 순서대로 자동 삽입됩니다. *arg_name* 이 따옴표로 분리되어 있지
않기 때문에, 포맷 문자열 내에서 임의의 딕셔너리 키(예를 들어, "'10'"
이나 "':-]'")를 지정할 수 없습니다. *arg_name* 다음에는 제한 없는 개수
의 인덱스나 어트리뷰트 표현식이 올 수 있습니다. "'.name'" 형태의 표현
식은 "getattr()"을 사용하여 이름있는 어트리뷰트를 선택하는 반면,
"'[index]'" 형태의 표현식은 "__getitem__()" 을 사용해서 인덱스 조회를
합니다.

버전 3.1에서 변경: 위치 인자 지정자는 "str.format()" 에서 생략 할 수
있습니다. 그래서, "'{} {}'.format(a, b)" 는 "'{0} {1}'.format(a, b)"
과 동등합니다.

버전 3.4에서 변경: 위치 인자 지정자는 "Formatter"에서 생략 할 수 있습
니다.

몇 가지 간단한 포맷 문자열 예제:

   "First, thou shalt count to {0}"  # 첫번째 위치 인자를 참조합니다
   "Bring me a {}"                   # 묵시적으로 첫번째 위치 인자를 참조합니다
   "From {} to {}"                   # "From {0} to {1}" 과 같습니다
   "My quest is {name}"              # 키워드 인자 'name' 을 참조합니다
   "Weight in tons {0.weight}"       # 첫번째 위치 인자의 'weight' 어트리뷰트
   "Units destroyed: {players[0]}"   # 키워드 인자 'players' 의 첫번째 요소.

*conversion* 필드는 포매팅 전에 형 코어션을 일으킵니다. 보통은, 값을
포매팅하는 작업은 값 자체의 "__format__()" 메서드에 의해 수행됩니다.
그러나 어떤 경우에는 형 자신의 포매팅 정의를 무시하고 문자열로 포맷되
도록 강제할 필요가 있습니다. "__format__()" 을 호출하기 전에 값을 문자
열로 변환하면, 일반적인 포매팅 논리가 무시됩니다.

현재 세 가지 변환 플래그가 지원됩니다: "'!s'" 는 값에 "str()" 을 호출
하고, "'!r'" 은 값에 "repr()" 을 호출하고, "'!a'" 는 값에 "ascii()" 를
호출합니다.

몇 가지 예:

   "Harold's a clever {0!s}"        # 먼저 인자에 str() 을 호출합니다
   "Bring out the holy {name!r}"    # 먼저 인자에 repr() 을 호출합니다
   "More {!a}"                      # 먼저 인자에 ascii() 를 호출합니다

*format_spec* 필드에는 값을 표시하는 방법에 대한 명세가 포함되어 있는
데, 필드 너비, 정렬, 채움, 십진 정밀도 등이 포함됩니다. 각 값 형은 자
체 "포매팅 미니 언어" 또는 *format_spec* 의 해석을 정의 할 수 있습니다
.

대부분의 내장형은 다음 절에서 설명하는 공통 포매팅 미니 언어를 지원합
니다.

A *format_spec* 필드는 그 안에 중첩된 치환 필드를 포함할 수도 있습니다
. 이러한 중첩 된 치환 필드에는 필드 이름, 변환 플래그 및 포맷 명세가
포함될 수 있지만, 더 깊은 중첩은 허용되지 않습니다. format_spec 내의
치환 필드는 *format_spec* 문자열이 해석되기 전에 치환됩니다. 이렇게 해
서 값의 포매팅을 동적으로 지정할 수 있게 합니다.

몇 가지 예제는 포맷 예제 섹션을 보십시오.


포맷 명세 미니 언어
-------------------

"Format specifications" are used within replacement fields contained
within a format string to define how individual values are presented
(see 포맷 문자열 문법, 포맷 문자열 리터럴, and t-strings). They can
also be passed directly to the built-in "format()" function.  Each
formattable type may define how the format specification is to be
interpreted.

대부분의 내장형은 포맷 명세에 대해 다음 옵션을 구현하지만, 일부 포맷
옵션은 숫자 형에서만 지원됩니다.

일반적인 관례는 빈 포맷 명세가 값에 "str()" 을 호출한 것과 같은 결과를
만드는 것입니다. 비어 있지 않은 포맷 명세는 보통 결과를 수정합니다.

*표준 포맷 지정자* 의 일반적인 형식은 다음과 같습니다:

   format_spec:             [options][width_and_precision][type]
   options:                 [[fill]align][sign]["z"]["#"]["0"]
   fill:                    <any character>
   align:                   "<" | ">" | "=" | "^"
   sign:                    "+" | "-" | " "
   width_and_precision:     [width_with_grouping][precision_with_grouping]
   width_with_grouping:     [width][grouping]
   precision_with_grouping: "." [precision][grouping] | "." grouping
   width:                   digit+
   precision:               digit+
   grouping:                "," | "_"
   type:                    "b" | "c" | "d" | "e" | "E" | "f" | "F" | "g"
                            | "G" | "n" | "o" | "s" | "x" | "X" | "%"

유효한 *align* 값이 지정되면, *fill* 문자가 앞에 나올 수 있는데 임의의
문자가 될 수 있고, 생략된 경우에는 스페이스가 기본값으로 사용됩니다.
포맷 문자열 리터럴 에서나 "str.format()" 메서드를 사용할 때는, 리터럴
중괄호(""{"" 또는 ""}"")를 *fill* 문자로 사용할 수 없습니다. 그러나,
중첩된 치환 필드로 중괄호를 삽입 할 수 있습니다. 이 제한은 "format()"
함수에는 영향을 미치지 않습니다.

다양한 정렬 옵션의 의미는 다음과 같습니다:

+-----------+------------------------------------------------------------+
| 옵션      | 의미                                                       |
|===========|============================================================|
| "'<'"     | 사용 가능한 공간 내에서 필드가 왼쪽 정렬되도록 합니다 (대  |
|           | 부분 객체에서 이것이 기본값입니다).                        |
+-----------+------------------------------------------------------------+
| "'>'"     | 사용 가능한 공간 내에서 필드가 오른쪽 정렬되도록 합니다 (  |
|           | 숫자에서 이것 이 기본값입니다).                            |
+-----------+------------------------------------------------------------+
| "'='"     | 채움이 부호 (있다면) 뒤에, 숫자 앞에 오도록 강제합니다. 이 |
|           | 것은 '+000000120' 형식으로 필드를 인쇄하는 데 사용됩니다.  |
|           | 이 정렬 옵션은 "complex"를 제외한 숫자 형에게만 유효합니다 |
|           | . 이것은 필드 너비 바로 앞 에 '0' 이 있으면 숫자에 대한 기 |
|           | 본값이 됩니다.                                             |
+-----------+------------------------------------------------------------+
| "'^'"     | 사용 가능한 공간 내에서 필드를 가운데에 배치합니다.        |
+-----------+------------------------------------------------------------+

최소 필드 너비가 정의되지 않으면, 필드 너비는 항상 필드를 채울 데이터
와 같은 크기이므로, 정렬 옵션은 이 경우 의미가 없습니다.

*sign* 옵션은 숫자 형에게만 유효하며, 다음 중 하나일 수 있습니다:

+-----------+------------------------------------------------------------+
| 옵션      | 의미                                                       |
|===========|============================================================|
| "'+'"     | 음수뿐만 아니라 양수에도 부호를 사용해야 함을 나타냅니다.  |
+-----------+------------------------------------------------------------+
| "'-'"     | 음수에 대해서만 부호를 사용해야 함을 나타냅니다 (이것이 기 |
|           | 본 동작입니 다).                                           |
+-----------+------------------------------------------------------------+
| 스페이스  | 양수에는 선행 스페이스를 사용하고, 음수에는 마이너스 부호  |
|           | 를 사용해야 함을 나타냅니다.                               |
+-----------+------------------------------------------------------------+

The "'z'" option coerces negative zero floating-point values to
positive zero after rounding to the format precision.  This option is
only valid for floating-point presentation types.

버전 3.11에서 변경: "'z'" 옵션을 추가했습니다 (**PEP 682** 도 보세요).

"'#'" 옵션은 변환에 "대안 형식" 이 사용되도록 만듭니다. 대안 형식은 형
별로 다르게 정의됩니다. 이 옵션은 정수, 실수와 복소수 형에게만 유효합
니다. 정수의 경우, 이진수, 8진수 또는 16진수 출력이 사용될 때, 이 옵션
은 출력값에 각각 접두사 "'0b'", "'0o'", "'0x'" 또는 "'0X'" 를 추가합니
다. 실수와 복소수의 경우, 대안 형식은 변환 결과의 소수점 아래 숫자가
없어도 항상 소수점 문자가 포함되게 합니다. 보통은, 소수점 문자는 그 뒤
에 숫자가 있는 경우에만 변환 결과에 나타납니다. 이에 더해, "'g'" 및
"'G'" 변환의 경우 끝에 붙는 0이 결과에서 제거되지 않습니다.

*width* 는 최소 총 필드 너비를 정의하는 십진 정수인데, 접두사, 구분자
및 다른 포매팅 문자들을 포함합니다. 지정하지 않으면, 필드 너비는 내용
에 의해 결정됩니다.

명시적 정렬이 주어지지 않을 때, *width* 필드 앞에 "'0'" 문자를 붙이면
"complex"를 제외한 숫자 형에 대해 부호를 고려하는 0 채움을 사용할 수
있습니다. 이것은 "'0'" 의 *fill* 문자와 "'='" 의 *alignment* 유형을 갖
는 것과 동등합니다.

버전 3.10에서 변경: Preceding the *width* field by "'0'" no longer
affects the default alignment for strings.

*precision* 은 표시 유형 "'f'"와 "'F'"의 경우 소수점 뒤에 표시될 자릿
수를, "'g'"와 "'G'"의 경우 소수점 앞, 뒤로 표시할 자릿수를 나타내는 십
진 정수입니다. 문자열 표시 유형의 경우 필드는 최대 필드 크기를 나타냅
니다 - 즉, 필드 내용에서 몇 개의 문자가 사용되는지 나타냅니다. 정수 표
시 유형에는 *precision* 이 허용되지 않습니다.

The *grouping* option after *width* and *precision* fields specifies a
digit group separator for the integral and fractional parts of a
number respectively. It can be one of the following:

+-----------+------------------------------------------------------------+
| 옵션      | 의미                                                       |
|===========|============================================================|
| "','"     | 정수 표시 유형 "'d'"와, "'n'"을 제외한 부동 소수점 표시 유 |
|           | 형에 대해 3 자리마다 쉼표를 삽입합니다. 다른 표시 유형에는 |
|           | 이 옵션이 지원되지 않습 니다.                              |
+-----------+------------------------------------------------------------+
| "'_'"     | 정수 표시 유형 "'d'"와, "'n'"을 제외한 부동 소수점 표시 유 |
|           | 형에 대해 3 자리마다 밑줄을 삽입합니다. 정수 표시 유형     |
|           | "'b'", "'o'", "'x'" 및 "'X'" 의 경우 밑줄이 4자리마다 삽입 |
|           | 됩니다. 다른 표시 유형에는 이 옵션 이 지원되지 않습니다.   |
+-----------+------------------------------------------------------------+

로케일을 고려하는 구분자의 경우, 대신 "'n'" 표시 유형을 사용하십시오.

버전 3.1에서 변경: "','" 옵션을 추가했습니다 (**PEP 378** 도 보세요).

버전 3.6에서 변경: "'_'" 옵션을 추가했습니다 (**PEP 515** 도 보세요).

버전 3.14에서 변경: Support the *grouping* option for the fractional
part.

마지막으로 *type* 은 데이터를 표시하는 방법을 결정합니다.

사용 가능한 문자열 표시 유형은 다음과 같습니다:

   +-----------+------------------------------------------------------------+
   | 유형      | 의미                                                       |
   |===========|============================================================|
   | "'s'"     | 문자열 포맷. 이것은 문자열의 기본 유형이고 생략될 수 있습  |
   |           | 니다.                                                      |
   +-----------+------------------------------------------------------------+
   | 없음      | "'s'" 와 같습니다.                                         |
   +-----------+------------------------------------------------------------+

사용 가능한 정수 표시 유형은 다음과 같습니다:

   +-----------+------------------------------------------------------------+
   | 유형      | 의미                                                       |
   |===========|============================================================|
   | "'b'"     | 이진 형식. 이진법으로 숫자를 출력합니다.                   |
   +-----------+------------------------------------------------------------+
   | "'c'"     | 문자. 인쇄하기 전에 정수를 해당 유니코드 문자로 변환합니다 |
   |           | .                                                          |
   +-----------+------------------------------------------------------------+
   | "'d'"     | 십진 정수. 십진법으로 숫자를 출력합니다.                   |
   +-----------+------------------------------------------------------------+
   | "'o'"     | 8진 형식. 8진법으로 숫자를 출력합니다.                     |
   +-----------+------------------------------------------------------------+
   | "'x'"     | 16진 형식. 9보다 큰 숫자의 경우 소문자를 사용하여 16진법으 |
   |           | 로 숫자를 출력합니다.                                      |
   +-----------+------------------------------------------------------------+
   | "'X'"     | 16진 형식. 9보다 큰 숫자의 경우 대문자를 사용하여 16진법으 |
   |           | 로 숫자를 출력합니다. "'#'"가 지정되면, 접두사 "'0x'"도 대 |
   |           | 문자로 변환되어 "'0X'"로 표시됩니다.                       |
   +-----------+------------------------------------------------------------+
   | "'n'"     | 숫자. 이는 현재 로케일 설정을 사용하여 적절한 숫자 그룹 구 |
   |           | 분자를 삽 입한다는 점을 제외하고는 "'d'" 와 같습니다.      |
   +-----------+------------------------------------------------------------+
   | 없음      | "'d'" 와 같습니다.                                         |
   +-----------+------------------------------------------------------------+

위의 표시 유형에 더해, 정수는 아래에 나열된 부동 소수점 표시 유형으로
포맷될 수 있습니다 ("'n'" 및 "없음" 제외). 그렇게 할 때, 포매팅 전에
정수를 부동 소수점 숫자로 변환하기 위해 "float()" 가 사용됩니다.

"float" 및 "Decimal" 값에 사용할 수 있는 표시 유형은 다음과 같습니다:

   +-----------+------------------------------------------------------------+
   | 유형      | 의미                                                       |
   |===========|============================================================|
   | "'e'"     | 과학적 표기법. 주어진 정밀도 "p"에 대해, 지수에서 계수를   |
   |           | 구분하는 문자 'e'를 사용하여 과학적 표기법으로 숫자를 포맷 |
   |           | 합니다. 계수는 소 수점 앞의 한 자리와 소수점 뒤에 "p" 자리 |
   |           | 를 가져서, 총 "p + 1" 유효 자릿수를 갖습니다. 정밀도가 지  |
   |           | 정되지 않으면, "float"의 경우는 소수 점 뒤에 "6" 숫자의 정 |
   |           | 밀도를 사용하고, "Decimal"의 경우는 모든 계수 숫자를 표시  |
   |           | 합니다. "p=0"이면, "#" 옵션을 사용하지 않는 한 소수점은 생 |
   |           | 략됩니다.  For "float", the exponent always contains at    |
   |           | least two digits, and is zero if the value is zero.        |
   +-----------+------------------------------------------------------------+
   | "'E'"     | 과학적 표기법. 구분 문자로 대문자 'E'를 사용한다는 것을 제 |
   |           | 외하고 "'e'" 와 같습니다.                                  |
   +-----------+------------------------------------------------------------+
   | "'f'"     | 고정 소수점 표기법. 주어진 정밀도 "p"에 대해, 소수점 뒤에  |
   |           | 정확히 "p" 자리가 있는 십진수로 숫자를 포맷합니다. 정밀도  |
   |           | 가 지정되지 않으 면, "float"의 경우는 소수점 뒤에 "6" 숫자 |
   |           | 의 정밀도를 사용하고, "Decimal"의 경우는 모든 계수 숫자를  |
   |           | 표시할 만큼 충분히 큰 정밀도를 사용합니다. "p=0"이면 , "#" |
   |           | 옵션을 사용하지 않는 한 소수점은 생략됩 니다.              |
   +-----------+------------------------------------------------------------+
   | "'F'"     | 고정 소수점 표기법. "'f'" 와 같지만, "nan" 을 "NAN" 으로,  |
   |           | "inf" 를 "INF" 로 변환합니다.                              |
   +-----------+------------------------------------------------------------+
   | "'g'"     | 범용 형식. 주어진 정밀도 "p >= 1" 에 대해, 숫자를 유효 숫  |
   |           | 자 "p" 로 자리 올림 한 다음, 결과를 크기에 따라 고정 소수  |
   |           | 점 형식이나 과학 표 기법으로 포맷합니다. 정밀도 "0"은 정밀 |
   |           | 도 "1"과 동등하게 처리됩니다.  정확한 규칙은 다음과 같습니 |
   |           | 다: 표시 유형 "'e'" 와 정밀도 "p-1" 로 포맷된 결과의 지수  |
   |           | 가 "exp" 라고 가정하십시오. 이때 "-m <= exp < p" 이면 (여  |
   |           | 기서 "m"은 float에서 -4이고 "Decimal" 이면 -6입니다), 숫자 |
   |           | 는 표시 형식 "'f'" 와 정밀도 "p-1-exp" 로 포맷됩니다. 그렇 |
   |           | 지 않으면 , 숫자는 표시 유형 "'e'" 와 정밀도 "p-1" 로 포맷 |
   |           | 됩니다. 두 경우 유 효하지 않은 후행 0은 모두 유효숫자부에  |
   |           | 서 제거되고, 뒤에 남아있는 숫 자가 없다면 "'#'" 옵션이 사  |
   |           | 용되지 않는 한 소수점도 제거됩니다.  정밀도가 지정되지 않  |
   |           | 으면, "float"의 경우 "6" 유효 자릿수의 정밀도를 사용합니다 |
   |           | . "Decimal"의 경우, 결과 계수는 값의 계수 숫자로 구성됩니  |
   |           | 다; 과학적 표기법은 절댓값이 "1e-6" 보다 작은 값과 최하위  |
   |           | 숫자의 자 릿값이 1보다 큰 값에 사용되며, 그렇지 않으면 고  |
   |           | 정 소수점 표기법이 사용됩니다.  양과 음의 무한대, 양과 음  |
   |           | 의 0, nans는 정밀도와 무관하게 각각 "inf", "-inf", "0",    |
   |           | "-0", "nan" 으로 포맷됩니다.                               |
   +-----------+------------------------------------------------------------+
   | "'G'"     | 범용 형식. 숫자가 너무 커지면 "'E'" 로 전환하는 것을 제외  |
   |           | 하고 "'g'" 와 같습니다. 무한과 NaN 의 표현도 대문자로 바뀝 |
   |           | 니다.                                                      |
   +-----------+------------------------------------------------------------+
   | "'n'"     | 숫자. 현재 로케일 설정을 사용하여 숫자의 정수부에 적절한   |
   |           | 숫자 그룹 구분자를 삽입한다는 점을 제외하면 "'g'" 와 같습  |
   |           | 니다.                                                      |
   +-----------+------------------------------------------------------------+
   | "'%'"     | 백분율. 숫자에 100을 곱해서 고정 ("'f'") 형식으로 표시한   |
   |           | 다음 백분 율 기호를 붙입니다.                              |
   +-----------+------------------------------------------------------------+
   | 없음      | "float"의 경우, "'g'" 유형과 유사하지만, 고정 소수점 표기  |
   |           | 법이 결과 를 포맷하는데 사용될 때, 소수점 이하로 적어도 하 |
   |           | 나의 숫자를 항상 포 함하고, "exp >= p - 1"일 때 과학적 표  |
   |           | 기법으로 전환합니다. 정밀도가 지정되지 않으면, 후자는 주어 |
   |           | 진 값을 충실히 표현하는 데 필요한 만큼 크게 설정됩니다.    |
   |           | "Decimal"의 경우, 현재 십진 컨텍스트의 "context.capitals"  |
   |           | 값에 따라 "'g'"나 "'G'"와 같습니다.  전체적인 효과는       |
   |           | "str()" 의 출력을 다른 포맷 수정자에 의해 변경된 것 처럼   |
   |           | 만드는 것입니다.                                           |
   +-----------+------------------------------------------------------------+

The result should be correctly rounded to a given precision "p" of
digits after the decimal point.  The rounding mode for "float" matches
that of the "round()" builtin.  For "Decimal", the rounding mode of
the current context will be used.

The available presentation types for "complex" are the same as those
for "float" ("'%'" is not allowed).  Both the real and imaginary
components of a complex number are formatted as floating-point
numbers, according to the specified presentation type.  They are
separated by the mandatory sign of the imaginary part, the latter
being terminated by a "j" suffix.  If the presentation type is
missing, the result will match the output of "str()" (complex numbers
with a non-zero real part are also surrounded by parentheses),
possibly altered by other format modifiers.


포맷 예제
---------

이 절은 "str.format()" 문법의 예와 예전 "%"-포매팅과의 비교를 포함합니
다.

대부분은 문법이 예전의 "%"-포매팅과 유사하며, "{}" 가 추가되고 "%" 대
신 및 ":" 이 사용됩니다. 예를 들어, "'%03.2f'" 는 "'{:03.2f}'" 로 번역
될 수 있습니다.

새 포맷 문법은 다음 예제에 보이는 것과 같이 새롭고 다양한 옵션도 지원
합니다.

위치로 인자 액세스:

   >>> '{0}, {1}, {2}'.format('a', 'b', 'c')
   'a, b, c'
   >>> '{}, {}, {}'.format('a', 'b', 'c')  # 3.1+ 에서만
   'a, b, c'
   >>> '{2}, {1}, {0}'.format('a', 'b', 'c')
   'c, b, a'
   >>> '{2}, {1}, {0}'.format(*'abc')      # 인자 시퀀스를 언패킹
   'c, b, a'
   >>> '{0}{1}{0}'.format('abra', 'cad')   # 인자의 인덱스는 반복할 수 있습니다
   'abracadabra'

이름으로 인자 액세스:

   >>> 'Coordinates: {latitude}, {longitude}'.format(latitude='37.24N', longitude='-115.81W')
   'Coordinates: 37.24N, -115.81W'
   >>> coord = {'latitude': '37.24N', 'longitude': '-115.81W'}
   >>> 'Coordinates: {latitude}, {longitude}'.format(**coord)
   'Coordinates: 37.24N, -115.81W'

인자의 어트리뷰트 액세스:

   >>> c = 3-5j
   >>> ('The complex number {0} is formed from the real part {0.real} '
   ...  'and the imaginary part {0.imag}.').format(c)
   'The complex number (3-5j) is formed from the real part 3.0 and the imaginary part -5.0.'
   >>> class Point:
   ...     def __init__(self, x, y):
   ...         self.x, self.y = x, y
   ...     def __str__(self):
   ...         return 'Point({self.x}, {self.y})'.format(self=self)
   ...
   >>> str(Point(4, 2))
   'Point(4, 2)'

인자의 항목 액세스:

   >>> coord = (3, 5)
   >>> 'X: {0[0]};  Y: {0[1]}'.format(coord)
   'X: 3;  Y: 5'

"%s" 과 "%r" 대체:

   >>> "repr() 은 따옴표를 표시하지만: {!r}; str() 은 그렇지 않습니다: {!s}".format('test1', 'test2')
   "repr() 은 따옴표를 표시하지만: 'test1'; str() 은 그렇지 않습니다: test2"

텍스트 정렬과 너비 지정:

   >>> '{:<30}'.format('left aligned')
   'left aligned                  '
   >>> '{:>30}'.format('right aligned')
   '                 right aligned'
   >>> '{:^30}'.format('centered')
   '           centered           '
   >>> '{:*^30}'.format('centered')  # 채움 문자로 '*' 를 사용합니다
   '***********centered***********'

"%+f", "%-f", "% f" 대체와 부호 지정:

   >>> '{:+f}; {:+f}'.format(3.14, -3.14)  # 항상 표시합니다
   '+3.140000; -3.140000'
   >>> '{: f}; {: f}'.format(3.14, -3.14)  # 양수는 스페이스를 표시합니다
   ' 3.140000; -3.140000'
   >>> '{:-f}; {:-f}'.format(3.14, -3.14)  # 음수만 표시합니다 -- '{:f}; {:f}' 와 같습니다
   '3.140000; -3.140000'

"%x", "%o" 대체와 다른 진법으로 값 변환:

   >>> # format 은 이진수도 지원합니다
   >>> "int: {0:d};  hex: {0:x};  oct: {0:o};  bin: {0:b}".format(42)
   'int: 42;  hex: 2a;  oct: 52;  bin: 101010'
   >>> # with 0x, 0o, or 0b as prefix:
   >>> "int: {0:d};  hex: {0:#x};  oct: {0:#o};  bin: {0:#b}".format(42)
   'int: 42;  hex: 0x2a;  oct: 0o52;  bin: 0b101010'

쉼표나 밑줄을 숫자 그룹 구분자로 사용:

   >>> '{:,}'.format(1234567890)
   '1,234,567,890'
   >>> '{:_}'.format(1234567890)
   '1_234_567_890'
   >>> '{:_b}'.format(1234567890)
   '100_1001_1001_0110_0000_0010_1101_0010'
   >>> '{:_x}'.format(1234567890)
   '4996_02d2'
   >>> '{:_}'.format(123456789.123456789)
   '123_456_789.12345679'
   >>> '{:.,}'.format(123456789.123456789)
   '123456789.123,456,79'
   >>> '{:,._}'.format(123456789.123456789)
   '123,456,789.123_456_79'

백분율 표현:

   >>> points = 19
   >>> total = 22
   >>> 'Correct answers: {:.2%}'.format(points/total)
   'Correct answers: 86.36%'

형별 포매팅 사용:

   >>> import datetime
   >>> d = datetime.datetime(2010, 7, 4, 12, 15, 58)
   >>> '{:%Y-%m-%d %H:%M:%S}'.format(d)
   '2010-07-04 12:15:58'

인자 중첩과 보다 복잡한 예제:

   >>> for align, text in zip('<^>', ['left', 'center', 'right']):
   ...     '{0:{fill}{align}16}'.format(text, fill=align, align=align)
   ...
   'left<<<<<<<<<<<<'
   '^^^^^center^^^^^'
   '>>>>>>>>>>>right'
   >>>
   >>> octets = [192, 168, 0, 1]
   >>> '{:02X}{:02X}{:02X}{:02X}'.format(*octets)
   'C0A80001'
   >>> int(_, 16)
   3232235521
   >>>
   >>> width = 5
   >>> for num in range(5,12):
   ...     for base in 'dXob':
   ...         print('{0:{width}{base}}'.format(num, base=base, width=width), end=' ')
   ...     print()
   ...
       5     5     5   101
       6     6     6   110
       7     7     7   111
       8     8    10  1000
       9     9    11  1001
      10     A    12  1010
      11     B    13  1011


Template strings ($-strings)
============================

참고:

  The feature described here was introduced in Python 2.4; a simple
  templating method based upon regular expressions. It predates
  "str.format()", formatted string literals, and template string
  literals.It is unrelated to template string literals (t-strings),
  which were introduced in Python 3.14. These evaluate to
  "string.templatelib.Template" objects, found in the
  "string.templatelib" module.

템플릿 문자열은 **PEP 292** 에 설명된 대로 더 간단한 문자열 치환을 제
공합니다. 템플릿 문자열의 주요 사례는 국제화(i18n)입니다. 이 문맥에서,
더 간단한 문법과 기능은 파이썬의 다른 내장 문자열 포매팅 기능보다 번역
하기 쉽게 만들기 때문입니다. i18n을 위해 템플릿 문자열을 기반으로 구축
된 라이브러리의 예는 flufl.i18n 패키지를 보십시오.

템플릿 문자열은 다음 규칙을 사용하여 "$"-기반 치환을 지원합니다:

* "$$" 는 이스케이프입니다. 이것은 하나의 "$" 로 치환됩니다.

* "$identifier" 는 매핑 키 ""identifier"" 와 일치하는 치환 자리 표시자
  를 지정합니다. 기본적으로, ""identifier"" 는 밑줄이나 ASCII 알파벳으
  로 시작하는 대소문자 구분 없는 ASCII 영숫자(밑줄 포함) 문자열로 제한
  됩니다. "$" 문자 뒤의 첫 번째 비 식별자 문자는 이 자리 표시자 명세를
  종료합니다.

* "${identifier}" 는 "$identifier" 와 동등합니다. 유효한 식별자 문자가
  자리 표시자 뒤에 오지만, 자리 표시자의 일부가 아니면 필요합니다, 가
  령 ""${noun}ification"".

문자열에 다른 방식으로 "$" 이 등장하면 "ValueError" 가 발생합니다.

"string" 모듈은 이 규칙들을 구현하는 "Template" 클래스를 제공합니다.
"Template" 의 메서드는 다음과 같습니다:

class string.Template(template)

   생성자는 템플릿 문자열 하나를 받아들입니다.

   substitute(mapping={}, /, **kwds)

      템플릿 치환을 수행하고, 새 문자열을 반환합니다. *mapping* 은 템
      플릿의 자리 표시자와 일치하는 키를 가진 임의의 딕셔너리류 객체입
      니다. 또는, 키워드가 자리 표시자인 키워드 인자를 제공 할 수 있습
      니다. *mapping* 및 *kwds* 가 모두 제공되고 중복이 있는 경우,
      *kwds* 의 자리 표시자가 우선합니다.

   safe_substitute(mapping={}, /, **kwds)

      "substitute()"와 비슷하지만, *mapping* 과 *kwds* 에 자리 표시자
      가 없는 경우, "KeyError" 예외를 발생시키지 않고 원래 자리 표시자
      가 결과 문자열에 그대로 나타납니다. 또한 "substitute()" 와는 달
      리, "$" 가 잘못 사용되는 경우 "ValueError" 를 일으키는 대신 단순
      히 "$" 를 반환합니다.

      다른 예외가 여전히 발생할 수 있지만, 이 메서드가 항상 예외를 발
      생시키는 대신 사용 가능한 문자열을 반환하려고 시도하기 때문에 "
      안전(safe)" 하다고 합니다. 다른 의미에서, "safe_substitute()" 는
      안전하다고 할 수 없습니다. 길 잃은(dangling) 구분 기호, 쌍을 이
      루지 않는 중괄호, 유효한 파이썬 식별자가 아닌 자리 표시자를 포함
      하는 잘못된 템플릿을 조용히 무시하기 때문입니다.

   is_valid()

      Returns "False" if the template has invalid placeholders that
      will cause "substitute()" to raise "ValueError".

      Added in version 3.11.

   get_identifiers()

      Returns a list of the valid identifiers in the template, in the
      order they first appear, ignoring any invalid identifiers.

      Added in version 3.11.

   "Template" 인스턴스는 공개 데이터 어트리뷰트도 하나 제공합니다:

   template

      이것은 생성자의 *template* 인자로 전달된 객체입니다. 일반적으로,
      변경해서는 안 되지만, 읽기 전용 액세스가 강제되지는 않습니다.

다음은 Template 사용 방법의 예입니다:

   >>> from string import Template
   >>> s = Template('$who likes $what')
   >>> s.substitute(who='tim', what='kung pao')
   'tim likes kung pao'
   >>> d = dict(who='tim')
   >>> Template('Give $who $100').substitute(d)
   Traceback (most recent call last):
   ...
   ValueError: Invalid placeholder in string: line 1, col 11
   >>> Template('$who likes $what').substitute(d)
   Traceback (most recent call last):
   ...
   KeyError: 'what'
   >>> Template('$who likes $what').safe_substitute(d)
   'tim likes $what'

고급 사용법: "Template" 의 서브 클래스를 파생하여, 자리 표시자 문법,
구분 기호 문자 또는 템플릿 문자열을 파싱하는데 사용되는 전체 정규식을
사용자 정의 할 수 있습니다. 이렇게 하려면, 다음 클래스 어트리뷰트를 재
정의할 수 있습니다:

* *delimiter* -- 자리 표시자를 도입하는 구분자를 나타내는 리터럴 문자
  열입니다. 기본값은 "$" 입니다. 구현체는 필요할 때 이 문자열에
  "re.escape()" 를 호출하므로, 이 문자열은 정규식이 *아니어야* 합니다.
  또한, 클래스 생성 후에 구분자를 변경할 수 없습니다 (즉, 다른 구분자
  는 반드시 서브 클래스의 클래스 이름 공간에 설정해야 합니다).

* *idpattern* -- 중괄호로 둘러싸지 않은 자리 표시자의 패턴을 설명하는
  정규식입니다. 기본값은 정규식 "(?a:[_a-z][_a-z0-9]*)" 입니다.
  *braceidpattern* 이 "None" 인 경우, 이 패턴은 중괄호가 있는 자리 표
  시자에게도 적용됩니다.

  참고:

    기본 *flags* 가 "re.IGNORECASE" 이기 때문에, 패턴 "[a-z]" 는 비
    ASCII 문자와 일치 할 수 있습니다. 이 때문에 정규식에 "a" 플래그를
    사용했습니다.

  버전 3.7에서 변경: *braceidpattern* 은 중괄호로 싸여있을 때와 그렇지
  않을 때 사용되는 별도의 패턴을 정의하는데 사용할 수 있습니다.

* *braceidpattern* -- *idpattern* 과 유사하지만, 중괄호로 싸인 자리 표
  시자에 대한 패턴을 설명합니다. 기본값은 "None" 인데, *idpattern* 을
  사용하는 것을 의미합니다 (즉, 같은 패턴이 중괄호가 있을 때와 없을 때
  모두 사용됩니다). 이 값을 주면, 중괄호가 있을 때와 없을 때의 자리 표
  시자에 서로 다른 패턴을 정의 할 수 있습니다.

  Added in version 3.7.

* *flags* -- 치환 인식에 사용되는 정규식을 컴파일할 때 적용될 정규식
  플래그입니다. 기본값은 "re.IGNORECASE" 입니다. "re.VERBOSE" 가 항상
  플래그에 추가되므로, 사용자 정의 *idpattern* 은 상세한 정규식의 규칙
  을 따라야 합니다.

  Added in version 3.2.

또는, 클래스 어트리뷰트 *pattern* 을 재정의하여 전체 정규식 패턴을 제
공 할 수 있습니다. 이렇게 하는 경우, 값은 네 개의 이름있는 캡처 그룹이
있는 정규식 객체여야 합니다. 캡처 그룹은 위에 제공된 규칙과 함께 유효
하지 않은 자리 표시자 규칙에 해당합니다:

* *escaped* -- 이 그룹은 이스케이프 시퀀스를 일치시킵니다, 예를 들어
  기본 패턴에서 "$$".

* *named* -- 이 그룹은 중괄호가 없는 자리 표시자 이름을 일치합니다; 캡
  처 그룹에 구분자를 포함해서는 안 됩니다.

* *braced* -- 이 그룹은 중괄호로 묶인 자리 표시자 이름을 일치시킵니다;
  캡처 그룹에 구분자나 중괄호를 포함해서는 안 됩니다.

* *invalid* -- 이 그룹은 그 외의 구분자 패턴(일반적으로 단일 구분자)을
  일치시키고, 정규식의 마지막에 나타나야 합니다.

The methods on this class will raise "ValueError" if the pattern
matches the template without one of these named groups matching.


도움 함수
=========

string.capwords(s, sep=None)

   인자를 "str.split()" 을 사용하여 단어로 나누고, "str.capitalize()"
   를 사용하여 각 단어의 첫 글자를 대문자로 만들고, 이렇게 만들어진 단
   어들을 "str.join()" 을 사용하여 결합합니다. 선택적 두 번째 인자
   *sep* 가 없거나 "None" 이면, 연속된 공백 문자는 단일 스페이스로 바
   뀌고 앞뒤 공백이 제거됩니다. 그렇지 않으면 *sep* 가 단어를 나누고
   합치는 데 사용됩니다.
