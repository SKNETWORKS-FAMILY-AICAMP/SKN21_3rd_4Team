"sysconfig" --- 파이썬의 구성 정보에 접근하기
*********************************************

Added in version 3.2.

**소스 코드:** Lib/sysconfig

======================================================================

"sysconfig" 모듈은 설치 경로 목록과 현재 플랫폼과 관련된 구성 변수와
같은 파이썬 구성 정보에 대한 액세스를 제공합니다.


구성 변수
=========

Python 배포판에는 "Makefile" 과 "pyconfig.h" 헤더 파일이 들어 있습니다
. 이 파일은 파이썬 바이너리 자체와 "setuptools" 를 사용하여 컴파일된
타사 C 확장을 빌드하는 데 필요합니다.

"sysconfig" 는 "get_config_vars()" 또는 "get_config_var()"를 사용하여
액세스 할 수 있는 딕셔너리에 이들 파일에 있는 모든 변수를 넣습니다.

윈도우에서는 훨씬 작은 세트입니다.

sysconfig.get_config_vars(*args)

   인자가 없으면, 현재 플랫폼과 관련된 모든 구성 변수의 딕셔너리를 반
   환합니다.

   인자가 있으면, 인자를 사용하여 구성 변수 딕셔너리에서 각 인자를 조
   회한 결괏값 리스트를 돌려줍니다.

   인자별로, 값이 없으면 "None" 을 반환합니다.

sysconfig.get_config_var(name)

   하나의 변수 *name* 의 값을 반환합니다.
   "get_config_vars().get(name)" 과 같습니다.

   *name* 을 찾지 못하면 "None" 을 반환합니다.

사용 예:

   >>> import sysconfig
   >>> sysconfig.get_config_var('Py_ENABLE_SHARED')
   0
   >>> sysconfig.get_config_var('LIBDIR')
   '/usr/local/lib'
   >>> sysconfig.get_config_vars('AR', 'CXX')
   ['ar', 'g++']


설치 경로
=========

파이썬은 플랫폼과 설치 옵션에 따라 다른 설치 스킴을 사용합니다. 이 스
킴은 "os.name" 에 의해 반환된 값을 기반으로 하는 고유한 식별자로
"sysconfig" 에 저장됩니다. 이 스킴은 패키지 설치기가 파일을 복사할 위
치를 결정하는 데 사용됩니다.

파이썬은 현재 9가지 스킴을 지원합니다:

* *posix_prefix*: 리눅스나 맥 OS 같은 포직스(POSIX) 플랫폼용 스킴. 이
  것은 파이썬이나 컴포넌트가 설치될 때 사용되는 기본 스킴입니다.

* *posix_home*: *home* 옵션이 사용될 때, 포직스 플랫폼용 스킴. 이 스킴
  은 특정 홈 접두어 아래에 있는 경로를 정의합니다.

* *posix_user*: *user* 옵션이 사용될 때, 포직스 플랫폼용 스킴. 이 스킴
  은 사용자 홈 디렉터리 아래에 있는 경로를 정의합니다
  ("site.USER_BASE").

* *posix_venv*: scheme for "Python virtual environments" on POSIX
  platforms; by default it is the same as *posix_prefix*.

* *nt*: 윈도우용 스킴. 이것은 파이썬이나 컴포넌트가 설치될 때 사용되는
  기본 스킴입니다.

* *nt_user*: *user* 옵션이 사용될 때, 윈도우용 스킴.

* *nt_venv*: scheme for "Python virtual environments" on Windows; by
  default it is the same as *nt*.

* *venv*: a scheme with values from either *posix_venv* or *nt_venv*
  depending on the platform Python runs on.

* *osx_framework_user*: *user* 옵션이 사용될, 맥 OS용 스킴.

각 스킴은 일련의 경로로 구성되며 각 경로는 고유한 식별자를 가집니다.
파이썬은 현재 8개의 경로를 사용합니다:

* *stdlib*: 플랫폼마다 다르지 않은 표준 파이썬 라이브러리 파일이 들어
  있는 디렉터리.

* *platstdlib*: 플랫폼마다 다른 표준 파이썬 라이브러리 파일이 들어있는
  디렉터리.

* *platlib*: 사이트마다, 플랫폼마다 다른 파일용 디렉터리.

* *purelib*: 사이트마다 다르지만, 플랫폼마다 다르지 않은 파일이 들어있
  는 디렉터리 ('순수한' 파이썬').

* *include*: 파이썬 C-API 를 위한 플랫폼마다 다르지 않은 헤더 파일용
  디렉터리.

* *platinclude*: 파이썬 C-API 를 위한 플랫폼마다 다른 헤더 파일용 디렉
  터리.

* *scripts*: 스크립트 파일용 디렉터리.

* *data*: 데이터 파일용 디렉터리.


User scheme
===========

This scheme is designed to be the most convenient solution for users
that don't have write permission to the global site-packages directory
or don't want to install into it.

Files will be installed into subdirectories of "site.USER_BASE"
(written as "*userbase*" hereafter).  This scheme installs pure Python
modules and extension modules in the same location (also known as
"site.USER_SITE").


"posix_user"
------------

+----------------+-------------------------------------------------------------+
| 경로           | 설치 디렉터리                                               |
|================|=============================================================|
| *stdlib*       | "*userbase*/lib/python*X.Y*"                                |
+----------------+-------------------------------------------------------------+
| *platstdlib*   | "*userbase*/lib/python*X.Y*"                                |
+----------------+-------------------------------------------------------------+
| *platlib*      | "*userbase*/lib/python*X.Y*/site-packages"                  |
+----------------+-------------------------------------------------------------+
| *purelib*      | "*userbase*/lib/python*X.Y*/site-packages"                  |
+----------------+-------------------------------------------------------------+
| *include*      | "*userbase*/include/python*X.Y*"                            |
+----------------+-------------------------------------------------------------+
| *scripts*      | "*userbase*/bin"                                            |
+----------------+-------------------------------------------------------------+
| *data*         | "*userbase*"                                                |
+----------------+-------------------------------------------------------------+


"nt_user"
---------

+----------------+-------------------------------------------------------------+
| 경로           | 설치 디렉터리                                               |
|================|=============================================================|
| *stdlib*       | "*userbase*\Python*XY*"                                     |
+----------------+-------------------------------------------------------------+
| *platstdlib*   | "*userbase*\Python*XY*"                                     |
+----------------+-------------------------------------------------------------+
| *platlib*      | "*userbase*\Python*XY*\site-packages"                       |
+----------------+-------------------------------------------------------------+
| *purelib*      | "*userbase*\Python*XY*\site-packages"                       |
+----------------+-------------------------------------------------------------+
| *include*      | "*userbase*\Python*XY*\Include"                             |
+----------------+-------------------------------------------------------------+
| *scripts*      | "*userbase*\Python*XY*\Scripts"                             |
+----------------+-------------------------------------------------------------+
| *data*         | "*userbase*"                                                |
+----------------+-------------------------------------------------------------+


"osx_framework_user"
--------------------

+----------------+-------------------------------------------------------------+
| 경로           | 설치 디렉터리                                               |
|================|=============================================================|
| *stdlib*       | "*userbase*/lib/python"                                     |
+----------------+-------------------------------------------------------------+
| *platstdlib*   | "*userbase*/lib/python"                                     |
+----------------+-------------------------------------------------------------+
| *platlib*      | "*userbase*/lib/python/site-packages"                       |
+----------------+-------------------------------------------------------------+
| *purelib*      | "*userbase*/lib/python/site-packages"                       |
+----------------+-------------------------------------------------------------+
| *include*      | "*userbase*/include/python*X.Y*"                            |
+----------------+-------------------------------------------------------------+
| *scripts*      | "*userbase*/bin"                                            |
+----------------+-------------------------------------------------------------+
| *data*         | "*userbase*"                                                |
+----------------+-------------------------------------------------------------+


Home scheme
===========

The idea behind the "home scheme" is that you build and maintain a
personal stash of Python modules.  This scheme's name is derived from
the idea of a "home" directory on Unix, since it's not unusual for a
Unix user to make their home directory have a layout similar to
"/usr/" or "/usr/local/". This scheme can be used by anyone,
regardless of the operating system they are installing for.


"posix_home"
------------

+----------------+-------------------------------------------------------------+
| 경로           | 설치 디렉터리                                               |
|================|=============================================================|
| *stdlib*       | "*home*/lib/python"                                         |
+----------------+-------------------------------------------------------------+
| *platstdlib*   | "*home*/lib/python"                                         |
+----------------+-------------------------------------------------------------+
| *platlib*      | "*home*/lib/python"                                         |
+----------------+-------------------------------------------------------------+
| *purelib*      | "*home*/lib/python"                                         |
+----------------+-------------------------------------------------------------+
| *include*      | "*home*/include/python"                                     |
+----------------+-------------------------------------------------------------+
| *platinclude*  | "*home*/include/python"                                     |
+----------------+-------------------------------------------------------------+
| *scripts*      | "*home*/bin"                                                |
+----------------+-------------------------------------------------------------+
| *data*         | "*home*"                                                    |
+----------------+-------------------------------------------------------------+


Prefix scheme
=============

The "prefix scheme" is useful when you wish to use one Python
installation to perform the build/install (i.e., to run the setup
script), but install modules into the third-party module directory of
a different Python installation (or something that looks like a
different Python installation).  If this sounds a trifle unusual, it
is---that's why the user and home schemes come before.  However, there
are at least two known cases where the prefix scheme will be useful.

First, consider that many Linux distributions put Python in "/usr",
rather than the more traditional "/usr/local".  This is entirely
appropriate, since in those cases Python is part of "the system"
rather than a local add-on. However, if you are installing Python
modules from source, you probably want them to go in
"/usr/local/lib/python2.*X*" rather than "/usr/lib/python2.*X*".

Another possibility is a network filesystem where the name used to
write to a remote directory is different from the name used to read
it: for example, the Python interpreter accessed as
"/usr/local/bin/python" might search for modules in
"/usr/local/lib/python2.*X*", but those modules would have to be
installed to, say, "/mnt/*@server*/export/lib/python2.*X*".


"posix_prefix"
--------------

+----------------+------------------------------------------------------------+
| 경로           | 설치 디렉터리                                              |
|================|============================================================|
| *stdlib*       | "*prefix*/lib/python*X.Y*"                                 |
+----------------+------------------------------------------------------------+
| *platstdlib*   | "*prefix*/lib/python*X.Y*"                                 |
+----------------+------------------------------------------------------------+
| *platlib*      | "*prefix*/lib/python*X.Y*/site-packages"                   |
+----------------+------------------------------------------------------------+
| *purelib*      | "*prefix*/lib/python*X.Y*/site-packages"                   |
+----------------+------------------------------------------------------------+
| *include*      | "*prefix*/include/python*X.Y*"                             |
+----------------+------------------------------------------------------------+
| *platinclude*  | "*prefix*/include/python*X.Y*"                             |
+----------------+------------------------------------------------------------+
| *scripts*      | "*prefix*/bin"                                             |
+----------------+------------------------------------------------------------+
| *data*         | "*prefix*"                                                 |
+----------------+------------------------------------------------------------+


"nt"
----

+----------------+------------------------------------------------------------+
| 경로           | 설치 디렉터리                                              |
|================|============================================================|
| *stdlib*       | "*prefix*\Lib"                                             |
+----------------+------------------------------------------------------------+
| *platstdlib*   | "*prefix*\Lib"                                             |
+----------------+------------------------------------------------------------+
| *platlib*      | "*prefix*\Lib\site-packages"                               |
+----------------+------------------------------------------------------------+
| *purelib*      | "*prefix*\Lib\site-packages"                               |
+----------------+------------------------------------------------------------+
| *include*      | "*prefix*\Include"                                         |
+----------------+------------------------------------------------------------+
| *platinclude*  | "*prefix*\Include"                                         |
+----------------+------------------------------------------------------------+
| *scripts*      | "*prefix*\Scripts"                                         |
+----------------+------------------------------------------------------------+
| *data*         | "*prefix*"                                                 |
+----------------+------------------------------------------------------------+


설치 경로 함수
==============

"sysconfig" 는 이러한 설치 경로를 결정하는 몇 가지 함수를 제공합니다.

sysconfig.get_scheme_names()

   현재 "sysconfig" 에서 지원되는 모든 스킴을 포함하는 튜플을 돌려줍니
   다.

sysconfig.get_default_scheme()

   현재 플랫폼에 대한 기본 스킴 이름을 반환합니다.

   Added in version 3.10: This function was previously named
   "_get_default_scheme()" and considered an implementation detail.

   버전 3.11에서 변경: When Python runs from a virtual environment,
   the *venv* scheme is returned.

sysconfig.get_preferred_scheme(key)

   Return a preferred scheme name for an installation layout specified
   by *key*.

   *key* must be either ""prefix"", ""home"", or ""user"".

   The return value is a scheme name listed in "get_scheme_names()".
   It can be passed to "sysconfig" functions that take a *scheme*
   argument, such as "get_paths()".

   Added in version 3.10.

   버전 3.11에서 변경: When Python runs from a virtual environment and
   "key="prefix"", the *venv* scheme is returned.

sysconfig._get_preferred_schemes()

   Return a dict containing preferred scheme names on the current
   platform. Python implementers and redistributors may add their
   preferred schemes to the "_INSTALL_SCHEMES" module-level global
   value, and modify this function to return those scheme names, to
   e.g. provide different schemes for system and language package
   managers to use, so packages installed by either do not mix with
   those by the other.

   End users should not use this function, but "get_default_scheme()"
   and "get_preferred_scheme()" instead.

   Added in version 3.10.

sysconfig.get_path_names()

   현재 "sysconfig" 에서 지원되는 모든 경로명을 포함하는 튜플을 돌려줍
   니다.

sysconfig.get_path(name[, scheme[, vars[, expand]]])

   *scheme* 이라는 설치 스킴에서, 경로 *name* 에 해당하는 설치 경로를
   돌려줍니다.

   *name* 은 "get_path_names()" 가 돌려주는 리스트에 있는 값이어야 합
   니다.

   "sysconfig" 는 각 경로명에 해당하는 설치 경로를 플랫폼별로 확장할
   변수와 함께 저장합니다. 예를 들어, *nt* 스킴의 *stdlib* 경로는
   "{base}/Lib" 입니다.

   "get_path()" 는 "get_config_vars()" 에 의해 반환된 변수를 사용하여
   경로를 확장합니다. 모든 변수는 각 플랫폼에 대한 기본값을 가지므로
   이 함수를 호출하고 기본값을 가져올 수 있습니다.

   *scheme* 이 제공되면, 그것은 "get_scheme_names()" 에 의해 반환된 리
   스트에 있는 값이어야 합니다. 그렇지 않으면, 현재 플랫폼의 기본 스킴
   이 사용됩니다.

   *vars* 가 제공되면, "get_config_vars()" 에 의해 반환된 딕셔너리를
   갱신할 변수의 딕셔너리여야 합니다.

   *expand* 가 "False" 로 설정되면, 경로는 변수를 사용하여 확장되지 않
   습니다.

   *name* 을 찾지 못하면, "KeyError"를 발생시킵니다.

sysconfig.get_paths([scheme[, vars[, expand]]])

   설치 스킴에 해당하는 모든 설치 경로를 포함하는 딕셔너리를 돌려줍니
   다. 자세한 정보는 "get_path()" 를 보십시오.

   *scheme* 을 제공하지 않으면, 현재 플랫폼에 대한 기본 스킴을 사용합
   니다.

   *vars* 가 제공되면, 경로를 확장하는 데 사용되는 딕셔너리를 갱신하는
   변수의 딕셔너리여야 합니다.

   *expand* 를 거짓으로 설정하면 경로가 확장되지 않습니다.

   *scheme* 이 존재하는 스킴이 아니면, "get_paths()" 는 "KeyError" 를
   발생시킵니다.


기타 함수
=========

sysconfig.get_python_version()

   "MAJOR.MINOR" 파이썬 버전 번호를 문자열로 반환합니다. "'%d.%d' %
   sys.version_info[:2]" 와 유사합니다.

sysconfig.get_platform()

   현재의 플랫폼을 식별하는 문자열을 돌려줍니다.

   이는 주로 플랫폼별 빌드 디렉터리와 플랫폼별로 빌드 된 배포판을 구별
   하기 위해 사용됩니다. 포함된 정확한 정보는 OS에 따라 다르지만, 일반
   적으로 OS 이름과 버전 및 아키텍처를 포함합니다 ("os.uname()" 에서
   제공됩니다); 예를 들어, 리눅스에서 커널 버전은 특별히 중요하지 않습
   니다.

   반환 값의 예:

   Windows:

   * win-amd64 (AMD64의 64비트 윈도우, 일명 x86_64, Intel64, EM64T 등)

   * win-arm64 (ARM64의 64비트 윈도우, 일명 AArch64)

   * win32 (기타 모든 것 - 구체적으로, sys.platform이 반환됩니다)

   POSIX based OS:

   * linux-x86_64

   * macosx-15.5-arm64

   * macosx-26.0-universal2 (macOS on Apple Silicon or Intel)

   * android-24-arm64_v8a

   다른 포직스 이외의 플랫폼의 경우, 현재는 "sys.platform" 만 반환합니
   다.

sysconfig.is_python_build()

   실행 중인 파이썬 인터프리터가 소스에서 빌드되어 빌드 된 위치에서 실
   행되고, "make install" 을 실행하거나 바이너리 설치 프로그램을 통해
   설치 한 결과가 아닌 위치에서 실행되는 것이 아니라면 "True" 를 반환
   합니다.

sysconfig.parse_config_h(fp[, vars])

   "config.h"-스타일 파일을 해석합니다.

   *fp* 는 "config.h"-류 파일을 가리키는 파일류 객체입니다.

   이름/값 쌍을 포함하는 딕셔너리가 반환됩니다. 선택적 딕셔너리가 두
   번째 인자로 전달되면, 새 사전 대신 사용되며 파일에서 읽은 값으로 갱
   신됩니다.

sysconfig.get_config_h_filename()

   "pyconfig.h" 의 경로를 반환합니다.

sysconfig.get_makefile_filename()

   "Makefile" 의 경로를 반환합니다.


Command-line usage
==================

"sysconfig" 를 파이썬의 *-m* 옵션으로 스크립트로 사용할 수 있습니다:

   $ python -m sysconfig
   Platform: "macosx-10.4-i386"
   Python version: "3.2"
   Current installation scheme: "posix_prefix"

   Paths:
           data = "/usr/local"
           include = "/Users/tarek/Dev/svn.python.org/py3k/Include"
           platinclude = "."
           platlib = "/usr/local/lib/python3.2/site-packages"
           platstdlib = "/usr/local/lib/python3.2"
           purelib = "/usr/local/lib/python3.2/site-packages"
           scripts = "/usr/local/bin"
           stdlib = "/usr/local/lib/python3.2"

   Variables:
           AC_APPLE_UNIVERSAL_BUILD = "0"
           AIX_GENUINE_CPLUSPLUS = "0"
           AR = "ar"
           ARFLAGS = "rc"
           ...

이 호출은 "get_platform()", "get_python_version()", "get_path()" 및
"get_config_vars()" 에 의해 반환된 정보를 표준 출력에 인쇄합니다.
