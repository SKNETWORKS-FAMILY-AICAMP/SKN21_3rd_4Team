"hmac" --- 메시지 인증을 위한 키 해싱
*************************************

**소스 코드:** Lib/hmac.py

======================================================================

This module implements the HMAC algorithm as described by **RFC
2104**. The interface allows to use any hash function with a *fixed*
digest size. In particular, extendable output functions such as
SHAKE-128 or SHAKE-256 cannot be used with HMAC.

hmac.new(key, msg=None, digestmod)

   새로운 hmac 객체를 반환합니다. *key*는 비밀 키를 제공하는 바이트열
   이나 바이트 배열(bytearray) 객체입니다. *msg*가 있으면,
   "update(msg)" 메서드 호출이 수행됩니다. *digestmod*는 다이제스트 이
   름, 다이제스트 생성자 또는 HMAC 객체가 사용할 모듈입니다.
   "hashlib.new()"에 적합한 모든 이름일 수 있습니다. 인자의 위치에도
   불구하고, 필수입니다.

   버전 3.4에서 변경: 매개 변수 *key*는 바이트열 또는 바이트 배열 객체
   일 수 있습니다. 매개 변수 *msg*는 "hashlib"가 지원하는 모든 형이 될
   수 있습니다. 매개 변수 *digestmod*는 해시 알고리즘의 이름이 될 수
   있습니다.

   버전 3.8에서 변경: *digestmod* 인자는 이제 필수입니다. 초기 *msg*가
   없을 때 어색함을 피하려면 키워드 인자로 전달하십시오.

hmac.digest(key, msg, digest)

   주어진 비밀 *key* 와 *digest*로 *msg*의 다이제스트를 반환합니다. 이
   함수는 "HMAC(key, msg, digest).digest()"와 동등하지만, 최적화된 C
   나 인라인 구현을 사용해서, 메모리에 맞는 메시지에는 더 빠릅니다. 매
   개 변수 *key*, *msg* 및 *digest*는 "new()"에서와 같은 뜻입니다.

   CPython 구현 세부 사항, 최적화된 C 구현은 *digest*가 문자열이고
   OpenSSL에서 지원하는 다이제스트 알고리즘의 이름일 때만 사용됩니다.

   Added in version 3.7.

class hmac.HMAC

   HMAC 객체에는 다음과 같은 메서드가 있습니다:

HMAC.update(msg)

   hmac 객체를 *msg*로 갱신합니다. 반복되는 호출은 모든 인자를 이어붙
   인 단일 호출과 동등합니다: "m.update(a); m.update(b)"는 "m.update(a
   + b)"와 동등합니다.

   버전 3.4에서 변경: 매개 변수 *msg*는 "hashlib"가 지원하는 모든 형이
   될 수 있습니다.

HMAC.digest()

   지금까지 "update()" 메서드로 전달된 바이트들의 다이제스트를 반환합
   니다. 이 바이트열 객체는 생성자에게 주어진 다이제스트의
   *digest_size*와 길이가 같습니다. NUL 바이트를 포함하여 비 ASCII 바
   이트를 포함할 수 있습니다.

   경고:

     검증 루틴에서 "digest()"의 출력을 외부에서 제공되는 다이제스트와
     비교할 때, "==" 연산자 대신 "compare_digest()" 함수를 사용하여 타
     이밍 공격의 취약점을 줄이는 것이 좋습니다.

HMAC.hexdigest()

   다이제스트가 16진수만 포함하는 길이가 두 배인 문자열로 반환된다는
   점을 제외하고는 "digest()"와 같습니다. 이것은 전자 메일이나 기타 비
   바이너리 환경에서 값을 안전하게 교환하는 데 사용될 수 있습니다.

   경고:

     검증 루틴에서 "hexdigest()"의 출력을 외부에서 제공되는 다이제스트
     와 비교할 때, "==" 연산자 대신 "compare_digest()" 함수를 사용하여
     타이밍 공격의 취약점을 줄이는 것이 좋습니다.

HMAC.copy()

   hmac 객체의 복사본("클론")을 반환합니다. 이것은 공통 초기 부분 문자
   열을 공유하는 문자열들의 다이제스트를 효율적으로 계산하는 데 사용할
   수 있습니다.

hmac 객체에는 다음과 같은 어트리뷰트가 있습니다:

HMAC.digest_size

   결과 HMAC 다이제스트의 크기(바이트).

HMAC.block_size

   해시 알고리즘의 내부 블록 크기(바이트).

   Added in version 3.4.

HMAC.name

   이 HMAC의 규범적 이름, 항상 소문자, 예를 들어 "hmac-md5".

   Added in version 3.4.

버전 3.10에서 변경: 설명되지 않은 어트리뷰트 "HMAC.digest_cons",
"HMAC.inner" 및 "HMAC.outer"를 제거했습니다.

이 모듈은 또한 다음 도우미 함수를 제공합니다:

hmac.compare_digest(a, b)

   "a == b"를 반환합니다. 이 함수는 내용 기반의 단락(short circuiting)
   동작을 피함으로써 타이밍 분석을 방지하도록 설계된 접근법을 사용해서
   암호화에 적합하게 만듭니다. *a*와 *b*는 모두 같은 형이어야 합니다:
   "str" (ASCII만, 예를 들어 "HMAC.hexdigest()"에 의해 반환된 것과 같
   은 것) 이나 *바이트열류 객체*.

   참고:

     *a*와 *b*의 길이가 다르거나 에러가 발생하면, 타이밍 공격이 이론적
     으로는 *a* 와 *b*의 형과 길이에 관한 정보를 드러낼 수 있습니다 -
     하지만 그 값은 아닙니다.

   Added in version 3.3.

   버전 3.10에서 변경: 이 함수는 사용할 수 있으면 내부적으로 OpenSSL의
   "CRYPTO_memcmp()"를 사용합니다.

더 보기:

  모듈 "hashlib"
     안전한 해시 함수를 제공하는 파이썬 모듈.
