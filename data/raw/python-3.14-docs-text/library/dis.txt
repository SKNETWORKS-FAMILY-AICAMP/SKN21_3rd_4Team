"dis" --- Disassembler for Python bytecode
******************************************

**소스 코드:** Lib/dis.py

======================================================================

"dis" 모듈은 CPython *바이트 코드*를 역 어셈블 하여 분석을 지원합니다.
이 모듈이 입력으로 취하는 CPython 바이트 코드는 파일
"Include/opcode.h"에 정의되어 있으며 컴파일러와 인터프리터에서 사용됩
니다.

바이트 코드는 CPython 인터프리터의 구현 세부 사항입니다. 파이썬 버전
간에 바이트 코드가 추가, 제거 또는 변경되지 않을 것이라는 보장은 없습
니다. 이 모듈을 사용하는 것이 파이썬 VM이나 파이썬 릴리스에 걸쳐 작동
할 것으로 생각하지 말아야 합니다.

버전 3.6에서 변경: 명령어마다 2바이트를 사용합니다. 이전에는 바이트 수
가 명령어에 따라 달랐습니다.

버전 3.10에서 변경: The argument of jump, exception handling and loop
instructions is now the instruction offset rather than the byte
offset.

버전 3.11에서 변경: Some instructions are accompanied by one or more
inline cache entries, which take the form of "CACHE" instructions.
These instructions are hidden by default, but can be shown by passing
"show_caches=True" to any "dis" utility. Furthermore, the interpreter
now adapts the bytecode to specialize it for different runtime
conditions. The adaptive bytecode can be shown by passing
"adaptive=True".

버전 3.12에서 변경: The argument of a jump is the offset of the target
instruction relative to the instruction that appears immediately after
the jump instruction's "CACHE" entries.As a consequence, the presence
of the "CACHE" instructions is transparent for forward jumps but needs
to be taken into account when reasoning about backward jumps.

버전 3.13에서 변경: The output shows logical labels rather than
instruction offsets for jump targets and exception handlers. The "-O"
command line option and the "show_offsets" argument were added.

버전 3.14에서 변경: The "-P" command-line option and the
"show_positions" argument were added.The "-S" command-line option is
added.

Example: Given the function "myfunc()":

   def myfunc(alist):
       return len(alist)

the following command can be used to display the disassembly of
"myfunc()":

   >>> dis.dis(myfunc)
     2           RESUME                   0

     3           LOAD_GLOBAL              1 (len + NULL)
                 LOAD_FAST_BORROW         0 (alist)
                 CALL                     1
                 RETURN_VALUE

("2"는 줄 번호입니다).


Command-line interface
======================

The "dis" module can be invoked as a script from the command line:

   python -m dis [-h] [-C] [-O] [-P] [-S] [infile]

The following options are accepted:

-h, --help

   Display usage and exit.

-C, --show-caches

   Show inline caches.

   Added in version 3.13.

-O, --show-offsets

   Show offsets of instructions.

   Added in version 3.13.

-P, --show-positions

   Show positions of instructions in the source code.

   Added in version 3.14.

-S, --specialized

   Show specialized bytecode.

   Added in version 3.14.

If "infile" is specified, its disassembled code will be written to
stdout. Otherwise, disassembly is performed on compiled source code
received from stdin.


바이트 코드 분석
================

Added in version 3.4.

바이트 코드 분석 API는 컴파일된 코드의 세부 사항에 쉽게 액세스 할 수
있도록 하는 "Bytecode" 객체로 파이썬 코드 조각을 감쌀 수 있도록 합니다
.

class dis.Bytecode(x, *, first_line=None, current_offset=None, show_caches=False, adaptive=False, show_offsets=False, show_positions=False)

   함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코드 문자
   열 또는 ("compile()"에서 반환된) 코드 객체에 해당하는 바이트 코드를
   분석합니다.

   이것은 아래에 나열된 많은 함수, 특히 "get_instructions()"를 둘러싼
   편리한 래퍼입니다, "Bytecode" 인스턴스를 이터레이트 하면 바이트 코
   드 연산이 "Instruction" 인스턴스로 산출되기 때문입니다.

   *first_line*이 "None"이 아니면, 역 어셈블 된 코드에서 첫 번째 소스
   줄에 대해 보고해야 하는 줄 번호를 나타냅니다. 그렇지 않으면, 소스
   줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다.

   *current_offset*이 "None"이 아니면, 역 어셈블 된 코드의 명령어 오프
   셋을 나타냅니다. 이를 설정하면, "dis()"가 지정된 옵코드(opcode)에
   대해 "현재 명령어" 마커를 표시합니다.

   If *show_caches* is "True", "dis()" will display inline cache
   entries used by the interpreter to specialize the bytecode.

   If *adaptive* is "True", "dis()" will display specialized bytecode
   that may be different from the original bytecode.

   If *show_offsets* is "True", "dis()" will include instruction
   offsets in the output.

   If *show_positions* is "True", "dis()" will include instruction
   source code positions in the output.

   classmethod from_traceback(tb, *, show_caches=False)

      주어진 트레이스백에서 "Bytecode" 인스턴스를 구성하고,
      *current_offset*을 예외를 일으킨 명령어로 설정합니다.

   codeobj

      컴파일된 코드 객체.

   first_line

      코드 객체의 첫 번째 소스 줄 (사용 가능하다면)

   dis()

      바이트 코드 연산의 포맷된 보기를 반환합니다 ("dis.dis()"가 인쇄
      하는 것과 같지만, 여러 줄 문자열로 반환됩니다).

   info()

      "code_info()"처럼, 코드 객체에 대한 자세한 정보가 포함된 포맷된
      여러 줄 문자열을 반환합니다.

   버전 3.7에서 변경: 이제 코루틴과 비동기 제너레이터 객체를 처리할 수
   있습니다.

   버전 3.11에서 변경: Added the *show_caches* and *adaptive*
   parameters.

   버전 3.13에서 변경: Added the *show_offsets* parameter

   버전 3.14에서 변경: Added the *show_positions* parameter.

Example:

   >>> bytecode = dis.Bytecode(myfunc)
   >>> for instr in bytecode:
   ...     print(instr.opname)
   ...
   RESUME
   LOAD_GLOBAL
   LOAD_FAST_BORROW
   CALL
   RETURN_VALUE


분석 함수
=========

"dis" 모듈은 또한 입력을 원하는 출력으로 직접 변환하는 다음 분석 함수
를 정의합니다. 단일 작업만 수행해서, 중간 분석 객체가 유용하지 않을 때
유용할 수 있습니다:

dis.code_info(x)

   제공된 함수, 제너레이터, 비동기 제너레이터, 코루틴, 메서드, 소스 코
   드 문자열 또는 코드 객체에 대한 자세한 코드 객체 정보가 포함된 포맷
   된 여러 줄 문자열을 반환합니다.

   코드 정보 문자열의 정확한 내용은 구현에 따라 달라지며 파이썬 VM이나
   파이썬 릴리스에 걸쳐 임의로 변경될 수 있습니다.

   Added in version 3.2.

   버전 3.7에서 변경: 이제 코루틴과 비동기 제너레이터 객체를 처리할 수
   있습니다.

dis.show_code(x, *, file=None)

   제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체에 대한 자세한
   코드 객체 정보를 *file*(또는 *file*이 지정되지 않으면 "sys.stdout")
   로 인쇄합니다.

   이것은 "print(code_info(x), file=file)"의 편리한 축약 형으로, 인터
   프리터 프롬프트에서의 대화식 탐색을 위한 것입니다.

   Added in version 3.2.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

dis.dis(x=None, *, file=None, depth=None, show_caches=False, adaptive=False, show_offsets=False, show_positions=False)

   Disassemble the *x* object.  *x* can denote either a module, a
   class, a method, a function, a generator, an asynchronous
   generator, a coroutine, a code object, a string of source code or a
   byte sequence of raw bytecode. For a module, it disassembles all
   functions. For a class, it disassembles all methods (including
   class and static methods). For a code object or sequence of raw
   bytecode, it prints one line per bytecode instruction. It also
   recursively disassembles nested code objects. These can include
   generator expressions, nested functions, the bodies of nested
   classes, and the code objects used for annotation scopes. Strings
   are first compiled to code objects with the "compile()" built-in
   function before being disassembled.  If no object is provided, this
   function disassembles the last traceback.

   역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면
   "sys.stdout"에 텍스트로 기록됩니다.

   재귀의 최대 깊이는 "None"이 아닌 한 *depth*에 의해 제한됩니다.
   "depth=0"은 재귀가 없음을 의미합니다.

   If *show_caches* is "True", this function will display inline cache
   entries used by the interpreter to specialize the bytecode.

   If *adaptive* is "True", this function will display specialized
   bytecode that may be different from the original bytecode.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

   버전 3.7에서 변경: 재귀 역 어셈블을 구현하고 *depth* 매개 변수를 추
   가했습니다.

   버전 3.7에서 변경: 이제 코루틴과 비동기 제너레이터 객체를 처리할 수
   있습니다.

   버전 3.11에서 변경: Added the *show_caches* and *adaptive*
   parameters.

   버전 3.13에서 변경: Added the *show_offsets* parameter.

   버전 3.14에서 변경: Added the *show_positions* parameter.

dis.distb(tb=None, *, file=None, show_caches=False, adaptive=False, show_offset=False, show_positions=False)

   트레이스백의 최상단 함수를 역 어셈블 합니다. 전달되지 않으면 마지막
   트레이스백을 사용합니다. 예외를 일으키는 명령어가 표시됩니다.

   역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면
   "sys.stdout"에 텍스트로 기록됩니다.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

   버전 3.11에서 변경: Added the *show_caches* and *adaptive*
   parameters.

   버전 3.13에서 변경: Added the *show_offsets* parameter.

   버전 3.14에서 변경: Added the *show_positions* parameter.

dis.disassemble(code, lasti=-1, *, file=None, show_caches=False, adaptive=False, show_offsets=False, show_positions=False)
dis.disco(code, lasti=-1, *, file=None, show_caches=False, adaptive=False, show_offsets=False, show_positions=False)

   코드 객체를 역 어셈블 하고, *lasti*가 제공되면 마지막 명령어를 표시
   합니다. 출력은 다음 열로 나뉩니다:

   1. the source code location of the instruction. Complete location
      information is shown if *show_positions* is true. Otherwise (the
      default) only the line number is displayed.

   2. 현재 명령어, "-->"로 표시됩니다,

   3. 레이블이 있는 명령어, ">>"로 표시됩니다,

   4. 명령어의 주소,

   5. 연산 코드 이름,

   6. 연산 매개 변수, 그리고

   7. 괄호 안에 있는 매개 변수의 해석.

   매개 변수 해석은 지역과 전역 변수 이름, 상숫값, 분기 대상 및 비교
   연산자를 인식합니다.

   역 어셈블리는 제공된다면 제공된 *file* 인자에, 그렇지 않으면
   "sys.stdout"에 텍스트로 기록됩니다.

   버전 3.4에서 변경: *file* 매개 변수를 추가했습니다.

   버전 3.11에서 변경: Added the *show_caches* and *adaptive*
   parameters.

   버전 3.13에서 변경: Added the *show_offsets* parameter.

   버전 3.14에서 변경: Added the *show_positions* parameter.

dis.get_instructions(x, *, first_line=None, show_caches=False, adaptive=False)

   제공된 함수, 메서드, 소스 코드 문자열 또는 코드 객체의 명령어들에
   대한 이터레이터를 반환합니다.

   이터레이터는 제공된 코드의 각 연산에 대한 세부 정보를 제공하는
   "Instruction" 네임드 튜플의 연속을 생성합니다.

   *first_line*이 "None"이 아니면, 역 어셈블 된 코드에서 첫 번째 소스
   줄에 대해 보고해야 하는 줄 번호를 나타냅니다. 그렇지 않으면, 소스
   줄 정보(있다면)를 역 어셈블 된 코드 객체에서 직접 취합니다.

   The *adaptive* parameter works as it does in "dis()".

   Added in version 3.4.

   버전 3.11에서 변경: Added the *show_caches* and *adaptive*
   parameters.

   버전 3.13에서 변경: The *show_caches* parameter is deprecated and
   has no effect. The iterator generates the "Instruction" instances
   with the *cache_info* field populated (regardless of the value of
   *show_caches*) and it no longer generates separate items for the
   cache entries.

dis.findlinestarts(code)

   This generator function uses the "co_lines()" method of the code
   object *code* to find the offsets which are starts of lines in the
   source code.  They are generated as "(offset, lineno)" pairs.

   버전 3.6에서 변경: 줄 번호가 줄어들 수 있습니다. 전에는, 언제나 증
   가했습니다.

   버전 3.10에서 변경: The **PEP 626** "co_lines()" method is used
   instead of the "co_firstlineno" and "co_lnotab" attributes of the
   code object.

   버전 3.13에서 변경: Line numbers can be "None" for bytecode that
   does not map to source lines.

dis.findlabels(code)

   원시 컴파일된 바이트 코드 문자열 *code*에서 점프 대상인 모든 오프셋
   을 감지하고, 이러한 오프셋의 리스트를 반환합니다.

dis.stack_effect(opcode, oparg=None, *, jump=None)

   인자 *oparg*를 갖는 *opcode*의 스택 효과를 계산합니다.

   코드에 점프 대상이 있고 *jump*가 "True"이면, "stack_effect()"는 점
   프의 스택 효과를 반환합니다. *jump*가 "False"이면, 점프하지 않는 스
   택 효과를 반환합니다. *jump*가 "None"(기본값)이면, 두 경우의 최대
   스택 효과를 반환합니다.

   Added in version 3.4.

   버전 3.8에서 변경: *jump* 매개 변수를 추가했습니다.

   버전 3.13에서 변경: If "oparg" is omitted (or "None"), the stack
   effect is now returned for "oparg=0". Previously this was an error
   for opcodes that use their arg. It is also no longer an error to
   pass an integer "oparg" when the "opcode" does not use it; the
   "oparg" in this case is ignored.


파이썬 바이트 코드 명령어
=========================

"get_instructions()" 함수와 "Bytecode" 클래스는 바이트 코드 명령어의
세부 사항을 "Instruction" 인스턴스로 제공합니다:

class dis.Instruction

   바이트 코드 연산에 대한 세부 사항

   opcode

      연산의 숫자 코드, 아래 나열된 옵코드 값과 옵코드 모음에 있는 바
      이트 코드 값에 해당합니다.

   opname

      연산의 사람이 읽을 수 있는 이름

   baseopcode

      numeric code for the base operation if operation is specialized;
      otherwise equal to "opcode"

   baseopname

      human readable name for the base operation if operation is
      specialized; otherwise equal to "opname"

   arg

      연산에 대한 숫자 인자 (있다면), 그렇지 않으면 "None"

   oparg

      alias for "arg"

   argval

      resolved arg value (if any), otherwise "None"

   argrepr

      human readable description of operation argument (if any),
      otherwise an empty string.

   offset

      바이트 코드 시퀀스 내에서 연산의 시작 인덱스

   start_offset

      start index of operation within bytecode sequence, including
      prefixed "EXTENDED_ARG" operations if present; otherwise equal
      to "offset"

   cache_offset

      start index of the cache entries following the operation

   end_offset

      end index of the cache entries following the operation

   starts_line

      "True" if this opcode starts a source line, otherwise "False"

   line_number

      source line number associated with this opcode (if any),
      otherwise "None"

   is_jump_target

      다른 코드가 여기로 점프하면 "True", 그렇지 않으면 "False"

   jump_target

      bytecode index of the jump target if this is a jump operation,
      otherwise "None"

   positions

      "dis.Positions" object holding the start and end locations that
      are covered by this instruction.

   cache_info

      Information about the cache entries of this instruction, as
      triplets of the form "(name, size, data)", where the "name" and
      "size" describe the cache format and data is the contents of the
      cache. "cache_info" is "None" if the instruction does not have
      caches.

   Added in version 3.4.

   버전 3.11에서 변경: Field "positions" is added.

   버전 3.13에서 변경: Changed field "starts_line".Added fields
   "start_offset", "cache_offset", "end_offset", "baseopname",
   "baseopcode", "jump_target", "oparg", "line_number" and
   "cache_info".

class dis.Positions

   In case the information is not available, some fields might be
   "None".

   lineno

   end_lineno

   col_offset

   end_col_offset

   Added in version 3.11.

파이썬 컴파일러는 현재 다음 바이트 코드 명령어를 생성합니다.

**일반 명령어**

In the following, We will refer to the interpreter stack as "STACK"
and describe operations on it as if it was a Python list. The top of
the stack corresponds to "STACK[-1]" in this language.

NOP

   Do nothing code.  Used as a placeholder by the bytecode optimizer,
   and to generate line tracing events.

NOT_TAKEN

   Do nothing code. Used by the interpreter to record "BRANCH_LEFT"
   and "BRANCH_RIGHT" events for "sys.monitoring".

   Added in version 3.14.

POP_ITER

   Removes the iterator from the top of the stack.

   Added in version 3.14.

POP_TOP

   Removes the top-of-stack item:

      STACK.pop()

END_FOR

   Removes the top-of-stack item. Equivalent to "POP_TOP". Used to
   clean up at the end of loops, hence the name.

   Added in version 3.12.

END_SEND

   Implements "del STACK[-2]". Used to clean up when a generator
   exits.

   Added in version 3.12.

COPY(i)

   Push the i-th item to the top of the stack without removing it from
   its original location:

      assert i > 0
      STACK.append(STACK[-i])

   Added in version 3.11.

SWAP(i)

   Swap the top of the stack with the i-th element:

      STACK[-i], STACK[-1] = STACK[-1], STACK[-i]

   Added in version 3.11.

CACHE

   Rather than being an actual instruction, this opcode is used to
   mark extra space for the interpreter to cache useful data directly
   in the bytecode itself. It is automatically hidden by all "dis"
   utilities, but can be viewed with "show_caches=True".

   Logically, this space is part of the preceding instruction. Many
   opcodes expect to be followed by an exact number of caches, and
   will instruct the interpreter to skip over them at runtime.

   Populated caches can look like arbitrary instructions, so great
   care should be taken when reading or modifying raw, adaptive
   bytecode containing quickened data.

   Added in version 3.11.

**단항 연산**

단항 연산은 스택의 최상단을 취하고, 연산을 적용한 다음, 결과를 스택에
다시 푸시합니다.

UNARY_NEGATIVE

   Implements "STACK[-1] = -STACK[-1]".

UNARY_NOT

   Implements "STACK[-1] = not STACK[-1]".

   버전 3.13에서 변경: This instruction now requires an exact "bool"
   operand.

UNARY_INVERT

   Implements "STACK[-1] = ~STACK[-1]".

GET_ITER

   Implements "STACK[-1] = iter(STACK[-1])".

GET_YIELD_FROM_ITER

   If "STACK[-1]" is a *generator iterator* or *coroutine* object it
   is left as is.  Otherwise, implements "STACK[-1] =
   iter(STACK[-1])".

   Added in version 3.5.

TO_BOOL

   Implements "STACK[-1] = bool(STACK[-1])".

   Added in version 3.13.

**Binary and in-place operations**

Binary operations remove the top two items from the stack ("STACK[-1]"
and "STACK[-2]"). They perform the operation, then put the result back
on the stack.

In-place operations are like binary operations, but the operation is
done in-place when "STACK[-2]" supports it, and the resulting
"STACK[-1]" may be (but does not have to be) the original "STACK[-2]".

BINARY_OP(op)

   Implements the binary and in-place operators (depending on the
   value of *op*):

      rhs = STACK.pop()
      lhs = STACK.pop()
      STACK.append(lhs op rhs)

   Added in version 3.11.

   버전 3.14에서 변경: With oparg :"NB_SUBSCR", implements binary
   subscript (replaces opcode "BINARY_SUBSCR")

STORE_SUBSCR

   Implements:

      key = STACK.pop()
      container = STACK.pop()
      value = STACK.pop()
      container[key] = value

DELETE_SUBSCR

   Implements:

      key = STACK.pop()
      container = STACK.pop()
      del container[key]

BINARY_SLICE

   Implements:

      end = STACK.pop()
      start = STACK.pop()
      container = STACK.pop()
      STACK.append(container[start:end])

   Added in version 3.12.

STORE_SLICE

   Implements:

      end = STACK.pop()
      start = STACK.pop()
      container = STACK.pop()
      values = STACK.pop()
      container[start:end] = value

   Added in version 3.12.

**코루틴 옵코드**

GET_AWAITABLE(where)

   Implements "STACK[-1] = get_awaitable(STACK[-1])", where
   "get_awaitable(o)" returns "o" if "o" is a coroutine object or a
   generator object with the "CO_ITERABLE_COROUTINE" flag, or resolves
   "o.__await__".

      If the "where" operand is nonzero, it indicates where the
      instruction occurs:

      * "1": After a call to "__aenter__"

      * "2": After a call to "__aexit__"

   Added in version 3.5.

   버전 3.11에서 변경: Previously, this instruction did not have an
   oparg.

GET_AITER

   Implements "STACK[-1] = STACK[-1].__aiter__()".

   Added in version 3.5.

   버전 3.7에서 변경: "__aiter__"로부터 어웨이터블 객체를 반환하는 것
   은 더는 지원되지 않습니다.

GET_ANEXT

   Implement "STACK.append(get_awaitable(STACK[-1].__anext__()))" to
   the stack. See "GET_AWAITABLE" for details about "get_awaitable".

   Added in version 3.5.

END_ASYNC_FOR

   Terminates an "async for" loop.  Handles an exception raised when
   awaiting a next item. The stack contains the async iterable in
   "STACK[-2]" and the raised exception in "STACK[-1]". Both are
   popped. If the exception is not "StopAsyncIteration", it is re-
   raised.

   Added in version 3.8.

   버전 3.11에서 변경: Exception representation on the stack now
   consist of one, not three, items.

CLEANUP_THROW

   Handles an exception raised during a "throw()" or "close()" call
   through the current frame.  If "STACK[-1]" is an instance of
   "StopIteration", pop three values from the stack and push its
   "value" member.  Otherwise, re-raise "STACK[-1]".

   Added in version 3.12.

**기타 옵코드**

SET_ADD(i)

   Implements:

      item = STACK.pop()
      set.add(STACK[-i], item)

   Used to implement set comprehensions.

LIST_APPEND(i)

   Implements:

      item = STACK.pop()
      list.append(STACK[-i], item)

   Used to implement list comprehensions.

MAP_ADD(i)

   Implements:

      value = STACK.pop()
      key = STACK.pop()
      dict.__setitem__(STACK[-i], key, value)

   Used to implement dict comprehensions.

   Added in version 3.1.

   버전 3.8에서 변경: Map value is "STACK[-1]" and map key is
   "STACK[-2]". Before, those were reversed.

모든 "SET_ADD", "LIST_APPEND" 및 "MAP_ADD" 명령어에 대해, 추가된 값이
나 키/값 쌍이 팝 되지만, 컨테이너 객체는 스택에 남아 있어서 루프의 추
가 이터레이션에 사용할 수 있습니다.

RETURN_VALUE

   Returns with "STACK[-1]" to the caller of the function.

YIELD_VALUE

   Yields "STACK.pop()" from a *generator*.

   버전 3.11에서 변경: oparg set to be the stack depth.

   버전 3.12에서 변경: oparg set to be the exception block depth, for
   efficient closing of generators.

   버전 3.13에서 변경: oparg is "1" if this instruction is part of a
   yield-from or await, and "0" otherwise.

SETUP_ANNOTATIONS

   "locals()"에 "__annotations__"가 정의되어 있는지 확인합니다, 그렇지
   않으면 비어있는 "dict"로 설정됩니다. 이 옵코드는 클래스나 모듈 본문
   에 *변수 어노테이션*이 정적으로 포함될 때만 생성됩니다.

   Added in version 3.6.

POP_EXCEPT

   Pops a value from the stack, which is used to restore the exception
   state.

   버전 3.11에서 변경: Exception representation on the stack now
   consist of one, not three, items.

RERAISE

   Re-raises the exception currently on top of the stack. If oparg is
   non-zero, pops an additional value from the stack which is used to
   set "f_lasti" of the current frame.

   Added in version 3.9.

   버전 3.11에서 변경: Exception representation on the stack now
   consist of one, not three, items.

PUSH_EXC_INFO

   Pops a value from the stack. Pushes the current exception to the
   top of the stack. Pushes the value originally popped back to the
   stack. Used in exception handlers.

   Added in version 3.11.

CHECK_EXC_MATCH

   Performs exception matching for "except". Tests whether the
   "STACK[-2]" is an exception matching "STACK[-1]". Pops "STACK[-1]"
   and pushes the boolean result of the test.

   Added in version 3.11.

CHECK_EG_MATCH

   Performs exception matching for "except*". Applies
   "split(STACK[-1])" on the exception group representing "STACK[-2]".

   In case of a match, pops two items from the stack and pushes the
   non-matching subgroup ("None" in case of full match) followed by
   the matching subgroup. When there is no match, pops one item (the
   match type) and pushes "None".

   Added in version 3.11.

WITH_EXCEPT_START

   Calls the function in position 4 on the stack with arguments (type,
   val, tb) representing the exception at the top of the stack. Used
   to implement the call "context_manager.__exit__(*exc_info())" when
   an exception has occurred in a "with" statement.

   Added in version 3.9.

   버전 3.11에서 변경: The "__exit__" function is in position 4 of the
   stack rather than 7. Exception representation on the stack now
   consist of one, not three, items.

LOAD_COMMON_CONSTANT

   Pushes a common constant onto the stack. The interpreter contains a
   hardcoded list of constants supported by this instruction.  Used by
   the "assert" statement to load "AssertionError".

   Added in version 3.14.

LOAD_BUILD_CLASS

   Pushes "builtins.__build_class__()" onto the stack.  It is later
   called to construct a class.

GET_LEN

   Perform "STACK.append(len(STACK[-1]))". Used in "match" statements
   where comparison with structure of pattern is needed.

   Added in version 3.10.

MATCH_MAPPING

   If "STACK[-1]" is an instance of "collections.abc.Mapping" (or,
   more technically: if it has the "Py_TPFLAGS_MAPPING" flag set in
   its "tp_flags"), push "True" onto the stack.  Otherwise, push
   "False".

   Added in version 3.10.

MATCH_SEQUENCE

   If "STACK[-1]" is an instance of "collections.abc.Sequence" and is
   *not* an instance of "str"/"bytes"/"bytearray" (or, more
   technically: if it has the "Py_TPFLAGS_SEQUENCE" flag set in its
   "tp_flags"), push "True" onto the stack.  Otherwise, push "False".

   Added in version 3.10.

MATCH_KEYS

   "STACK[-1]" is a tuple of mapping keys, and "STACK[-2]" is the
   match subject. If "STACK[-2]" contains all of the keys in
   "STACK[-1]", push a "tuple" containing the corresponding values.
   Otherwise, push "None".

   Added in version 3.10.

   버전 3.11에서 변경: Previously, this instruction also pushed a
   boolean value indicating success ("True") or failure ("False").

STORE_NAME(namei)

   Implements "name = STACK.pop()". *namei* is the index of *name* in
   the attribute "co_names" of the code object. The compiler tries to
   use "STORE_FAST" or "STORE_GLOBAL" if possible.

DELETE_NAME(namei)

   Implements "del name", where *namei* is the index into "co_names"
   attribute of the code object.

UNPACK_SEQUENCE(count)

   Unpacks "STACK[-1]" into *count* individual values, which are put
   onto the stack right-to-left. Require there to be exactly *count*
   values.:

      assert(len(STACK[-1]) == count)
      STACK.extend(STACK.pop()[:-count-1:-1])

UNPACK_EX(counts)

   Implements assignment with a starred target: Unpacks an iterable in
   "STACK[-1]" into individual values, where the total number of
   values can be smaller than the number of items in the iterable: one
   of the new values will be a list of all leftover items.

   The number of values before and after the list value is limited to
   255.

   The number of values before the list value is encoded in the
   argument of the opcode. The number of values after the list if any
   is encoded using an "EXTENDED_ARG". As a consequence, the argument
   can be seen as a two bytes values where the low byte of *counts* is
   the number of values before the list value, the high byte of
   *counts* the number of values after it.

   The extracted values are put onto the stack right-to-left, i.e. "a,
   *b, c = d" will be stored after execution as "STACK.extend((a, b,
   c))".

STORE_ATTR(namei)

   Implements:

      obj = STACK.pop()
      value = STACK.pop()
      obj.name = value

   where *namei* is the index of name in "co_names" of the code
   object.

DELETE_ATTR(namei)

   Implements:

      obj = STACK.pop()
      del obj.name

   where *namei* is the index of name into "co_names" of the code
   object.

STORE_GLOBAL(namei)

   "STORE_NAME"처럼 작동하지만, 이름을 전역으로 저장합니다.

DELETE_GLOBAL(namei)

   "DELETE_NAME"처럼 작동하지만, 전역 이름을 삭제합니다.

LOAD_CONST(consti)

   "co_consts[consti]"를 스택으로 푸시합니다.

LOAD_SMALL_INT(i)

   Pushes the integer "i" onto the stack. "i" must be in "range(256)"

   Added in version 3.14.

LOAD_NAME(namei)

   Pushes the value associated with "co_names[namei]" onto the stack.
   The name is looked up within the locals, then the globals, then the
   builtins.

LOAD_LOCALS

   Pushes a reference to the locals dictionary onto the stack.  This
   is used to prepare namespace dictionaries for
   "LOAD_FROM_DICT_OR_DEREF" and "LOAD_FROM_DICT_OR_GLOBALS".

   Added in version 3.12.

LOAD_FROM_DICT_OR_GLOBALS(i)

   Pops a mapping off the stack and looks up the value for
   "co_names[namei]". If the name is not found there, looks it up in
   the globals and then the builtins, similar to "LOAD_GLOBAL". This
   is used for loading global variables in annotation scopes within
   class bodies.

   Added in version 3.12.

BUILD_TEMPLATE

   Constructs a new "Template" instance from a tuple of strings and a
   tuple of interpolations and pushes the resulting object onto the
   stack:

      interpolations = STACK.pop()
      strings = STACK.pop()
      STACK.append(_build_template(strings, interpolations))

   Added in version 3.14.

BUILD_INTERPOLATION(format)

   Constructs a new "Interpolation" instance from a value and its
   source expression and pushes the resulting object onto the stack.

   If no conversion or format specification is present, "format" is
   set to "2".

   If the low bit of "format" is set, it indicates that the
   interpolation contains a format specification.

   If "format >> 2" is non-zero, it indicates that the interpolation
   contains a conversion. The value of "format >> 2" is the conversion
   type ("0" for no conversion, "1" for "!s", "2" for "!r", and "3"
   for "!a"):

      conversion = format >> 2
      if format & 1:
          format_spec = STACK.pop()
      else:
          format_spec = None
      expression = STACK.pop()
      value = STACK.pop()
      STACK.append(_build_interpolation(value, expression, conversion, format_spec))

   Added in version 3.14.

BUILD_TUPLE(count)

   Creates a tuple consuming *count* items from the stack, and pushes
   the resulting tuple onto the stack:

      if count == 0:
          value = ()
      else:
          value = tuple(STACK[-count:])
          STACK = STACK[:-count]

      STACK.append(value)

BUILD_LIST(count)

   "BUILD_TUPLE"처럼 작동하지만, 리스트를 만듭니다.

BUILD_SET(count)

   "BUILD_TUPLE"처럼 작동하지만, 집합을 만듭니다.

BUILD_MAP(count)

   Pushes a new dictionary object onto the stack.  Pops "2 * count"
   items so that the dictionary holds *count* entries: "{...,
   STACK[-4]: STACK[-3], STACK[-2]: STACK[-1]}".

   버전 3.5에서 변경: 딕셔너리는 *count* 항목을 갖도록 미리 크기가 조
   정된 빈 딕셔너리를 만드는 대신 스택 항목에서 만들어집니다.

BUILD_STRING(count)

   스택에서 *count* 문자열을 이어붙이고 결과 문자열을 스택으로 푸시합
   니다.

   Added in version 3.6.

LIST_EXTEND(i)

   Implements:

      seq = STACK.pop()
      list.extend(STACK[-i], seq)

   Used to build lists.

   Added in version 3.9.

SET_UPDATE(i)

   Implements:

      seq = STACK.pop()
      set.update(STACK[-i], seq)

   Used to build sets.

   Added in version 3.9.

DICT_UPDATE(i)

   Implements:

      map = STACK.pop()
      dict.update(STACK[-i], map)

   Used to build dicts.

   Added in version 3.9.

DICT_MERGE(i)

   "DICT_UPDATE"와 유사하지만, 중복 키에 대해 예외를 발생시킵니다.

   Added in version 3.9.

LOAD_ATTR(namei)

   If the low bit of "namei" is not set, this replaces "STACK[-1]"
   with "getattr(STACK[-1], co_names[namei>>1])".

   If the low bit of "namei" is set, this will attempt to load a
   method named "co_names[namei>>1]" from the "STACK[-1]" object.
   "STACK[-1]" is popped. This bytecode distinguishes two cases: if
   "STACK[-1]" has a method with the correct name, the bytecode pushes
   the unbound method and "STACK[-1]". "STACK[-1]" will be used as the
   first argument ("self") by "CALL" or "CALL_KW" when calling the
   unbound method. Otherwise, "NULL" and the object returned by the
   attribute lookup are pushed.

   버전 3.12에서 변경: If the low bit of "namei" is set, then a "NULL"
   or "self" is pushed to the stack before the attribute or unbound
   method respectively.

LOAD_SUPER_ATTR(namei)

   This opcode implements "super()", both in its zero-argument and
   two-argument forms (e.g. "super().method()", "super().attr" and
   "super(cls, self).method()", "super(cls, self).attr").

   It pops three values from the stack (from top of stack down):

   * "self": the first argument to the current method

   * "cls": the class within which the current method was defined

   * the global "super"

   With respect to its argument, it works similarly to "LOAD_ATTR",
   except that "namei" is shifted left by 2 bits instead of 1.

   The low bit of "namei" signals to attempt a method load, as with
   "LOAD_ATTR", which results in pushing "NULL" and the loaded method.
   When it is unset a single value is pushed to the stack.

   The second-low bit of "namei", if set, means that this was a two-
   argument call to "super()" (unset means zero-argument).

   Added in version 3.12.

COMPARE_OP(opname)

   Performs a Boolean operation.  The operation name can be found in
   "cmp_op[opname >> 5]". If the fifth-lowest bit of "opname" is set
   ("opname & 16"), the result should be coerced to "bool".

   버전 3.13에서 변경: The fifth-lowest bit of the oparg now indicates
   a forced conversion to "bool".

IS_OP(invert)

   "is" 비교를 수행하거나, "invert"가 1이면 "is not"을 수행합니다.

   Added in version 3.9.

CONTAINS_OP(invert)

   "in" 비교를 수행하거나, "invert"가 1이면 "not in"을 수행합니다.

   Added in version 3.9.

IMPORT_NAME(namei)

   Imports the module "co_names[namei]".  "STACK[-1]" and "STACK[-2]"
   are popped and provide the *fromlist* and *level* arguments of
   "__import__()". The module object is pushed onto the stack.  The
   current namespace is not affected: for a proper import statement, a
   subsequent "STORE_FAST" instruction modifies the namespace.

IMPORT_FROM(namei)

   Loads the attribute "co_names[namei]" from the module found in
   "STACK[-1]". The resulting object is pushed onto the stack, to be
   subsequently stored by a "STORE_FAST" instruction.

JUMP_FORWARD(delta)

   바이트 코드 카운터를 *delta*만큼 증가시킵니다.

JUMP_BACKWARD(delta)

   Decrements bytecode counter by *delta*. Checks for interrupts.

   Added in version 3.11.

JUMP_BACKWARD_NO_INTERRUPT(delta)

   Decrements bytecode counter by *delta*. Does not check for
   interrupts.

   Added in version 3.11.

POP_JUMP_IF_TRUE(delta)

   If "STACK[-1]" is true, increments the bytecode counter by *delta*.
   "STACK[-1]" is popped.

   버전 3.11에서 변경: The oparg is now a relative delta rather than
   an absolute target. This opcode is a pseudo-instruction, replaced
   in final bytecode by the directed versions (forward/backward).

   버전 3.12에서 변경: This is no longer a pseudo-instruction.

   버전 3.13에서 변경: This instruction now requires an exact "bool"
   operand.

POP_JUMP_IF_FALSE(delta)

   If "STACK[-1]" is false, increments the bytecode counter by
   *delta*. "STACK[-1]" is popped.

   버전 3.11에서 변경: The oparg is now a relative delta rather than
   an absolute target. This opcode is a pseudo-instruction, replaced
   in final bytecode by the directed versions (forward/backward).

   버전 3.12에서 변경: This is no longer a pseudo-instruction.

   버전 3.13에서 변경: This instruction now requires an exact "bool"
   operand.

POP_JUMP_IF_NOT_NONE(delta)

   If "STACK[-1]" is not "None", increments the bytecode counter by
   *delta*. "STACK[-1]" is popped.

   Added in version 3.11.

   버전 3.12에서 변경: This is no longer a pseudo-instruction.

POP_JUMP_IF_NONE(delta)

   If "STACK[-1]" is "None", increments the bytecode counter by
   *delta*. "STACK[-1]" is popped.

   Added in version 3.11.

   버전 3.12에서 변경: This is no longer a pseudo-instruction.

FOR_ITER(delta)

   "STACK[-1]" is an *iterator*.  Call its "__next__()" method. If
   this yields a new value, push it on the stack (leaving the iterator
   below it).  If the iterator indicates it is exhausted then the byte
   code counter is incremented by *delta*.

   버전 3.12에서 변경: Up until 3.11 the iterator was popped when it
   was exhausted.

LOAD_GLOBAL(namei)

   Loads the global named "co_names[namei>>1]" onto the stack.

   버전 3.11에서 변경: If the low bit of "namei" is set, then a "NULL"
   is pushed to the stack before the global variable.

LOAD_FAST(var_num)

   지역 "co_varnames[var_num]"에 대한 참조를 스택으로 푸시합니다.

   버전 3.12에서 변경: This opcode is now only used in situations
   where the local variable is guaranteed to be initialized. It cannot
   raise "UnboundLocalError".

LOAD_FAST_BORROW(var_num)

   Pushes a borrowed reference to the local "co_varnames[var_num]"
   onto the stack.

   Added in version 3.14.

LOAD_FAST_LOAD_FAST(var_nums)

   Pushes references to "co_varnames[var_nums >> 4]" and
   "co_varnames[var_nums & 15]" onto the stack.

   Added in version 3.13.

LOAD_FAST_BORROW_LOAD_FAST_BORROW(var_nums)

   Pushes borrowed references to "co_varnames[var_nums >> 4]" and
   "co_varnames[var_nums & 15]" onto the stack.

   Added in version 3.14.

LOAD_FAST_CHECK(var_num)

   Pushes a reference to the local "co_varnames[var_num]" onto the
   stack, raising an "UnboundLocalError" if the local variable has not
   been initialized.

   Added in version 3.12.

LOAD_FAST_AND_CLEAR(var_num)

   Pushes a reference to the local "co_varnames[var_num]" onto the
   stack (or pushes "NULL" onto the stack if the local variable has
   not been initialized) and sets "co_varnames[var_num]" to "NULL".

   Added in version 3.12.

STORE_FAST(var_num)

   Stores "STACK.pop()" into the local "co_varnames[var_num]".

STORE_FAST_STORE_FAST(var_nums)

   Stores "STACK[-1]" into "co_varnames[var_nums >> 4]" and
   "STACK[-2]" into "co_varnames[var_nums & 15]".

   Added in version 3.13.

STORE_FAST_LOAD_FAST(var_nums)

   Stores "STACK.pop()" into the local "co_varnames[var_nums >> 4]"
   and pushes a reference to the local "co_varnames[var_nums & 15]"
   onto the stack.

   Added in version 3.13.

DELETE_FAST(var_num)

   지역 "co_varnames[var_num]"을 삭제합니다.

MAKE_CELL(i)

   Creates a new cell in slot "i".  If that slot is nonempty then that
   value is stored into the new cell.

   Added in version 3.11.

LOAD_DEREF(i)

   Loads the cell contained in slot "i" of the "fast locals" storage.
   Pushes a reference to the object the cell contains on the stack.

   버전 3.11에서 변경: "i" is no longer offset by the length of
   "co_varnames".

LOAD_FROM_DICT_OR_DEREF(i)

   Pops a mapping off the stack and looks up the name associated with
   slot "i" of the "fast locals" storage in this mapping. If the name
   is not found there, loads it from the cell contained in slot "i",
   similar to "LOAD_DEREF". This is used for loading *closure
   variables* in class bodies (which previously used
   "LOAD_CLASSDEREF") and in annotation scopes within class bodies.

   Added in version 3.12.

STORE_DEREF(i)

   Stores "STACK.pop()" into the cell contained in slot "i" of the
   "fast locals" storage.

   버전 3.11에서 변경: "i" is no longer offset by the length of
   "co_varnames".

DELETE_DEREF(i)

   Empties the cell contained in slot "i" of the "fast locals"
   storage. Used by the "del" statement.

   Added in version 3.2.

   버전 3.11에서 변경: "i" is no longer offset by the length of
   "co_varnames".

COPY_FREE_VARS(n)

   Copies the "n" *free (closure) variables* from the closure into the
   frame. Removes the need for special code on the caller's side when
   calling closures.

   Added in version 3.11.

RAISE_VARARGS(argc)

   *argc*의 값에 따라, "raise" 문의 3가지 형식 중 하나를 사용하여 예외
   를 발생시킵니다:

   * 0: "raise" (이전 예외를 다시 발생시킵니다)

   * 1: "raise STACK[-1]" (raise exception instance or type at
     "STACK[-1]")

   * 2: "raise STACK[-2] from STACK[-1]" (raise exception instance or
     type at "STACK[-2]" with "__cause__" set to "STACK[-1]")

CALL(argc)

   Calls a callable object with the number of arguments specified by
   "argc". On the stack are (in ascending order):

   * The callable

   * "self" or "NULL"

   * The remaining positional arguments

   "argc" is the total of the positional arguments, excluding "self".

   "CALL" pops all arguments and the callable object off the stack,
   calls the callable object with those arguments, and pushes the
   return value returned by the callable object.

   Added in version 3.11.

   버전 3.13에서 변경: The callable now always appears at the same
   position on the stack.

   버전 3.13에서 변경: Calls with keyword arguments are now handled by
   "CALL_KW".

CALL_KW(argc)

   Calls a callable object with the number of arguments specified by
   "argc", including one or more named arguments. On the stack are (in
   ascending order):

   * The callable

   * "self" or "NULL"

   * The remaining positional arguments

   * The named arguments

   * A "tuple" of keyword argument names

   "argc" is the total of the positional and named arguments,
   excluding "self". The length of the tuple of keyword argument names
   is the number of named arguments.

   "CALL_KW" pops all arguments, the keyword names, and the callable
   object off the stack, calls the callable object with those
   arguments, and pushes the return value returned by the callable
   object.

   Added in version 3.13.

CALL_FUNCTION_EX(flags)

   위치와 키워드 인자의 변수 집합으로 콜러블 객체를 호출합니다.
   *flags*의 최하위 비트가 설정되면, 스택의 맨 위에 추가 키워드 인자가
   포함된 매핑 객체가 포함됩니다. 콜러블이 호출되기 전에, 매핑 객체와
   이터러블 객체는 각각 "언팩" 되고 그 내용이 각각 키워드와 위치 인자
   로 전달됩니다. "CALL_FUNCTION_EX"는 모든 인자와 콜러블 객체를 스택
   에서 팝하고, 해당 인자로 콜러블 객체를 호출한 다음, 콜러블 객체가
   반환한 반환 값을 푸시합니다.

   Added in version 3.6.

PUSH_NULL

   Pushes a "NULL" to the stack. Used in the call sequence to match
   the "NULL" pushed by "LOAD_METHOD" for non-method calls.

   Added in version 3.11.

MAKE_FUNCTION

   Pushes a new function object on the stack built from the code
   object at "STACK[-1]".

   버전 3.10에서 변경: Flag value "0x04" is a tuple of strings instead
   of dictionary

   버전 3.11에서 변경: Qualified name at "STACK[-1]" was removed.

   버전 3.13에서 변경: Extra function attributes on the stack,
   signaled by oparg flags, were removed. They now use
   "SET_FUNCTION_ATTRIBUTE".

SET_FUNCTION_ATTRIBUTE(flag)

   Sets an attribute on a function object. Expects the function at
   "STACK[-1]" and the attribute value to set at "STACK[-2]"; consumes
   both and leaves the function at "STACK[-1]". The flag determines
   which attribute to set:

   * "0x01" 위치 전용과 위치-키워드 매개 변수를 위한 기본값의 위치 순
     서 튜플

   * "0x02" 키워드 전용 매개 변수의 기본값 딕셔너리

   * "0x04" a tuple of strings containing parameters' annotations

   * "0x08" 자유 변수를 위한 셀을 포함하는 튜플, 클로저를 만듭니다

   * "0x10" the *annotate function* for the function object

   Added in version 3.13.

   버전 3.14에서 변경: Added "0x10" to indicate the annotate function
   for the function object.

BUILD_SLICE(argc)

   Pushes a slice object on the stack.  *argc* must be 2 or 3.  If it
   is 2, implements:

      end = STACK.pop()
      start = STACK.pop()
      STACK.append(slice(start, end))

   if it is 3, implements:

      step = STACK.pop()
      end = STACK.pop()
      start = STACK.pop()
      STACK.append(slice(start, end, step))

   See the "slice()" built-in function for more information.

EXTENDED_ARG(ext)

   너무 커서 기본 1바이트에 맞지 않는 인자를 가진 옵코드에 접두어로 붙
   입니다. *ext*는 인자에서 더 높은 비트로 작동하는 추가 바이트를 보유
   합니다. 각 옵코드마다, 최대 3개의 접두사 "EXTENDED_ARG"가 허용되며,
   2바이트에서 4바이트 사이의 인자를 형성합니다.

CONVERT_VALUE(oparg)

   Convert value to a string, depending on "oparg":

      value = STACK.pop()
      result = func(value)
      STACK.append(result)

   * "oparg == 1": call "str()" on *value*

   * "oparg == 2": call "repr()" on *value*

   * "oparg == 3": call "ascii()" on *value*

   Used for implementing formatted string literals (f-strings).

   Added in version 3.13.

FORMAT_SIMPLE

   Formats the value on top of stack:

      value = STACK.pop()
      result = value.__format__("")
      STACK.append(result)

   Used for implementing formatted string literals (f-strings).

   Added in version 3.13.

FORMAT_WITH_SPEC

   Formats the given value with the given format spec:

      spec = STACK.pop()
      value = STACK.pop()
      result = value.__format__(spec)
      STACK.append(result)

   Used for implementing formatted string literals (f-strings).

   Added in version 3.13.

MATCH_CLASS(count)

   "STACK[-1]" is a tuple of keyword attribute names, "STACK[-2]" is
   the class being matched against, and "STACK[-3]" is the match
   subject.  *count* is the number of positional sub-patterns.

   Pop "STACK[-1]", "STACK[-2]", and "STACK[-3]". If "STACK[-3]" is an
   instance of "STACK[-2]" and has the positional and keyword
   attributes required by *count* and "STACK[-1]", push a tuple of
   extracted attributes. Otherwise, push "None".

   Added in version 3.10.

   버전 3.11에서 변경: Previously, this instruction also pushed a
   boolean value indicating success ("True") or failure ("False").

RESUME(context)

   A no-op. Performs internal tracing, debugging and optimization
   checks.

   The "context" operand consists of two parts. The lowest two bits
   indicate where the "RESUME" occurs:

   * "0" The start of a function, which is neither a generator,
     coroutine nor an async generator

   * "1" After a "yield" expression

   * "2" After a "yield from" expression

   * "3" After an "await" expression

   The next bit is "1" if the RESUME is at except-depth "1", and "0"
   otherwise.

   Added in version 3.11.

   버전 3.13에서 변경: The oparg value changed to include information
   about except-depth

RETURN_GENERATOR

   Create a generator, coroutine, or async generator from the current
   frame. Used as first opcode of in code object for the above
   mentioned callables. Clear the current frame and return the newly
   created generator.

   Added in version 3.11.

SEND(delta)

   Equivalent to "STACK[-1] = STACK[-2].send(STACK[-1])". Used in
   "yield from" and "await" statements.

   If the call raises "StopIteration", pop the top value from the
   stack, push the exception's "value" attribute, and increment the
   bytecode counter by *delta*.

   Added in version 3.11.

HAVE_ARGUMENT

   This is not really an opcode.  It identifies the dividing line
   between opcodes in the range [0,255] which don't use their argument
   and those that do ("< HAVE_ARGUMENT" and ">= HAVE_ARGUMENT",
   respectively).

   If your application uses pseudo instructions or specialized
   instructions, use the "hasarg" collection instead.

   버전 3.6에서 변경: 이제 모든 명령어에는 인자가 있지만, "<
   HAVE_ARGUMENT"인 옵코드는 이를 무시합니다. 이전에는, ">=
   HAVE_ARGUMENT"인 옵코드에만 인자가 있었습니다.

   버전 3.12에서 변경: Pseudo instructions were added to the "dis"
   module, and for them it is not true that comparison with
   "HAVE_ARGUMENT" indicates whether they use their arg.

   버전 3.13부터 폐지됨: Use "hasarg" instead.

CALL_INTRINSIC_1

   Calls an intrinsic function with one argument. Passes "STACK[-1]"
   as the argument and sets "STACK[-1]" to the result. Used to
   implement functionality that is not performance critical.

   The operand determines which intrinsic function is called:

   +-------------------------------------+-------------------------------------+
   | Operand                             | Description                         |
   |=====================================|=====================================|
   | "INTRINSIC_1_INVALID"               | Not valid                           |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_PRINT"                   | Prints the argument to standard     |
   |                                     | out. Used in the REPL.              |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_IMPORT_STAR"             | Performs "import *" for the named   |
   |                                     | module.                             |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_STOPITERATION_ERROR"     | Extracts the return value from a    |
   |                                     | "StopIteration" exception.          |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_ASYNC_GEN_WRAP"          | Wraps an async generator value      |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_UNARY_POSITIVE"          | Performs the unary "+" operation    |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_LIST_TO_TUPLE"           | Converts a list to a tuple          |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_TYPEVAR"                 | Creates a "typing.TypeVar"          |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_PARAMSPEC"               | Creates a "typing.ParamSpec"        |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_TYPEVARTUPLE"            | Creates a "typing.TypeVarTuple"     |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_SUBSCRIPT_GENERIC"       | Returns "typing.Generic"            |
   |                                     | subscripted with the argument       |
   +-------------------------------------+-------------------------------------+
   | "INTRINSIC_TYPEALIAS"               | Creates a "typing.TypeAliasType";   |
   |                                     | used in the "type" statement. The   |
   |                                     | argument is a tuple of the type     |
   |                                     | alias's name, type parameters, and  |
   |                                     | value.                              |
   +-------------------------------------+-------------------------------------+

   Added in version 3.12.

CALL_INTRINSIC_2

   Calls an intrinsic function with two arguments. Used to implement
   functionality that is not performance critical:

      arg2 = STACK.pop()
      arg1 = STACK.pop()
      result = intrinsic2(arg1, arg2)
      STACK.append(result)

   The operand determines which intrinsic function is called:

   +------------------------------------------+-------------------------------------+
   | Operand                                  | Description                         |
   |==========================================|=====================================|
   | "INTRINSIC_2_INVALID"                    | Not valid                           |
   +------------------------------------------+-------------------------------------+
   | "INTRINSIC_PREP_RERAISE_STAR"            | Calculates the "ExceptionGroup" to  |
   |                                          | raise from a "try-except*".         |
   +------------------------------------------+-------------------------------------+
   | "INTRINSIC_TYPEVAR_WITH_BOUND"           | Creates a "typing.TypeVar" with a   |
   |                                          | bound.                              |
   +------------------------------------------+-------------------------------------+
   | "INTRINSIC_TYPEVAR_WITH_CONSTRAINTS"     | Creates a "typing.TypeVar" with     |
   |                                          | constraints.                        |
   +------------------------------------------+-------------------------------------+
   | "INTRINSIC_SET_FUNCTION_TYPE_PARAMS"     | Sets the "__type_params__"          |
   |                                          | attribute of a function.            |
   +------------------------------------------+-------------------------------------+

   Added in version 3.12.

LOAD_SPECIAL

   Performs special method lookup on "STACK[-1]". If
   "type(STACK[-1]).__xxx__" is a method, leave
   "type(STACK[-1]).__xxx__; STACK[-1]" on the stack. If
   "type(STACK[-1]).__xxx__" is not a method, leave
   "STACK[-1].__xxx__; NULL" on the stack.

   Added in version 3.14.

**Pseudo-instructions**

These opcodes do not appear in Python bytecode. They are used by the
compiler but are replaced by real opcodes or removed before bytecode
is generated.

SETUP_FINALLY(target)

   Set up an exception handler for the following code block. If an
   exception occurs, the value stack level is restored to its current
   state and control is transferred to the exception handler at
   "target".

SETUP_CLEANUP(target)

   Like "SETUP_FINALLY", but in case of an exception also pushes the
   last instruction ("lasti") to the stack so that "RERAISE" can
   restore it. If an exception occurs, the value stack level and the
   last instruction on the frame are restored to their current state,
   and control is transferred to the exception handler at "target".

SETUP_WITH(target)

   Like "SETUP_CLEANUP", but in case of an exception one more item is
   popped from the stack before control is transferred to the
   exception handler at "target".

   This variant is used in "with" and "async with" constructs, which
   push the return value of the context manager's "__enter__()" or
   "__aenter__()" to the stack.

POP_BLOCK

   Marks the end of the code block associated with the last
   "SETUP_FINALLY", "SETUP_CLEANUP" or "SETUP_WITH".

LOAD_CONST_IMMORTAL(consti)

   Works as "LOAD_CONST", but is more efficient for immortal objects.

JUMP
JUMP_NO_INTERRUPT

   Undirected relative jump instructions which are replaced by their
   directed (forward/backward) counterparts by the assembler.

JUMP_IF_TRUE
JUMP_IF_FALSE

   Conditional jumps which do not impact the stack. Replaced by the
   sequence "COPY 1", "TO_BOOL", "POP_JUMP_IF_TRUE/FALSE".

LOAD_CLOSURE(i)

   Pushes a reference to the cell contained in slot "i" of the "fast
   locals" storage.

   Note that "LOAD_CLOSURE" is replaced with "LOAD_FAST" in the
   assembler.

   버전 3.13에서 변경: This opcode is now a pseudo-instruction.


옵코드 모음
===========

이 모음은 바이트 코드 명령어의 자동 검사를 위해 제공됩니다:

버전 3.12에서 변경: The collections now contain pseudo instructions
and instrumented instructions as well. These are opcodes with values
">= MIN_PSEUDO_OPCODE" and ">= MIN_INSTRUMENTED_OPCODE".

dis.opname

   연산 이름의 시퀀스, 바이트 코드를 사용하여 인덱싱할 수 있습니다.

dis.opmap

   연산 이름을 바이트 코드로 매핑하는 딕셔너리.

dis.cmp_op

   모든 비교 연산 이름의 시퀀스.

dis.hasarg

   Sequence of bytecodes that use their argument.

   Added in version 3.12.

dis.hasconst

   상수에 액세스하는 바이트 코드의 시퀀스.

dis.hasfree

   Sequence of bytecodes that access a *free (closure) variable*.
   'free' in this context refers to names in the current scope that
   are referenced by inner scopes or names in outer scopes that are
   referenced from this scope.  It does *not* include references to
   global or builtin scopes.

dis.hasname

   어트리뷰트를 이름으로 액세스하는 바이트 코드의 시퀀스.

dis.hasjump

   Sequence of bytecodes that have a jump target. All jumps are
   relative.

   Added in version 3.13.

dis.haslocal

   지역 변수에 액세스하는 바이트 코드의 시퀀스.

dis.hascompare

   불리언 연산의 바이트 코드의 시퀀스.

dis.hasexc

   Sequence of bytecodes that set an exception handler.

   Added in version 3.12.

dis.hasjrel

   상대 점프 대상이 있는 바이트 코드의 시퀀스.

   버전 3.13부터 폐지됨: All jumps are now relative. Use "hasjump".

dis.hasjabs

   절대 점프 대상이 있는 바이트 코드의 시퀀스.

   버전 3.13부터 폐지됨: All jumps are now relative. This list is
   empty.
