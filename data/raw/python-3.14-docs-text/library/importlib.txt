"importlib" --- "import"의 구현
*******************************

Added in version 3.1.

**소스 코드:** Lib/importlib/__init__.py

======================================================================


소개
====

"importlib" 패키지의 목적은 세 가지입니다.

하나는 파이썬 소스 코드에서 "import" 문(그리고, 확장하면
"__import__()" 함수)의 구현을 제공하는 것입니다. 이것은 모든 파이썬 인
터프리터에 이식할 수 있는 "import"의 구현을 제공합니다. 또한 파이썬 이
외의 프로그래밍 언어로 구현된 것보다 이해하기 쉬운 구현을 제공합니다.

둘째, "import"를 구현하는 구성 요소가 이 패키지에서 노출되어, 사용자가
임포트 프로세스에 참여하기 위해 자신의 사용자 지정 객체(일반적으로 *임
포터*라고 합니다)를 쉽게 만들 수 있도록 합니다.

Three, the package contains modules exposing additional functionality
for managing aspects of Python packages:

* "importlib.metadata" presents access to metadata from third-party
  distributions.

* "importlib.resources" provides routines for accessing non-code
  "resources" from Python packages.

더 보기:

  임포트(import) 문
     "import" 문의 언어 레퍼런스.

  패키지 명세
     패키지의 원래 명세. 이 문서를 작성한 이후로 일부 의미가 변경되었
     습니다 (예를 들어 "sys.modules"의 "None"을 기반으로 하는 리디렉션
     ).

  "__import__()" 함수
     "import" 문은 이 함수의 편의 문법입니다.

  The initialization of the sys.path module search path
     The initialization of "sys.path".

  **PEP 235**
     대소 문자를 구분하지 않는 플랫폼에서의 임포트

  **PEP 263**
     파이썬 소스 코드 인코딩 정의

  **PEP 302**
     새로운 임포트 훅

  **PEP 328**
     임포트: 다중 줄과 절대/상대

  **PEP 366**
     메인 모듈 명시적 상대 임포트

  **PEP 420**
     묵시적 이름 공간 패키지

  **PEP 451**
     임포트 시스템을 위한 ModuleSpec 형

  **PEP 488**
     PYO 파일 제거

  **PEP 489**
     다단계 확장 모듈 초기화

  **PEP 552**
     결정론적 pyc

  **PEP 3120**
     UTF-8을 기본 소스 인코딩으로 사용하기

  **PEP 3147**
     PYC 저장소 디렉터리


함수
====

importlib.__import__(name, globals=None, locals=None, fromlist=(), level=0)

   내장 "__import__()" 함수의 구현.

   참고:

     프로그래밍 방식으로 모듈을 임포트 하려면 이 함수 대신
     "import_module()"을 사용해야 합니다.

importlib.import_module(name, package=None)

   모듈을 임포트 합니다. *name* 인자는 절대나 상대적인 항으로 임포트
   할 모듈을 지정합니다 (예를 들어 "pkg.mod"나 "..mod"). 이름이 상대적
   인 항으로 지정되면, *package* 인자는 패키지 이름을 결정하기 위한 앵
   커 역할을 하는 패키지 이름으로 설정해야 합니다 (예를 들어
   "import_module('..mod', 'pkg.subpkg')"는 "pkg.mod"를 임포트 합니다
   ).

   "import_module()" 함수는 "importlib.__import__()" 주위를 감싸는 단
   순화 래퍼 역할을 합니다. 이는 함수의 모든 의미가
   "importlib.__import__()"에서 파생됨을 뜻합니다. 이 두 함수의 가장
   중요한 차이점은 "import_module()"이 지정된 패키지나 모듈(예를 들어
   "pkg.mod")을 반환하는 반면, "__import__()"는 최상위 패키지나 모듈(
   예를 들어 "pkg")을 반환한다는 것입니다.

   인터프리터가 실행을 시작한 이후 만들어진 모듈(예를 들어, 파이썬 소
   스 파일을 만들면)을 동적으로 임포트 하는 경우, 임포트 시스템에서 새
   모듈을 알 수 있도록 "invalidate_caches()"를 호출해야 할 수 있습니다
   .

   버전 3.3에서 변경: 부모 패키지는 자동으로 임포트 됩니다.

importlib.invalidate_caches()

   "sys.meta_path"에 저장된 파인더의 내부 캐시를 무효로 합니다. 파인더
   가 "invalidate_caches()"를 구현하면 무효화를 수행하기 위해 호출됩니
   다. 모든 파인더가 새로운 모듈의 존재를 알 수 있도록 프로그램이 실행
   되는 동안 모듈이 만들어진/설치된 경우 이 함수를 호출해야 합니다.

   Added in version 3.3.

   버전 3.10에서 변경: Namespace packages created/installed in a
   different "sys.path" location after the same namespace was already
   imported are noticed.

importlib.reload(module)

   이전에 임포트 한 *module*을 다시 로드합니다. 인자는 모듈 객체여야
   해서, 이전에 성공적으로 임포트 됐어야 합니다. 외부 편집기를 사용하
   여 모듈 소스 파일을 편집했고 파이썬 인터프리터를 떠나지 않고 새 버
   전을 시험해보고 싶을 때 유용합니다. 반환 값은 모듈 객체입니다 (재
   임포트로 인해 다른 객체가 "sys.modules"에 배치되면 다를 수 있습니다
   ).

   "reload()"가 실행될 때:

   * 파이썬 모듈의 코드가 다시 컴파일되고 모듈 수준 코드가 다시 실행되
     어, 원래 모듈을 로드한 *로더*를 재사용하여 모듈 딕셔너리에 있는
     이름에 연결되는 새로운 객체 집합을 정의합니다. 확장 모듈의 "init"
     함수는 두 번째에는 호출되지 않습니다.

   * 파이썬의 다른 모든 객체와 마찬가지로 이전 객체는 참조 횟수가 0으
     로 떨어진 후에만 자원이 회수됩니다.

   * 모듈 이름 공간의 이름은 새로운 객체나 변경된 객체를 가리키도록 갱
     신됩니다.

   * 이전 객체에 대한 다른 참조(가령 모듈 외부의 이름)는 새 객체를 참
     조하기 위해 다시 연결되지 않으며 필요하다면 그들이 등장하는 각 이
     름 공간에서 갱신되어야 합니다.

   다른 여러 가지 경고가 있습니다:

   모듈을 다시 로드할 때, 그것의 (모듈의 전역 변수를 포함하는) 딕셔너
   리가 유지됩니다. 이름을 재정의하면 이전 정의를 대체해서, 일반적으로
   문제가 되지 않습니다. 새 버전의 모듈이 이전 버전이 정의한 이름을 정
   의하지 않으면, 이전 정의가 그대로 남습니다. 이 기능은 객체의 전역
   테이블이나 캐시를 유지한다면 모듈의 이점으로 사용될 수 있습니다 ---
   "try" 문으로 테이블의 존재를 검사하고 필요하다면 초기화를 건너뛸 수
   있습니다:

      try:
          cache
      except NameError:
          cache = {}

   일반적으로 내장이나 동적으로 로드된 모듈을 다시 로드하는 것은 그리
   유용하지 않습니다. "sys", "__main__", "builtins" 및 기타 주요 모듈
   을 다시 로드하지 않는 것이 좋습니다. 많은 경우 확장 모듈은 두 번 이
   상 초기화되도록 설계되지 않았으며, 다시 로드할 때 임의의 방식으로
   실패할 수 있습니다.

   모듈이 "from" ... "import" ...를 사용하여 다른 모듈에서 객체를 임포
   트 하면, 다른 모듈에 대해 "reload()"를 호출해도 그것에서 임포트 한
   객체를 재정의하지 않습니다 --- 이것을 피하는 한 가지 방법은 "from"
   문을 다시 실행하는 것입니다, 다른 방법은 대신 "import"와 정규화된
   이름(*module.name*)을 사용하는 것입니다.

   모듈이 클래스의 인스턴스를 인스턴스 화하면, 클래스를 정의하는 모듈
   을 다시 로드해도 인스턴스의 메서드 정의에는 영향을 미치지 않습니다
   --- 이전 클래스 정의를 계속 사용합니다. 파생 클래스의 경우도 마찬가
   지입니다.

   Added in version 3.4.

   버전 3.7에서 변경: 다시 로드되는 모듈에 "ModuleSpec"이 없으면
   "ModuleNotFoundError" 가 발생합니다.

   경고:

     This function is not thread-safe. Calling it from multiple
     threads can result in unexpected behavior. It's recommended to
     use the "threading.Lock" or other synchronization primitives for
     thread-safe module reloading.


"importlib.abc" -- import와 관련된 추상 베이스 클래스
=====================================================

**소스 코드:** Lib/importlib/abc.py

======================================================================

"importlib.abc" 모듈에는 "import"에서 사용하는 모든 핵심 추상 베이스
클래스가 포함되어 있습니다. 핵심 ABC 구현에 도움이 되도록 핵심 추상 베
이스 클래스의 일부 서브 클래스도 제공됩니다.

ABC 계층:

   object
    +-- MetaPathFinder
    +-- PathEntryFinder
    +-- Loader
         +-- ResourceLoader --------+
         +-- InspectLoader          |
              +-- ExecutionLoader --+
                                    +-- FileLoader
                                    +-- SourceLoader

class importlib.abc.MetaPathFinder

   *메타 경로 파인더*를 나타내는 추상 베이스 클래스.

   Added in version 3.3.

   버전 3.10에서 변경: No longer a subclass of "Finder".

   find_spec(fullname, path, target=None)

      지정된 모듈의 *스펙*을 찾는 추상 메서드. 최상위 임포트 인 경우,
      *path*는 "None"입니다. 그렇지 않으면, 이것은 서브 패키지나 모듈
      의 검색이 되고, *path*는 부모 패키지의 "__path__" 값입니다. 스펙
      을 찾을 수 없으면, "None"이 반환됩니다. 전달될 때, "target"은 파
      인더가 반환할 스펙에 대해 더 정교하게 추측하기 위해 사용할 수 있
      는 모듈 객체입니다. "importlib.util.spec_from_loader()"는 구상
      "MetaPathFinders"를 구현하는 데 유용할 수 있습니다.

      Added in version 3.4.

   invalidate_caches()

      호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적
      메서드. "sys.meta_path"에서 모든 파인더의 캐시를 무효로 할 때
      "importlib.invalidate_caches()"에서 사용합니다.

      버전 3.4에서 변경: 호출될 때 "NotImplemented" 대신 "None"을 반환
      합니다.

class importlib.abc.PathEntryFinder

   *경로 엔트리 파인더*를 나타내는 추상 베이스 클래스.
   "MetaPathFinder"와 일부 유사하지만, "PathEntryFinder"는
   "importlib.machinery.PathFinder"가 제공하는 경로 기반 임포트 서브
   시스템 내에서만 사용하려는 것입니다.

   Added in version 3.3.

   버전 3.10에서 변경: No longer a subclass of "Finder".

   find_spec(fullname, target=None)

      지정된 모듈의 *스펙*을 찾는 추상 메서드. 파인더는 할당된 *경로
      엔트리* 내에서만 모듈을 검색합니다. 스펙을 찾을 수 없으면,
      "None"이 반환됩니다. 전달될 때, "target"은 파인더가 반환할 스펙
      에 대해 더 정교하게 추측하기 위해 사용할 수 있는 모듈 객체입니다
      . "importlib.util.spec_from_loader()"는 구상 "PathEntryFinders"
      를 구현하는 데 유용할 수 있습니다.

      Added in version 3.4.

   invalidate_caches()

      호출될 때, 파인더가 사용하는 내부 캐시를 무효로 해야 하는 선택적
      메서드. 모든 캐시 된 파인더의 캐시를 무효화 할 때
      "importlib.machinery.PathFinder.invalidate_caches()"에서 사용합
      니다.

class importlib.abc.Loader

   *로더*의 추상 베이스 클래스. 로더에 대한 정확한 정의는 **PEP 302**
   를 참조하십시오.

   리소스 읽기를 지원하려는 로더는
   "importlib.resources.abc.ResourceReader"에 지정된 대로
   "get_resource_reader()" 메서드를 구현해야 합니다.

   버전 3.7에서 변경: 선택적 "get_resource_reader()" 메서드를 도입했습
   니다.

   create_module(spec)

      모듈을 임포트 할 때 사용할 모듈 객체를 반환하는 메서드. 이 메서
      드는 "None"을 반환해서 기본 모듈 생성 시맨틱이 적용되어야 함을
      나타낼 수 있습니다.

      Added in version 3.4.

      버전 3.6에서 변경: "exec_module()"이 정의될 때 이 메서드는 더는
      선택 사항이 아닙니다.

   exec_module(module)

      모듈을 임포트 하거나 다시 로드할 때 자체 이름 공간에서 모듈을 실
      행하는 추상 메서드. "exec_module()"이 호출될 때 모듈이 이미 초기
      화되어 있어야 합니다. 이 메서드가 존재하면, "create_module()"을
      정의해야 합니다.

      Added in version 3.4.

      버전 3.6에서 변경: "create_module()"도 정의해야 합니다.

   load_module(fullname)

      모듈을 로드하는 레거시 메서드. 모듈을 로드할 수 없으면,
      "ImportError"가 발생하고, 그렇지 않으면 로드된 모듈이 반환됩니다
      .

      요청된 모듈이 "sys.modules"에 이미 존재하면, 해당 모듈이 사용되
      고 다시 로드되어야 합니다. 그렇지 않으면 로더는 임포트에서 재귀
      를 방지하기 위해 로드를 시작하기 전에 새 모듈을 만들어
      "sys.modules"에 삽입해야 합니다. 로더가 모듈을 삽입했는데 로드에
      실패하면, 로더가 "sys.modules"에서 모듈을 제거해야 합니다; 로더
      가 실행을 시작하기 전에 이미 "sys.modules"에 있었던 모듈은 그대
      로 두어야 합니다.

      로더는 모듈에서 여러 어트리뷰트를 설정해야 합니다 (이러한 어트리
      뷰트 중 일부는 모듈을 다시 로드할 때 변경될 수 있습니다):

      * "module.__name__"

      * "module.__file__"

      * "module.__cached__" *(폐지됨)*

      * "module.__path__"

      * "module.__package__" *(폐지됨)*

      * "module.__loader__" *(폐지됨)*

      "exec_module()"을 사용할 수 있으면 이전 버전과 호환되는 기능이
      제공됩니다.

      버전 3.4에서 변경: 호출될 때 "NotImplementedError" 대신
      "ImportError"를 발생시킵니다. "exec_module()"을 사용할 수 있을
      때 제공되는 기능.

      Deprecated since version 3.4, will be removed in version 3.15:
      모듈 로드에 권장되는 API는 "exec_module()"(및 "create_module()")
      입니다. 로더는 "load_module()" 대신 이것을 구현해야 합니다. 임포
      트 절차는 "exec_module()"이 구현될 때 "load_module()"의 다른 모
      든 책임을 처리합니다.

class importlib.abc.ResourceLoader

   *TraversableResources 로 대체되었습니다*

      스토리지 백 엔드에서 임의의 리소스를 로드하기 위한 선택적 **PEP
      302** 프로토콜을 구현하는 *로더*의 추상 베이스 클래스.

      버전 3.7부터 폐지됨: This ABC is deprecated in favour of
      supporting resource loading through
      "importlib.resources.abc.TraversableResources". This class
      exists for backwards compatibility only with other ABCs in this
      module.

      abstractmethod get_data(path)

            *path*에 있는 데이터를 바이트열로 반환하는 추상 메서드. 임
            의의 데이터를 저장할 수 있는 파일류 스토리지 백 엔드가 있
            는 로더는 이 추상 메서드를 구현하여 저장된 데이터에 직접
            액세스하도록 할 수 있습니다. *path*를 찾을 수 없으면
            "OSError"가 발생합니다. *path*는 모듈의 "__file__" 어트리
            뷰트나 패키지의 "__path__"에서 온 항목을 사용하여 구성될
            것으로 기대됩니다.

            버전 3.4에서 변경: "NotImplementedError" 대신 "OSError"를
            발생시킵니다.

class importlib.abc.InspectLoader

   모듈을 검사(inspect)하는 로더를 위한 선택적 **PEP 302** 프로토콜을
   구현하는 *로더*의 추상 베이스 클래스.

   get_code(fullname)

      모듈에 대한 코드 객체나, 모듈에 코드 객체가 없으면 (예를 들어,
      내장 모듈이 이런 경우입니다) "None"을 반환합니다. 로더가 요청한
      모듈을 찾을 수 없으면 "ImportError"가 발생합니다.

      참고:

        이 메서드에는 기본 구현이 있지만, 가능하다면 성능을 위해 재정
        의하는 것이 좋습니다.

      버전 3.4에서 변경: 더는 추상적이지 않고 구상 구현이 제공됩니다.

   abstractmethod get_source(fullname)

         모듈의 소스를 반환하는 추상 메서드. 인식된 모든 줄 구분자를
         "'\n'" 문자로 변환하는 *유니버설 줄 넘김*을 사용하여 텍스트
         문자열로 반환됩니다. 사용 가능한 소스가 없으면 (예를 들어, 내
         장 모듈) "None"을 반환합니다. 로더가 지정된 모듈을 찾을 수 없
         으면 "ImportError"를 발생시킵니다.

         버전 3.4에서 변경: "NotImplementedError" 대신 "ImportError"를
         발생시킵니다.

   is_package(fullname)

      모듈이 패키지이면 참값을 반환하고, 그렇지 않으면 거짓 값을 반환
      하는 선택적 메서드. *로더*가 모듈을 찾을 수 없으면 "ImportError"
      가 발생합니다.

      버전 3.4에서 변경: "NotImplementedError" 대신 "ImportError"를 발
      생시킵니다.

   static source_to_code(data, path='<string>')

      파이썬 소스에서 코드 객체를 만듭니다.

      *data* 인자는 "compile()" 함수가 지원하는 것은 무엇이든 될 수 있
      습니다 (즉 문자열이나 바이트열). *path* 인자는 소스 코드가 온 곳
      의 "경로"여야 하며, 추상 개념(예를 들어 zip 파일에서의 위치)일
      수 있습니다.

      후속 코드 객체를 사용하면 "exec(code, module.__dict__)"를 실행하
      여 그 코드를 모듈에서 실행할 수 있습니다.

      Added in version 3.4.

      버전 3.5에서 변경: 메서드를 정적(static)으로 만들었습니다.

   exec_module(module)

      "Loader.exec_module()"의 구현.

      Added in version 3.4.

   load_module(fullname)

      "Loader.load_module()"의 구현.

      Deprecated since version 3.4, will be removed in version 3.15:
      대신 "exec_module()"을 사용하십시오.

class importlib.abc.ExecutionLoader

   구현될 때, 모듈이 스크립트로 실행되도록 돕는 "InspectLoader"에서 상
   속되는 추상 베이스 클래스. ABC는 선택적 **PEP 302** 프로토콜을 표현
   합니다.

   abstractmethod get_filename(fullname)

         지정된 모듈의 "__file__" 값을 반환하는 추상 메서드. 사용 가능
         한 경로가 없으면 "ImportError"가 발생합니다.

         소스 코드를 사용할 수 있으면, 메서드는 모듈을 로드하는 데 바
         이트 코드를 사용했는지와 관계없이 소스 파일의 경로를 반환해야
         합니다.

         버전 3.4에서 변경: "NotImplementedError" 대신 "ImportError"를
         발생시킵니다.

class importlib.abc.FileLoader(fullname, path)

   "ResourceLoader"와 "ExecutionLoader"를 상속하고
   "ResourceLoader.get_data()"와 "ExecutionLoader.get_filename()"의 구
   상 구현을 제공하는 추상 베이스 클래스.

   *fullname* 인자는 로더가 처리해야 하는 모듈의 완전히 결정된
   (resolved) 이름입니다. *path* 인자는 모듈의 파일 경로입니다.

   Added in version 3.3.

   name

      로더가 처리할 수 있는 모듈의 이름.

   path

      모듈 파일의 경로.

   load_module(fullname)

      super의 "load_module()"을 호출합니다.

      Deprecated since version 3.4, will be removed in version 3.15:
      대신 "Loader.exec_module()"을 사용하십시오.

   abstractmethod get_filename(fullname)

      "path"를 반환합니다.

   abstractmethod get_data(path)

      *path*를 바이너리 파일로 읽고 그것의 바이트열을 반환합니다.

class importlib.abc.SourceLoader

   소스 (및 선택적으로 바이트 코드) 파일 로드를 구현하기 위한 추상 베
   이스 클래스. 이 클래스는 "ResourceLoader"와 "ExecutionLoader"를 모
   두 상속하며, 다음을 구현해야 합니다:

   * "ResourceLoader.get_data()"

   * "ExecutionLoader.get_filename()"
        소스 파일의 경로만 반환해야 합니다; 소스 없는 로딩은 지원되지
        않습니다.

   이 클래스에 의해 정의된 추상 메서드는 선택적 바이트 코드 파일 지원
   을 추가하는 것입니다. 이러한 선택적 메서드를 구현하지 않으면 (또는
   그들이 "NotImplementedError"를 발생시키도록 하면) 로더가 소스 코드
   에 대해서만 작동하도록 만듭니다. 메서드를 구현하면 로더가 소스*와*
   바이트 코드 파일 모두에 대해 작동하게 할 수 있습니다; 바이트 코드만
   제공되는 *소스 없는* 로드는 허용하지 않습니다. 바이트 코드 파일은
   파이썬 컴파일러의 구문 분석 단계를 제거하여 로딩 속도를 높이기 위한
   최적화라서, 바이트 코드 전용 API는 노출되지 않습니다.

   path_stats(path)

      지정된 경로에 대한 메타 데이터를 포함하는 "dict"를 반환하는 선택
      적 추상 메서드. 지원되는 딕셔너리 키는 다음과 같습니다:

      * "'mtime'" (필수): 소스 코드의 수정 시간을 나타내는 정수나 부동
        소수점 숫자;

      * "'size'" (선택): 바이트 단위의 소스 코드의 크기.

      향후 확장을 위해, 딕셔너리의 다른 키는 무시됩니다. 경로를 처리할
      수 없으면, "OSError"가 발생합니다.

      Added in version 3.3.

      버전 3.4에서 변경: "NotImplementedError" 대신 "OSError"를 발생시
      킵니다.

   path_mtime(path)

      지정된 경로의 수정 시간을 반환하는 선택적 추상 메서드.

      버전 3.3부터 폐지됨: 이 메서드는 폐지되었고 "path_stats()"로 대
      체되었습니다. 구현할 필요는 없지만, 호환성을 위해 여전히 제공됩
      니다. 경로를 처리할 수 없으면 "OSError"를 발생시킵니다.

      버전 3.4에서 변경: "NotImplementedError" 대신 "OSError"를 발생시
      킵니다.

   set_data(path, data)

      지정된 바이트열을 파일 경로에 쓰는 선택적 추상 메서드. 존재하지
      않는 중간 디렉터리는 자동으로 만들어집니다.

      경로가 읽기 전용("errno.EACCES"/"PermissionError")이라서 경로에
      쓰지 못할 때 예외를 전파하지 않습니다.

      버전 3.4에서 변경: 호출할 때 더는 "NotImplementedError"를 발생시
      키지 않습니다.

   get_code(fullname)

      "InspectLoader.get_code()"의 구상 구현.

   exec_module(module)

      "Loader.exec_module()"의 구상 구현.

      Added in version 3.4.

   load_module(fullname)

      "Loader.load_module()"의 구상 구현.

      Deprecated since version 3.4, will be removed in version 3.15:
      대신 "exec_module()"을 사용하십시오.

   get_source(fullname)

      "InspectLoader.get_source()"의 구상 구현.

   is_package(fullname)

      "InspectLoader.is_package()"의 구상 구현.
      ("ExecutionLoader.get_filename()"에서 제공되는) 파일 경로가 파일
      확장자를 제거했을 때 "__init__"라는 이름의 파일이고 *동시에* 모
      듈 이름 자체가 "__init__"로 끝나지 않으면 모듈은 패키지로 결정됩
      니다.

class importlib.abc.ResourceReader

   *TraversableResources 로 대체되었습니다*

   *리소스(resources)*를 읽을 수 있는 기능을 제공하는 *추상 베이스 클
   래스*.

   이 ABC의 관점에서, *리소스(resource)*는 패키지 내에 제공되는 바이너
   리 아티팩트(artifact)입니다. 일반적으로 이것은 패키지의
   "__init__.py" 파일 옆에 있는 데이터 파일 같은 것입니다. 이 클래스의
   목적은 이러한 데이터 파일에 대한 액세스를 추상화하여 패키지와 해당
   데이터 파일이 예를 들어 zip 파일에 있는지 파일 시스템에 저장되어 있
   는지가 중요하지 않도록 만드는 것입니다.

   이 클래스의 모든 메서드에서, *resource* 인자는 개념적으로 단지 파일
   이름을 나타내는 *경로류 객체*가 될 것으로 기대됩니다. 이는
   *resource* 인자에 서브 디렉터리 경로가 포함되지 않아야 함을 의미합
   니다. 판독기(reader)가 읽으려는 패키지의 위치가 "디렉터리"의 역할을
   하기 때문입니다. 따라서 디렉터리와 파일 이름에 대한 은유는 각각 패
   키지와 리소스입니다. 이것은 또한 이 클래스의 인스턴스가 (잠재적으로
   여러 패키지나 모듈을 나타내는 대신) 특정 패키지와 직접적으로 연관될
   것으로 기대되는 이유입니다.

   리소스 읽기를 지원하려는 로더는 이 ABC의 인터페이스를 구현하는 객체
   를 반환하는 "get_resource_reader(fullname)"이라는 메서드를 제공해야
   합니다. fullname으로 지정된 모듈이 패키지가 아니면, 이 메서드는
   "None"을 반환해야 합니다. 이 ABC와 호환되는 객체는 지정된 모듈이 패
   키지일 때만 반환해야 합니다.

   Added in version 3.7.

   Deprecated since version 3.12, removed in version 3.14: 대신
   "importlib.resources.abc.TraversableResources"을 사용하십시오.

   abstractmethod open_resource(resource)

         *resource*의 바이너리 읽기를 위해 열린 *파일류 객체*를 반환합
         니다.

         리소스를 찾을 수 없으면, "FileNotFoundError" 가 발생합니다.

   abstractmethod resource_path(resource)

         *resource*에 대한 파일 시스템 경로를 반환합니다.

         리소스가 파일 시스템에 구체적으로 존재하지 않으면,
         "FileNotFoundError" 가 발생합니다.

   abstractmethod is_resource(name)

         명명된 *name*을 리소스로 간주하면 "True"를 반환합니다. *name*
         이 없으면, "FileNotFoundError" 가 발생합니다.

   abstractmethod contents()

         패키지 내용에 대한 문자열의 *이터러블*을 반환합니다. 이터레이
         터가 반환한 모든 이름이 실제 리소스일 필요는 없음에 유의하십
         시오, 예를 들어 "is_resource()"가 거짓인 이름을 반환하는 것이
         허용됩니다.

         리소스가 아닌 이름이 반환되도록 하는 것은 패키지와 그것의 리
         소스가 저장되는 방법이 사전에 알려졌고 리소스가 아닌 이름이
         유용한 상황을 허용하기 위함입니다. 예를 들어, 패키지와 리소스
         가 파일 시스템에 저장되어있는 것으로 알려졌을 때 해당 서브 디
         렉터리 이름을 직접 사용할 수 있도록 서브 디렉터리 이름 반환이
         허용됩니다.

         추상 메서드는 항목이 없는 이터러블을 반환합니다.

class importlib.abc.Traversable

   디렉터리를 탐색하고 파일을 여는 데 적합한 "pathlib.Path" 메서드의
   부분집합이 있는 객체.

   For a representation of the object on the file-system, use
   "importlib.resources.as_file()".

   Added in version 3.9.

   Deprecated since version 3.12, removed in version 3.14: 대신
   "importlib.resources.abc.Traversable"을 사용하십시오.

   name

      Abstract. The base name of this object without any parent
      references.

   abstractmethod iterdir()

      Yield "Traversable" objects in "self".

   abstractmethod is_dir()

      Return "True" if "self" is a directory.

   abstractmethod is_file()

      Return "True" if "self" is a file.

   abstractmethod joinpath(child)

      Return Traversable child in "self".

   abstractmethod __truediv__(child)

      Return "Traversable" child in "self".

   abstractmethod open(mode='r', *args, **kwargs)

      *mode* may be 'r' or 'rb' to open as text or binary. Return a
      handle suitable for reading (same as "pathlib.Path.open").

      When opening as text, accepts encoding parameters such as those
      accepted by "io.TextIOWrapper".

   read_bytes()

      Read contents of "self" as bytes.

   read_text(encoding=None)

      Read contents of "self" as text.

class importlib.abc.TraversableResources

   "importlib.resources.files()" 인터페이스를 제공할 수 있는 리소스 리
   더를 위한 추상 베이스 클래스.
   "importlib.resources.abc.ResourceReader"를 서브 클래싱하고
   "importlib.resources.abc.ResourceReader"의 추상 메서드의 구상 구현
   을 제공합니다. 따라서, "importlib.abc.TraversableResources"를 제공
   하는 모든 로더는 ResourceReader도 제공합니다.

   Loaders that wish to support resource reading are expected to
   implement this interface.

   Added in version 3.9.

   Deprecated since version 3.12, removed in version 3.14: 대신
   "importlib.resources.abc.TraversableResources"을 사용하십시오.

   abstractmethod files()

      Returns a "importlib.resources.abc.Traversable" object for the
      loaded package.


"importlib.machinery" -- 임포터와 경로 훅
=========================================

**소스 코드:** Lib/importlib/machinery.py

======================================================================

이 모듈에는 "import"가 모듈을 찾고 로드하는 데 도움이 되는 다양한 객체
가 포함되어 있습니다.

importlib.machinery.SOURCE_SUFFIXES

   소스 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트.

   Added in version 3.3.

importlib.machinery.DEBUG_BYTECODE_SUFFIXES

   최적화되지 않은 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리
   스트.

   Added in version 3.3.

   버전 3.5부터 폐지됨: 대신 "BYTECODE_SUFFIXES"를 사용하십시오.

importlib.machinery.OPTIMIZED_BYTECODE_SUFFIXES

   최적화된 바이트 코드 모듈의 파일 접미사를 나타내는 문자열 리스트.

   Added in version 3.3.

   버전 3.5부터 폐지됨: 대신 "BYTECODE_SUFFIXES"를 사용하십시오.

importlib.machinery.BYTECODE_SUFFIXES

   바이트 코드 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트 (
   앞의 점을 포함합니다).

   Added in version 3.3.

   버전 3.5에서 변경: 이 값은 더는 "__debug__"에 의존하지 않습니다.

importlib.machinery.EXTENSION_SUFFIXES

   확장 모듈로 인식되는 파일 접미사를 나타내는 문자열 리스트.

   Added in version 3.3.

importlib.machinery.all_suffixes()

   표준 임포트 절차가 인식하는 모듈의 모든 파일 접미사를 나타내는 문자
   열의 결합한 리스트를 반환합니다. 이것은 모듈 종류에 대한 세부 정보
   없이 파일 시스템 경로가 잠재적으로 모듈을 참조하는지를 알아야 하는
   코드(예를 들어, "inspect.getmodulename()")를 위한 도우미입니다.

   Added in version 3.3.

class importlib.machinery.BuiltinImporter

   내장 모듈용 *임포터*. 알려진 모든 내장 모듈은
   "sys.builtin_module_names"에 나열되어 있습니다. 이 클래스는
   "importlib.abc.MetaPathFinder"와 "importlib.abc.InspectLoader" ABC
   를 구현합니다.

   이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정
   의합니다.

   버전 3.5에서 변경: **PEP 489**의 일부로, 내장 임포터는 이제
   "Loader.create_module()"과 "Loader.exec_module()"을 구현합니다.

class importlib.machinery.FrozenImporter

   프로즌(frozen) 모듈용 *임포터*. 이 클래스는
   "importlib.abc.MetaPathFinder"와 "importlib.abc.InspectLoader" ABC
   를 구현합니다.

   이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정
   의합니다.

   버전 3.4에서 변경: "Loader.create_module()"과
   "Loader.exec_module()" 메서드를 얻었습니다.

class importlib.machinery.WindowsRegistryFinder

   윈도우 레지스트리에 선언된 모듈용 *파인더*. 이 클래스는
   "importlib.abc.MetaPathFinder" ABC를 구현합니다.

   이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정
   의합니다.

   Added in version 3.3.

   버전 3.6부터 폐지됨: 대신 "site" 구성을 사용하십시오. 이후 버전의
   파이썬은 기본적으로 이 파인더를 활성화하지 않을 수 있습니다.

class importlib.machinery.PathFinder

   "sys.path"와 패키지 "__path__" 어트리뷰트용 *파인더*. 이 클래스는
   "importlib.abc.MetaPathFinder" ABC를 구현합니다.

   이 클래스는 인스턴스 화의 필요성을 완화하기 위해 클래스 메서드만 정
   의합니다.

   classmethod find_spec(fullname, path=None, target=None)

      "sys.path" 또는, 정의되었다면, *path*에서 *fullname*에 의해 지정
      된 모듈에 대한 *스펙*을 찾으려고 시도하는 클래스 메서드. 검색된
      각 경로 엔트리에 대해, "sys.path_importer_cache"가 확인됩니다.
      거짓이 아닌 객체를 찾으면 검색 중인 모듈을 찾기 위한 *경로 엔트
      리 파인더*로 사용됩니다. "sys.path_importer_cache"에 엔트리가 없
      으면, "sys.path_hooks"에서 경로 엔트리를 위한 파인더를 검색하고,
      발견되면, 모듈에 대해 조회되는 것과 동시에
      "sys.path_importer_cache"에 저장됩니다. 파인더가 아예 발견되지
      않으면 "None"이 캐시에 저장되고 반환됩니다.

      Added in version 3.4.

      버전 3.5에서 변경: 현재 작업 디렉터리 -- 빈 문자열로 표현됩니다
      -- 가 더는 유효하지 않으면 "None"이 반환되지만
      "sys.path_importer_cache"에 값이 캐시 되지는 않습니다.

   classmethod invalidate_caches()

      메서드를 정의하는 "sys.path_importer_cache"에 저장된 모든 파인더
      에 대해 "importlib.abc.PathEntryFinder.invalidate_caches()"를 호
      출합니다. "sys.path_importer_cache"에 "None"으로 설정된 엔트리가
      삭제됩니다.

      버전 3.7에서 변경: "sys.path_importer_cache"에서 "None"의 엔트리
      가 삭제됩니다.

   버전 3.4에서 변경: "''"(즉 빈 문자열)에 대해서는 현재 작업 디렉터리
   로 "sys.path_hooks"의 객체를 호출합니다.

class importlib.machinery.FileFinder(path, *loader_details)

   파일 시스템에서의 결과를 캐시 하는 "importlib.abc.PathEntryFinder"
   의 구상 구현.

   *path* 인자는 파인더가 검색을 담당하는 디렉터리입니다.

   *loader_details* 인자는 각각 로더와 로더가 인식하는 파일 접미사의
   시퀀스를 포함하는 가변 개수의 2개 항목 튜플입니다. 로더는 모듈 이름
   과 찾은 파일의 경로로 구성되는 두 인자를 받아들이는 콜러블일 것으로
   기대됩니다.

   파인더는 필요에 따라 디렉터리 내용을 캐시 하여, 각 모듈 검색에서
   stat 호출을 수행하여 캐시가 시효가 지나지 않았는지 확인합니다. 캐시
   만료는 파일 시스템의 운영 체제 상태 정보의 세분성에 의존하기 때문에
   , 모듈 검색, 새 파일 생성 및 새 파일이 나타내는 모듈 검색의 잠재적
   경쟁 조건이 있습니다. stat 호출의 세분성 이하로 연산이 아주 빠르게
   수행되면, 모듈 검색이 실패합니다. 이를 방지하려면, 모듈을 동적으로
   만들 때, "importlib.invalidate_caches()"를 호출해야 합니다.

   Added in version 3.3.

   path

      파인더가 검색할 경로.

   find_spec(fullname, target=None)

      "path" 내에서 *fullname*을 처리할 스펙을 찾으려고 합니다.

      Added in version 3.4.

   invalidate_caches()

      내부 캐시를 지웁니다.

   classmethod path_hook(*loader_details)

      "sys.path_hooks"에 사용할 클로저를 반환하는 클래스 메서드.
      "FileFinder"의 인스턴스는 클로저에 직접 제공된 경로 인자와
      *loader_details*를 간접적으로 사용하여 클로저에 의해 반환됩니다.

      클로저에 대한 인자가 기존 디렉터리가 아니면, "ImportError"가 발
      생합니다.

class importlib.machinery.SourceFileLoader(fullname, path)

   "importlib.abc.FileLoader"를 서브 클래싱하고 다른 메서드의 구상 구
   현을 제공하는 "importlib.abc.SourceLoader"의 구상 구현.

   Added in version 3.3.

   name

      이 로더가 처리할 모듈의 이름.

   path

      소스 파일의 경로.

   is_package(fullname)

      "path"가 패키지에 대한 것으로 드러나면 "True"를 반환합니다.

   path_stats(path)

      "importlib.abc.SourceLoader.path_stats()"의 구상 구현.

   set_data(path, data)

      "importlib.abc.SourceLoader.set_data()"의 구상 구현.

   load_module(name=None)

      로드할 모듈 이름을 지정하는 것이 선택적인
      "importlib.abc.Loader.load_module()"의 구상 구현.

      Deprecated since version 3.6, will be removed in version 3.15:
      대신 "importlib.abc.Loader.exec_module()"을 사용하십시오.

class importlib.machinery.SourcelessFileLoader(fullname, path)

   바이트 코드 파일을 (즉, 소스 코드 파일 없이) 임포트 할 수 있는
   "importlib.abc.FileLoader"의 구상 구현.

   바이트 코드 파일(그래서 소스 코드 파일이 아닌)을 직접 사용하면 모든
   파이썬 구현이나 바이트 코드 형식을 변경하는 새 버전의 파이썬에서 모
   듈을 사용할 수 없게 됨에 유의하십시오.

   Added in version 3.3.

   name

      로더가 처리할 모듈의 이름.

   path

      바이트 코드 파일의 경로.

   is_package(fullname)

      "path"를 기반으로 모듈이 패키지인지 판단합니다.

   get_code(fullname)

      "path"에서 만들어진 "name"의 코드 객체를 반환합니다.

   get_source(fullname)

      이 로더가 사용될 때는 바이트 코드 파일에 소스가 없어서 "None"을
      반환합니다.

   load_module(name=None)

   로드할 모듈 이름을 지정하는 것이 선택적인
   "importlib.abc.Loader.load_module()"의 구상 구현.

   Deprecated since version 3.6, will be removed in version 3.15: 대신
   "importlib.abc.Loader.exec_module()"을 사용하십시오.

class importlib.machinery.ExtensionFileLoader(fullname, path)

   확장 모듈을 위한 "importlib.abc.ExecutionLoader"의 구상 구현.

   *fullname* 인자는 로더가 지원할 모듈의 이름을 지정합니다. *path* 인
   자는 확장 모듈 파일의 경로입니다.

   Note that, by default, importing an extension module will fail in
   subinterpreters if it doesn't implement multi-phase init (see **PEP
   489**), even if it would otherwise import successfully.

   Added in version 3.3.

   버전 3.12에서 변경: Multi-phase init is now required for use in
   subinterpreters.

   name

      로더가 지원하는 모듈의 이름.

   path

      확장 모듈의 경로.

   create_module(spec)

      **PEP 489**에 따라 지정된 명세에서 모듈 객체를 만듭니다.

      Added in version 3.5.

   exec_module(module)

      **PEP 489**에 따라 주어진 모듈 객체를 초기화합니다.

      Added in version 3.5.

   is_package(fullname)

      "EXTENSION_SUFFIXES"에 기반해서 파일 경로가 패키지의 "__init__"
      모듈을 가리키면 "True"를 반환합니다.

   get_code(fullname)

      확장 모듈에는 코드 객체가 없어서 "None"을 반환합니다.

   get_source(fullname)

      확장 모듈에는 소스 코드가 없어서 "None"을 반환합니다.

   get_filename(fullname)

      "path"를 반환합니다.

      Added in version 3.4.

class importlib.machinery.NamespaceLoader(name, path, path_finder)

   A concrete implementation of "importlib.abc.InspectLoader" for
   namespace packages.  This is an alias for a private class and is
   only made public for introspecting the "__loader__" attribute on
   namespace packages:

      >>> from importlib.machinery import NamespaceLoader
      >>> import my_namespace
      >>> isinstance(my_namespace.__loader__, NamespaceLoader)
      True
      >>> import importlib.abc
      >>> isinstance(my_namespace.__loader__, importlib.abc.Loader)
      True

   Added in version 3.11.

class importlib.machinery.ModuleSpec(name, loader, *, origin=None, loader_state=None, is_package=None)

   모듈의 임포트 시스템 관련 상태에 대한 명세. 이것은 일반적으로 모듈
   의 "__spec__" 어트리뷰트로 노출됩니다. 이 중 많은 어트리뷰트는 모듈
   에서도 직접 제공됩니다: 예를 들어, "module.__spec__.origin ==
   module.__file__". 그러나 *values*는 일반적으로 동등하지만, 두 객체
   간에 동기화가 없기 때문에 다를 수 있음에 유의하십시오. 예를 들어,
   실행 시간에 모듈의 "__file__"을 갱신할 수 있으며, 이는 모듈의
   "__spec__.origin"에 자동으로 반영되지 않고, 그 반대도 마찬가지 입니
   다.

   Added in version 3.4.

   name

      The module's fully qualified name (see "module.__name__"). The
      *finder* should always set this attribute to a non-empty string.

   loader

      모듈을 로드하는 데 사용되는 *로더* ("module.__loader__"를 참조하
      세요). *파인더*는 항상 이 어트리뷰트를 설정해야 합니다.

   origin

      The location the *loader* should use to load the module (see
      "module.__file__"). For example, for modules loaded from a ".py"
      file this is the filename. The *finder* should always set this
      attribute to a meaningful value for the *loader* to use.  In the
      uncommon case that there is not one (like for namespace
      packages), it should be set to "None".

   submodule_search_locations

      A (possibly empty) *sequence* of strings enumerating the
      locations in which a package's submodules will be found (see
      "module.__path__"). Most of the time there will only be a single
      directory in this list.

      The *finder* should set this attribute to a sequence, even an
      empty one, to indicate to the import system that the module is a
      package.  It should be set to "None" for non-package modules.
      It is set automatically later to a special object for namespace
      packages.

   loader_state

      The *finder* may set this attribute to an object containing
      additional, module-specific data to use when loading the module.
      Otherwise it should be set to "None".

   cached

      The filename of a compiled version of the module's code (see
      "module.__cached__"). The *finder* should always set this
      attribute but it may be "None" for modules that do not need
      compiled code stored.

   parent

      (읽기 전용) 모듈이 속한 패키지의 패키지의 완전히 정규화된 이름 (
      또는 최상위 수준 모듈의 경우 빈 문자열). "module.__package__"를
      참조하세요. 모듈이 패키지면, "name"과 같습니다.

   has_location

      "True" if the spec's "origin" refers to a loadable location,
      "False" otherwise.  This value impacts how "origin" is
      interpreted and how the module's "__file__" is populated.

class importlib.machinery.AppleFrameworkLoader(name, path)

   프레임워크 형식의 확장 모듈을 로드할 수 있는
   "importlib.machinery.ExtensionFileLoader"의 특수화.

   For compatibility with the iOS App Store, *all* binary modules in
   an iOS app must be dynamic libraries, contained in a framework with
   appropriate metadata, stored in the "Frameworks" folder of the
   packaged app. There can be only a single binary per framework, and
   there can be no executable binary material outside the Frameworks
   folder.

   To accommodate this requirement, when running on iOS, extension
   module binaries are *not* packaged as ".so" files on "sys.path",
   but as individual standalone frameworks. To discover those
   frameworks, this loader is registered against the ".fwork" file
   extension, with a ".fwork" file acting as a placeholder in the
   original location of the binary on "sys.path". The ".fwork" file
   contains the path of the actual binary in the "Frameworks" folder,
   relative to the app bundle. To allow for resolving a framework-
   packaged binary back to the original location, the framework is
   expected to contain a ".origin" file that contains the location of
   the ".fwork" file, relative to the app bundle.

   For example, consider the case of an import "from foo.bar import
   _whiz", where "_whiz" is implemented with the binary module
   "sources/foo/bar/_whiz.abi3.so", with "sources" being the location
   registered on "sys.path", relative to the application bundle. This
   module *must* be distributed as
   "Frameworks/foo.bar._whiz.framework/foo.bar._whiz" (creating the
   framework name from the full import path of the module), with an
   "Info.plist" file in the ".framework" directory identifying the
   binary as a framework. The "foo.bar._whiz" module would be
   represented in the original location with a
   "sources/foo/bar/_whiz.abi3.fwork" marker file, containing the path
   "Frameworks/foo.bar._whiz/foo.bar._whiz". The framework would also
   contain "Frameworks/foo.bar._whiz.framework/foo.bar._whiz.origin",
   containing the path to the ".fwork" file.

   When a module is loaded with this loader, the "__file__" for the
   module will report as the location of the ".fwork" file. This
   allows code to use the "__file__" of a  module as an anchor for
   file system traversal. However, the spec origin will reference the
   location of the *actual* binary in the ".framework" folder.

   The Xcode project building the app is responsible for converting
   any ".so" files from wherever they exist in the "PYTHONPATH" into
   frameworks in the "Frameworks" folder (including stripping
   extensions from the module file, the addition of framework
   metadata, and signing the resulting framework), and creating the
   ".fwork" and ".origin" files. This will usually be done with a
   build step in the Xcode project; see the iOS documentation for
   details on how to construct this build step.

   Added in version 3.13.

   가용성: iOS.

   name

      로더가 지원하는 모듈의 이름.

   path

      확장 모듈의 ".fwork" 파일 경로.


"importlib.util" -- 임포터를 위한 유틸리티 코드
===============================================

**소스 코드:** Lib/importlib/util.py

======================================================================

이 모듈에는 *임포터* 구성에 도움이 되는 다양한 객체가 포함되어 있습니
다.

importlib.util.MAGIC_NUMBER

   바이트 코드 버전 번호를 나타내는 바이트열. 바이트 코드의 로드/쓰기
   에 도움이 필요하면 "importlib.abc.SourceLoader"를 고려하십시오.

   Added in version 3.4.

importlib.util.cache_from_source(path, debug_override=None, *, optimization=None)

   소스 *path*와 연관된 바이트 컴파일된 파일의 **PEP 3147**/**PEP
   488** 경로를 반환합니다. 예를 들어, *path*가 "/foo/bar/baz.py"이면
   반환값은 파이썬 3.2의 경우
   "/foo/bar/__pycache__/baz.cpython-32.pyc"입니다. "cpython-32" 문자
   열은 현재 매직 태그에서 온 것입니다 ("get_tag()"를 참조하십시오;
   "sys.implementation.cache_tag"가 정의되지 않으면
   "NotImplementedError" 가 발생합니다).

   *optimization* 매개 변수는 바이트 코드 파일의 최적화 수준을 지정하
   는 데 사용됩니다. 빈 문자열은 최적화하지 않음을 나타내므로,
   *optimization*이 "''" 인 "/foo/bar/baz.py"는 바이트 코드 경로가
   "/foo/bar/__pycache__/baz.cpython-32.pyc"가 됩니다. "None"은 인터프
   리터의 최적화 수준이 사용되도록 합니다. 다른 값의 문자열 표현은 사
   용되므로, *optimization*이 "2"인 "/foo/bar/baz.py"는 바이트 코드 경
   로가 "/foo/bar/__pycache__/baz.cpython-32.opt-2.pyc"가 됩니다.
   *optimization*의 문자열 표현은 영숫자만 가능하며, 그렇지 않으면
   "ValueError"가 발생합니다.

   *debug_override* 매개 변수는 폐지되었고 "__debug__"의 시스템값을 대
   체하는 데 사용할 수 있습니다. "True" 값은 *optimization*을 빈 문자
   열로 설정하는 것과 등등합니다. "False" 값은 *optimization*을 "1"로
   설정하는 것과 같습니다. *debug_override*와 *optimization*이 모두
   "None"이 아니면 "TypeError"가 발생합니다.

   Added in version 3.4.

   버전 3.5에서 변경: *optimization* 매개 변수가 추가되었고
   *debug_override* 매개 변수는 폐지되었습니다.

   버전 3.6에서 변경: *경로류 객체*를 받아들입니다.

importlib.util.source_from_cache(path)

   *path*에 **PEP 3147** 파일 이름이 주어지면, 연관된 소스 코드 파일
   경로를 반환합니다. 예를 들어, *path*가
   "/foo/bar/__pycache__/baz.cpython-32.pyc"이면 반환된 경로는
   "/foo/bar/baz.py"입니다. *path*는 존재할 필요는 없지만, **PEP
   3147**이나 **PEP 488** 형식을 준수하지 않으면, "ValueError"가 발생
   합니다. "sys.implementation.cache_tag"가 정의되지 않으면,
   "NotImplementedError" 가 발생합니다.

   Added in version 3.4.

   버전 3.6에서 변경: *경로류 객체*를 받아들입니다.

importlib.util.decode_source(source_bytes)

   소스 코드를 나타내는 주어진 바이트열을 디코딩하고 유니버설 줄 넘김
   이 적용된 문자열로 반환합니다
   ("importlib.abc.InspectLoader.get_source()"에 필요한 대로).

   Added in version 3.4.

importlib.util.resolve_name(name, package)

   상대 모듈 이름을 절대 이름으로 결정합니다.

   **name** 선두에 점이 없으면, **name**이 단순히 반환됩니다. 이를 통
   해 **package** 인자가 필요한지 확인하지 않고
   "importlib.util.resolve_name('sys', __spec__.parent)"와 같은 사용이
   가능합니다.

   **name**이 상대 모듈 이름이지만 **package**가 거짓 값(예를 들어
   "None"이나 빈 문자열)이면 "ImportError"가 발생합니다. "ImportError"
   는 또한 상대 이름이 그것을 포함하는 패키지를 벗어날 것 같으면 발생
   합니다 (예를 들어 "spam" 패키지 내에서 "..bacon"을 요청하는 것).

   Added in version 3.3.

   버전 3.9에서 변경: import 문과의 일관성을 개선하기 위해, 잘못된 상
   대 임포트 시도에 대해 "ValueError" 대신 "ImportError"를 발생시킵니
   다.

importlib.util.find_spec(name, package=None)

   선택적으로 지정된 **package** 이름에 상대적으로, 모듈의 *스펙*을 찾
   습니다. 모듈이 "sys.modules"에 있으면, "sys.modules[name].__spec__"
   이 반환됩니다 (스펙이 "None"이 되거나 설정되지 않지 않은 한, 그럴
   경우는 "ValueError"가 발생합니다). 그렇지 않으면 "sys.meta_path"를
   사용한 검색이 수행됩니다. 스펙을 찾지 못하면 "None"이 반환됩니다.

   **name**이 서브 모듈에 관한 것이면 (점을 포함하면), 부모 모듈은 자
   동으로 임포트 됩니다.

   **name**과 **package**는 "import_module()"과 같게 작동합니다.

   Added in version 3.4.

   버전 3.7에서 변경: **package**가 실제로 패키지가 아니면 (즉
   "__path__" 어트리뷰트가 없으면) "AttributeError" 대신
   "ModuleNotFoundError"를 발생시킵니다.

importlib.util.module_from_spec(spec)

   **spec**과 "spec.loader.create_module"을 기반으로 새 모듈을 만듭니
   다.

   "spec.loader.create_module"이 "None"을 반환하지 않으면, 어떤 기존
   어트리뷰트도 재설정되지 않습니다. 또한 **spec**에 액세스하거나 모듈
   에서 어트리뷰트를 설정하는 동안 트리거 되면 "AttributeError"가 발생
   하지 않습니다.

   **spec**은 모듈에서 가능한 많은 임포트 제어 어트리뷰트를 설정하는
   데 사용되므로 새 모듈을 작성하는 데 "types.ModuleType"을 사용하는
   것보다 이 함수가 선호됩니다.

   Added in version 3.5.

importlib.util.spec_from_loader(name, loader, *, origin=None, is_package=None)

   로더(loader)를 기반으로 "ModuleSpec" 인스턴스를 만들기 위한 팩토리
   함수. 매개 변수는 ModuleSpec에서와 같은 의미입니다. 이 함수는
   "InspectLoader.is_package()"와 같은 사용 가능한 *로더* API를 사용하
   여 스펙에 빠진 정보를 채웁니다.

   Added in version 3.4.

importlib.util.spec_from_file_location(name, location, *, loader=None, submodule_search_locations=None)

   파일 경로를 기반으로 "ModuleSpec" 인스턴스를 만드는 팩토리 함수. 로
   더 API를 사용하고 모듈이 파일 기반일 것이라는 것이 뜻하는 것으로 누
   락된 정보가 스펙에 채워집니다.

   Added in version 3.4.

   버전 3.6에서 변경: *경로류 객체*를 받아들입니다.

importlib.util.source_hash(source_bytes)

   *source_bytes*의 해시를 바이트열로 반환합니다. 해시 기반 ".pyc" 파
   일은 해당 소스 파일 내용의 "source_hash()"를 헤더에 포함합니다.

   Added in version 3.7.

importlib.util._incompatible_extension_module_restrictions(*, disable_check)

   A context manager that can temporarily skip the compatibility check
   for extension modules.  By default the check is enabled and will
   fail when a single-phase init module is imported in a
   subinterpreter. It will also fail for a multi-phase init module
   that doesn't explicitly support a per-interpreter GIL, when
   imported in an interpreter with its own GIL.

   Note that this function is meant to accommodate an unusual case;
   one which is likely to eventually go away.  There's is a pretty
   good chance this is not what you were looking for.

   You can get the same effect as this function by implementing the
   basic interface of multi-phase init (**PEP 489**) and lying about
   support for multiple interpreters (or per-interpreter GIL).

   경고:

     Using this function to disable the check can lead to unexpected
     behavior and even crashes.  It should only be used during
     extension module development.

   Added in version 3.12.

class importlib.util.LazyLoader(loader)

   모듈이 어트리뷰트에 액세스할 때까지 모듈 로더의 실행을 연기하는 클
   래스.

   이 클래스는 필요한 모듈 형에 대한 제어로 "exec_module()"을 정의하는
   로더**에서만** 작동합니다. 같은 이유로, 로더의 "create_module()" 메
   서드는 "None"을 반환하거나, *슬롯*을 사용하지 않고 "__class__" 어트
   리뷰트가 변경될 수 있는 형을 반환해야 합니다. 마지막으로,
   "sys.modules"에 배치된 객체를 치환하는 모듈은 인터프리터 전체에서
   모듈 참조를 안전하게 대체할 방법이 없어서 작동하지 않습니다; 이러한
   치환이 감지되면 "ValueError"가 발생합니다.

   참고:

     시작 시간이 중요한 프로젝트의 경우, 이 클래스를 사용하면 사용하지
     않을 모듈을 로드하는 데 드는 비용을 최소화할 수 있습니다. 시작 시
     간이 핵심이 아닌 프로젝트의 경우 로딩이 지연되는 동안 만들어진,
     따라서 문맥을 벗어난 에러 메시지 때문에, 이 클래스를 사용하지 말
     것을 **강하게** 권고합니다.

   Added in version 3.5.

   버전 3.6에서 변경: "importlib.machinery.BuiltinImporter"와
   "importlib.machinery.ExtensionFileLoader" 에 대한 호환성 경고를 제
   거하고, "create_module()"을 호출하기 시작했습니다.

   classmethod factory(loader)

      지연된 로더(lazy loader)를 만드는 콜러블을 반환하는 클래스 메서
      드. 이것은 로더가 인스턴스가 아닌 클래스로 전달되는 상황에서 사
      용하려는 것입니다.

         suffixes = importlib.machinery.SOURCE_SUFFIXES
         loader = importlib.machinery.SourceFileLoader
         lazy_loader = importlib.util.LazyLoader.factory(loader)
         finder = importlib.machinery.FileFinder(path, (lazy_loader, suffixes))


예
==


프로그래밍 방식으로 임포트 하기
-------------------------------

프로그래밍 방식으로 모듈을 임포트 하려면, "importlib.import_module()"
을 사용하십시오.

   import importlib

   itertools = importlib.import_module('itertools')


모듈을 임포트 할 수 있는지 확인하기
-----------------------------------

실제로 임포트를 수행하지 않고 모듈을 임포트 할 수 있는지 확인해야 하면
, "importlib.util.find_spec()"을 사용해야 합니다.

Note that if "name" is a submodule (contains a dot),
"importlib.util.find_spec()" will import the parent module.

   import importlib.util
   import sys

   # 설명을 위해.
   name = 'itertools'

   if name in sys.modules:
       print(f"{name!r} already in sys.modules")
   elif (spec := importlib.util.find_spec(name)) is not None:
       # 실제 임포트를 수행하기로 선택하면 ...
       module = importlib.util.module_from_spec(spec)
       sys.modules[name] = module
       spec.loader.exec_module(module)
       print(f"{name!r} has been imported")
   else:
       print(f"can't find the {name!r} module")


소스 파일을 직접 임포트 하기
----------------------------

This recipe should be used with caution: it is an approximation of an
import statement where the file path is specified directly, rather
than "sys.path" being searched. Alternatives should first be
considered first, such as modifying "sys.path" when a proper module is
required, or using "runpy.run_path()" when the global namespace
resulting from running a Python file is appropriate.

파이썬 소스 파일을 경로에서 직접 임포트 하려면, 다음 조리법을 사용하십
시오:

   import importlib.util
   import sys


   def import_from_path(module_name, file_path):
       spec = importlib.util.spec_from_file_location(module_name, file_path)
       module = importlib.util.module_from_spec(spec)
       sys.modules[module_name] = module
       spec.loader.exec_module(module)
       return module


   # 오직 설명을 위해 (`json` 의 사용은 임의적입니다).
   import json
   file_path = json.__file__
   module_name = json.__name__

   # `import json` 과 유사한 결과.
   json = import_from_path(module_name, file_path)


Implementing lazy imports
-------------------------

The example below shows how to implement lazy imports:

   >>> import importlib.util
   >>> import sys
   >>> def lazy_import(name):
   ...     spec = importlib.util.find_spec(name)
   ...     loader = importlib.util.LazyLoader(spec.loader)
   ...     spec.loader = loader
   ...     module = importlib.util.module_from_spec(spec)
   ...     sys.modules[name] = module
   ...     loader.exec_module(module)
   ...     return module
   ...
   >>> lazy_typing = lazy_import("typing")
   >>> #lazy_typing 은 실제 모듈 객체입니다,
   >>> #하지만 아직 메모리에 로드되지 않았습니다.
   >>> lazy_typing.TYPE_CHECKING
   False


임포터 설정하기
---------------

임포트의 심층 사용자 정의를 위해서는, 일반적으로 *임포터*를 구현하려고
합니다. 이는 *파인더*와 *로더* 측면을 모두 관리한다는 의미입니다. 파인
더에는 필요에 따라 두 가지 종류가 있습니다: *메타 경로 파인더*나 *경로
엔트리 파인더*. 전자는 "sys.meta_path"에 배치하는 것이고 후자는
"sys.path_hooks"에서 *경로 엔트리 훅*을 사용하여 만드는 것으로
"sys.path" 항목과 함께 작동하여 파인더를 만듭니다. 이 예제는 임포트가
임포터를 사용할 수 있도록 임포터를 등록하는 방법을 보여줍니다 (임포터
를 직접 만들려면, 이 패키지에 정의된 적절한 클래스의 설명서를 읽으십시
오):

   import importlib.machinery
   import sys

   # 오직 설명을 위해.
   SpamMetaPathFinder = importlib.machinery.PathFinder
   SpamPathEntryFinder = importlib.machinery.FileFinder
   loader_details = (importlib.machinery.SourceFileLoader,
                     importlib.machinery.SOURCE_SUFFIXES)

   # 메타 경로 파인더 설정하기.
   # 파인더를 우선순위 측면에서 리스트의 올바른 위치에
   # 넣으십시오.
   sys.meta_path.append(SpamMetaPathFinder)

   # 경로 엔트리 파인더 설정하기.
   # 경로 훅을 우선순위 측면에서 리스트의 올바른 위치에
   # 넣으십시오.
   sys.path_hooks.append(SpamPathEntryFinder.path_hook(loader_details))


"importlib.import_module()" 근사하기
------------------------------------

임포트 자체는 파이썬 코드로 구현되므로, importlib를 통해 대부분의 임포
트 절차를 노출할 수 있습니다. 다음은 "importlib.import_module()"의 근
사적인(approximate) 구현을 제공하여 importlib가 노출하는 다양한 API를
설명하는 데 도움을 줍니다:

   import importlib.util
   import sys

   def import_module(name, package=None):
       """import의 대략적인 구현."""
       absolute_name = importlib.util.resolve_name(name, package)
       try:
           return sys.modules[absolute_name]
       except KeyError:
           pass

       path = None
       if '.' in absolute_name:
           parent_name, _, child_name = absolute_name.rpartition('.')
           parent_module = import_module(parent_name)
           path = parent_module.__spec__.submodule_search_locations
       for finder in sys.meta_path:
           spec = finder.find_spec(absolute_name, path)
           if spec is not None:
               break
       else:
           msg = f'No module named {absolute_name!r}'
           raise ModuleNotFoundError(msg, name=absolute_name)
       module = importlib.util.module_from_spec(spec)
       sys.modules[absolute_name] = module
       spec.loader.exec_module(module)
       if path is not None:
           setattr(parent_module, child_name, module)
       return module
