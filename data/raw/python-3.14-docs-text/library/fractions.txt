"fractions" --- 유리수
**********************

**소스 코드:** Lib/fractions.py

======================================================================

"fractions" 모듈은 유리수 산술을 지원합니다.

A Fraction instance can be constructed from a pair of rational
numbers, from a single number, or from a string.

class fractions.Fraction(numerator=0, denominator=1)
class fractions.Fraction(number)
class fractions.Fraction(string)

   The first version requires that *numerator* and *denominator* are
   instances of "numbers.Rational" and returns a new "Fraction"
   instance with a value equal to "numerator/denominator". If
   *denominator* is zero, it raises a "ZeroDivisionError".

   The second version requires that *number* is an instance of
   "numbers.Rational" or has the "as_integer_ratio()" method (this
   includes "float" and "decimal.Decimal"). It returns a "Fraction"
   instance with exactly the same value. Assumed, that the
   "as_integer_ratio()" method returns a pair of coprime integers and
   last one is positive. Note that due to the usual issues with binary
   point (see 부동 소수점 산술: 문제점 및 한계), the argument to
   "Fraction(1.1)" is not exactly equal to 11/10, and so
   "Fraction(1.1)" does *not* return "Fraction(11, 10)" as one might
   expect. (But see the documentation for the "limit_denominator()"
   method below.)

   The last version of the constructor expects a string. The usual
   form for this instance is:

      [sign] numerator ['/' denominator]

   이때, 선택적 "sign"은 '+' 나 '-'일 수 있으며 "numerator" 와
   "denominator"(있다면)는 십진수 문자열입니다 (밑줄은 코드에서 정수
   리터럴과 마찬가지로 숫자를 구분하는 데 사용할 수 있습니다). 또한,
   유한한 값을 나타내고 "float" 생성자에서 허용하는 모든 문자열은
   "Fraction" 생성자에서도 허용됩니다. 모든 형식에서, 입력 문자열에는
   선행과/이나 후행 공백이 있을 수도 있습니다. 여기 예제가 있습니다:

      >>> from fractions import Fraction
      >>> Fraction(16, -10)
      Fraction(-8, 5)
      >>> Fraction(123)
      Fraction(123, 1)
      >>> Fraction()
      Fraction(0, 1)
      >>> Fraction('3/7')
      Fraction(3, 7)
      >>> Fraction(' -3/7 ')
      Fraction(-3, 7)
      >>> Fraction('1.414213 \t\n')
      Fraction(1414213, 1000000)
      >>> Fraction('-.125')
      Fraction(-1, 8)
      >>> Fraction('7e-6')
      Fraction(7, 1000000)
      >>> Fraction(2.25)
      Fraction(9, 4)
      >>> Fraction(1.1)
      Fraction(2476979795053773, 2251799813685248)
      >>> from decimal import Decimal
      >>> Fraction(Decimal('1.1'))
      Fraction(11, 10)

   "Fraction" 클래스는 추상 베이스 클래스 "numbers.Rational"를 상속하
   며, 그 클래스의 모든 메서드와 연산을 구현합니다. "Fraction" 인스턴
   스는 *해시 가능*하고, 불변으로 취급해야 합니다. 또한, "Fraction"에
   는 다음과 같은 프로퍼티와 메서드가 있습니다:

   버전 3.2에서 변경: "Fraction" 생성자는 이제 "float"와
   "decimal.Decimal" 인스턴스를 받아들입니다.

   버전 3.9에서 변경: "math.gcd()" 함수가 이제 *numerator*와
   *denominator*를 정규화하는 데 사용됩니다. "math.gcd()"는 항상 "int"
   형을 반환합니다. 이전에는, GCD 형이 *numerator*와 *denominator*에
   의존했습니다.

   버전 3.11에서 변경: Underscores are now permitted when creating a
   "Fraction" instance from a string, following **PEP 515** rules.

   버전 3.11에서 변경: "Fraction" implements "__int__" now to satisfy
   "typing.SupportsInt" instance checks.

   버전 3.12에서 변경: Space is allowed around the slash for string
   inputs: "Fraction('2 / 3')".

   버전 3.12에서 변경: "Fraction" instances now support float-style
   formatting, with presentation types ""e"", ""E"", ""f"", ""F"",
   ""g"", ""G"" and ""%""".

   버전 3.13에서 변경: Formatting of "Fraction" instances without a
   presentation type now supports fill, alignment, sign handling,
   minimum width and grouping.

   버전 3.14에서 변경: The "Fraction" constructor now accepts any
   objects with the "as_integer_ratio()" method.

   numerator

      기약 분수로 나타낼 때 Fraction의 분자.

   denominator

      Denominator of the Fraction in lowest terms. Guaranteed to be
      positive.

   as_integer_ratio()

      비율이 원래 Fraction과 같습니다. 비율은 양의 분모를 갖는 가장 작
      은 항으로 표현됩니다.

      Added in version 3.8.

   is_integer()

      Return "True" if the Fraction is an integer.

      Added in version 3.12.

   classmethod from_float(f)

      "float" 나 "numbers.Integral"의 인스턴스만 받아들이는 대체 생성
      자. "Fraction.from_float(0.3)"가 "Fraction(3, 10)"와 같은 값이
      아니라는 점에 유의하십시오.

      참고:

        파이썬 3.2 이상에서는, "float"에서 직접 "Fraction" 인스턴스를
        생성할 수도 있습니다.

   classmethod from_decimal(dec)

      "decimal.Decimal" 나 "numbers.Integral"의 인스턴스만 받아들이는
      대체 생성자.

      참고:

        파이썬 3.2 이상에서는, "decimal.Decimal" 인스턴스에서 직접
        "Fraction" 인스턴스를 생성할 수도 있습니다.

   classmethod from_number(number)

      Alternative constructor which only accepts instances of
      "numbers.Integral", "numbers.Rational", "float" or
      "decimal.Decimal", and objects with the "as_integer_ratio()"
      method, but not strings.

      Added in version 3.14.

   limit_denominator(max_denominator=1000000)

      분모가 최대 max_denominator인 "self"에 가장 가까운 "Fraction"을
      찾아서 반환합니다. 이 메서드는 주어진 부동 소수점 수에 대한 유리
      한 근사를 찾는 데 유용합니다:

      >>> from fractions import Fraction
      >>> Fraction('3.1415926535897932').limit_denominator(1000)
      Fraction(355, 113)

      또는 float로 표현된 유리수를 복구할 때 유용합니다:

      >>> from math import pi, cos
      >>> Fraction(cos(pi/3))
      Fraction(4503599627370497, 9007199254740992)
      >>> Fraction(cos(pi/3)).limit_denominator()
      Fraction(1, 2)
      >>> Fraction(1.1).limit_denominator()
      Fraction(11, 10)

   __floor__()

      가장 큰 "int" "<= self"를 반환합니다. 이 메서드는 "math.floor()"
      함수를 통해 액세스할 수도 있습니다:

      >>> from math import floor
      >>> floor(Fraction(355, 113))
      3

   __ceil__()

      가장 작은 "int" ">= self"를 반환합니다. 이 메서드는
      "math.ceil()" 함수를 통해 액세스할 수도 있습니다.

   __round__()
   __round__(ndigits)

      첫 번째 버전은 "self"에 가장 가까운 "int"를 반환하는데, 절반은
      짝수로 자리 올림 합니다. 두 번째 버전은 "self"를 가장 가까운
      "Fraction(1, 10**ndigits)"의 배수로 자리 올림 하는데 ("ndigits"
      가 음수면 논리적으로), 역시 짝수로 자리 올림 합니다. 이 메서드는
      "round()" 함수를 통해 액세스할 수도 있습니다.

   __format__(format_spec, /)

      Provides support for formatting of "Fraction" instances via the
      "str.format()" method, the "format()" built-in function, or
      Formatted string literals.

      If the "format_spec" format specification string does not end
      with one of the presentation types "'e'", "'E'", "'f'", "'F'",
      "'g'", "'G'" or "'%'" then formatting follows the general rules
      for fill, alignment, sign handling, minimum width, and grouping
      as described in the format specification mini-language. The
      "alternate form" flag "'#'" is supported: if present, it forces
      the output string to always include an explicit denominator,
      even when the value being formatted is an exact integer. The
      zero-fill flag "'0'" is not supported.

      If the "format_spec" format specification string ends with one
      of the presentation types "'e'", "'E'", "'f'", "'F'", "'g'",
      "'G'" or "'%'" then formatting follows the rules outlined for
      the "float" type in the 포맷 명세 미니 언어 section.

      Here are some examples:

         >>> from fractions import Fraction
         >>> format(Fraction(103993, 33102), '_')
         '103_993/33_102'
         >>> format(Fraction(1, 7), '.^+10')
         '...+1/7...'
         >>> format(Fraction(3, 1), '')
         '3'
         >>> format(Fraction(3, 1), '#')
         '3/1'
         >>> format(Fraction(1, 7), '.40g')
         '0.1428571428571428571428571428571428571429'
         >>> format(Fraction('1234567.855'), '_.2f')
         '1_234_567.86'
         >>> f"{Fraction(355, 113):*>20.6e}"
         '********3.141593e+00'
         >>> old_price, new_price = 499, 672
         >>> "{:.2%} price increase".format(Fraction(new_price, old_price) - 1)
         '34.67% price increase'

더 보기:

  모듈 "numbers"
     숫자 계층을 구성하는 추상 베이스 클래스.
