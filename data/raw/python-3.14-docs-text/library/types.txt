"types" --- 동적 형 생성과 내장형 이름
**************************************

**소스 코드:** Lib/types.py

======================================================================

이 모듈은 새로운 형의 동적 생성을 지원하는 유틸리티 함수를 정의합니다.

표준 파이썬 인터프리터가 사용하지만, "int"나 "str"처럼 내장으로 노출되
지 않는 일부 객체 형의 이름도 정의합니다.

마지막으로, 내장되기에 충분히 기본적이지 않은 몇 가지 추가 형 관련 유
틸리티 클래스와 함수를 제공합니다.


동적 형 생성
============

types.new_class(name, bases=(), kwds=None, exec_body=None)

   적절한 메타 클래스를 사용하여 동적으로 클래스 객체를 만듭니다.

   처음 세 개의 인자는 클래스 정의 헤더를 구성하는 요소들입니다: 클래
   스 이름, 베이스 클래스 (순서대로), 키워드 인자 (가령 "metaclass").

   *exec_body* 인자는 새로 만들어진 클래스 이름 공간을 채우는 데 사용
   되는 콜백입니다. 클래스 이름 공간을 유일한 인자로 받아들이고 클래스
   내용으로 이름 공간을 직접 갱신해야 합니다. 콜백이 제공되지 않으면,
   "lambda ns: None"를 전달하는 것과 같은 효과가 있습니다.

   Added in version 3.3.

types.prepare_class(name, bases=(), kwds=None)

   적절한 메타 클래스를 계산하고 클래스 이름 공간을 만듭니다.

   인자는 클래스 정의 헤더를 구성하는 요소들입니다: 클래스 이름, 베이
   스 클래스 (순서대로) 및 키워드 인자 (가령 "metaclass").

   반환 값은 3-튜플입니다: "metaclass, namespace, kwds"

   *metaclass*는 적절한 메타 클래스이고, *namespace*는 준비된 클래스
   이름 공간이며 *kwds*는 "'metaclass'" 항목이 제거된 전달된 *kwds* 인
   자의 갱신된 사본입니다. *kwds* 인자가 전달되지 않으면, 빈 딕셔너리
   가 됩니다.

   Added in version 3.3.

   버전 3.6에서 변경: 반환된 튜플의 "namespace" 요소의 기본값이 변경되
   었습니다. 이제 메타 클래스에 "__prepare__" 메서드가 없으면 삽입 순
   서 보존 맵핑이 사용됩니다.

더 보기:

  메타 클래스
     이 함수들이 지원하는 클래스 생성 절차에 대한 자세한 내용

  **PEP 3115** - 파이썬 3000의 메타 클래스
     "__prepare__" 이름 공간 훅을 도입했습니다

types.resolve_bases(bases)

   **PEP 560**의 명세에 따라 MRO 항목을 동적으로 결정합니다.

   이 함수는 "type"의 인스턴스가 아닌 항목들을 *bases*에서 찾고,
   "__mro_entries__()" 메서드가 있는 각 객체가 이 메서드 호출의 언 패
   킹 된 결과로 대체된 튜플을 반환합니다. *bases* 항목이 "type"의 인스
   턴스이거나, "__mro_entries__()" 메서드가 없으면, 반환 튜플에 변경되
   지 않은 상태로 포함됩니다.

   Added in version 3.7.

types.get_original_bases(cls, /)

   Return the tuple of objects originally given as the bases of *cls*
   before the "__mro_entries__()" method has been called on any bases
   (following the mechanisms laid out in **PEP 560**). This is useful
   for introspecting Generics.

   For classes that have an "__orig_bases__" attribute, this function
   returns the value of "cls.__orig_bases__". For classes without the
   "__orig_bases__" attribute, "cls.__bases__" is returned.

   예제:

      from typing import TypeVar, Generic, NamedTuple, TypedDict

      T = TypeVar("T")
      class Foo(Generic[T]): ...
      class Bar(Foo[int], float): ...
      class Baz(list[str]): ...
      Eggs = NamedTuple("Eggs", [("a", int), ("b", str)])
      Spam = TypedDict("Spam", {"a": int, "b": str})

      assert Bar.__bases__ == (Foo, float)
      assert get_original_bases(Bar) == (Foo[int], float)

      assert Baz.__bases__ == (list,)
      assert get_original_bases(Baz) == (list[str],)

      assert Eggs.__bases__ == (tuple,)
      assert get_original_bases(Eggs) == (NamedTuple,)

      assert Spam.__bases__ == (dict,)
      assert get_original_bases(Spam) == (TypedDict,)

      assert int.__bases__ == (object,)
      assert get_original_bases(int) == (object,)

   Added in version 3.12.

더 보기: **PEP 560** - typing 모듈과 제네릭 형에 대한 코어 지원


표준 인터프리터 형
==================

이 모듈은 파이썬 인터프리터를 구현하는 데 필요한 많은 형의 이름을 제공
합니다. "listiterator" 형과 같이 처리 중에 우연히 발생하는 일부 형은
의도적으로 포함하지 않았습니다.

이러한 이름의 일반적인 용도는 "isinstance()"나 "issubclass()" 검사입니
다.

이러한 형을 인스턴스 화할 때는 서명이 파이썬 버전마다 다를 수 있음에
유의해야 합니다.

다음과 같은 형들에 대해 표준 이름이 정의됩니다:

types.NoneType

   The type of "None".

   Added in version 3.10.

types.FunctionType
types.LambdaType

   사용자 정의 함수와 "lambda" 표현식이 만든 함수의 형.

   인자 "code"로 감사 이벤트 "function.__new__"를 발생시킵니다.

   감사 이벤트는 함수 객체의 직접 인스턴스 화에서만 발생하며, 일반 컴
   파일에서는 발생하지 않습니다.

types.GeneratorType

   제너레이터 함수가 만든, *제너레이터*-이터레이터 객체의 형.

types.CoroutineType

   "async def" 함수가 만든 *코루틴* 객체의 형.

   Added in version 3.5.

types.AsyncGeneratorType

   비동기 제너레이터 함수가 만든, *비동기 제너레이터*-이터레이터 객체
   의 형.

   Added in version 3.6.

class types.CodeType(**kwargs)

   "compile()"이 반환하는 것과 같은 코드 객체의 형.

   인자 "code", "filename", "name", "argcount", "posonlyargcount",
   "kwonlyargcount", "nlocals", "stacksize", "flags"로 감사 이벤트
   "code.__new__"를 발생시킵니다.

   감사된 인자는 초기화자가 요구하는 이름이나 위치와 일치하지 않을 수
   있음에 유의하십시오. 감사 이벤트는 코드 객체의 직접 인스턴스 화에서
   만 발생하며, 일반 컴파일에서는 발생하지 않습니다.

types.CellType

   셀 객체의 형: 이러한 객체는 함수의 *클로저 변수*에 대한 컨테이너로
   사용됩니다.

   Added in version 3.8.

types.MethodType

   사용자 정의 클래스 인스턴스의 메서드 형.

types.BuiltinFunctionType
types.BuiltinMethodType

   "len()"이나 "sys.exit()" 와 같은 내장 함수와 내장 클래스의 메서드의
   형. (여기서, "내장"이라는 용어는 "C로 작성된"을 의미합니다.)

types.WrapperDescriptorType

   "object.__init__()"나 "object.__lt__()"와 같은, 일부 내장 데이터형
   과 베이스 클래스의 메서드의 형.

   Added in version 3.7.

types.MethodWrapperType

   일부 내장 데이터형과 베이스 클래스의 *연결된(bound)* 메서드의 형.
   예를 들어 "object().__str__"의 형입니다.

   Added in version 3.7.

types.NotImplementedType

   The type of "NotImplemented".

   Added in version 3.10.

types.MethodDescriptorType

   "str.join()"과 같은 일부 내장 데이터형의 메서드의 형.

   Added in version 3.7.

types.ClassMethodDescriptorType

   "dict.__dict__['fromkeys']"와 같은 일부 내장 데이터형의 *연결되지
   않은(unbound)* 클래스 메서드의 형.

   Added in version 3.7.

class types.ModuleType(name, doc=None)

   *모듈*의 형. 생성자는 만들 모듈의 이름과 선택적으로 *독스트링*을 취
   합니다.

   더 보기:

     Documentation on module objects
        Provides details on the special attributes that can be found
        on instances of "ModuleType".

     "importlib.util.module_from_spec()"
        Modules created using the "ModuleType" constructor are created
        with many of their special attributes unset or set to default
        values. "module_from_spec()" provides a more robust way of
        creating "ModuleType" instances which ensures the various
        attributes are set appropriately.

types.EllipsisType

   The type of "Ellipsis".

   Added in version 3.10.

class types.GenericAlias(t_origin, t_args)

   "list[int]"와 같은 매개 변수화된 제네릭의 형입니다.

   "t_origin"은 "list", "tuple" 또는 "dict"와 같이 매개 변수화되지 않
   은 제네릭 클래스여야 합니다. "t_args"는 "t_origin"을 매개 변수화하
   는 형의 "tuple"(길이 1일 수 있습니다)이어야 합니다:

      >>> from types import GenericAlias

      >>> list[int] == GenericAlias(list, (int,))
      True
      >>> dict[str, int] == GenericAlias(dict, (str, int))
      True

   Added in version 3.9.

   버전 3.9.2에서 변경: 이 형은 이제 서브 클래싱 할 수 있습니다.

   더 보기:

     Generic Alias Types
        In-depth documentation on instances of "types.GenericAlias"

     **PEP 585** - Type Hinting Generics In Standard Collections
        Introducing the "types.GenericAlias" class

class types.UnionType

   The type of union type expressions.

   Added in version 3.10.

   버전 3.14에서 변경: This is now an alias for "typing.Union".

class types.TracebackType(tb_next, tb_frame, tb_lasti, tb_lineno)

   "sys.exception().__traceback__"에서 발견되는 것과 같은 트레이스백
   객체의 형.

   사용 가능한 어트리뷰트와 연산에 대한 세부 사항 및 동적으로 트레이스
   백을 만드는 것에 대한 지침은 언어 레퍼런스를 참조하십시오.

types.FrameType

   "tb"가 트레이스백 객체일 때 "tb.tb_frame"에서 발견되는 것과 같은 프
   레임 객체의 형.

types.GetSetDescriptorType

   "FrameType.f_locals"나 "array.array.typecode"와 같은, "PyGetSetDef"
   가 있는 확장 모듈에서 정의된 객체의 형. 이 형은 객체 어트리뷰트에
   대한 디스크립터로 사용됩니다. "property" 형과 같은 목적을 갖지만,
   확장 모듈에 정의된 클래스에 사용됩니다.

types.MemberDescriptorType

   "datetime.timedelta.days"와 같은, "PyMemberDef"가 있는 확장 모듈에
   서 정의된 객체의 형. 이 형은 표준 변환 함수를 사용하는 간단한 C 데
   이터 멤버의 디스크립터로 사용됩니다; "property" 형과 같은 목적을 갖
   지만, 확장 모듈에 정의된 클래스를 위한 것입니다.

   In addition, when a class is defined with a "__slots__" attribute,
   then for each slot, an instance of "MemberDescriptorType" will be
   added as an attribute on the class. This allows the slot to appear
   in the class's "__dict__".

   파이썬의 다른 구현에서, 이 형은 "GetSetDescriptorType"과 같을 수 있
   습니다.

class types.MappingProxyType(mapping)

   매핑의 읽기 전용 프락시. 매핑 항목에 대한 동적 뷰를 제공하는데, 매
   핑이 변경될 때 뷰가 이러한 변경 사항을 반영함을 의미합니다.

   Added in version 3.3.

   버전 3.9에서 변경: **PEP 584**의 새 병합 ("|") 연산자를 지원하도록
   갱신되었습니다. 단순히 하부 매핑에 위임합니다.

   key in proxy

      하부 매핑에 키 *key*가 있으면 "True"를, 그렇지 않으면 "False"를
      반환합니다.

   proxy[key]

      키 *key*를 사용하여 하부 매핑의 항목을 반환합니다. *key*가 하부
      매핑에 없으면 "KeyError"를 발생시킵니다.

   iter(proxy)

      하부 매핑의 키에 대한 이터레이터를 반환합니다. 이것은
      "iter(proxy.keys())"의 줄임 표현입니다.

   len(proxy)

      하부 매핑의 항목 수를 반환합니다.

   copy()

      하부 매핑의 얕은 사본을 반환합니다.

   get(key[, default])

      *key*가 하부 매핑에 있으면 *key*의 값을, 그렇지 않으면 *default*
      를 반환합니다. *default*를 지정하지 않으면, 기본적으로 "None"으
      로 설정되므로, 이 메서드는 절대 "KeyError"를 발생시키지 않습니다
      .

   items()

      하부 매핑의 항목(items)("(key, value)" 쌍)의 새 뷰를 반환합니다.

   keys()

      하부 매핑의 키(keys)의 새로운 뷰를 반환합니다.

   values()

      하부 매핑의 값(values)의 새 뷰를 반환합니다.

   reversed(proxy)

      하부 매핑의 키(keys)에 대한 역 이터레이터를 반환합니다.

      Added in version 3.9.

   hash(proxy)

      하부 매핑의 해시를 반환합니다.

      Added in version 3.12.

class types.CapsuleType

   The type of capsule objects.

   Added in version 3.13.


추가 유틸리티 클래스와 함수
===========================

class types.SimpleNamespace

   이름 공간에 대한 어트리뷰트 액세스와 의미 있는 repr을 제공하는 간단
   한 "object" 서브 클래스.

   Unlike "object", with "SimpleNamespace" you can add and remove
   attributes.

   "SimpleNamespace" objects may be initialized in the same way as
   "dict": either with keyword arguments, with a single positional
   argument, or with both. When initialized with keyword arguments,
   those are directly added to the underlying namespace.
   Alternatively, when initialized with a positional argument, the
   underlying namespace will be updated with key-value pairs from that
   argument (either a mapping object or an *iterable* object producing
   key-value pairs). All such keys must be strings.

   형은 다음 코드와 대략 동등합니다:

      class SimpleNamespace:
          def __init__(self, mapping_or_iterable=(), /, **kwargs):
              self.__dict__.update(mapping_or_iterable)
              self.__dict__.update(kwargs)

          def __repr__(self):
              items = (f"{k}={v!r}" for k, v in self.__dict__.items())
              return "{}({})".format(type(self).__name__, ", ".join(items))

          def __eq__(self, other):
              if isinstance(self, SimpleNamespace) and isinstance(other, SimpleNamespace):
                 return self.__dict__ == other.__dict__
              return NotImplemented

   "SimpleNamespace"는 "class NS: pass"의 대체품으로 유용할 수 있습니
   다. 하지만, 구조화된 레코드형에는 "namedtuple()"을 대신 사용하십시
   오.

   "SimpleNamespace" objects are supported by "copy.replace()".

   Added in version 3.3.

   버전 3.9에서 변경: repr의 어트리뷰트 순서가 알파벳순에서 삽입 순으
   로 변경되었습니다 ("dict"처럼).

   버전 3.13에서 변경: Added support for an optional positional
   argument.

types.DynamicClassAttribute(fget=None, fset=None, fdel=None, doc=None)

   클래스의 어트리뷰트 액세스를 __getattr__ 로 보냅니다.

   디스크립터이며, 인스턴스와 클래스를 통해 액세스할 때 다르게 작동하
   는 어트리뷰트를 정의하는 데 사용됩니다. 인스턴스 액세스는 정상적으
   로 유지되지만, 클래스를 통한 어트리뷰트 액세스는 클래스의
   __getattr__ 메서드로 보냅니다; 이는 AttributeError를 발생 시켜 수행
   됩니다.

   이를 통해 인스턴스에서 활성화된 프로퍼티를 가짐과 동시에, 클래스에
   서 같은 이름을 가진 가상 어트리뷰트를 가질 수 있습니다 (예제는
   "enum.Enum"을 참조하십시오).

   Added in version 3.4.


코루틴 유틸리티 함수
====================

types.coroutine(gen_func)

   이 함수는 *제너레이터* 함수를 제너레이터 기반 코루틴을 반환하는 *코
   루틴 함수*로 변환합니다. 제너레이터 기반 코루틴은 여전히 *제너레이
   터 이터레이터*이지만, *코루틴* 객체로도 간주하며 *어웨이터블*입니다
   . 그러나, 반드시 "__await__()" 메서드를 구현할 필요는 없습니다.

   *gen_func*가 제너레이터 함수면 제자리(in-place)에서 수정됩니다.

   *gen_func*가 제너레이터 함수가 아니면, 래핑 됩니다.
   "collections.abc.Generator"의 인스턴스를 반환하면, 인스턴스는 *어웨
   이터블* 프락시 객체로 래핑 됩니다. 다른 모든 형의 객체는 그대로 반
   환됩니다.

   Added in version 3.5.
