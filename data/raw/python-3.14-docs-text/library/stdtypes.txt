내장형
******

다음 섹션에서는 인터프리터에 내장된 표준형에 관해 설명합니다.

기본 내장 유형은 숫자, 시퀀스, 매핑, 클래스, 인스턴스 및 예외입니다.

일부 컬렉션 클래스는 가변입니다. 제자리에서 멤버를 추가, 삭제 또는 재
배치하고 특정 항목을 반환하지 않는 메서드는 컬렉션 인스턴스 자체를 반
환하지 않고 "None" 을 반환합니다.

일부 연산들은 여러 객체 형에서 지원됩니다; 특히 사실상 모든 객체를 동
등 비교하고, 논리값을 검사하고, ("repr()" 함수 또는 약간 다른 "str()"
함수를 사용해서) 문자열로 변환할 수 있습니다. 두 번째 함수는 "print()"
함수로 객체를 쓸 때 묵시적으로 사용됩니다.


논리값 검사
===========

모든 객체는 논리값을 검사할 수 있는데, "if" 또는 "while" 조건 또는 다
음에 나오는 논리 연산의 피연산자로 사용될 수 있도록 합니다.

By default, an object is considered true unless its class defines
either a "__bool__()" method that returns "False" or a "__len__()"
method that returns zero, when called with the object. [1] If one of
the methods raises an exception when called, the exception is
propagated and the object does not have a truth value (for example,
"NotImplemented"). Here are most of the built-in objects considered
false:

* constants defined to be false: "None" and "False"

* 모든 숫자 형들의 영: "0", "0.0", "0j", "Decimal(0)", "Fraction(0,
  1)"

* 빈 시퀀스와 컬렉션: "''", "()", "[]", "{}", "set()", "range(0)"

논리값을 돌려주는 연산과 내장 함수는 달리 명시하지 않는 한 항상 거짓의
경우 "0" 이나 "False" 를, 참이면 "1" 이나 "True" 를 돌려줍니다. (중요
한 예외: 논리 연산 "or" 와 "and" 는 항상 피연산자 중 하나를 돌려줍니다
.)


논리 연산 --- "and", "or", "not"
================================

이것들은 우선순위에 따라 오름차순으로 정렬된 논리 연산들입니다:

+---------------+-----------------------------------+---------+
| 연산          | 결과                              | 노트    |
|===============|===================================|=========|
| "x or y"      | if *x* is true, then *x*, else    | (1)     |
|               | *y*                               |         |
+---------------+-----------------------------------+---------+
| "x and y"     | *x*가 거짓이면 *x*, 그렇지 않으면 | (2)     |
|               | *y*                               |         |
+---------------+-----------------------------------+---------+
| "not x"       | *x* 가 거짓이면 "True", 그렇지 않 | (3)     |
|               | 으면 "False"                      |         |
+---------------+-----------------------------------+---------+

노트:

1. 이것은 단락-회로 연산자이므로 첫 번째 인자가 거짓일 때만 두 번째의
   값을 구합니다.

2. 이것은 단락-회로 연산자이므로 첫 번째 인자가 참일 때만 두 번째의 값
   을 구합니다.

3. "not" 은 비논리 연산자들보다 낮은 우선순위를 갖습니다. 그래서, "not
   a == b" 는 "not (a == b)" 로 해석되고, "a == not b" 는 문법 오류입
   니다.


비교
====

파이썬에는 8가지 비교 연산이 있습니다. 이들 모두는 같은 우선순위를 가
집니다 (논리 연산보다는 높습니다). 비교는 임의로 연결될 수 있습니다;
예를 들어 "x < y <= z" 는 *y* 의 값을 한 번만 구한다는 점을 제외하고는
"x < y and y <= z" 와 동등합니다 (하지만 두 경우 모두 "x < y" 가 거짓
으로 밝혀지면 *z* 의 값을 구하지 않습니다).

이 표는 비교 연산을 요약합니다:

+--------------+---------------------------+
| 연산         | 뜻                        |
|==============|===========================|
| "<"          | 엄격히 작다               |
+--------------+---------------------------+
| "<="         | 작거나 같다               |
+--------------+---------------------------+
| ">"          | 엄격히 크다               |
+--------------+---------------------------+
| ">="         | 크거나 같다               |
+--------------+---------------------------+
| "=="         | 같다                      |
+--------------+---------------------------+
| "!="         | 같지 않다                 |
+--------------+---------------------------+
| "is"         | 객체 아이덴티티           |
+--------------+---------------------------+
| "is not"     | 부정된 객체 아이덴티티    |
+--------------+---------------------------+

Unless stated otherwise, objects of different types never compare
equal. The "==" operator is always defined but for some object types
(for example, class objects) is equivalent to "is". The "<", "<=", ">"
and ">=" operators are only defined where they make sense; for
example, they raise a "TypeError" exception when one of the arguments
is a complex number.

Non-identical instances of a class normally compare as non-equal
unless the class defines the "__eq__()" method.

Instances of a class cannot be ordered with respect to other instances
of the same class, or other types of object, unless the class defines
enough of the methods "__lt__()", "__le__()", "__gt__()", and
"__ge__()" (in general, "__lt__()" and "__eq__()" are sufficient, if
you want the conventional meanings of the comparison operators).

"is" 와 "is not" 연산자의 동작은 사용자 정의할 수 없습니다; 또한 임의
의 두 객체에 적용할 수 있으며 예외를 발생시키지 않습니다.

Two more operations with the same syntactic priority, "in" and "not
in", are supported by types that are *iterable* or implement the
"__contains__()" method.


숫자 형 --- "int", "float", "complex"
=====================================

There are three distinct numeric types: *integers*, *floating-point
numbers*, and *complex numbers*.  In addition, Booleans are a subtype
of integers.  Integers have unlimited precision.  Floating-point
numbers are usually implemented using double in C; information about
the precision and internal representation of floating-point numbers
for the machine on which your program is running is available in
"sys.float_info".  Complex numbers have a real and imaginary part,
which are each a floating-point number.  To extract these parts from a
complex number *z*, use "z.real" and "z.imag". (The standard library
includes the additional numeric types "fractions.Fraction", for
rationals, and "decimal.Decimal", for floating-point numbers with
user-definable precision.)

Numbers are created by numeric literals or as the result of built-in
functions and operators.  Unadorned integer literals (including hex,
octal and binary numbers) yield integers.  Numeric literals containing
a decimal point or an exponent sign yield floating-point numbers.
Appending "'j'" or "'J'" to a numeric literal yields an imaginary
number (a complex number with a zero real part) which you can add to
an integer or float to get a complex number with real and imaginary
parts.

생성자 "int()", "float()", "complex()"를 특정 형의 숫자를 만드는데 사
용할 수 있습니다.

Python fully supports mixed arithmetic: when a binary arithmetic
operator has operands of different numeric types, the operand with the
"narrower" type is widened to that of the other, where integer is
narrower than floating point. Arithmetic with complex and real
operands is defined by the usual mathematical formula, for example:

   x + complex(u, v) = complex(x + u, v)
   x * complex(u, v) = complex(x * u, x * v)

A comparison between numbers of different types behaves as though the
exact values of those numbers were being compared. [2]

(복소수를 제외한) 모든 숫자 형은 다음과 같은 연산들을 지원합니다 (연산
의 우선순위는 연산자 우선순위를 참조하십시오):

+-----------------------+-----------------------------------+-----------+----------------------+
| 연산                  | 결과                              | 노트      | 전체 문서            |
|=======================|===================================|===========|======================|
| "x + y"               | *x* 와 *y* 의 합                  |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "x - y"               | *x* 와 *y* 의 차                  |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "x * y"               | *x* 와 *y* 의 곱                  |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "x / y"               | *x* 와 *y* 의 몫                  |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "x // y"              | *x* 와 *y* 의 정수로 내림한 몫    | (1)(2)    |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "x % y"               | "x / y" 의 나머지                 | (2)       |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "-x"                  | 음의 *x*                          |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "+x"                  | *x* 그대로                        |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "abs(x)"              | *x* 의 절댓값 또는 크기           |           | "abs()"              |
+-----------------------+-----------------------------------+-----------+----------------------+
| "int(x)"              | 정수로 변환된 *x*                 | (3)(6)    | "int()"              |
+-----------------------+-----------------------------------+-----------+----------------------+
| "float(x)"            | 실수로 변환된 *x*                 | (4)(6)    | "float()"            |
+-----------------------+-----------------------------------+-----------+----------------------+
| "complex(re, im)"     | 실수부 *re* 와 허수부 *im* 으로   | (6)       | "complex()"          |
|                       | 구성된 복소수. *im* 의 기본값은 0 |           |                      |
|                       | 입니 다.                          |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "c.conjugate()"       | 복소수 *c* 의 켤레                |           |                      |
+-----------------------+-----------------------------------+-----------+----------------------+
| "divmod(x, y)"        | 쌍 "(x // y, x % y)"              | (2)       | "divmod()"           |
+-----------------------+-----------------------------------+-----------+----------------------+
| "pow(x, y)"           | *x* 의 *y* 거듭제곱               | (5)       | "pow()"              |
+-----------------------+-----------------------------------+-----------+----------------------+
| "x ** y"              | *x* 의 *y* 거듭제곱               | (5)       |                      |
+-----------------------+-----------------------------------+-----------+----------------------+

노트:

1. Also referred to as integer division.  For operands of type "int",
   the result has type "int".  For operands of type "float", the
   result has type "float".  In general, the result is a whole
   integer, though the result's type is not necessarily "int".  The
   result is always rounded towards minus infinity: "1//2" is "0",
   "(-1)//2" is "-1", "1//(-2)" is "-1", and "(-1)//(-2)" is "0".

2. 복소수에는 사용할 수 없습니다. 적절한 경우 "abs()"를 사용하여 실수
   로 변환하십시오.

3. Conversion from "float" to "int" truncates, discarding the
   fractional part. See functions "math.floor()" and "math.ceil()" for
   alternative conversions.

4. float는 또한 숫자가 아님(NaN)과 양 또는 음의 무한대를 나타내는 문자
   열 "nan"과 접두사 "+" 나 "-" 가 선택적으로 붙을 수 있는 "inf"를 받
   아들입니다.

5. 파이썬은 프로그래밍 언어들에서 흔히 그렇듯이, 있는 것처럼 "pow(0,
   0)" 와 "0 ** 0" 이 "1" 이 되도록 정의합니다.

6. 받아들여지는 숫자 리터럴은 "0" 에서 "9" 까지 또는 모든 동등한 유니
   코드들을 ("Nd" 속성을 가진 코드 포인트들) 포함합니다.

   See the Unicode Standard for a complete list of code points with
   the "Nd" property.

모든 "numbers.Real" 형 ("int" 와 "float") 은 또한 다음과 같은 연산들을
포함합니다:

+----------------------+-----------------------------------------------+
| 연산                 | 결과                                          |
|======================|===============================================|
| "math.trunc(x)"      | *x* 는 "Integral" 로 잘립니다                 |
+----------------------+-----------------------------------------------+
| "round(x[, n])"      | *x* 를 *n* 자리로 반올림하는데, 절반 값은 짝  |
|                      | 수로 반올림합니다. *n* 을 생략하면 기본값은 0 |
|                      | 입니다.                                       |
+----------------------+-----------------------------------------------+
| "math.floor(x)"      | 가장 큰 "Integral" <= *x*                     |
+----------------------+-----------------------------------------------+
| "math.ceil(x)"       | 가장 작은 "Integral" >= *x*                   |
+----------------------+-----------------------------------------------+

추가적인 숫자 연산은 "math"와 "cmath" 모듈을 보십시오.


정수 형에 대한 비트 연산
------------------------

비트 연산은 정수에 대해서만 의미가 있습니다. 비트 연산의 결과는 무한한
부호 비트를 갖는 2의 보수로 수행되는 것처럼 계산됩니다.

이진 비트 연산의 우선순위는 모두 숫자 연산보다 낮고 비교보다 높습니다;
일항 연산 "~" 은 다른 일항 연산들 ("+" 와 "-") 과 같은 우선순위를 가집
니다.

이 표는 비트 연산을 나열하는데, 우선순위에 따라 오름차순으로 정렬되어
있습니다:

+--------------+----------------------------------+------------+
| 연산         | 결과                             | 노트       |
|==============|==================================|============|
| "x | y"      | *x* 와 *y* 의 비트별 *or*        | (4)        |
+--------------+----------------------------------+------------+
| "x ^ y"      | *x* 와 *y* 의 비트별 *배타적 or  | (4)        |
|              | (exclusive or)*                  |            |
+--------------+----------------------------------+------------+
| "x & y"      | *x* 와 *y* 의 비트별 *and*       | (4)        |
+--------------+----------------------------------+------------+
| "x << n"     | *x* 를 *n* 비트만큼 왼쪽으로 시  | (1)(2)     |
|              | 프트                             |            |
+--------------+----------------------------------+------------+
| "x >> n"     | *x* 를 *n* 비트만큼 오른쪽으로   | (1)(3)     |
|              | 시프트                           |            |
+--------------+----------------------------------+------------+
| "~x"         | *x* 의 비트 반전                 |            |
+--------------+----------------------------------+------------+

노트:

1. 음의 시프트 수는 허락되지 않고 "ValueError" 를 일으킵니다.

2. *n* 비트만큼의 왼쪽 시프트는 "pow(2, n)" 를 곱하는 것과 동등합니다.

3. *n* 비트만큼 오른쪽으로 시프트 하는 것은 "pow(2, n)" 로 정수 나눗셈
   (floor division)하는 것과 동등합니다.

4. 무한한 부호 비트가 있는 것과 같은 결과를 얻으려면, 유한한 2의 보수
   표현으로 적어도 하나의 추가적인 부호 확장 비트를 사용하여 ("1 +
   max(x.bit_length(), y.bit_length())" 이상의 작업 비트 폭) 이러한 계
   산을 수행하는 것으로 충분합니다.


정수 형에 대한 추가 메서드
--------------------------

int 형은 "numbers.Integral" *추상 베이스 클래스* 를 구현합니다. 또한,
몇 가지 메서드를 더 제공합니다:

int.bit_length()

   부호와 선행 0을 제외하고, 이진수로 정수를 나타내는 데 필요한 비트
   수를 돌려줍니다:

      >>> n = -37
      >>> bin(n)
      '-0b100101'
      >>> n.bit_length()
      6

   좀 더 정확하게 말하자면, "x" 가 0이 아니면, "x.bit_length()" 는
   "2**(k-1) <= abs(x) < 2**k" 를 만족하는 유일한 양의 정수 "k" 입니다
   . 동등하게, "abs(x)" 가 정확하게 반올림된 로그값을 가질 만큼 아주
   작으면, "k = 1 + int(log(abs(x), 2))" 가 됩니다. "x" 가 0이면,
   "x.bit_length()" 는 "0" 을 돌려줍니다.

   다음 코드와 동등합니다:

      def bit_length(self):
          s = bin(self)       # binary representation:  bin(-37) --> '-0b100101'
          s = s.lstrip('-0b') # remove leading zeros and minus sign
          return len(s)       # len('100101') --> 6

   Added in version 3.1.

int.bit_count()

   Return the number of ones in the binary representation of the
   absolute value of the integer. This is also known as the population
   count. Example:

      >>> n = 19
      >>> bin(n)
      '0b10011'
      >>> n.bit_count()
      3
      >>> (-n).bit_count()
      3

   다음 코드와 동등합니다:

      def bit_count(self):
          return bin(self).count("1")

   Added in version 3.10.

int.to_bytes(length=1, byteorder='big', *, signed=False)

   정수를 나타내는 바이트의 배열을 돌려줍니다.

   >>> (1024).to_bytes(2, byteorder='big')
   b'\x04\x00'
   >>> (1024).to_bytes(10, byteorder='big')
   b'\x00\x00\x00\x00\x00\x00\x00\x00\x04\x00'
   >>> (-1024).to_bytes(10, byteorder='big', signed=True)
   b'\xff\xff\xff\xff\xff\xff\xff\xff\xfc\x00'
   >>> x = 1000
   >>> x.to_bytes((x.bit_length() + 7) // 8, byteorder='little')
   b'\xe8\x03'

   The integer is represented using *length* bytes, and defaults to 1.
   An "OverflowError" is raised if the integer is not representable
   with the given number of bytes.

   The *byteorder* argument determines the byte order used to
   represent the integer, and defaults to ""big"".  If *byteorder* is
   ""big"", the most significant byte is at the beginning of the byte
   array.  If *byteorder* is ""little"", the most significant byte is
   at the end of the byte array.

   *signed* 인자는 정수를 표현하는데 2의 보수가 사용되는지를 결정합니
   다. *signed* 가 "False" 이고 음의 정수가 주어지면, "OverflowError"
   가 일어납니다. *signed* 의 기본값은 "False" 입니다.

   The default values can be used to conveniently turn an integer into
   a single byte object:

      >>> (65).to_bytes()
      b'A'

   However, when using the default arguments, don't try to convert a
   value greater than 255 or you'll get an "OverflowError".

   다음 코드와 동등합니다:

      def to_bytes(n, length=1, byteorder='big', signed=False):
          if byteorder == 'little':
              order = range(length)
          elif byteorder == 'big':
              order = reversed(range(length))
          else:
              raise ValueError("byteorder must be either 'little' or 'big'")

          return bytes((n >> i*8) & 0xff for i in order)

   Added in version 3.2.

   버전 3.11에서 변경: Added default argument values for "length" and
   "byteorder".

classmethod int.from_bytes(bytes, byteorder='big', *, signed=False)

   주어진 바이트 배열로 표현되는 정수를 돌려줍니다.

   >>> int.from_bytes(b'\x00\x10', byteorder='big')
   16
   >>> int.from_bytes(b'\x00\x10', byteorder='little')
   4096
   >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=True)
   -1024
   >>> int.from_bytes(b'\xfc\x00', byteorder='big', signed=False)
   64512
   >>> int.from_bytes([255, 0, 0], byteorder='big')
   16711680

   인자 *bytes* 는 *바이트열류 객체* 이거나 바이트를 생성하는 이터러블
   이어야 합니다.

   The *byteorder* argument determines the byte order used to
   represent the integer, and defaults to ""big"".  If *byteorder* is
   ""big"", the most significant byte is at the beginning of the byte
   array.  If *byteorder* is ""little"", the most significant byte is
   at the end of the byte array.  To request the native byte order of
   the host system, use "sys.byteorder" as the byte order value.

   *signed* 인자는 정수를 표현하는데 2의 보수가 사용되는지를 나타냅니
   다.

   다음 코드와 동등합니다:

      def from_bytes(bytes, byteorder='big', signed=False):
          if byteorder == 'little':
              little_ordered = list(bytes)
          elif byteorder == 'big':
              little_ordered = list(reversed(bytes))
          else:
              raise ValueError("byteorder must be either 'little' or 'big'")

          n = sum(b << i*8 for i, b in enumerate(little_ordered))
          if signed and little_ordered and (little_ordered[-1] & 0x80):
              n -= 1 << 8*len(little_ordered)

          return n

   Added in version 3.2.

   버전 3.11에서 변경: Added default argument value for "byteorder".

int.as_integer_ratio()

   Return a pair of integers whose ratio is equal to the original
   integer and has a positive denominator.  The integer ratio of
   integers (whole numbers) is always the integer as the numerator and
   "1" as the denominator.

   Added in version 3.8.

int.is_integer()

   Returns "True". Exists for duck type compatibility with
   "float.is_integer()".

   Added in version 3.12.


실수에 대한 추가 메서드
-----------------------

float 형은 "numbers.Real" *추상 베이스 클래스* 를 구현합니다. 또한,
float는 다음과 같은 추가 메서드를 갖습니다.

classmethod float.from_number(x)

   Class method to return a floating-point number constructed from a
   number *x*.

   If the argument is an integer or a floating-point number, a
   floating-point number with the same value (within Python's
   floating-point precision) is returned.  If the argument is outside
   the range of a Python float, an "OverflowError" will be raised.

   For a general Python object "x", "float.from_number(x)" delegates
   to "x.__float__()". If "__float__()" is not defined then it falls
   back to "__index__()".

   Added in version 3.14.

float.as_integer_ratio()

   Return a pair of integers whose ratio is exactly equal to the
   original float. The ratio is in lowest terms and has a positive
   denominator.  Raises "OverflowError" on infinities and a
   "ValueError" on NaNs.

float.is_integer()

   float 인스턴스가 정숫값을 가진 유한이면 "True" 를, 그렇지 않으면
   "False" 를 돌려줍니다:

      >>> (-2.0).is_integer()
      True
      >>> (3.2).is_integer()
      False

두 가지 메서드가 16진수 문자열과의 변환을 지원합니다. 파이썬의 float는
내부적으로 이진수로 저장되기 때문에 float를 *십진수* 문자열로 또는 그
반대로 변환하는 것은 보통 반올림 오류를 수반합니다. 이에 반해, 16진수
문자열은 부동 소수점 숫자의 정확한 표현과 지정을 가능하게 합니다. 이것
은 디버깅 및 수치 작업에 유용할 수 있습니다.

float.hex()

   부동 소수점의 16진수 문자열 표현을 돌려줍니다. 유한 부동 소수점의
   경우, 이 표현은 항상 선행하는 "0x" 와 후행하는 "p" 와 지수를 포함합
   니다.

classmethod float.fromhex(s)

   16진수 문자열 *s* 로 표현되는 float를 돌려주는 클래스 메서드. 문자
   열 *s* 는 앞뒤 공백을 가질 수 있습니다.

"float.hex()" 는 인스턴스 메서드인 반면, "float.fromhex()" 는 클래스
메서드임에 주의하세요.

16진수 문자열은 다음과 같은 형식을 취합니다:

   [sign] ['0x'] integer ['.' fraction] ['p' exponent]

선택적인 "sign" 은 "+" 나 "-" 가 될 수 있고, "integer" 와 "fraction"
은 16진수 문자열이고, "exponent" 는 선택적인 선행 부호가 붙을 수 있는
십진수입니다. 대소 문자는 중요하지 않으며 integer 나 fraction 중 어느
하나에 적어도 하나의 16진수가 있어야 합니다. 이 문법은 C99 표준의
6.4.4.2 절에 지정된 문법과 비슷하며, 자바 1.5 이상에서 사용되는 문법과
도 비슷합니다. 특히, "float.hex()" 의 출력은 C 또는 자바 코드에서 16진
수의 부동 소수점 리터럴로 사용할 수 있으며, C의 "%a" 포맷 문자나 자바
의 "Double.toHexString" 가 만들어내는 16진수 문자열은
"float.fromhex()" 가 받아들입니다.

지수는 16진수가 아닌 십진수로 쓰이고, 숫자에 곱해지는 2의 거듭제곱을
제공한다는 점에 유의하십시오. 예를 들어, 16진수 문자열 "0x3.a7p10" 는
부동 소수점 숫자 "(3 + 10./16 + 7./16**2) * 2.0**10" 또는 "3740.0" 를
나타냅니다:

   >>> float.fromhex('0x3.a7p10')
   3740.0

"3740.0" 에 역변환을 적용하면 같은 숫자를 나타내는 다른 16진수 문자열
을 얻을 수 있습니다:

   >>> float.hex(3740.0)
   '0x1.d380000000000p+11'


Additional Methods on Complex
-----------------------------

The "complex" type implements the "numbers.Complex" *abstract base
class*. "complex" also has the following additional methods.

classmethod complex.from_number(x)

   Class method to convert a number to a complex number.

   For a general Python object "x", "complex.from_number(x)" delegates
   to "x.__complex__()".  If "__complex__()" is not defined then it
   falls back to "__float__()".  If "__float__()" is not defined then
   it falls back to "__index__()".

   Added in version 3.14.


숫자 형의 해싱
--------------

For numbers "x" and "y", possibly of different types, it's a
requirement that "hash(x) == hash(y)" whenever "x == y" (see the
"__hash__()" method documentation for more details).  For ease of
implementation and efficiency across a variety of numeric types
(including "int", "float", "decimal.Decimal" and "fractions.Fraction")
Python's hash for numeric types is based on a single mathematical
function that's defined for any rational number, and hence applies to
all instances of "int" and "fractions.Fraction", and all finite
instances of "float" and "decimal.Decimal".  Essentially, this
function is given by reduction modulo "P" for a fixed prime "P".  The
value of "P" is made available to Python as the "modulus" attribute of
"sys.hash_info".

현재, 사용되는 소수는 32-비트 C long을 가진 기계에서는 "P = 2**31 - 1"
이고, 64-비트 C long을 가진 기계에서는 "P = 2**61 - 1" 입니다.

다음은 규칙에 대한 세부 사항입니다:

* "x = m / n" 이 음이 아닌 유리수이고 "n" 이 "P" 로 나뉘지 않는다면,
  "hash(x)" 를 "m * invmod(n, P) % P" 로 정의합니다. 여기서 "invmod(n,
  P)" 는 "n" 의 모듈로 "P" 역수를 줍니다.

* "x = m / n" 이 음이 아닌 유리수이고 "n" 이 "P" 나뉘면 (하지만 "m" 은
  나뉘지 않으면) "n" 은 모듈로 "P" 역수를 가지지 않고 위의 규칙은 적용
  되지 않습니다; 이 경우 "hash(x)" 를 상숫값 "sys.hash_info.inf" 로 정
  의합니다.

* "x = m / n" 이 음의 유리수이면 "hash(x)" 를 "-hash(-x)" 로 정의합니
  다. 얻어진 해시가 "-1" 이면 "-2" 로 바꿉니다.

* The particular values "sys.hash_info.inf" and "-sys.hash_info.inf"
  are used as hash values for positive infinity or negative infinity
  (respectively).

* 복소수("complex") "z" 의 경우, "hash(z.real) + sys.hash_info.imag *
  hash(z.imag)" 를 계산하여 실수부와 허수부의 해시값을 결합하는데,
  "2**sys.hash_info.width" 의 모듈로로 환원해서
  "range(-2**(sys.hash_info.width - 1), 2**(sys.hash_info.width - 1))"
  범위에 들어가도록 만듭니다. 다시 한번, 결과가 "-1" 이라면 "-2" 로 바
  꿉니다.

위의 규칙을 명확히 하기 위해, 여기에 유리수, "float", "complex" 의 해
시를 계산하는, 내장 해시와 동등한, 파이썬 코드를 예시합니다:

   import sys, math

   def hash_fraction(m, n):
       """Compute the hash of a rational number m / n.

       Assumes m and n are integers, with n positive.
       Equivalent to hash(fractions.Fraction(m, n)).

       """
       P = sys.hash_info.modulus
       # Remove common factors of P.  (Unnecessary if m and n already coprime.)
       while m % P == n % P == 0:
           m, n = m // P, n // P

       if n % P == 0:
           hash_value = sys.hash_info.inf
       else:
           # Fermat's Little Theorem: pow(n, P-1, P) is 1, so
           # pow(n, P-2, P) gives the inverse of n modulo P.
           hash_value = (abs(m) % P) * pow(n, P - 2, P) % P
       if m < 0:
           hash_value = -hash_value
       if hash_value == -1:
           hash_value = -2
       return hash_value

   def hash_float(x):
       """Compute the hash of a float x."""

       if math.isnan(x):
           return object.__hash__(x)
       elif math.isinf(x):
           return sys.hash_info.inf if x > 0 else -sys.hash_info.inf
       else:
           return hash_fraction(*x.as_integer_ratio())

   def hash_complex(z):
       """Compute the hash of a complex number z."""

       hash_value = hash_float(z.real) + sys.hash_info.imag * hash_float(z.imag)
       # do a signed reduction modulo 2**sys.hash_info.width
       M = 2**(sys.hash_info.width - 1)
       hash_value = (hash_value & (M - 1)) - (hash_value & M)
       if hash_value == -1:
           hash_value = -2
       return hash_value


Boolean Type - "bool"
=====================

Booleans represent truth values. The "bool" type has exactly two
constant instances: "True" and "False".

The built-in function "bool()"  converts any value to a boolean, if
the value can be interpreted as a truth value (see section 논리값 검사
above).

For logical operations, use the boolean operators "and", "or" and
"not". When applying the bitwise operators "&", "|", "^" to two
booleans, they return a bool equivalent to the logical operations
"and", "or", "xor". However, the logical operators "and", "or" and
"!=" should be preferred over "&", "|" and "^".

버전 3.12부터 폐지됨: The use of the bitwise inversion operator "~" is
deprecated and will raise an error in Python 3.16.

"bool" is a subclass of "int" (see 숫자 형 --- int, float, complex).
In many numeric contexts, "False" and "True" behave like the integers
0 and 1, respectively. However, relying on this is discouraged;
explicitly convert using "int()" instead.


이터레이터 형
=============

파이썬은 컨테이너에 대한 이터레이션 개념을 지원합니다. 이것은 두 개의
메서드를 사용해서 구현됩니다; 이것들은 사용자 정의 클래스가 이터레이션
을 지원할 수 있도록 하는 데 사용됩니다. 아래에서 더 자세히 설명할 시퀀
스는 항상 이터레이션 메서드를 지원합니다.

One method needs to be defined for container objects to provide
*iterable* support:

container.__iter__()

   Return an *iterator* object.  The object is required to support the
   iterator protocol described below.  If a container supports
   different types of iteration, additional methods can be provided to
   specifically request iterators for those iteration types.  (An
   example of an object supporting multiple forms of iteration would
   be a tree structure which supports both breadth-first and depth-
   first traversal.)  This method corresponds to the "tp_iter" slot of
   the type structure for Python objects in the Python/C API.

이터레이터 객체 자체는 다음과 같은 두 가지 메서드를 지원해야 하는데,
둘이 함께 *이터레이터 프로토콜 (iterator protocol)* 를 이룹니다.:

iterator.__iter__()

   Return the *iterator* object itself.  This is required to allow
   both containers and iterators to be used with the "for" and "in"
   statements.  This method corresponds to the "tp_iter" slot of the
   type structure for Python objects in the Python/C API.

iterator.__next__()

   Return the next item from the *iterator*.  If there are no further
   items, raise the "StopIteration" exception.  This method
   corresponds to the "tp_iternext" slot of the type structure for
   Python objects in the Python/C API.

파이썬은 일반적이거나 특정한 시퀀스 형, 딕셔너리, 기타 더 특화된 형태
에 대한 이터레이션을 지원하기 위해 여러 이터레이터 객체를 정의합니다.
이터레이터 프로토콜의 구현을 넘어서 개별적인 형이 중요하지는 않습니다.

일단 이터레이터의 "__next__()" 메서드가 "StopIteration" 를 일으키면,
그 이후의 호출에 대해서도 같이 동작해야 합니다. 이 속성을 따르지 않는
구현은 망가진 것으로 간주합니다.


제너레이터 형
-------------

Python's *generator*s provide a convenient way to implement the
iterator protocol.  If a container object's "__iter__()" method is
implemented as a generator, it will automatically return an iterator
object (technically, a generator object) supplying the "__iter__()"
and "__next__()" methods. More information about generators can be
found in the documentation for the yield expression.


시퀀스 형 --- "list", "tuple", "range"
======================================

세 가지 기본 시퀀스 형이 있습니다: 리스트, 튜플, 범위 객체. 바이너리
데이터 와 텍스트 문자열 의 처리를 위해 추가된 시퀀스 형들은 별도의 섹
션에서 설명합니다.


공통 시퀀스 연산
----------------

다음 표의 연산들은 대부분의 가변과 불변 시퀀스에서 지원됩니다. 사용자
정의 시퀀스에서 이 연산들을 올바르게 구현하기 쉽게 하려고
"collections.abc.Sequence" ABC가 제공됩니다.

이 표는 우선순위에 따라 오름차순으로 시퀀스 연산들을 나열합니다. 표에
서, *s* 와 *t* 는 같은 형의 시퀀스고, *n*, *i*, *j*, *k* 는 정수이고,
*x* 는 *s* 가 요구하는 형과 값 제한을 만족하는 임의의 객체입니다.

"in" 과 "not in" 연산은 비교 연산과 우선순위가 같습니다. "+" (이어 붙
이기)와 "*" (반복) 연산은 대응하는 숫자 연산과 같은 우선순위를 갖습니
다. [3]

+----------------------------+----------------------------------+------------+
| 연산                       | 결과                             | 노트       |
|============================|==================================|============|
| "x in s"                   | *s* 의 항목 중 하나가 *x* 와 같  | (1)        |
|                            | 으면 "True", 그렇지 않으면       |            |
|                            | "False"                          |            |
+----------------------------+----------------------------------+------------+
| "x not in s"               | *s* 의 항목 중 하나가 *x* 와 같  | (1)        |
|                            | 으면 "False", 그렇지 않으면      |            |
|                            | "True"                           |            |
+----------------------------+----------------------------------+------------+
| "s + t"                    | *s* 와 *t* 의 이어 붙이기        | (6)(7)     |
+----------------------------+----------------------------------+------------+
| "s * n" 또는 "n * s"       | *s* 를 그 자신에 *n* 번 더하는   | (2)(7)     |
|                            | 것과 같습니다                    |            |
+----------------------------+----------------------------------+------------+
| "s[i]"                     | *s* 의 *i* 번째 항목, 0에서 시작 | (3)(8)     |
|                            | 합니다                           |            |
+----------------------------+----------------------------------+------------+
| "s[i:j]"                   | *s* 의 *i* 에서 *j* 까지의 슬라  | (3)(4)     |
|                            | 이스                             |            |
+----------------------------+----------------------------------+------------+
| "s[i:j:k]"                 | *s* 의 *i* 에서 *j* 까지 스텝    | (3)(5)     |
|                            | *k* 의 슬라이스                  |            |
+----------------------------+----------------------------------+------------+
| "len(s)"                   | *s* 의 길이                      |            |
+----------------------------+----------------------------------+------------+
| "min(s)"                   | *s* 의 가장 작은 항목            |            |
+----------------------------+----------------------------------+------------+
| "max(s)"                   | *s* 의 가장 큰 항목              |            |
+----------------------------+----------------------------------+------------+

같은 형의 시퀀스는 비교를 지원합니다. 특히, 튜플과 리스트는 대응하는
항목들을 사전적으로 비교합니다. 이것은 같다고 비교되기 위해서는, 모든
항목이 같다고 비교되고, 두 시퀀스의 형과 길이가 같아야 함을 의미합니다
. (자세한 내용은 언어 레퍼런스의 비교를 참조하십시오.)

Forward and reversed iterators over mutable sequences access values
using an index.  That index will continue to march forward (or
backward) even if the underlying sequence is mutated.  The iterator
terminates only when an "IndexError" or a "StopIteration" is
encountered (or when the index drops below zero).

노트:

1. "in" 과 "not in" 연산은 일반적으로 단순한 포함 검사를 위해서만 사용
   되지만, 몇몇 특수한 시퀀스 ("str", "bytes", "bytearray" 같은) 들은
   서브 시퀀스 검사에 사용하기도 합니다:

      >>> "gg" in "eggs"
      True

2. *n* 의 값이 "0" 보다 작으면 "0" 으로 처리됩니다 (*s* 와 같은 형의
   빈 시퀀스가 됩니다). 시퀀스 *s* 의 항목들이 복사되지 않음에 주의해
   야 합니다; 그들은 여러 번 참조됩니다. 이것은 종종 새 파이썬 프로그
   래머들을 괴롭힙니다; 이 코드를 살펴보세요:

      >>> lists = [[]] * 3
      >>> lists
      [[], [], []]
      >>> lists[0].append(3)
      >>> lists
      [[3], [3], [3]]

   무슨 일이 일어났는가 하면, "[[]]" 는 빈 리스트를 포함하는 길이 1인
   리스트인데, "[[]] * 3" 의 세 항목은 모두 같은 빈 리스트를 참조합니
   다. "lists" 의 어느 항목을 수정하더라도 이 하나의 리스트를 수정하게
   됩니다. 서로 다른 리스트들을 포함하는 리스트는 이런 식으로 만들 수
   있습니다:

      >>> lists = [[] for i in range(3)]
      >>> lists[0].append(3)
      >>> lists[1].append(5)
      >>> lists[2].append(7)
      >>> lists
      [[3], [5], [7]]

   더 자세한 설명은 FAQ 항목 다차원 리스트를 어떻게 만듭니까?에서 얻을
   수 있습니다.

3. *i* 또는 *j* 가 음수인 경우, 인덱스는 시퀀스 *s* 의 끝에 상대적입니
   다: "len(s) + i" 이나 "len(s) + j" 로 치환됩니다. 하지만 "-0" 은 여
   전히 "0" 입니다.

4. *i* 에서 *j* 까지의 *s* 의 슬라이스는 "i <= k < j" 를 만족하는 인덱
   스 *k* 의 항목들로 구성된 시퀀스로 정의됩니다. *i* 또는 *j* 가
   "len(s)" 보다 크면 "len(s)" 을 사용합니다. *i* 가 생략되거나 "None"
   이라면 "0" 을 사용합니다. *j* 가 생략되거나 "None" 이면 "len(s)" 을
   사용합니다. *i* 가 *j* 보다 크거나 같으면 빈 슬라이스가 됩니다.

5. 스텝 *k* 가 있는 *i* 에서 *j* 까지의 슬라이스는 "0 <= n < (j-i)/k"
   를 만족하는 인덱스 "x = i + n*k" 의 항목들로 구성된 시퀀스로 정의됩
   니다. 다시 말하면, 인덱스는 "i", "i+k", "i+2*k", "i+3*k" 등이며 *j*
   에 도달할 때 멈춥니다 (하지만 절대 *j* 를 포함하지는 않습니다). *k*
   가 양수면 *i* 와 *j* 는 더 큰 경우 "len(s)" 로 줄어듭니다. *k* 가
   음수면, *i* 와 *j* 는 더 큰 경우 "len(s) - 1" 로 줄어듭니다. *i* 또
   는 *j* 가 생략되거나 "None" 이면, 그것들은 "끝" 값이 됩니다 (끝은
   *k* 의 부호에 따라 달라집니다). *k* 는 0일 수 없음에 주의하세요.
   *k* 가 "None" 이면 "1" 로 취급됩니다.

6. 불변 시퀀스를 이어 붙이면 항상 새로운 객체가 생성됩니다. 이것은 반
   복적으로 이어붙이기를 해서 시퀀스를 만들 때 실행 시간이 시퀀스의 총
   길이의 제곱에 비례한다는 뜻입니다. 선형 실행 시간 비용을 얻으려면
   아래 대안 중 하나로 전환해야 합니다:

   * "str" 객체를 이어붙이기를 한다면, 리스트를 만들고 마지막에
     "str.join()" 을 사용하거나 "io.StringIO" 인스턴스에 쓰고 완료될
     때 값을 꺼낼 수 있습니다

   * "bytes" 객체를 연결하는 경우 비슷하게 "bytes.join()" 또는
     "io.BytesIO" 를 사용하거나, "bytearray" 객체를 사용하여 제자리에
     서 이어붙이기를 할 수 있습니다. "bytearray" 객체는 가변이고 효율
     적인 과할당(overallocation) 메커니즘을 가지고 있습니다.

   * "tuple" 객체를 이어붙이기를 한다면, 대신 "list"를 extend 하십시오
     .

   * 다른 형의 경우 관련 클래스 문서를 조사하십시오.

7. 일부 시퀀스 형 (예를 들어 "range")은 특정 패턴을 따르는 항목 시퀀스
   만 지원하기 때문에 시퀀스 이어붙이기나 반복을 지원하지 않습니다.

8. An "IndexError" is raised if *i* is outside the sequence range.

-[ Sequence Methods ]-

Sequence types also support the following methods:

sequence.count(value, /)

   Return the total number of occurrences of *value* in *sequence*.

sequence.index(value[, start[, stop])

   Return the index of the first occurrence of *value* in *sequence*.

   Raises "ValueError" if *value* is not found in *sequence*.

   The *start* or *stop* arguments allow for efficient searching of
   subsections of the sequence, beginning at *start* and ending at
   *stop*. This is roughly equivalent to "start +
   sequence[start:stop].index(value)", only without copying any data.

   조심:

     Not all sequence types support passing the *start* and *stop*
     arguments.


불변 시퀀스 형
--------------

불변 시퀀스 형이 일반적으로 구현하지만, 가변 시퀀스 형에서는 구현되지
않는 연산은 내장 "hash()" 에 대한 지원입니다.

이 지원은 "tuple" 인스턴스와 같은 불변 시퀀스를 "dict" 키로 사용하고
"set" 및 "frozenset" 인스턴스에 저장할 수 있도록 합니다.

해시 불가능 값을 포함하는 불변 시퀀스를 해시 하려고 하면 "TypeError"
를 일으킵니다.


가변 시퀀스 형
--------------

다음 표의 연산들은 가변 시퀀스 형에 정의되어 있습니다. 사용자 정의 시
퀀스에서 이 연산들을 올바르게 구현하기 쉽게 하려고
"collections.abc.MutableSequence" ABC가 제공됩니다.

표에서 *s* 는 가변 시퀀스 형의 인스턴스이고, *t* 는 임의의 이터러블 객
체이며, *x* 는 *s* 가 요구하는 형 및 값 제한을 충족시키는 임의의 객체
입니다 (예를 들어, "bytearray" 는 값 제한 "0 <= x <= 255" 를 만족하는
정수만 받아들입니다.

+--------------------------------+----------------------------------+-----------------------+
| 연산                           | 결과                             | 노트                  |
|================================|==================================|=======================|
| "s[i] = x"                     | *s* 의 항목 *i* 를 *x* 로 대체합 |                       |
|                                | 니다                             |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i]"                     | removes item *i* of *s*          |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s[i:j] = t"                   | *i* 에서 *j* 까지의 *s* 슬라이스 |                       |
|                                | 가 이터러블 *t* 의 내용으로 대체 |                       |
|                                | 됩니다                           |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i:j]"                   | removes the elements of "s[i:j]" |                       |
|                                | from the list (same as "s[i:j] = |                       |
|                                | []")                             |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s[i:j:k] = t"                 | "s[i:j:k]" 의 항목들이 *t* 의 항 | (1)                   |
|                                | 목들로 대체됩니다                |                       |
+--------------------------------+----------------------------------+-----------------------+
| "del s[i:j:k]"                 | 리스트에서 "s[i:j:k]" 의 항목들  |                       |
|                                | 을 제거합니다                    |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s += t"                       | *t* 의 내용으로 *s* 를 확장합니  |                       |
|                                | 다 (대부분 "s[len(s):len(s)] =   |                       |
|                                | t" 와 같 습니다)                 |                       |
+--------------------------------+----------------------------------+-----------------------+
| "s *= n"                       | 내용이 *n* 번 반복되도록 *s* 를  | (2)                   |
|                                | 갱신합니다                       |                       |
+--------------------------------+----------------------------------+-----------------------+

노트:

1. If *k* is not equal to "1", *t* must have the same length as the
   slice it is replacing.

2. *n* 값은 정수이거나, "__index__()" 를 구현하는 객체입니다. *n* 이 0
   이거나 음수면 시퀀스를 지웁니다. 시퀀스의 항목들은 복사되지 않습니
   다; 공통 시퀀스 연산에서 "s * n" 를 위해 설명한 것처럼 여러 번 참조
   됩니다.

-[ Mutable Sequence Methods ]-

Mutable sequence types also support the following methods:

sequence.append(value, /)

   Append *value* to the end of the sequence This is equivalent to
   writing "seq[len(seq):len(seq)] = [value]".

sequence.clear()

   Added in version 3.3.

   Remove all items from *sequence*. This is equivalent to writing
   "del sequence[:]".

sequence.copy()

   Added in version 3.3.

   Create a shallow copy of *sequence*. This is equivalent to writing
   "sequence[:]".

   힌트:

     The "copy()" method is not part of the "MutableSequence" "ABC",
     but most concrete mutable sequence types provide it.

sequence.extend(iterable, /)

   Extend *sequence* with the contents of *iterable*. For the most
   part, this is the same as writing "seq[len(seq):len(seq)] =
   iterable".

sequence.insert(index, value, /)

   Insert *value* into *sequence* at the given *index*. This is
   equivalent to writing "sequence[index:index] = [value]".

sequence.pop(index=-1, /)

   Retrieve the item at *index* and also removes it from *sequence*.
   By default, the last item in *sequence* is removed and returned.

sequence.remove(value, /)

   Remove the first item from *sequence* where "sequence[i] == value".

   Raises "ValueError" if *value* is not found in *sequence*.

sequence.reverse()

   Reverse the items of *sequence* in place. This method maintains
   economy of space when reversing a large sequence. To remind users
   that it operates by side-effect, it returns "None".


리스트
------

리스트는 가변 시퀀스로, 일반적으로 등질 항목들의 모음을 저장하는 데 사
용됩니다 (정확한 유사도는 응용 프로그램마다 다를 수 있습니다).

class list(iterable=(), /)

   리스트는 여러 가지 방법으로 만들 수 있습니다:

   * 대괄호를 사용하여 빈 리스트를 표시하기: "[]"

   * 대괄호를 사용하여 쉼표로 항목 구분하기: "[a]", "[a, b, c]"

   * 리스트 컴프리헨션 사용하기: "[x for x in iterable]"

   * 형 생성자를 사용하기: "list()" 또는 "list(iterable)"

   생성자는 항목들과 그 순서가 *iterable* 과 같은 리스트를 만듭니다.
   *iterable* 은 시퀀스, 이터레이션을 지원하는 컨테이너, 이터레이터 객
   체가 될 수 있습니다. *iterable* 이 이미 리스트라면, "iterable[:]"
   과 비슷하게 복사본을 만들어서 반환합니다. 예를 들어, "list('abc')"
   는 "['a', 'b', 'c']" 를 반환하고 "list( (1, 2, 3) )" 는 "[1, 2, 3]"
   를 반환합니다. 인자가 주어지지 않으면, 생성자는 새로운 빈 리스트인
   "[]" 을 만듭니다.

   다른 많은 연산도 리스트를 만드는데, 내장 "sorted()" 도 그런 것 중
   하나다.

   리스트는 공통 과 가변 시퀀스 연산들을 모두 구현합니다. 또한, 리스트
   는 다음과 같은 추가 메서드를 제공합니다:

   sort(*, key=None, reverse=False)

      이 메서드는 항목 간의 "<" 비교만 사용하여 리스트를 제자리에서 정
      렬합니다. 예외는 억제되지 않습니다 - 비교 연산이 실패하면 전체
      정렬 연산이 실패합니다 (리스트는 부분적으로 수정된 상태로 남아있
      게 됩니다).

      "sort()" 는 키워드로만 전달할 수 있는 두 개의 인자를 받아들입니
      다 (키워드-전용 인자):

      *key* 는 인자 하나를 받아들이는 함수를 지정하는데, 각 리스트 요
      소에서 비교 키를 추출하는 데 사용됩니다 (예를 들어,
      "key=str.lower"). 리스트의 각 항목에 해당하는 키는 한 번만 계산
      된 후 전체 정렬 프로세스에 사용됩니다. 기본값 "None" 은 리스트
      항목들이 별도의 키값을 계산하지 않고 직접 정렬된다는 것을 의미합
      니다.

      "functools.cmp_to_key()" 유틸리티는 2.x 스타일 *cmp* 함수를
      *key* 함수로 변환하는 데 사용할 수 있습니다.

      *reverse* 는 논리값입니다. "True" 로 설정되면, 각 비교가 역전된
      것처럼 리스트 요소들이 정렬됩니다.

      이 메서드는 큰 시퀀스를 정렬할 때 공간 절약을 위해 시퀀스를 제자
      리에서 수정합니다. 부작용으로 작동한다는 것을 사용자에게 상기시
      키기 위해 정렬된 시퀀스를 돌려주지 않습니다 (새 정렬 된 리스트
      인스턴스를 명시적으로 요청하려면 "sorted()"를 사용하십시오).

      "sort()" 메서드는 안정적임이 보장됩니다. 정렬은 같다고 비교되는
      요소들의 상대적 순서를 변경하지 않으면 안정적입니다 --- 이는 여
      러 번 정렬하는 데 유용합니다 (예를 들어, 부서별로 정렬한 후에 급
      여 등급으로 정렬).

      정렬 예제와 간단한 정렬 자습서는 정렬 기법를 참조하십시오.

      리스트가 정렬되는 동안, 리스트를 변경하려고 할 때의, 또는 관찰하
      려고 할 때조차, 효과는 정의되지 않습니다. 파이썬의 C 구현은 그동
      안 리스트를 비어있는 것으로 보이게 하고, 정렬 중에 리스트가 변경
      되었음을 감지할 수 있다면 "ValueError" 를 일으킵니다.


튜플
----

튜플은 불변 시퀀스인데, 보통 이질적인 데이터의 모음을 저장하는 데 사용
됩니다 (예를 들어, 내장 "enumerate()" 가 만드는 2-튜플). 튜플은 등질적
인 데이터의 불변 시퀀스가 필요한 경우에도 사용됩니다 (예를 들어, "set"
이나 "dict" 인스턴스에 저장하고자 하는 경우).

class tuple(iterable=(), /)

   튜플은 여러 가지 방법으로 만들 수 있습니다:

   * 괄호를 사용하여 빈 튜플을 나타내기: "()"

   * 단일 항목 튜플을 위해 끝에 쉼표를 붙이기: "a," 또는 "(a,)"

   * 항목을 쉼표로 구분하기: "a, b, c" 또는 "(a, b, c)"

   * 내장 "tuple()" 사용하기: "tuple()" 또는 "tuple(iterable)"

   생성자는 항목들과 그 순서가 *iterable* 과 같은 튜플을 만듭니다.
   *iterable* 은 시퀀스, 이터레이션을 지원하는 컨테이너, 이터레이터 객
   체가 될 수 있습니다. *iterable* 이 이미 튜플이라면 변경되지 않은 상
   태로 반환됩니다. 예를 들어 "tuple('abc')" 는 "('a', 'b', 'c')" 를
   반환하고, "tuple( [1, 2, 3] )" 는 "(1, 2, 3)" 을 반환합니다. 인자가
   주어지지 않으면, 생성자는 새로운 빈 튜플인 "()" 을 만듭니다.

   튜플을 만드는 것은 실제로는 괄호가 아닌 쉼표임에 유의하십시오. 괄호
   는 빈 튜플의 경우를 제외하고는 선택적이거나 문법상의 모호함을 피하
   고자 필요합니다. 예를 들어, "f(a, b, c)" 는 3개의 인자를 가진 함수
   호출이지만, "f((a, b, c))" 는 하나의 인자로 3-튜플을 갖는 함수 호출
   입니다.

   튜플은 공통 시퀀스 연산을 모두 구현합니다.

이름에 의한 액세스가 인덱스에 의한 액세스보다 더 명확한 이질적 데이터
컬렉션의 경우, "collections.namedtuple()" 이 단순한 튜플 객체보다 더
적절한 선택일 수 있습니다.


범위
----

"range" 형은 숫자의 불변 시퀀스를 나타내며 "for" 루프에서 특정 횟수만
큼 반복하는 데 흔히 사용됩니다.

class range(stop, /)
class range(start, stop, step=1, /)

   The arguments to the range constructor must be integers (either
   built-in "int" or any object that implements the "__index__()"
   special method).  If the *step* argument is omitted, it defaults to
   "1". If the *start* argument is omitted, it defaults to "0". If
   *step* is zero, "ValueError" is raised.

   양수 *step* 의 경우, 범위 "r" 의 내용은 식 "r[i] = start + step*i"
   에 의해 결정됩니다. 이때 "i >= 0" 이고 "r[i] < stop" 입니다.

   음수 *step* 의 경우, 범위의 내용은 여전히 식 "r[i] = start +
   step*i" 에 의해 결정되지만, 제약 조건은 "i >= 0" 과 "r[i] > stop"
   이 됩니다.

   "r[0]" 제약 조건을 만족시키지 않으면 범위 객체는 비게 됩니다. 범위
   는 음의 인덱스를 지원하지만, 이는 시퀀스의 끝에서부터 양의 인덱스만
   큼 떨어진 인덱스로 해석됩니다.

   "sys.maxsize" 보다 큰 절댓값을 포함하는 범위는 허용되지만, ("len()"
   과 같은) 일부 기능은 "OverflowError" 를 발생시킬 수 있습니다.

   범위 예제:

      >>> list(range(10))
      [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
      >>> list(range(1, 11))
      [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
      >>> list(range(0, 30, 5))
      [0, 5, 10, 15, 20, 25]
      >>> list(range(0, 10, 3))
      [0, 3, 6, 9]
      >>> list(range(0, -10, -1))
      [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
      >>> list(range(0))
      []
      >>> list(range(1, 0))
      []

   범위는 이어 붙이기와 반복을 제외한 공통 시퀀스 연산을 모두 구현합니
   다 (범위 객체는 엄격한 패턴을 따르는 시퀀스 만 나타낼 수 있는데 반
   복과 이어 붙이기는 보통 그 패턴을 위반한다는 사실에 기인합니다).

   start

      *start* 매개변수의 값 (또는 매개변수가 제공되지 않으면 "0")

   stop

      *stop* 매개변수의 값

   step

      *step* 매개변수의 값 (또는 매개변수가 제공되지 않으면 "1")

정규 "list" 나 "tuple" 에 비해 "range" 형의 장점은 "range" 객체는 표현
하는 범위의 크기에 무관하게 항상 같은 (작은) 양의 메모리를 사용한다는
것입니다 ("start", "stop", "step" 값만을 저장하고, 필요에 따라 개별 항
목과 하위 범위를 계산하기 때문입니다).

범위 객체는 "collections.abc.Sequence" ABC를 구현하고, 포함 검사, 요소
인덱스 검색, 슬라이싱, 음수 인덱스 지원과 같은 기능을 제공합니다 (시퀀
스 형 --- list, tuple, range 를 보세요):

>>> r = range(0, 20, 2)
>>> r
range(0, 20, 2)
>>> 11 in r
False
>>> 10 in r
True
>>> r.index(10)
5
>>> r[5]
10
>>> r[:5]
range(0, 10, 2)
>>> r[-1]
18

"==" 나 "!=" 로 범위 객체가 같은지 검사하면 시퀀스처럼 비교합니다. 즉,
두 범위 객체가 같은 시퀀스의 값을 나타낼 때 같다고 취급됩니다. (같다고
비교되는 두 개의 범위 객체가 서로 다른 "start", "stop", "step" 어트리
뷰트를 가질 수 있음에 주의하세요. 예를 들어, "range(0) == range(2, 1,
3)" 또는 "range(0, 3, 2) == range(0, 4, 2)".)

버전 3.2에서 변경: 시퀀스 ABC를 구현합니다. "int" 객체의 포함 검사는
모든 항목을 이터레이트하는 대신 상수 시간으로 수행됩니다.

버전 3.3에서 변경: (객체 아이덴티티에 기반을 두는 대신) 범위 객체가 정
의하는 값들의 시퀀스에 기반을 둔 비교를 위해 '==' 와 '!=' 를 정의합니
다.Added the "start", "stop" and "step" attributes.

더 보기:

  * The linspace recipe shows how to implement a lazy version of range
    suitable for floating-point applications.


Text and Binary Sequence Type Methods Summary
=============================================

The following table summarizes the text and binary sequence types
methods by category.

+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| Category                   | "str" methods                                                   | "bytes" and "bytearray" methods                                           |
|============================|====================|=========|=========|========================|======================|==========|==========|==============================|
| Formatting                 | "str.format()"                                                  |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.format_map()"                                              |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | 포맷 문자열 리터럴                                              |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | printf 스타일 문자열 포매팅                                     | printf 스타일 바이너리 포매팅                                             |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| Searching and Replacing    | "str.find()"       | "str.rfind()"                              | "bytes.find()"       | "bytes.rfind()"                                    |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.index()"      | "str.rindex()"                             | "bytes.index()"      | "bytes.rindex()"                                   |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.startswith()"                                              | "bytes.startswith()"                                                      |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.endswith()"                                                | "bytes.endswith()"                                                        |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.count()"                                                   | "bytes.count()"                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.replace()"                                                 | "bytes.replace()"                                                         |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| Splitting and Joining      | "str.split()"                | "str.rsplit()"                   | "bytes.split()"                 | "bytes.rsplit()"                        |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.splitlines()"                                              | "bytes.splitlines()"                                                      |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.partition()"                                               | "bytes.partition()"                                                       |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.rpartition()"                                              | "bytes.rpartition()"                                                      |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.join()"                                                    | "bytes.join()"                                                            |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| String Classification      | "str.isalpha()"                                                 | "bytes.isalpha()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isdecimal()"                                               |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isdigit()"                                                 | "bytes.isdigit()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isnumeric()"                                               |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isalnum()"                                                 | "bytes.isalnum()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isidentifier()"                                            |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.islower()"                                                 | "bytes.islower()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isupper()"                                                 | "bytes.isupper()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.istitle()"                                                 | "bytes.istitle()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isspace()"                                                 | "bytes.isspace()"                                                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.isprintable()"                                             |                                                                           |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| Case Manipulation          | "str.lower()"                                                   | "bytes.lower()"                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.upper()"                                                   | "bytes.upper()"                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.casefold()"                                                |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.capitalize()"                                              | "bytes.capitalize()"                                                      |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.title()"                                                   | "bytes.title()"                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.swapcase()"                                                | "bytes.swapcase()"                                                        |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| Padding and Stripping      | "str.ljust()"                | "str.rjust()"                    | "bytes.ljust()"                 | "bytes.rjust()"                         |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.center()"                                                  | "bytes.center()"                                                          |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.expandtabs()"                                              | "bytes.expandtabs()"                                                      |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.strip()"                                                   | "bytes.strip()"                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.lstrip()"                         | "str.rstrip()"         | "bytes.lstrip()"                           | "bytes.rstrip()"             |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
| Translation and Encoding   | "str.translate()"                                               | "bytes.translate()"                                                       |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.maketrans()"                                               | "bytes.maketrans()"                                                       |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            | "str.encode()"                                                  |                                                                           |
|                            +--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+
|                            |                                                                 | "bytes.decode()"                                                          |
+----------------------------+--------------------+---------+---------+------------------------+----------------------+----------+----------+------------------------------+


텍스트 시퀀스 형 --- "str"
==========================

파이썬의 텍스트 데이터는 "str", 또는 *문자열 (strings)*, 객체를 사용하
여 처리됩니다. 문자열은 유니코드 코드 포인트의 불변 시퀀스 입니다. 문
자열 리터럴은 다양한 방법으로 작성됩니다:

* 작은따옴표: "'"큰" 따옴표를 담을 수 있습니다'"

* Double quotes: ""allows embedded 'single' quotes""

* 삼중 따옴표: "'''세 개의 작은따옴표'''", """"세 개의 큰따옴표""""

삼중 따옴표로 묶인 문자열은 여러 줄에 걸쳐있을 수 있습니다 - 연관된 모
든 공백이 문자열 리터럴에 포함됩니다.

단일 표현식의 일부이고 그 들 사이에 공백만 있는 문자열 리터럴은 묵시적
으로 단일 문자열 리터럴로 변환됩니다. 즉, "("spam " "eggs") == "spam
eggs"".

See 문자열과 바이트열 리터럴 for more about the various forms of
string literal, including supported escape sequences, and the "r"
("raw") prefix that disables most escape sequence processing.

문자열은 "str" 생성자를 사용하여 다른 객체로부터 만들어질 수도 있습니
다.

별도의 "문자" 형이 없으므로 문자열을 인덱싱하면 길이가 1인 문자열이 생
성됩니다. 즉, 비어 있지 않은 문자열 *s* 의 경우, "s[0] == s[0:1]" 입니
다.

또한, 가변 문자열형은 없지만, 여러 단편으로부터 문자열을 효율적으로 구
성하는데 "str.join()" 또는 "io.StringIO" 를 사용할 수 있습니다.

버전 3.3에서 변경: 파이썬 2시리즈와의 하위 호환성을 위해서, "u" 접두어
가 문자열 리터럴에 다시 한번 허용됩니다. 문자열 리터럴의 의미에 영향을
미치지 않으며 "r" 접두사와 결합 될 수 없습니다.

class str(*, encoding='utf-8', errors='strict')
class str(object)
class str(object, encoding, errors='strict')
class str(object, *, errors)

   *object* 의 문자열 버전을 돌려줍니다. *object* 가 제공되지 않으면,
   빈 문자열을 돌려줍니다. 그렇지 않으면, "str()" 의 동작은 *encoding*
   또는 *errors* 가 주어졌는지에 따라 달라지는데, 다음과 같습니다.

   If neither *encoding* nor *errors* is given, "str(object)" returns
   "type(object).__str__(object)", which is the "informal" or nicely
   printable string representation of *object*.  For string objects,
   this is the string itself.  If *object* does not have a "__str__()"
   method, then "str()" falls back to returning "repr(object)".

   *encoding* 또는 *errors* 중 적어도 하나가 주어지면, *object* 는
   *bytes-like object* (예, "bytes" 또는 "bytearray") 이어야 합니다.
   이 경우, *object* 가 "bytes" (또는 "bytearray") 객체이면,
   "str(bytes, encoding, errors)" 는 "bytes.decode(encoding, errors)"
   와 동등합니다. 그 이외의 경우, "bytes.decode()" 호출 전에 버퍼 객체
   의 하부 바이트열 객체를 얻습니다. 버퍼 객체에 대한 정보는 바이너리
   시퀀스 형 --- bytes, bytearray, memoryview와 버퍼 프로토콜 를 보십
   시오.

   *encoding* 또는 *errors* 인자 없이 "bytes" 객체를 "str()" 에 전달하
   는 것은 비형식적 문자열 표현을 반환하는 첫 번째 상황에 해당합니다 (
   파이썬 명령행 옵션 "-b" 도 보십시오). 예를 들면:

      >>> str(b'Zoot!')
      "b'Zoot!'"

   "str" 클래스와 그 메서드에 대한 더 자세한 정보는 텍스트 시퀀스 형
   --- str와 아래의 문자열 메서드 섹션을 보십시오. 포맷된 문자열을 출
   력하려면 포맷 문자열 리터럴 및 포맷 문자열 문법 섹션을 참조하십시오
   . 또한, 텍스트 처리 서비스 섹션을 보십시오.


문자열 메서드
-------------

문자열은 공통 시퀀스 연산들을 모두 구현하고, 아래에 기술된 추가적인 메
서드도 구현합니다.

문자열은 또한 두 가지 스타일의 문자열 포매팅을 지원합니다. 하나는 큰
폭의 유연성과 사용자 지정을 제공하고 (참조 "str.format()", 포맷 문자열
문법, 사용자 지정 문자열 포매팅을 참조하세요) 다른 하나는 C "printf"
스타일에 기반을 두는데, 더 좁은 범위의 형을 처리하고 올바르게 사용하기
는 다소 어렵지만, 처리할 수 있는 경우에는 종종 더 빠릅니다 (printf 스
타일 문자열 포매팅).

표준 라이브러리의 텍스트 처리 서비스 섹션은 다양한 텍스트 관련 유틸리
티를 ("re" 모듈의 정규식 지원을 포함합니다) 제공하는 많은 다른 모듈들
을 다룹니다.

str.capitalize()

   첫 문자가 대문자이고 나머지가 소문자인 문자열의 복사본을 돌려줍니다
   .

   버전 3.8에서 변경: 이제 첫 번째 문자는 대문자가 아닌 제목 케이스로
   바뀝니다. 이는 이중 문자(digraph)와 같은 문자는 전체 문자 대신 첫
   문자만 대문자로 표시된다는 뜻입니다.

str.casefold()

   케이스 폴딩 된 문자열을 반환합니다. 케이스 폴딩 된 문자열은 대소문
   자를 무시한 매칭에 사용될 수 있습니다.

   케이스 폴딩은 소문자로 변환하는 것과 비슷하지만 문자열의 모든 케이
   스 구분을 제거하기 때문에 보다 공격적입니다. 예를 들어, 독일어 소문
   자 "'ß'" 는 ""ss"" 와 동등합니다. 이미 소문자이므로 "lower()" 는
   "'ß'" 에 아무런 영향을 미치지 않습니다; "casefold()" 는 ""ss"" 로
   변환합니다.

   The casefolding algorithm is described in section 3.13 'Default
   Case Folding' of the Unicode Standard.

   Added in version 3.3.

str.center(width, fillchar=' ', /)

   Return centered in a string of length *width*. Padding is done
   using the specified *fillchar* (default is an ASCII space). The
   original string is returned if *width* is less than or equal to
   "len(s)".  For example:

      >>> 'Python'.center(10)
      '  Python  '
      >>> 'Python'.center(10, '-')
      '--Python--'
      >>> 'Python'.center(4)
      'Python'

str.count(sub[, start[, end]])

   범위 [*start*, *end*] 에서 부분 문자열 *sub* 가 중첩되지 않고 등장
   하는 횟수를 돌려줍니다. 선택적 인자 *start* 와 *end* 는 슬라이스 표
   기법으로 해석됩니다.

   If *sub* is empty, returns the number of empty strings between
   characters which is the length of the string plus one. For example:

      >>> 'spam, spam, spam'.count('spam')
      3
      >>> 'spam, spam, spam'.count('spam', 5)
      2
      >>> 'spam, spam, spam'.count('spam', 5, 10)
      1
      >>> 'spam, spam, spam'.count('eggs')
      0
      >>> 'spam, spam, spam'.count('')
      17

str.encode(encoding='utf-8', errors='strict')

   Return the string encoded to "bytes".

   *encoding* defaults to "'utf-8'"; see 표준 인코딩 for possible
   values.

   *errors* controls how encoding errors are handled. If "'strict'"
   (the default), a "UnicodeError" exception is raised. Other possible
   values are "'ignore'", "'replace'", "'xmlcharrefreplace'",
   "'backslashreplace'" and any other name registered via
   "codecs.register_error()". See 에러 처리기 for details.

   For performance reasons, the value of *errors* is not checked for
   validity unless an encoding error actually occurs, 파이썬 개발 모드
   is enabled or a debug build is used. For example:

      >>> encoded_str_to_bytes = 'Python'.encode()
      >>> type(encoded_str_to_bytes)
      <class 'bytes'>
      >>> encoded_str_to_bytes
      b'Python'

   버전 3.1에서 변경: 키워드 인자 지원이 추가되었습니다.

   버전 3.9에서 변경: The value of the *errors* argument is now
   checked in 파이썬 개발 모드 and in debug mode.

str.endswith(suffix[, start[, end]])

   Return "True" if the string ends with the specified *suffix*,
   otherwise return "False".  *suffix* can also be a tuple of suffixes
   to look for.  With optional *start*, test beginning at that
   position.  With optional *end*, stop comparing at that position.
   Using *start* and *end* is equivalent to
   "str[start:end].endswith(suffix)". For example:

      >>> 'Python'.endswith('on')
      True
      >>> 'a tuple of suffixes'.endswith(('at', 'in'))
      False
      >>> 'a tuple of suffixes'.endswith(('at', 'es'))
      True
      >>> 'Python is amazing'.endswith('is', 0, 9)
      True

   See also "startswith()" and "removesuffix()".

str.expandtabs(tabsize=8)

   Return a copy of the string where all tab characters are replaced
   by one or more spaces, depending on the current column and the
   given tab size.  Tab positions occur every *tabsize* characters
   (default is 8, giving tab positions at columns 0, 8, 16 and so on).
   To expand the string, the current column is set to zero and the
   string is examined character by character.  If the character is a
   tab ("\t"), one or more space characters are inserted in the result
   until the current column is equal to the next tab position. (The
   tab character itself is not copied.)  If the character is a newline
   ("\n") or return ("\r"), it is copied and the current column is
   reset to zero.  Any other character is copied unchanged and the
   current column is incremented by one regardless of how the
   character is represented when printed. For example:

      >>> '01\t012\t0123\t01234'.expandtabs()
      '01      012     0123    01234'
      >>> '01\t012\t0123\t01234'.expandtabs(4)
      '01  012 0123    01234'
      >>> print('01\t012\n0123\t01234'.expandtabs(4))
      01  012
      0123    01234

str.find(sub[, start[, end]])

   Return the lowest index in the string where substring *sub* is
   found within the slice "s[start:end]".  Optional arguments *start*
   and *end* are interpreted as in slice notation.  Return "-1" if
   *sub* is not found. For example:

      >>> 'spam, spam, spam'.find('sp')
      0
      >>> 'spam, spam, spam'.find('sp', 5)
      6

   See also "rfind()" and "index()".

   참고:

     "find()" 메서드는 *sub* 의 위치를 알아야 할 경우에만 사용해야 합
     니다. *sub* 가 부분 문자열인지 확인하려면 "in" 연산자를 사용하십
     시오:

        >>> 'Py' in 'Python'
        True

str.format(*args, **kwargs)

   Perform a string formatting operation.  The string on which this
   method is called can contain literal text or replacement fields
   delimited by braces "{}".  Each replacement field contains either
   the numeric index of a positional argument, or the name of a
   keyword argument.  Returns a copy of the string where each
   replacement field is replaced with the string value of the
   corresponding argument. For example:

      >>> "The sum of 1 + 2 is {0}".format(1+2)
      'The sum of 1 + 2 is 3'
      >>> "The sum of {a} + {b} is {answer}".format(answer=1+2, a=1, b=2)
      'The sum of 1 + 2 is 3'
      >>> "{1} expects the {0} Inquisition!".format("Spanish", "Nobody")
      'Nobody expects the Spanish Inquisition!'

   포맷 문자열에 지정할 수 있는 다양한 포맷 옵션에 대한 설명은 포맷 문
   자열 문법 을 참조하십시오.

   참고:

     숫자("int", "float", "complex", "decimal.Decimal"와 서브 클래스)
     를 "n" 형식으로 포매팅할 때 (예: "'{:n}'.format(1234)"), 이 함수
     는 일시적으로 "LC_CTYPE" 로케일을 "LC_NUMERIC" 로케일로 설정하여
     "localeconv()" 의 "decimal_point" 와 "thousands_sep" 필드를 디코
     드하는데, 이 필드들이 ASCII가 아니거나 1바이트보다 길고,
     "LC_NUMERIC" 로케일이 "LC_CTYPE" 로케일과 다를 때만 그렇게 합니다
     . 이 임시 변경은 다른 스레드에 영향을 줍니다.

   버전 3.7에서 변경: 숫자를 "n" 형식으로 포매팅할 때, 이 함수는 어떤
   경우에 일시적으로 "LC_CTYPE" 로케일을 "LC_NUMERIC" 로케일로 설정합
   니다.

str.format_map(mapping, /)

   "str.format(**mapping)" 과 비슷하지만, "dict"로 복사되지 않고
   "mapping" 을 직접 사용합니다. 예를 들어 "mapping" 이 dict 서브 클래
   스면 유용합니다:

   >>> class Default(dict):
   ...     def __missing__(self, key):
   ...         return key
   ...
   >>> '{name} was born in {country}'.format_map(Default(name='Guido'))
   'Guido was born in country'

   Added in version 3.2.

str.index(sub[, start[, end]])

   "find()" 과 비슷하지만, 부분 문자열을 찾을 수 없는 경우
   "ValueError" 를 일으킵니다.

str.isalnum()

   문자열 내의 모든 문자가 알파벳과 숫자이고, 적어도 하나의 문자가 존
   재하는 경우 "True"를 돌려주고, 그렇지 않으면 "False"를 돌려줍니다.
   문자 "c" 는 다음 중 하나가 "True" 를 반환하면 알파벳이거나 숫자입니
   다: "c.isalpha()", "c.isdecimal()", "c.isdigit()", "c.isnumeric()".

str.isalpha()

   Return "True" if all characters in the string are alphabetic and
   there is at least one character, "False" otherwise.  Alphabetic
   characters are those characters defined in the Unicode character
   database as "Letter", i.e., those with general category property
   being one of "Lm", "Lt", "Lu", "Ll", or "Lo".  Note that this is
   different from the Alphabetic property defined in the section 4.10
   'Letters, Alphabetic, and Ideographic' of the Unicode Standard. For
   example:

      >>> 'Letters and spaces'.isalpha()
      False
      >>> 'LettersOnly'.isalpha()
      True
      >>> 'µ'.isalpha()  # non-ASCII characters can be considered alphabetical too
      True

   See 유니코드 속성.

str.isascii()

   Return "True" if the string is empty or all characters in the
   string are ASCII, "False" otherwise. ASCII characters have code
   points in the range U+0000-U+007F. For example:

      >>> 'ASCII characters'.isascii()
      True
      >>> 'µ'.isascii()
      False

   Added in version 3.7.

str.isdecimal()

   Return "True" if all characters in the string are decimal
   characters and there is at least one character, "False" otherwise.
   Decimal characters are those that can be used to form numbers in
   base 10, such as U+0660, ARABIC-INDIC DIGIT ZERO.  Formally a
   decimal character is a character in the Unicode General Category
   "Nd". For example:

      >>> '0123456789'.isdecimal()
      True
      >>> '٠١٢٣٤٥٦٧٨٩'.isdecimal()  # Arabic-Indic digits zero to nine
      True
      >>> 'alphabetic'.isdecimal()
      False

str.isdigit()

   문자열 내의 모든 문자가 디짓이고, 적어도 하나의 문자가 존재하는 경
   우 "True"를 돌려주고, 그렇지 않으면 "False"를 돌려줍니다. 디짓에는
   십진수 문자와 호환성 위 첨자 숫자와 같은 특수 처리가 필요한 숫자가
   포함됩니다. 여기에는 카로슈티 숫자처럼 십진법으로 숫자를 구성할 때
   사용될 수 없는 것들이 포함됩니다. 형식적으로, 디짓은 속성값이
   Numeric_Type=Digit 또는 Numeric_Type=Decimal인 문자입니다.

str.isidentifier()

   문자열이 섹션 section Names (identifiers and keywords) 의 언어 정의
   에 따른 유효한 식별자면 "True"를 돌려줍니다.

   "keyword.iskeyword()" can be used to test whether string "s" is a
   reserved identifier, such as "def" and "class".

   예제:

      >>> from keyword import iskeyword

      >>> 'hello'.isidentifier(), iskeyword('hello')
      (True, False)
      >>> 'def'.isidentifier(), iskeyword('def')
      (True, True)

str.islower()

   문자열 내의 모든 케이스 문자가 [4] 소문자이고, 적어도 하나의 케이스
   문자가 존재하는 경우 "True"를 돌려주고, 그렇지 않으면 "False"를 돌
   려줍니다.

str.isnumeric()

   Return "True" if all characters in the string are numeric
   characters, and there is at least one character, "False" otherwise.
   Numeric characters include digit characters, and all characters
   that have the Unicode numeric value property, e.g. U+2155, VULGAR
   FRACTION ONE FIFTH.  Formally, numeric characters are those with
   the property value Numeric_Type=Digit, Numeric_Type=Decimal or
   Numeric_Type=Numeric. For example:

      >>> '0123456789'.isnumeric()
      True
      >>> '٠١٢٣٤٥٦٧٨٩'.isnumeric()  # Arabic-indic digit zero to nine
      True
      >>> '⅕'.isnumeric()  # Vulgar fraction one fifth
      True
      >>> '²'.isdecimal(), '²'.isdigit(),  '²'.isnumeric()
      (False, True, True)

   See also "isdecimal()" and "isdigit()". Numeric characters are a
   superset of decimal numbers.

str.isprintable()

   Return "True" if all characters in the string are printable,
   "False" if it contains at least one non-printable character.

   Here "printable" means the character is suitable for "repr()" to
   use in its output; "non-printable" means that "repr()" on built-in
   types will hex-escape the character.  It has no bearing on the
   handling of strings written to "sys.stdout" or "sys.stderr".

   The printable characters are those which in the Unicode character
   database (see "unicodedata") have a general category in group
   Letter, Mark, Number, Punctuation, or Symbol (L, M, N, P, or S);
   plus the ASCII space 0x20. Nonprintable characters are those in
   group Separator or Other (Z or C), except the ASCII space.

str.isspace()

   문자열 내에 공백 문자만 있고, 적어도 하나의 문자가 존재하는 경우
   "True"를 돌려주고, 그렇지 않으면 "False"를 돌려줍니다.

   유니코드 문자 데이터베이스("unicodedata"를 참조하십시오)에서, 일반
   범주(general category)가 "Zs"("Separator, space")이거나 양방향 클래
   스(bidirectional class)가 "WS", "B" 또는 "S" 중 하나이면 문자는 *공
   백(whitespace)*입니다.

str.istitle()

   문자열이 제목 케이스 문자열이고 하나 이상의 문자가 있는 경우 "True"
   를 돌려줍니다. 예를 들어 대문자 앞에는 케이스 없는 문자만 올 수 있
   고 소문자는 케이스 문자 뒤에만 올 수 있습니다. 그렇지 않은 경우는
   "False"를 돌려줍니다.

   For example:

      >>> 'Spam, Spam, Spam'.istitle()
      True
      >>> 'spam, spam, spam'.istitle()
      False
      >>> 'SPAM, SPAM, SPAM'.istitle()
      False

   See also "title()".

str.isupper()

   문자열 내의 모든 케이스 문자가 [4] 대문자이고, 적어도 하나의 케이스
   문자가 존재하는 경우 "True"를 돌려주고, 그렇지 않으면 "False"를 돌
   려줍니다.

   >>> 'BANANA'.isupper()
   True
   >>> 'banana'.isupper()
   False
   >>> 'baNana'.isupper()
   False
   >>> ' '.isupper()
   False

str.join(iterable, /)

   Return a string which is the concatenation of the strings in
   *iterable*. A "TypeError" will be raised if there are any non-
   string values in *iterable*, including "bytes" objects.  The
   separator between elements is the string providing this method. For
   example:

      >>> ', '.join(['spam', 'spam', 'spam'])
      'spam, spam, spam'
      >>> '-'.join('Python')
      'P-y-t-h-o-n'

   See also "split()".

str.ljust(width, fillchar=' ', /)

   왼쪽으로 정렬된 문자열을 길이 *width* 인 문자열로 돌려줍니다. 지정
   된 *fillchar* (기본값은 ASCII 스페이스)을 사용하여 채웁니다.
   *width* 가 "len(s)" 보다 작거나 같은 경우 원래 문자열이 반환됩니다.

   For example:

      >>> 'Python'.ljust(10)
      'Python    '
      >>> 'Python'.ljust(10, '.')
      'Python....'
      >>> 'Monty Python'.ljust(10, '.')
      'Monty Python'

   See also "rjust()".

str.lower()

   모든 케이스 문자 [4] 가 소문자로 변환된 문자열의 복사본을 돌려줍니
   다.

   The lowercasing algorithm used is described in section 3.13
   'Default Case Folding' of the Unicode Standard.

str.lstrip(chars=None, /)

   선행 문자가 제거된 문자열의 복사본을 돌려줍니다. *chars* 인자는 제
   거할 문자 집합을 지정하는 문자열입니다. 생략되거나 "None" 이라면,
   *chars* 인자의 기본값은 공백을 제거하도록 합니다. *chars* 인자는 접
   두사가 아닙니다; 모든 값 조합이 제거됩니다:

      >>> '   spacious   '.lstrip()
      'spacious   '
      >>> 'www.example.com'.lstrip('cmowz.')
      'example.com'

   문자 집합의 모든 것이 아닌 단일 접두사 문자열을 제거하는 메서드는
   "str.removeprefix()"를 참조하십시오. 예를 들면:

      >>> 'Arthur: three!'.lstrip('Arthur: ')
      'ee!'
      >>> 'Arthur: three!'.removeprefix('Arthur: ')
      'three!'

static str.maketrans(dict, /)
static str.maketrans(from, to, remove='', /)

   이 정적 메서드는 "str.translate()" 에 사용할 수 있는 변환표를 돌려
   줍니다.

   인자가 하나만 있으면 유니코드 포인트 (정수) 또는 문자 (길이가 1인
   문자열)를 유니코드 포인트, 문자열 (임의 길이) 또는 "None" 으로 매핑
   하는 딕셔너리여야 합니다. 문자 키는 유니코드 포인트로 변환됩니다.

   If there are two arguments, they must be strings of equal length,
   and in the resulting dictionary, each character in *from* will be
   mapped to the character at the same position in *to*.  If there is
   a third argument, it must be a string, whose characters will be
   mapped to "None" in the result.

str.partition(sep, /)

   *sep* 가 처음 나타나는 위치에서 문자열을 나누고, 구분자 앞에 있는
   부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍
   니다. 구분자가 발견되지 않으면, 문자열 자신과 그 뒤를 따르는 두 개
   의 빈 문자열로 구성된 3-튜플을 돌려줍니다.

str.removeprefix(prefix, /)

   문자열이 *prefix* 문자열로 시작하면, "string[len(prefix):]"를 반환
   합니다. 그렇지 않으면, 원래 문자열의 사본을 반환합니다:

      >>> 'TestHook'.removeprefix('Test')
      'Hook'
      >>> 'BaseTestCase'.removeprefix('Test')
      'BaseTestCase'

   Added in version 3.9.

str.removesuffix(suffix, /)

   문자열이 *suffix* 문자열로 끝나고 해당 *suffix*가 비어 있지 않으면,
   "string[:-len(suffix)]"를 반환합니다. 그렇지 않으면, 원래 문자열의
   사본을 반환합니다:

      >>> 'MiscTests'.removesuffix('Tests')
      'Misc'
      >>> 'TmpDirMixin'.removesuffix('Tests')
      'TmpDirMixin'

   Added in version 3.9.

str.replace(old, new, /, count=-1)

   Return a copy of the string with all occurrences of substring *old*
   replaced by *new*.  If *count* is given, only the first *count*
   occurrences are replaced. If *count* is not specified or "-1", then
   all occurrences are replaced.

   버전 3.13에서 변경: *count* is now supported as a keyword argument.

str.rfind(sub[, start[, end]])

   부분 문자열 *sub* 가 "s[start:end]" 내에 등장하는 가장 큰 문자열의
   인덱스를 돌려줍니다. 선택적 인자 *start* 와 *end* 는 슬라이스 표기
   법으로 해석됩니다. 실패하면 "-1" 을 돌려줍니다.

str.rindex(sub[, start[, end]])

   "rfind()"와 비슷하지만, 부분 문자열 *sub* 를 찾을 수 없는 경우
   "ValueError" 를 일으킵니다.

str.rjust(width, fillchar=' ', /)

   오른쪽으로 정렬된 문자열을 길이 *width* 인 문자열로 돌려줍니다. 지
   정된 *fillchar* (기본값은 ASCII 스페이스)을 사용하여 채웁니다.
   *width* 가 "len(s)" 보다 작거나 같은 경우 원래 문자열이 반환됩니다.

str.rpartition(sep, /)

   *sep* 가 마지막으로 나타나는 위치에서 문자열을 나누고, 구분자 앞에
   있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을
   돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 문자열과 그 뒤를
   따르는 문자열 자신으로 구성된 3-튜플을 돌려줍니다.

str.rsplit(sep=None, maxsplit=-1)

   *sep* 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를
   돌려줍니다. *maxsplit* 이 주어지면 가장 오른쪽에서 최대 *maxsplit*
   번의 분할이 수행됩니다. *sep* 이 지정되지 않거나 "None" 이면, 구분
   자로 모든 공백 문자가 사용됩니다. 오른쪽에서 분리하는 것을 제외하면
   , "rsplit()"는 아래에서 자세히 설명될 "split()"처럼 동작합니다.

str.rstrip(chars=None, /)

   후행 문자가 제거된 문자열의 복사본을 돌려줍니다. *chars* 인자는 제
   거할 문자 집합을 지정하는 문자열입니다. 생략되거나 "None" 이라면,
   *chars* 인자의 기본값은 공백을 제거하도록 합니다. *chars* 인자는 접
   미사가 아닙니다; 모든 값 조합이 제거됩니다:

      >>> '   spacious   '.rstrip()
      '   spacious'
      >>> 'mississippi'.rstrip('ipz')
      'mississ'

   문자 집합의 모든 것이 아닌 단일 접미사 문자열을 제거하는 메서드는
   "str.removesuffix()"를 참조하십시오. 예를 들면:

      >>> 'Monty Python'.rstrip(' Python')
      'M'
      >>> 'Monty Python'.removesuffix(' Python')
      'Monty'

str.split(sep=None, maxsplit=-1)

   *sep* 를 구분자 문자열로 사용하여 문자열에 있는 단어들의 리스트를
   돌려줍니다. *maxsplit* 이 주어지면 최대 *maxsplit* 번의 분할이 수행
   됩니다 (따라서, 리스트는 최대 "maxsplit+1" 개의 요소를 가지게 됩니
   다). *maxsplit* 이 지정되지 않았거나 "-1" 이라면 분할 수에 제한이
   없습니다 (가능한 모든 분할이 만들어집니다).

   If *sep* is given, consecutive delimiters are not grouped together
   and are deemed to delimit empty strings (for example,
   "'1,,2'.split(',')" returns "['1', '', '2']").  The *sep* argument
   may consist of multiple characters as a single delimiter (to split
   with multiple delimiters, use "re.split()"). Splitting an empty
   string with a specified separator returns "['']".

   예를 들면:

      >>> '1,2,3'.split(',')
      ['1', '2', '3']
      >>> '1,2,3'.split(',', maxsplit=1)
      ['1', '2,3']
      >>> '1,2,,3,'.split(',')
      ['1', '2', '', '3', '']
      >>> '1<>2<>3<4'.split('<>')
      ['1', '2', '3<4']

   *sep* 이 지정되지 않거나 "None" 이면, 다른 분할 알고리즘이 적용됩니
   다: 연속된 공백 문자는 단일한 구분자로 간주하고, 문자열이 선행이나
   후행 공백을 포함해도 결과는 시작과 끝에 빈 문자열을 포함하지 않습니
   다. 결과적으로, 빈 문자열이나 공백만으로 구성된 문자열을 "None" 구
   분자로 나누면 "[]" 를 돌려줍니다.

   예를 들면:

      >>> '1 2 3'.split()
      ['1', '2', '3']
      >>> '1 2 3'.split(maxsplit=1)
      ['1', '2 3']
      >>> '   1   2   3   '.split()
      ['1', '2', '3']

   If *sep* is not specified or is "None" and  *maxsplit* is "0", only
   leading runs of consecutive whitespace are considered.

   예를 들면:

      >>> "".split(None, 0)
      []
      >>> "   ".split(None, 0)
      []
      >>> "   foo   ".split(maxsplit=0)
      ['foo   ']

   See also "join()".

str.splitlines(keepends=False)

   줄 경계에서 나눈 문자열의 줄 리스트를 돌려줍니다. *keepends* 가 참
   으로 주어지지 않는 한 결과 리스트에 줄 바꿈은 포함되지 않습니다.

   이 메서드는 다음 줄 경계에서 나눕니다. 특히, 경계는 *유니버설 줄 넘
   김* 을 포함합니다.

   +-------------------------+-------------------------------+
   | 표현                    | 설명                          |
   |=========================|===============================|
   | "\n"                    | 줄 넘김                       |
   +-------------------------+-------------------------------+
   | "\r"                    | 캐리지 리턴                   |
   +-------------------------+-------------------------------+
   | "\r\n"                  | 캐리지 리턴 + 줄 넘김         |
   +-------------------------+-------------------------------+
   | "\v" 또는 "\x0b"        | 수직 탭                       |
   +-------------------------+-------------------------------+
   | "\f" 또는 "\x0c"        | 폼 피드                       |
   +-------------------------+-------------------------------+
   | "\x1c"                  | 파일 구분자                   |
   +-------------------------+-------------------------------+
   | "\x1d"                  | 그룹 구분자                   |
   +-------------------------+-------------------------------+
   | "\x1e"                  | 레코드 구분자                 |
   +-------------------------+-------------------------------+
   | "\x85"                  | 다음 줄 (C1 제어 코드)        |
   +-------------------------+-------------------------------+
   | "\u2028"                | 줄 구분자                     |
   +-------------------------+-------------------------------+
   | "\u2029"                | 문단 구분자                   |
   +-------------------------+-------------------------------+

   버전 3.2에서 변경: "\v" 와 "\f" 를 줄 경계 목록에 추가했습니다.

   예를 들면:

      >>> 'ab c\n\nde fg\rkl\r\n'.splitlines()
      ['ab c', '', 'de fg', 'kl']
      >>> 'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
      ['ab c\n', '\n', 'de fg\r', 'kl\r\n']

   구분자 문자열 *sep* 이 주어졌을 때 "split()" 와 달리, 이 메서드는
   빈 문자열에 대해서 빈 리스트를 돌려주고, 마지막 줄 바꿈은 새 줄을
   만들지 않습니다:

      >>> "".splitlines()
      []
      >>> "One line\n".splitlines()
      ['One line']

   비교해 보면, "split('\n')" 는 이렇게 됩니다:

      >>> ''.split('\n')
      ['']
      >>> 'Two lines\n'.split('\n')
      ['Two lines', '']

str.startswith(prefix[, start[, end]])

   문자열이 지정된 *prefix* 로 시작하면 "True" 를 돌려주고, 그렇지 않
   으면 "False" 를 돌려줍니다. *prefix* 는 찾고자 하는 접두사들의 튜플
   이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에서 검사를
   시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를 중단합니
   다.

str.strip(chars=None, /)

   선행과 후행 문자가 제거된 문자열의 복사본을 돌려줍니다. *chars* 인
   자는 제거할 문자 집합을 지정하는 문자열입니다. 생략되거나 "None" 이
   라면, *chars* 인자의 기본값은 공백을 제거하도록 합니다. *chars* 인
   자는 접두사나 접미사가 아닙니다; 모든 값 조합이 제거됩니다:

      >>> '   spacious   '.strip()
      'spacious'
      >>> 'www.example.com'.strip('cmowz.')
      'example'

   가장 바깥쪽의 선행 또는 후행 *chars* 인자 값들이 문자열에서 제거됩
   니다. 문자는 *chars* 에 있는 문자 집합에 포함되지 않은 문자에 도달
   할 때까지 맨 앞에서 제거됩니다. 끝에서도 유사한 동작이 수행됩니다.
   예를 들면:

      >>> comment_string = '#....... Section 3.2.1 Issue #32 .......'
      >>> comment_string.strip('.#! ')
      'Section 3.2.1 Issue #32'

str.swapcase()

   대문자를 소문자로, 그 반대로 마찬가지로 변환 한 문자열의 복사본을
   돌려줍니다. "s.swapcase().swapcase() == s" 가 반드시 성립하지 않음
   에 주의하십시오.

str.title()

   단어가 대문자로 시작하고 나머지 문자는 소문자가 되도록 문자열의 제
   목 케이스 버전을 돌려줍니다.

   예를 들면:

      >>> 'Hello world'.title()
      'Hello World'

   이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의
   를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 소유의 아
   포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과
   가 아닐 수도 있습니다:

      >>> "they're bill's friends from the UK".title()
      "They'Re Bill'S Friends From The Uk"

   The "string.capwords()" function does not have this problem, as it
   splits words on spaces only.

   Alternatively, a workaround for apostrophes can be constructed
   using regular expressions:

      >>> import re
      >>> def titlecase(s):
      ...     return re.sub(r"[A-Za-z]+('[A-Za-z]+)?",
      ...                   lambda mo: mo.group(0).capitalize(),
      ...                   s)
      ...
      >>> titlecase("they're bill's friends.")
      "They're Bill's Friends."

   See also "istitle()".

str.translate(table, /)

   Return a copy of the string in which each character has been mapped
   through the given translation table.  The table must be an object
   that implements indexing via "__getitem__()", typically a *mapping*
   or *sequence*.  When indexed by a Unicode ordinal (an integer), the
   table object can do any of the following: return a Unicode ordinal
   or a string, to map the character to one or more other characters;
   return "None", to delete the character from the return string; or
   raise a "LookupError" exception, to map the character to itself.

   "str.maketrans()" 를 사용하여 다른 형식의 문자 대 문자 매핑으로 부
   터 변환 맵을 만들 수 있습니다.

   커스텀 문자 매핑에 대한 보다 유연한 접근법은 "codecs" 모듈을 참고하
   십시오.

str.upper()

   모든 케이스 문자 [4] 가 대문자로 변환된 문자열의 복사본을 돌려줍니
   다. "s" 가 케이스 없는 문자를 포함하거나 결과 문자의 유니코드 범주
   가 "Lu" (Letter, 대문자) 가 아닌 경우, 예를 들어 "Lt" (Letter, 제목
   케이스), "s.upper().isupper()" 가 "False" 일 수 있음에 주의하십시오
   .

   The uppercasing algorithm used is described in section 3.13
   'Default Case Folding' of the Unicode Standard.

str.zfill(width, /)

   길이가 *width* 인 문자열을 만들기 위해 ASCII "'0'" 문자를 왼쪽에 채
   운 문자열의 복사본을 돌려줍니다. 선행 부호 접두어("'+'"/"'-'")는 부
   호 문자의 앞이 아니라 *뒤* 에 채워 넣는 것으로 처리됩니다. *width*
   가 "len(s)" 보다 작거나 같은 경우 원래 문자열을 돌려줍니다.

   예를 들면:

      >>> "42".zfill(5)
      '00042'
      >>> "-42".zfill(5)
      '-0042'


Formatted String Literals (f-strings)
-------------------------------------

Added in version 3.6.

버전 3.7에서 변경: The "await" and "async for" can be used in
expressions within f-strings.

버전 3.8에서 변경: Added the debug specifier ("=")

버전 3.12에서 변경: Many restrictions on expressions within f-strings
have been removed. Notably, nested strings, comments, and backslashes
are now permitted.

An *f-string* (formally a *formatted string literal*) is a string
literal that is prefixed with "f" or "F". This type of string literal
allows embedding the results of arbitrary Python expressions within
*replacement fields*, which are delimited by curly brackets ("{}").
Each replacement field must contain an expression, optionally followed
by:

* a *debug specifier* -- an equal sign ("=");

* a *conversion specifier* -- "!s", "!r" or "!a"; and/or

* a *format specifier* prefixed with a colon (":").

See the Lexical Analysis section on f-strings for details on the
syntax of these fields.


Debug specifier
~~~~~~~~~~~~~~~

Added in version 3.8.

If a debug specifier -- an equal sign ("=") -- appears after the
replacement field expression, the resulting f-string will contain the
expression's source, the equal sign, and the value of the expression.
This is often useful for debugging:

   >>> number = 14.3
   >>> f'{number=}'
   'number=14.3'

Whitespace before, inside and after the expression, as well as
whitespace after the equal sign, is significant --- it is retained in
the result:

   >>> f'{ number  -  4  = }'
   ' number  -  4  = 10.3'


Conversion specifier
~~~~~~~~~~~~~~~~~~~~

By default, the value of a replacement field expression is converted
to a string using "str()":

   >>> from fractions import Fraction
   >>> one_third = Fraction(1, 3)
   >>> f'{one_third}'
   '1/3'

When a debug specifier but no format specifier is used, the default
conversion instead uses "repr()":

   >>> f'{one_third = }'
   'one_third = Fraction(1, 3)'

The conversion can be specified explicitly using one of these
specifiers:

* "!s" for "str()"

* "!r" for "repr()"

* "!a" for "ascii()"

예를 들면:

   >>> str(one_third)
   '1/3'
   >>> repr(one_third)
   'Fraction(1, 3)'

   >>> f'{one_third!s} is {one_third!r}'
   '1/3 is Fraction(1, 3)'

   >>> string = "¡kočka 😸!"
   >>> ascii(string)
   "'\\xa1ko\\u010dka \\U0001f638!'"

   >>> f'{string = !a}'
   "string = '\\xa1ko\\u010dka \\U0001f638!'"


Format specifier
~~~~~~~~~~~~~~~~

After the expression has been evaluated, and possibly converted using
an explicit conversion specifier, it is formatted using the "format()"
function. If the replacement field includes a *format specifier*
introduced by a colon (":"), the specifier is passed to "format()" as
the second argument. The result of "format()" is then used as the
final value for the replacement field. For example:

   >>> from fractions import Fraction
   >>> one_third = Fraction(1, 3)
   >>> f'{one_third:.6f}'
   '0.333333'
   >>> f'{one_third:_^+10}'
   '___+1/3___'
   >>> >>> f'{one_third!r:_^20}'
   '___Fraction(1, 3)___'
   >>> f'{one_third = :~>10}~'
   'one_third = ~~~~~~~1/3~'


Template String Literals (t-strings)
------------------------------------

An *t-string* (formally a *template string literal*) is a string
literal that is prefixed with "t" or "T".

These strings follow the same syntax and evaluation rules as formatted
string literals, with for the following differences:

* Rather than evaluating to a "str" object, template string literals
  evaluate to a "string.templatelib.Template" object.

* The "format()" protocol is not used. Instead, the format specifier
  and conversions (if any) are passed to a new "Interpolation" object
  that is created for each evaluated expression. It is up to code that
  processes the resulting "Template" object to decide how to handle
  format specifiers and conversions.

* Format specifiers containing nested replacement fields are evaluated
  eagerly, prior to being passed to the "Interpolation" object. For
  instance, an interpolation of the form "{amount:.{precision}f}" will
  evaluate the inner expression "{precision}" to determine the value
  of the "format_spec" attribute. If "precision" were to be "2", the
  resulting format specifier would be "'.2f'".

* When the equals sign "'='" is provided in an interpolation
  expression, the text of the expression is appended to the literal
  string that precedes the relevant interpolation. This includes the
  equals sign and any surrounding whitespace. The "Interpolation"
  instance for the expression will be created as normal, except that
  "conversion" will be set to '"r"' ("repr()") by default. If an
  explicit conversion or format specifier are provided, this will
  override the default behaviour.


"printf" 스타일 문자열 포매팅
-----------------------------

참고:

  The formatting operations described here exhibit a variety of quirks
  that lead to a number of common errors (such as failing to display
  tuples and dictionaries correctly).Using formatted string literals,
  the "str.format()" interface, or "string.Template" may help avoid
  these errors. Each of these alternatives provides their own trade-
  offs and benefits of simplicity, flexibility, and/or extensibility.

String objects have one unique built-in operation: the "%" operator
(modulo). This is also known as the string *formatting* or
*interpolation* operator. Given "format % values" (where *format* is a
string), "%" conversion specifications in *format* are replaced with
zero or more elements of *values*. The effect is similar to using the
"sprintf()" function in the C language. For example:

   >>> print('%s has %d quote types.' % ('Python', 2))
   Python has 2 quote types.

*format* 이 하나의 인자를 요구하면, *values* 는 하나의 비 튜플 객체 일
수 있습니다. [5] 그렇지 않으면, *values* 는 format 문자열이 지정하는
항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어, 딕셔너리) 이어
야 합니다.

변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포
함하는데, 반드시 이 순서대로 나와야 합니다:

1. "'%'" 문자: 명세의 시작을 나타냅니다.

2. 매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (
   예를 들어, "(somename)").

3. 변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다.

4. 최소 필드 폭 (선택 사항): "'*'" (애스터리스크) 로 지정하면, 실제 폭
   은 *values* 튜플의 다음 요소에서 읽히고, 변환할 객체는 최소 필드 폭
   과 선택적 정밀도 뒤에 옵니다.

5. 정밀도 (선택 사항): "'.'" (점) 다음에 정밀도가 옵니다. "'*'" (애스
   터리스크) 로 지정하면, 실제 정밀도는 *values* 튜플의 다음 요소에서
   읽히고, 변환할 값은 정밀도 뒤에 옵니다.

6. 길이 수정자 (선택 사항).

7. 변환 유형.

오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 문자열에 있는 변환
명세는 *반드시* "'%'" 문자 바로 뒤에 그 딕셔너리의 매핑 키를 괄호로 둘
러싼 형태로 포함해야 합니다. 매핑 키는 포맷할 값을 매핑으로 부터 선택
합니다. 예를 들어:

>>> print('%(language)s has %(number)03d quote types.' %
...       {'language': "Python", "number": 2})
Python has 002 quote types.

이 경우 "*" 지정자를 사용할 수 없습니다 (순차적인 매개변수 목록이 필요
하기 때문입니다).

변환 플래그 문자는 다음과 같습니다:

+-----------+-----------------------------------------------------------------------+
| 플래그    | 뜻                                                                    |
|===========|=======================================================================|
| "'#'"     | 값 변환에 "대체 형식" (아래에 정의되어있습니다) 을 사용합니다.        |
+-----------+-----------------------------------------------------------------------+
| "'0'"     | 변환은 숫자 값의 경우 0으로 채웁니다.                                 |
+-----------+-----------------------------------------------------------------------+
| "'-'"     | 변환된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 "'0'" 변환보다 우선   |
|           | 합 니다).                                                             |
+-----------+-----------------------------------------------------------------------+
| "' '"     | (스페이스) 부호 있는 변환 때문에 만들어진 양수 앞에 빈칸을 남겨둡니다 |
|           | (음수면 빈 문자열입니다).                                             |
+-----------+-----------------------------------------------------------------------+
| "'+'"     | 부호 문자 ("'+'" or "'-'") 가 변환 앞에 놓입니다 ("' '" 플래그에 우선 |
|           | 합니다).                                                              |
+-----------+-----------------------------------------------------------------------+

길이 수정자 ("h", "l", "L") 를 제공할 수는 있지만, 파이썬에서 필요하지
않기 때문에 무시됩니다 -- 예를 들어 "%ld" 는 "%d" 와 같습니다.

변환 유형은 다음과 같습니다:

+--------------+-------------------------------------------------------+---------+
| 변환         | 뜻                                                    | 노트    |
|==============|=======================================================|=========|
| "'d'"        | 부호 있는 정수 십진 표기.                             |         |
+--------------+-------------------------------------------------------+---------+
| "'i'"        | 부호 있는 정수 십진 표기.                             |         |
+--------------+-------------------------------------------------------+---------+
| "'o'"        | 부호 있는 8진수 값.                                   | (1)     |
+--------------+-------------------------------------------------------+---------+
| "'u'"        | 쓸데없는 유형 -- "'d'" 와 같습니다.                   | (6)     |
+--------------+-------------------------------------------------------+---------+
| "'x'"        | 부호 있는 16진수 (소문자).                            | (2)     |
+--------------+-------------------------------------------------------+---------+
| "'X'"        | 부호 있는 16진수 (대문자).                            | (2)     |
+--------------+-------------------------------------------------------+---------+
| "'e'"        | Floating-point exponential format (lowercase).        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'E'"        | Floating-point exponential format (uppercase).        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'f'"        | Floating-point decimal format.                        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'F'"        | Floating-point decimal format.                        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'g'"        | Floating-point format. Uses lowercase exponential     | (4)     |
|              | format if exponent is less than -4 or not less than   |         |
|              | precision, decimal format otherwise.                  |         |
+--------------+-------------------------------------------------------+---------+
| "'G'"        | Floating-point format. Uses uppercase exponential     | (4)     |
|              | format if exponent is less than -4 or not less than   |         |
|              | precision, decimal format otherwise.                  |         |
+--------------+-------------------------------------------------------+---------+
| "'c'"        | 단일 문자 (정수 또는 길이 1인 문자열을 허용합니다).   |         |
+--------------+-------------------------------------------------------+---------+
| "'r'"        | 문자열 ("repr()"을 사용하여 파이썬 객체를 변환합니다  | (5)     |
|              | ).                                                    |         |
+--------------+-------------------------------------------------------+---------+
| "'s'"        | 문자열 ("str()" 을 사용하여 파이썬 객체를 변환합니다  | (5)     |
|              | ).                                                    |         |
+--------------+-------------------------------------------------------+---------+
| "'a'"        | 문자열 ("ascii()" 를 사용하여 파이썬 객체를 변환합니  | (5)     |
|              | 다).                                                  |         |
+--------------+-------------------------------------------------------+---------+
| "'%'"        | 인자는 변환되지 않고, 결과에 "'%'" 문자가 표시됩니다. |         |
+--------------+-------------------------------------------------------+---------+

노트:

1. 대체 형식은 첫 번째 숫자 앞에 선행 8진수 지정자 ("'0o'")를 삽입합니
   다.

2. 대체 형식은 첫 번째 숫자 앞에 선행 "'0x'" 또는 "'0X'" ("'x'" 나
   "'X'" 유형 중 어느 것을 사용하느냐에 따라 달라집니다) 를 삽입합니다
   .

3. 대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함합니다
   .

   정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다.

4. 대체 형식은 결과에 항상 소수점을 포함하고 뒤에 오는 0은 제거되지 않
   습니다.

   정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다.

5. 정밀도가 "N" 이라면, 출력은 "N" 문자로 잘립니다.

6. **PEP 237**을 참조하세요.

파이썬 문자열은 명시적인 길이를 가지고 있으므로, "%s" 변환은 문자열의
끝이 "'\0'" 이라고 가정하지 않습니다.

버전 3.1에서 변경: 절댓값이 1e50 을 넘는 숫자에 대한 "%f" 변환은 더는
"%g" 변환으로 대체되지 않습니다.


바이너리 시퀀스 형 --- "bytes", "bytearray", "memoryview"
=========================================================

바이너리 데이터를 조작하기 위한 핵심 내장형은 "bytes" 와 "bytearray"
입니다. 이것들은 "memoryview" 에 의해 지원되는데, 다른 바이너리 객체들
의 메모리에 복사 없이 접근하기 위해 버퍼 프로토콜 을 사용합니다.

"array" 모듈은 32-비트 정수와 IEEE754 배정도 부동 소수점 같은 기본 데
이터형의 효율적인 저장을 지원합니다.


바이트열 객체
-------------

바이트열 객체는 단일 바이트들의 불변 시퀀스입니다. 많은 주요 바이너리
프로토콜이 ASCII 텍스트 인코딩을 기반으로 하므로, 바이트열 객체는
ASCII 호환 데이터로 작업 할 때만 유효한 여러 가지 메서드를 제공하며 다
양한 다른 방법으로 문자열 객체와 밀접한 관련이 있습니다.

class bytes(source=b'')
class bytes(source, encoding, errors='strict')

   첫째로, 바이트열 리터럴의 문법은 문자열 리터럴과 거의 같지만 "b" 접
   두사가 추가된다는 점이 다릅니다.:

   * 작은따옴표: "b'still allows embedded "double" quotes'"

   * Double quotes: "b"still allows embedded 'single' quotes""

   * 삼중 따옴표: "b'''3 single quotes'''", "b"""3 double quotes""""

   바이트열 리터럴에는 ASCII 문자만 허용됩니다 (선언된 소스 코드 인코
   딩과 관계없습니다). 127 보다 큰 바이너리 값은 적절한 이스케이프 시
   퀀스를 사용하여 바이트열 리터럴에 입력해야 합니다.

   문자열 리터럴의 경우와 마찬가지로 바이트열 리터럴은 이스케이프 시퀀
   스 처리를 비활성화하기 위해 "r" 접두사를 사용할 수도 있습니다. 지원
   되는 이스케이프 시퀀스를 포함하여 바이트열 리터럴의 다양한 형식에
   대한 자세한 내용은 문자열과 바이트열 리터럴 을 참조하십시오.

   바이트열 리터럴과 그 표현은 ASCII 텍스트를 기반으로 하지만, 바이트
   열 객체는 실제로는 정수의 불변 시퀀스처럼 동작하고, 시퀀스의 각 값
   은 "0 <= x < 256" 이 되도록 제한됩니다 (이 제한을 위반하려고 시도하
   면 "ValueError" 를 일으킵니다). 이것은 많은 바이너리 형식이 ASCII
   기반 요소를 포함하고 일부 텍스트 지향 알고리즘으로 유용하게 조작될
   수 있지만, 임의의 바이너리 데이터에 일반적으로 적용될 수는 없음을
   강조하기 위한 것입니다 (텍스트 처리 알고리즘을 맹목적으로 ASCII 호
   환이 아닌 바이너리 데이터 형식에 적용하면 대개 데이터 손상으로 이어
   집니다).

   리터럴 형식 외에도, 바이트열 객체는 여러 가지 다른 방법으로 만들 수
   있습니다.:

   * 지정된 길이의 0으로 채워진 바이트열 객체: "bytes(10)"

   * 정수의 이터러블로부터: "bytes(range(20))"

   * 버퍼 프로토콜을 통해 기존 바이너리 데이터 복사: "bytes(obj)"

   내장 bytes 도 참조하세요.

   2개의 16진수는 정확히 하나의 바이트에 대응하기 때문에 16진수는 바이
   너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. 따라서,
   바이트열 형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습니
   다:

   classmethod fromhex(string, /)

      이 "bytes" 클래스 메서드는 주어진 문자열 객체를 디코딩해서 바이
      트열 객체를 돌려줍니다. 문자열은 바이트 당 두 개의 16진수가 포함
      되어야 하며 ASCII 공백은 무시됩니다.

      >>> bytes.fromhex('2Ef0 F1f2  ')
      b'.\xf0\xf1\xf2'

      버전 3.7에서 변경: 이제 "bytes.fromhex()" 는 스페이스뿐만 아니라
      문자열에 있는 모든 ASCII 공백을 건너뜁니다.

      버전 3.14에서 변경: "bytes.fromhex()" now accepts ASCII "bytes"
      and *bytes-like objects* as input.

   바이트열 객체를 16진수 표현으로 변환하기 위한 역변환 함수가 있습니
   다.

   hex(*, bytes_per_sep=1)
   hex(sep, bytes_per_sep=1)

      인스턴스의 바이트마다 2 자릿수의 16진수로 표현한 문자열 객체를
      돌려줍니다.

      >>> b'\xf0\xf1\xf2'.hex()
      'f0f1f2'

      If you want to make the hex string easier to read, you can
      specify a single character separator *sep* parameter to include
      in the output. By default, this separator will be included
      between each byte. A second optional *bytes_per_sep* parameter
      controls the spacing. Positive values calculate the separator
      position from the right, negative values from the left.

      >>> value = b'\xf0\xf1\xf2'
      >>> value.hex('-')
      'f0-f1-f2'
      >>> value.hex('_', 2)
      'f0_f1f2'
      >>> b'UUDDLRLRAB'.hex(' ', -4)
      '55554444 4c524c52 4142'

      Added in version 3.5.

      버전 3.8에서 변경: 이제 "bytes.hex()"는 16진수 출력의 바이트 사
      이에 구분 기호를 삽입하기 위해 선택적 *sep*과 *bytes_per_sep* 매
      개 변수를 지원합니다.

바이트열 객체는 정수의 시퀀스(튜플과 유사)이기 때문에, 바이트열 객체
*b* 에 대해서, "b[0]" 는 정수가 됩니다. 반면, "b[0:1]" 는 길이 1인 바
이트열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인 문자열을
생성하는 텍스트 문자열과 대조됩니다)

바이트열 객체의 표현은 리터럴 형식 ("b'...'") 을 사용하는데, 종종
"bytes([46, 46, 46])" 보다 유용하기 때문입니다. "list(b)" 를 사용하면
바이트열 객체를 항상 정수 리스트로 변환할 수 있습니다.


바이트 배열 객체
----------------

"bytearray" 객체는 "bytes" 객체의 가변형입니다.

class bytearray(source=b'')
class bytearray(source, encoding, errors='strict')

   바이트 배열 객체에 대한 전용 리터럴 문법은 없으며 항상 생성자를 호
   출하여 만듭니다:

   * 빈 인스턴스 만들기: "bytearray()"

   * 주어진 길이의 0으로 채워진 인스턴스 만들기: "bytearray(10)"

   * 정수의 이터러블로부터: "bytearray(range(20))"

   * 버퍼 프로토콜을 통해 기존 바이너리 데이터 복사:
     "bytearray(b'Hi!')"

   바이트 배열 객체는 가변이기 때문에, 바이트열 과 바이트 배열 연산 에
   설명되어있는 공통 바이트열과 바이트 배열 연산에 더해, 가변 시퀀스
   연산도 지원합니다.

   내장 bytearray 도 참조하세요.

   2개의 16진수는 정확히 하나의 바이트에 대응하기 때문에 16진수는 바이
   너리 데이터를 설명하는 데 일반적으로 사용되는 형식입니다. 따라서,
   바이트 배열형은 그 형식의 데이터를 읽는 추가의 클래스 메서드를 갖습
   니다:

   classmethod fromhex(string, /)

      이 "bytearray" 클래스 메서드는 주어진 문자열 객체를 디코딩해서
      바이트 배열 객체를 돌려줍니다. 문자열은 바이트 당 두 개의 16진수
      가 포함되어야 하며 ASCII 공백은 무시됩니다.

      >>> bytearray.fromhex('2Ef0 F1f2  ')
      bytearray(b'.\xf0\xf1\xf2')

      버전 3.7에서 변경: 이제 "bytearray.fromhex()" 는 스페이스뿐만 아
      니라 문자열에 있는 모든 ASCII 공백을 건너뜁니다.

      버전 3.14에서 변경: "bytearray.fromhex()" now accepts ASCII
      "bytes" and *bytes-like objects* as input.

   바이트 배열 객체를 16진수 표현으로 변환하기 위한 역변환 함수가 있습
   니다.

   hex(*, bytes_per_sep=1)
   hex(sep, bytes_per_sep=1)

      인스턴스의 바이트마다 2 자릿수의 16진수로 표현한 문자열 객체를
      돌려줍니다.

      >>> bytearray(b'\xf0\xf1\xf2').hex()
      'f0f1f2'

      Added in version 3.5.

      버전 3.8에서 변경: "bytes.hex()"와 비슷하게, 이제
      "bytearray.hex()"는 16진수 출력의 바이트 사이에 구분 기호를 삽입
      하기 위해 선택적 *sep*과 *bytes_per_sep* 매개 변수를 지원합니다.

   resize(size, /)

      Resize the "bytearray" to contain *size* bytes. *size* must be
      greater than or equal to 0.

      If the "bytearray" needs to shrink, bytes beyond *size* are
      truncated.

      If the "bytearray" needs to grow, all new bytes, those beyond
      *size*, will be set to null bytes.

      This is equivalent to:

      >>> def resize(ba, size):
      ...     if len(ba) > size:
      ...         del ba[size:]
      ...     else:
      ...         ba += b'\0' * (size - len(ba))

      Examples:

      >>> shrink = bytearray(b'abc')
      >>> shrink.resize(1)
      >>> (shrink, len(shrink))
      (bytearray(b'a'), 1)
      >>> grow = bytearray(b'abc')
      >>> grow.resize(5)
      >>> (grow, len(grow))
      (bytearray(b'abc\x00\x00'), 5)

      Added in version 3.14.

바이트 배열 객체는 정수의 시퀀스(리스트와 유사)이기 때문에, 바이트 배
열 객체 *b* 에 대해서, "b[0]" 는 정수가 됩니다. 반면, "b[0:1]" 는 길이
1인 바이트 배열 객체가 됩니다. (이것은 인덱싱과 슬라이싱 모두 길이 1인
문자열을 생성하는 텍스트 문자열과 대조됩니다)

바이트 배열 객체의 표현은 바이트열 리터럴 형식 ("bytearray(b'...')")
을 사용하는데, 종종 "bytearray([46, 46, 46])" 보다 유용하기 때문입니다
. "list(b)" 를 사용하면 바이트 배열 객체를 항상 정수 리스트로 변환할
수 있습니다.


바이트열 과 바이트 배열 연산
----------------------------

바이트열와 바이트 배열 객체는 공통 시퀀스 연산을 지원합니다. 이것들은
같은 형의 피연산자뿐만 아니라 모든 *bytes-like object*와 상호 운용됩니
다. 이러한 유연성으로 인해, 오류 없이 작업을 자유롭게 혼합할 수 있습니
다. 그러나, 결과의 반환형은 피연산자의 순서에 따라 달라질 수 있습니다.

참고:

  바이트열 및 바이트 배열 객체의 메서드는 인자로 문자열을 받아들이지
  않습니다, 문자열의 메서드가 바이트열을 인자로 허용하지 않는 것과 마
  찬가지입니다. 예를 들어, 다음과 같이 작성해야 합니다:

     a = "abc"
     b = a.replace("a", "f")

  그리고:

     a = b"abc"
     b = a.replace(b"a", b"f")

일부 바이트열 및 바이트 배열 연산은 ASCII 호환 바이너리 형식을 가정하
므로, 임의의 바이너리 데이터로 작업 할 때는 피해야 합니다. 이러한 제한
사항은 아래에서 다룹니다.

참고:

  이러한 ASCII 기반 연산을 사용하여 ASCII 기반 형식으로 저장되지 않은
  바이너리 데이터를 조작하면 데이터가 손상될 수 있습니다.

바이트열 및 바이트 배열 객체에 대한 다음 메서드는 임의의 바이너리 데이
터와 함께 사용할 수 있습니다.

bytes.count(sub[, start[, end]])
bytearray.count(sub[, start[, end]])

   범위 [*start*, *end*] 에서 서브 시퀀스 *sub* 가 중첩되지 않고 등장
   하는 횟수를 돌려줍니다. 선택적 인자 *start* 와 *end* 는 슬라이스 표
   기법으로 해석됩니다.

   검색할 서브 시퀀스는 임의의 *bytes-like object* 또는 0에서 255 사이
   의 정수일 수 있습니다.

   If *sub* is empty, returns the number of empty slices between
   characters which is the length of the bytes object plus one.

   버전 3.3에서 변경: 서브 시퀀스로 0에서 255 사이의 정수도 허용합니다
   .

bytes.removeprefix(prefix, /)
bytearray.removeprefix(prefix, /)

   바이너리 데이터가 *prefix* 문자열로 시작하면, "bytes[len(prefix):]"
   를 반환합니다. 그렇지 않으면, 원래 바이너리 데이터의 사본을 반환합
   니다:

      >>> b'TestHook'.removeprefix(b'Test')
      b'Hook'
      >>> b'BaseTestCase'.removeprefix(b'Test')
      b'BaseTestCase'

   *prefix*는 임의의 *바이트열류 객체* 일 수 있습니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

   Added in version 3.9.

bytes.removesuffix(suffix, /)
bytearray.removesuffix(suffix, /)

   바이너리 데이터가 *suffix* 문자열로 끝나고 해당 *suffix*가 비어 있
   지 않으면 "bytes[:-len(suffix)]"를 반환합니다. 그렇지 않으면, 원래
   바이너리 데이터의 사본을 반환합니다:

      >>> b'MiscTests'.removesuffix(b'Tests')
      b'Misc'
      >>> b'TmpDirMixin'.removesuffix(b'Tests')
      b'TmpDirMixin'

   *suffix*는 임의의 *바이트열류 객체* 일 수 있습니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

   Added in version 3.9.

bytes.decode(encoding='utf-8', errors='strict')
bytearray.decode(encoding='utf-8', errors='strict')

   Return the bytes decoded to a "str".

   *encoding* defaults to "'utf-8'"; see 표준 인코딩 for possible
   values.

   *errors* controls how decoding errors are handled. If "'strict'"
   (the default), a "UnicodeError" exception is raised. Other possible
   values are "'ignore'", "'replace'", and any other name registered
   via "codecs.register_error()". See 에러 처리기 for details.

   For performance reasons, the value of *errors* is not checked for
   validity unless a decoding error actually occurs, 파이썬 개발 모드
   is enabled or a debug build is used.

   참고:

     Passing the *encoding* argument to "str" allows decoding any
     *bytes-like object* directly, without needing to make a temporary
     "bytes" or "bytearray" object.

   버전 3.1에서 변경: 키워드 인자 지원이 추가되었습니다.

   버전 3.9에서 변경: The value of the *errors* argument is now
   checked in 파이썬 개발 모드 and in debug mode.

bytes.endswith(suffix[, start[, end]])
bytearray.endswith(suffix[, start[, end]])

   바이너리 데이터가 지정된 *suffix* 로 끝나면 "True" 를 돌려주고, 그
   렇지 않으면 "False" 를 돌려줍니다. *suffix* 는 찾고자 하는 접미사들
   의 튜플이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에서
   검사를 시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를 중
   단합니다.

   검색할 접미사(들)는 임의의 *bytes-like object* 일 수 있습니다.

bytes.find(sub[, start[, end]])
bytearray.find(sub[, start[, end]])

   서브 시퀀스 *sub* 가 슬라이스 "s[start:end]" 내에 등장하는 가장 작
   은 데이터의 인덱스를 돌려줍니다. 선택적 인자 *start* 와 *end* 는 슬
   라이스 표기법으로 해석됩니다. *sub* 가 없으면 "-1" 을 돌려줍니다.

   검색할 서브 시퀀스는 임의의 *bytes-like object* 또는 0에서 255 사이
   의 정수일 수 있습니다.

   참고:

     "find()" 메서드는 *sub* 의 위치를 알아야 할 경우에만 사용해야 합
     니다. *sub* 가 부분 문자열인지 여부를 확인하려면 "in" 연산자를 사
     용하십시오:

        >>> b'Py' in b'Python'
        True

   버전 3.3에서 변경: 서브 시퀀스로 0에서 255 사이의 정수도 허용합니다
   .

bytes.index(sub[, start[, end]])
bytearray.index(sub[, start[, end]])

   "find()" 과 비슷하지만, 서브 시퀀스를 찾을 수 없는 경우
   "ValueError" 를 일으킵니다.

   검색할 서브 시퀀스는 임의의 *bytes-like object* 또는 0에서 255 사이
   의 정수일 수 있습니다.

   버전 3.3에서 변경: 서브 시퀀스로 0에서 255 사이의 정수도 허용합니다
   .

bytes.join(iterable, /)
bytearray.join(iterable, /)

   *iterable* 의 바이너리 데이터 시퀀스들을 이어 붙이기 한 바이트열 또
   는 바이트 배열 객체를 돌려줍니다. *iterable* 에 "str" 객체나 기타
   *bytes-like object* 가 아닌 값이 있으면 "TypeError" 를 일으킵니다.
   요소들 사이의 구분자는 이 메서드를 제공하는 바이트열 이나 바이트 배
   열 객체입니다.

static bytes.maketrans(from, to, /)
static bytearray.maketrans(from, to, /)

   이 정적 메서드는 "bytes.translate()" 에 사용할 수 있는 변환표를 돌
   려주는데, *from* 에 있는 문자를 *to* 의 같은 위치에 있는 문자로 매
   핑합니다; *from* 과 *to* 는 모두 *bytes-like object* 여야 하고 길이
   가 같아야 합니다.

   Added in version 3.1.

bytes.partition(sep, /)
bytearray.partition(sep, /)

   *sep* 가 처음 나타나는 위치에서 시퀀스를 나누고, 구분자 앞에 있는
   부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을 돌려줍
   니다. 구분자가 발견되지 않으면, 원래 시퀀스의 복사본과 그 뒤를 따르
   는 두 개의 빈 바이트열 또는 바이트 배열 객체로 구성된 3-튜플을 돌려
   줍니다.

   검색할 구분자는 임의의 *bytes-like object* 일 수 있습니다.

bytes.replace(old, new, count=-1, /)
bytearray.replace(old, new, count=-1, /)

   모든 서브 시퀀스 *old* 가 *new* 로 치환된 시퀀스의 복사본을 돌려줍
   니다. 선택적 인자 *count* 가 주어지면, 앞의 *count* 개만 치환됩니다
   .

   검색할 서브 시퀀스와 그 대체물은 임의의 *bytes-like object* 일 수
   있습니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.rfind(sub[, start[, end]])
bytearray.rfind(sub[, start[, end]])

   서브 시퀀스 *sub* 가 "s[start:end]" 내에 등장하는 가장 큰 시퀀스의
   인덱스를 돌려줍니다. 선택적 인자 *start* 와 *end* 는 슬라이스 표기
   법으로 해석됩니다. 실패하면 "-1" 을 돌려줍니다.

   검색할 서브 시퀀스는 임의의 *bytes-like object* 또는 0에서 255 사이
   의 정수일 수 있습니다.

   버전 3.3에서 변경: 서브 시퀀스로 0에서 255 사이의 정수도 허용합니다
   .

bytes.rindex(sub[, start[, end]])
bytearray.rindex(sub[, start[, end]])

   "rfind()" 와 비슷하지만, 서브 시퀀스 *sub* 를 찾을 수 없는 경우
   "ValueError" 를 일으킵니다.

   검색할 서브 시퀀스는 임의의 *bytes-like object* 또는 0에서 255 사이
   의 정수일 수 있습니다.

   버전 3.3에서 변경: 서브 시퀀스로 0에서 255 사이의 정수도 허용합니다
   .

bytes.rpartition(sep, /)
bytearray.rpartition(sep, /)

   *sep* 가 마지막으로 나타나는 위치에서 시퀀스를 나누고, 구분자 앞에
   있는 부분, 구분자 자체, 구분자 뒤에 오는 부분으로 구성된 3-튜플을
   돌려줍니다. 구분자가 발견되지 않으면, 두 개의 빈 바이트열 또는 바이
   트 배열 객체와 그 뒤를 따르는 원래 시퀀스의 복사본으로 구성된 3-튜
   플을 돌려줍니다.

   검색할 구분자는 임의의 *bytes-like object* 일 수 있습니다.

bytes.startswith(prefix[, start[, end]])
bytearray.startswith(prefix[, start[, end]])

   바이너리 데이터가 지정된 *prefix* 로 시작하면 "True" 를 돌려주고,
   그렇지 않으면 "False" 를 돌려줍니다. *prefix* 는 찾고자 하는 접두사
   들의 튜플이 될 수도 있습니다. 선택적 *start* 가 제공되면 그 위치에
   서 검사를 시작합니다. 선택적 *end* 를 사용하면 해당 위치에서 비교를
   중단합니다.

   검색할 접두사(들)는 임의의 *bytes-like object* 일 수 있습니다.

bytes.translate(table, /, delete=b'')
bytearray.translate(table, /, delete=b'')

   생략 가능한 인자 *delete* 의 모든 바이트를 제거하고, 나머지 바이트
   들을 주어진 변환표로 매핑한 바이트열이나 바이트 배열 객체의 복사본
   을 돌려줍니다. table은 길이 256인 바이트열 객체이어야 합니다.

   "bytes.maketrans()" 메서드를 사용하여 변환표를 만들 수 있습니다.

   문자를 지우기만 하는 변환에는 *table* 인자를 "None" 으로 설정하십시
   오:

      >>> b'read this short text'.translate(None, b'aeiou')
      b'rd ths shrt txt'

   버전 3.6에서 변경: 이제 *delete* 는 키워드 인자로 지원됩니다.

바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리
형식의 사용을 가정하는 기본 동작을 갖지만, 적절한 인자를 전달하여 임의
의 바이너리 데이터와 함께 사용할 수 있습니다. 이 섹션의 바이트 배열 메
서드는 모두 제자리에서 작동하지 않고 대신 새로운 객체를 생성함에 주의
하십시오.

bytes.center(width, fillbyte=b' ', /)
bytearray.center(width, fillbyte=b' ', /)

   길이 *width* 인 시퀀스의 가운데에 정렬한 객체의 복사본을 돌려줍니다
   . 지정된 *fillbyte* (기본값은 ASCII 스페이스)를 사용하여 채웁니다.
   "bytes" 객체의 경우, *width* 가 "len(s)" 보다 작거나 같은 경우 원래
   시퀀스가 반환됩니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.ljust(width, fillbyte=b' ', /)
bytearray.ljust(width, fillbyte=b' ', /)

   왼쪽으로 정렬된 객체의 복사본을 길이 *width* 인 시퀀스로 돌려줍니다
   . 지정된 *fillbyte* (기본값은 ASCII 스페이스)을 사용하여 채웁니다.
   "bytes" 객체의 경우, *width* 가 "len(s)" 보다 작거나 같은 경우 원래
   시퀀스가 반환됩니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.lstrip(bytes=None, /)
bytearray.lstrip(bytes=None, /)

   Return a copy of the sequence with specified leading bytes removed.
   The *bytes* argument is a binary sequence specifying the set of
   byte values to be removed.  If omitted or "None", the *bytes*
   argument defaults to removing ASCII whitespace.  The *bytes*
   argument is not a prefix; rather, all combinations of its values
   are stripped:

      >>> b'   spacious   '.lstrip()
      b'spacious   '
      >>> b'www.example.com'.lstrip(b'cmowz.')
      b'example.com'

   제거할 바이트 값의 바이너리 시퀀스는 임의의 *바이트열류 객체*일 수
   있습니다. 문자 집합의 모든 것이 아닌 단일 접두사 문자열을 제거하는
   메서드는 "removeprefix()"를 참조하십시오. 예를 들면:

      >>> b'Arthur: three!'.lstrip(b'Arthur: ')
      b'ee!'
      >>> b'Arthur: three!'.removeprefix(b'Arthur: ')
      b'three!'

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.rjust(width, fillbyte=b' ', /)
bytearray.rjust(width, fillbyte=b' ', /)

   오른쪽으로 정렬된 객체의 복사본을 길이 *width* 인 시퀀스로 돌려줍니
   다. 지정된 *fillbyte* (기본값은 ASCII 스페이스)를 사용하여 채웁니다
   . "bytes" 객체의 경우, *width* 가 "len(s)" 보다 작거나 같은 경우 원
   래 시퀀스가 반환됩니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.rsplit(sep=None, maxsplit=-1)
bytearray.rsplit(sep=None, maxsplit=-1)

   *sep* 을 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브
   시퀀스로 나눕니다. *maxsplit* 이 주어지면 가장 오른쪽에서 최대
   *maxsplit* 번의 분할이 수행됩니다. *sep* 이 지정되지 않거나 "None"
   이면, ASCII 공백 문자만으로 이루어진 모든 서브 시퀀스는 구분자입니
   다. 오른쪽에서 분리하는 것을 제외하면, "rsplit()"는 아래에서 자세히
   설명될 "split()"처럼 동작합니다.

bytes.rstrip(bytes=None, /)
bytearray.rstrip(bytes=None, /)

   Return a copy of the sequence with specified trailing bytes
   removed.  The *bytes* argument is a binary sequence specifying the
   set of byte values to be removed.  If omitted or "None", the
   *bytes* argument defaults to removing ASCII whitespace.  The
   *bytes* argument is not a suffix; rather, all combinations of its
   values are stripped:

      >>> b'   spacious   '.rstrip()
      b'   spacious'
      >>> b'mississippi'.rstrip(b'ipz')
      b'mississ'

   제거할 바이트 값의 바이너리 시퀀스는 임의의 *바이트열류 객체*일 수
   있습니다. 문자 집합의 모든 것이 아닌 단일 접미사 문자열을 제거하는
   메서드는 "removesuffix()"를 참조하십시오. 예를 들면:

      >>> b'Monty Python'.rstrip(b' Python')
      b'M'
      >>> b'Monty Python'.removesuffix(b' Python')
      b'Monty'

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.split(sep=None, maxsplit=-1)
bytearray.split(sep=None, maxsplit=-1)

   *sep* 를 구분자 시퀀스로 사용하여 바이너리 시퀀스를 같은 형의 서브
   시퀀스로 나눕니다. *maxsplit* 이 지정되고 음수가 아닌 경우, 최대
   *maxsplit* 분할이 수행됩니다 (따라서, 리스트는 최대 "maxsplit+1" 개
   의 요소를 가지게 됩니다). *maxsplit* 이 지정되지 않았거나 "-1" 이라
   면 분할 수에 제한이 없습니다 (가능한 모든 분할이 만들어집니다).

   If *sep* is given, consecutive delimiters are not grouped together
   and are deemed to delimit empty subsequences (for example,
   "b'1,,2'.split(b',')" returns "[b'1', b'', b'2']").  The *sep*
   argument may consist of a multibyte sequence as a single delimiter.
   Splitting an empty sequence with a specified separator returns
   "[b'']" or "[bytearray(b'')]" depending on the type of object being
   split.  The *sep* argument may be any *bytes-like object*.

   예를 들면:

      >>> b'1,2,3'.split(b',')
      [b'1', b'2', b'3']
      >>> b'1,2,3'.split(b',', maxsplit=1)
      [b'1', b'2,3']
      >>> b'1,2,,3,'.split(b',')
      [b'1', b'2', b'', b'3', b'']
      >>> b'1<>2<>3<4'.split(b'<>')
      [b'1', b'2', b'3<4']

   *sep* 이 지정되지 않거나 "None" 이면, 다른 분할 알고리즘이 적용됩니
   다: 연속된 ASCII 공백 문자는 단일한 구분자로 간주하고, 시퀀스가 선
   행이나 후행 공백을 포함해도 결과는 시작과 끝에 빈 시퀀스를 포함하지
   않습니다. 결과적으로, 빈 시퀀스나 ASCII 공백만으로 구성된 시퀀스를
   "None" 구분자로 나누면 "[]" 를 돌려줍니다.

   예를 들면:

      >>> b'1 2 3'.split()
      [b'1', b'2', b'3']
      >>> b'1 2 3'.split(maxsplit=1)
      [b'1', b'2 3']
      >>> b'   1   2   3   '.split()
      [b'1', b'2', b'3']

bytes.strip(bytes=None, /)
bytearray.strip(bytes=None, /)

   Return a copy of the sequence with specified leading and trailing
   bytes removed. The *bytes* argument is a binary sequence specifying
   the set of byte values to be removed.  If omitted or "None", the
   *bytes* argument defaults to removing ASCII whitespace. The *bytes*
   argument is not a prefix or suffix; rather, all combinations of its
   values are stripped:

      >>> b'   spacious   '.strip()
      b'spacious'
      >>> b'www.example.com'.strip(b'cmowz.')
      b'example'

   제거할 바이트 값의 바이너리 시퀀스는 임의의 *bytes-like object* 일
   수 있습니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

바이트열 및 바이트 배열 객체에 대한 다음 메서드는 ASCII 호환 바이너리
형식의 사용을 가정하며 임의의 바이너리 데이터에 적용하면 안 됩니다. 이
섹션의 바이트 배열 메서드는 모두 제자리에서 작동하지 *않고* 대신 새로
운 객체를 생성합니다.

bytes.capitalize()
bytearray.capitalize()

   각 바이트가 ASCII 문자로 해석되고 첫 번째 바이트는 대문자로, 나머지
   는 소문자로 만든 시퀀스의 복사본을 돌려줍니다. ASCII 바이트가 아닌
   값들은 변경되지 않고 전달됩니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.expandtabs(tabsize=8)
bytearray.expandtabs(tabsize=8)

   모든 ASCII 탭 문자들을 현재의 열과 주어진 탭 크기에 따라 하나나 그
   이상의 ASCII 스페이스로 치환한 시퀀스의 복사본을 돌려줍니다. 탭 위
   치는 *tabsize* 바이트마다 발생합니다 (기본값은 8이고, 열 0, 8, 16
   등에 탭 위치를 지정합니다). 시퀀스를 확장하기 위해 현재 열이 0으로
   설정되고 시퀀스를 바이트 단위로 검사합니다. 바이트가 ASCII 탭 문자
   ("b'\t'") 이면, 현재 열이 다음 탭 위치와 같아질 때까지 하나 이상의
   스페이스 문자가 삽입됩니다. (탭 문자 자체는 복사되지 않습니다.) 현
   재 바이트가 ASCII 개행 문자 ("b'\n'") 또는 캐리지 리턴 ("b'\r'") 이
   면 복사되고 현재 열은 0으로 재설정됩니다. 다른 바이트는 변경되지 않
   고 복사되고 현재 열은 인쇄할 때 바이트가 어떻게 표시되는지에 관계없
   이 1씩 증가합니다.

      >>> b'01\t012\t0123\t01234'.expandtabs()
      b'01      012     0123    01234'
      >>> b'01\t012\t0123\t01234'.expandtabs(4)
      b'01  012 0123    01234'

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.isalnum()
bytearray.isalnum()

   시퀀스의 모든 바이트가 알파벳 ASCII 문자 또는 ASCII 십진수이고 시퀀
   스가 비어 있지 않으면 "True"를 돌려주고 그렇지 않으면 "False"를 돌
   려줍니다. 알파벳 ASCII 문자는, 시퀀스
   "b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'" 에 있는
   바이트 값입니다. ASCII 십진수는 시퀀스 "b'0123456789'" 에 있는 바이
   트 값입니다.

   예를 들면:

      >>> b'ABCabc1'.isalnum()
      True
      >>> b'ABC abc1'.isalnum()
      False

bytes.isalpha()
bytearray.isalpha()

   시퀀스의 모든 바이트가 알파벳 ASCII 문자이고 시퀀스가 비어 있지 않
   으면 "True"를 돌려주고 그렇지 않으면 "False"를 돌려줍니다. 알파벳
   ASCII 문자는, 시퀀스
   "b'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'" 에 있는
   바이트 값입니다.

   예를 들면:

      >>> b'ABCabc'.isalpha()
      True
      >>> b'ABCabc1'.isalpha()
      False

bytes.isascii()
bytearray.isascii()

   시퀀스가 비어 있거나 시퀀스의 모든 바이트가 ASCII면 "True"를 돌려주
   고, 그렇지 않으면 "False"를 돌려줍니다. ASCII 바이트의 범위는
   0-0x7F 입니다.

   Added in version 3.7.

bytes.isdigit()
bytearray.isdigit()

   시퀀스의 모든 바이트가 ASCII 십진수이며 시퀀스가 비어 있지 않으면
   "True"를 돌려주고 그렇지 않으면 "False"를 돌려줍니다. ASCII 십진수
   는 시퀀스 "b'0123456789'" 에 있는 바이트 값입니다.

   예를 들면:

      >>> b'1234'.isdigit()
      True
      >>> b'1.23'.isdigit()
      False

bytes.islower()
bytearray.islower()

   시퀀스에 적어도 하나의 ASCII 소문자가 있고, ASCII 대문자가 없으면
   "True"를, 그렇지 않으면 "False"를 돌려줍니다.

   예를 들면:

      >>> b'hello world'.islower()
      True
      >>> b'Hello world'.islower()
      False

   ASCII 소문자는 시퀀스 "b'abcdefghijklmnopqrstuvwxyz'" 에 있는 바이
   트 값입니다. ASCII 대문자는, 시퀀스 "b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
   에 있는 바이트 값입니다.

bytes.isspace()
bytearray.isspace()

   시퀀스의 모든 바이트가 ASCII 공백이고, 시퀀스가 비어 있지 않으면
   "True"를 돌려주고 그렇지 않으면 "False"를 돌려줍니다. ASCII 공백 문
   자는 시퀀스 "b' \t\n\r\x0b\f'"(스페이스, 탭, 줄 바꿈, 캐리지 리턴,
   수직 탭, 폼 피드)에 있는 바이트 값입니다.

bytes.istitle()
bytearray.istitle()

   시퀀스가 ASCII 제목 케이스고 시퀀스가 비어있지 않으면 "True"를 돌려
   주고 그렇지 않으면 "False"를 돌려줍니다. "제목 케이스" 의 정의에 대
   한 자세한 내용은 "bytes.title()" 을 참조하십시오.

   예를 들면:

      >>> b'Hello World'.istitle()
      True
      >>> b'Hello world'.istitle()
      False

bytes.isupper()
bytearray.isupper()

   시퀀스에 적어도 하나의 ASCII 대문자가 있고, ASCII 소문자가 없으면
   "True"를, 그렇지 않으면 "False"를 돌려줍니다.

   예를 들면:

      >>> b'HELLO WORLD'.isupper()
      True
      >>> b'Hello world'.isupper()
      False

   ASCII 소문자는 시퀀스 "b'abcdefghijklmnopqrstuvwxyz'" 에 있는 바이
   트 값입니다. ASCII 대문자는, 시퀀스 "b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
   에 있는 바이트 값입니다.

bytes.lower()
bytearray.lower()

   모든 ASCII 대문자를 해당 소문자로 변환한 시퀀스의 복사본을 돌려줍니
   다.

   예를 들면:

      >>> b'Hello World'.lower()
      b'hello world'

   ASCII 소문자는 시퀀스 "b'abcdefghijklmnopqrstuvwxyz'" 에 있는 바이
   트 값입니다. ASCII 대문자는, 시퀀스 "b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
   에 있는 바이트 값입니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.splitlines(keepends=False)
bytearray.splitlines(keepends=False)

   ASCII 줄 경계에서 나눈 바이너리 시퀀스의 줄 리스트를 돌려줍니다. 이
   메서드는 줄을 나누는데 *universal newlines* 접근법을 사용합니다.
   *keepends* 가 참으로 주어지지 않는 한 결과 리스트에 줄 바꿈은 포함
   되지 않습니다.

   예를 들면:

      >>> b'ab c\n\nde fg\rkl\r\n'.splitlines()
      [b'ab c', b'', b'de fg', b'kl']
      >>> b'ab c\n\nde fg\rkl\r\n'.splitlines(keepends=True)
      [b'ab c\n', b'\n', b'de fg\r', b'kl\r\n']

   구분자 시퀀스 *sep* 이 주어졌을 때 "split()" 와 달리, 이 메서드는
   빈 시퀀스에 대해서 빈 리스트를 돌려주고, 마지막 줄 바꿈은 새 줄을
   만들지 않습니다:

      >>> b"".split(b'\n'), b"Two lines\n".split(b'\n')
      ([b''], [b'Two lines', b''])
      >>> b"".splitlines(), b"One line\n".splitlines()
      ([], [b'One line'])

bytes.swapcase()
bytearray.swapcase()

   모든 ASCII 소문자를 해당 대문자로, 그 반대도 마찬가지로 변환한 시퀀
   스의 복사본을 돌려줍니다.

   예를 들면:

      >>> b'Hello World'.swapcase()
      b'hELLO wORLD'

   ASCII 소문자는 시퀀스 "b'abcdefghijklmnopqrstuvwxyz'" 에 있는 바이
   트 값입니다. ASCII 대문자는, 시퀀스 "b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
   에 있는 바이트 값입니다.

   Unlike "str.swapcase()", it is always the case that
   "bin.swapcase().swapcase() == bin" for the binary versions. Case
   conversions are symmetrical in ASCII, even though that is not
   generally true for arbitrary Unicode code points.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.title()
bytearray.title()

   단어가 ASCII 대문자로 시작하고 나머지 문자들은 소문자인 제목 케이스
   버전의 바이너리 시퀀스를 돌려줍니다. 케이스 없는 바이트 값은 수정되
   지 않은 상태로 남습니다.

   예를 들면:

      >>> b'Hello world'.title()
      b'Hello World'

   ASCII 소문자는 시퀀스 "b'abcdefghijklmnopqrstuvwxyz'" 에 있는 바이
   트 값입니다. ASCII 대문자는 시퀀스 "b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
   에 있는 바이트 값입니다. 다른 모든 바이트 값은 케이스가 없습니다.

   이 알고리즘은 단어를 글자들의 연속으로 보는 간단한 언어 독립적 정의
   를 사용합니다. 이 정의는 여러 상황에서 작동하지만, 축약과 소유의 아
   포스트로피가 단어 경계를 형성한다는 것을 의미하고, 이는 원하는 결과
   가 아닐 수도 있습니다:

      >>> b"they're bill's friends from the UK".title()
      b"They'Re Bill'S Friends From The Uk"

   정규식을 사용하여 아포스트로피에 대한 해결 방법을 구성할 수 있습니
   다:

      >>> import re
      >>> def titlecase(s):
      ...     return re.sub(rb"[A-Za-z]+('[A-Za-z]+)?",
      ...                   lambda mo: mo.group(0)[0:1].upper() +
      ...                              mo.group(0)[1:].lower(),
      ...                   s)
      ...
      >>> titlecase(b"they're bill's friends.")
      b"They're Bill's Friends."

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.upper()
bytearray.upper()

   모든 ASCII 소문자를 해당 대문자로 변환한 시퀀스의 복사본을 돌려줍니
   다.

   예를 들면:

      >>> b'Hello World'.upper()
      b'HELLO WORLD'

   ASCII 소문자는 시퀀스 "b'abcdefghijklmnopqrstuvwxyz'" 에 있는 바이
   트 값입니다. ASCII 대문자는, 시퀀스 "b'ABCDEFGHIJKLMNOPQRSTUVWXYZ'"
   에 있는 바이트 값입니다.

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.

bytes.zfill(width, /)
bytearray.zfill(width, /)

   길이가 *width* 인 시퀀스를 만들기 위해 ASCII "b'0'" 문자를 왼쪽에
   채운 시퀀스의 복사본을 돌려줍니다. 선행 부호 접두어("b'+'"/"b'-'")
   는 부호 문자의 앞이 아니라 *뒤* 에 채우는 것으로 처리됩니다.
   "bytes" 객체의 경우, *width* 가 "len(s)" 보다 작거나 같은 경우 원래
   시퀀스를 돌려줍니다.

   예를 들면:

      >>> b"42".zfill(5)
      b'00042'
      >>> b"-42".zfill(5)
      b'-0042'

   참고:

     이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* -
     변경되지 않는 경우조차 항상 새 객체를 만듭니다.


"printf" 스타일 바이너리 포매팅
-------------------------------

참고:

  여기에 설명된 포맷 연산은 여러 가지 일반적인 오류를 (예를 들어 튜플
  과 딕셔너리를 올바르게 표시하지 못하는 것) 유발하는 다양한 문제점들
  이 있습니다. 인쇄될 값이 튜플 또는 딕셔너리일 경우 튜플로 감싸야 합
  니다.

바이너리 시퀀스 객체는 한가지 고유한 내장 연산을 갖고 있습니다: "%" 연
산자 (모듈로). 이것은 바이너리 *포매팅* 또는 *치환* 연산자라고도 합니
다. "format % values" 가 주어질 때 (*format* 은 바이너리 시퀀스입니다
), *format* 내부의 "%" 변환 명세는 0개 이상의 *values* 의 요소로 대체
됩니다. 이 효과는 C 언어에서 "sprintf()"를 사용하는 것과 비슷합니다.

*format* 이 하나의 인자를 요구하면, *values* 는 하나의 비 튜플 객체 일
수 있습니다. [5] 그렇지 않으면, *values* 는 format 바이너리 시퀀스 객
체가 지정하는 항목의 수와 같은 튜플이거나 단일 매핑 객체 (예를 들어,
딕셔너리) 여야 합니다.

변환 명세는 두 개 이상의 문자를 포함하며 다음과 같은 구성 요소들을 포
함하는데, 반드시 이 순서대로 나와야 합니다:

1. "'%'" 문자: 명세의 시작을 나타냅니다.

2. 매핑 키 (선택 사항): 괄호로 둘러싸인 문자들의 시퀀스로 구성됩니다 (
   예를 들어, "(somename)").

3. 변환 플래그 (선택 사항): 일부 변환 유형의 결과에 영향을 줍니다.

4. 최소 필드 폭 (선택 사항): "'*'" (애스터리스크) 로 지정하면, 실제 폭
   은 *values* 튜플의 다음 요소에서 읽히고, 변환할 객체는 최소 필드 폭
   과 선택적 정밀도 뒤에 옵니다.

5. 정밀도 (선택 사항): "'.'" (점) 다음에 정밀도가 옵니다. "'*'" (애스
   터리스크) 로 지정하면, 실제 정밀도는 *values* 튜플의 다음 요소에서
   읽히고, 변환할 값은 정밀도 뒤에 옵니다.

6. 길이 수정자 (선택 사항).

7. 변환 유형.

오른쪽 인자가 딕셔너리 (또는 다른 매핑 형) 인 경우, 바이너리 시퀀스 객
체에 있는 변환 명세는 *반드시* "'%'" 문자 바로 뒤에 그 딕셔너리의 매핑
키를 괄호로 둘러싼 형태로 포함해야 합니다. 매핑 키는 포맷할 값을 매핑
으로 부터 선택합니다. 예를 들어:

>>> print(b'%(language)s has %(number)03d quote types.' %
...       {b'language': b"Python", b"number": 2})
b'Python has 002 quote types.'

이 경우 "*" 지정자를 사용할 수 없습니다 (순차적인 매개변수 목록이 필요
하기 때문입니다).

변환 플래그 문자는 다음과 같습니다:

+-----------+-----------------------------------------------------------------------+
| 플래그    | 뜻                                                                    |
|===========|=======================================================================|
| "'#'"     | 값 변환에 "대체 형식" (아래에 정의되어있습니다) 을 사용합니다.        |
+-----------+-----------------------------------------------------------------------+
| "'0'"     | 변환은 숫자 값의 경우 0으로 채웁니다.                                 |
+-----------+-----------------------------------------------------------------------+
| "'-'"     | 변환된 값은 왼쪽으로 정렬됩니다 (둘 다 주어지면 "'0'" 변환보다 우선   |
|           | 합 니다).                                                             |
+-----------+-----------------------------------------------------------------------+
| "' '"     | (스페이스) 부호 있는 변환 때문에 만들어진 양수 앞에 빈칸을 남겨둡니다 |
|           | (음수면 빈 문자열입니다).                                             |
+-----------+-----------------------------------------------------------------------+
| "'+'"     | 부호 문자 ("'+'" or "'-'") 가 변환 앞에 놓입니다 ("' '" 플래그에 우선 |
|           | 합니다).                                                              |
+-----------+-----------------------------------------------------------------------+

길이 수정자 ("h", "l", "L") 를 제공할 수는 있지만, 파이썬에서 필요하지
않기 때문에 무시됩니다 -- 예를 들어 "%ld" 는 "%d" 와 같습니다.

변환 유형은 다음과 같습니다:

+--------------+-------------------------------------------------------+---------+
| 변환         | 뜻                                                    | 노트    |
|==============|=======================================================|=========|
| "'d'"        | 부호 있는 정수 십진 표기.                             |         |
+--------------+-------------------------------------------------------+---------+
| "'i'"        | 부호 있는 정수 십진 표기.                             |         |
+--------------+-------------------------------------------------------+---------+
| "'o'"        | 부호 있는 8진수 값.                                   | (1)     |
+--------------+-------------------------------------------------------+---------+
| "'u'"        | 쓸데없는 유형 -- "'d'" 와 같습니다.                   | (8)     |
+--------------+-------------------------------------------------------+---------+
| "'x'"        | 부호 있는 16진수 (소문자).                            | (2)     |
+--------------+-------------------------------------------------------+---------+
| "'X'"        | 부호 있는 16진수 (대문자).                            | (2)     |
+--------------+-------------------------------------------------------+---------+
| "'e'"        | Floating-point exponential format (lowercase).        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'E'"        | Floating-point exponential format (uppercase).        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'f'"        | Floating-point decimal format.                        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'F'"        | Floating-point decimal format.                        | (3)     |
+--------------+-------------------------------------------------------+---------+
| "'g'"        | Floating-point format. Uses lowercase exponential     | (4)     |
|              | format if exponent is less than -4 or not less than   |         |
|              | precision, decimal format otherwise.                  |         |
+--------------+-------------------------------------------------------+---------+
| "'G'"        | Floating-point format. Uses uppercase exponential     | (4)     |
|              | format if exponent is less than -4 or not less than   |         |
|              | precision, decimal format otherwise.                  |         |
+--------------+-------------------------------------------------------+---------+
| "'c'"        | 단일 바이트 (정수 또는 길이 1인 바이너리 시퀀스를 허  |         |
|              | 용합니다).                                            |         |
+--------------+-------------------------------------------------------+---------+
| "'b'"        | Bytes (any object that follows the buffer protocol or | (5)     |
|              | has "__bytes__()").                                   |         |
+--------------+-------------------------------------------------------+---------+
| "'s'"        | "'s'" 는 "'b'" 의 별칭이고 파이썬 2/3에서만 사용되어  | (6)     |
|              | 야 합니다.                                            |         |
+--------------+-------------------------------------------------------+---------+
| "'a'"        | Bytes (converts any Python object using               | (5)     |
|              | "repr(obj).encode('ascii', 'backslashreplace')").     |         |
+--------------+-------------------------------------------------------+---------+
| "'r'"        | "'r'" 는 "'a'" 의 별칭이고 파이썬 2/3에서만 사용되어  | (7)     |
|              | 야 합니다.                                            |         |
+--------------+-------------------------------------------------------+---------+
| "'%'"        | 인자는 변환되지 않고, 결과에 "'%'" 문자가 표시됩니다. |         |
+--------------+-------------------------------------------------------+---------+

노트:

1. 대체 형식은 첫 번째 숫자 앞에 선행 8진수 지정자 ("'0o'")를 삽입합니
   다.

2. 대체 형식은 첫 번째 숫자 앞에 선행 "'0x'" 또는 "'0X'" ("'x'" 나
   "'X'" 유형 중 어느 것을 사용하느냐에 따라 달라집니다) 를 삽입합니다
   .

3. 대체 형식은 그 뒤에 숫자가 나오지 않더라도 항상 소수점을 포함합니다
   .

   정밀도는 소수점 이하 자릿수를 결정하며 기본값은 6입니다.

4. 대체 형식은 결과에 항상 소수점을 포함하고 뒤에 오는 0은 제거되지 않
   습니다.

   정밀도는 소수점 앞뒤의 유효 자릿수를 결정하며 기본값은 6입니다.

5. 정밀도가 "N" 이라면, 출력은 "N" 문자로 잘립니다.

6. "b'%s'" 는 폐지되었습니다. 하지만 3.x 시리즈에서는 제거되지 않습니
   다.

7. "b'%r'" 는 폐지되었습니다. 하지만 3.x 시리즈에서는 제거되지 않습니
   다.

8. **PEP 237**을 참조하세요.

참고:

  이 메서드의 바이트 배열 버전은 제자리에서 동작하지 *않습니다* - 변경
  되지 않는 경우조차 항상 새 객체를 만듭니다.

더 보기: **PEP 461** - bytes와 bytearray에 % 포매팅 추가

Added in version 3.5.


메모리 뷰
---------

"memoryview" 객체는 파이썬 코드가 버퍼 프로토콜 을 지원하는 객체의 내
부 데이터에 복사 없이 접근할 수 있게 합니다.

class memoryview(object)

      Create a "memoryview" that references *object*.  *object* must
      support the buffer protocol.  Built-in objects that support the
      buffer protocol include "bytes" and "bytearray".

      A "memoryview" has the notion of an *element*, which is the
      atomic memory unit handled by the originating *object*.  For
      many simple types such as "bytes" and "bytearray", an element is
      a single byte, but other types such as "array.array" may have
      bigger elements.

      "len(view)" is equal to the length of "tolist", which is the
      nested list representation of the view. If "view.ndim = 1", this
      is equal to the number of elements in the view.

      버전 3.12에서 변경: If "view.ndim == 0", "len(view)" now raises
      "TypeError" instead of returning 1.

      The "itemsize" attribute will give you the number of bytes in a
      single element.

      "memoryview" 는 슬라이싱과 인덱싱을 지원하여 데이터를 노출합니다
      . 일차원 슬라이스는 서브 뷰를 만듭니다:

         >>> v = memoryview(b'abcefg')
         >>> v[1]
         98
         >>> v[-1]
         103
         >>> v[1:4]
         <memory at 0x7f3ddc9f4350>
         >>> bytes(v[1:4])
         b'bce'

      "format" 이 "struct" 모듈의 네이티브 형식 지정자 중 하나인 경우,
      정수 또는 정수의 튜플을 사용하는 인덱싱도 지원되며 올바른 형으로
      하나의 요소를 돌려줍니다. 일차원 메모리 뷰는 정수 또는 하나의 정
      수를 갖는 튜플로 인덱싱 할 수 있습니다. 다차원 메모리 뷰는 정확
      히 *ndim* 개의 정수를 갖는 튜플로 인덱싱할 수 있습니다. 여기서
      *ndim* 은 차원 수입니다. 영차원 메모리 뷰는 빈 튜플로 인덱싱할
      수 있습니다.

      다음은 바이트가 아닌 형식의 예입니다:

         >>> import array
         >>> a = array.array('l', [-11111111, 22222222, -33333333, 44444444])
         >>> m = memoryview(a)
         >>> m[0]
         -11111111
         >>> m[-1]
         44444444
         >>> m[::2].tolist()
         [-11111111, -33333333]

      하부 객체가 쓰기 가능하면, 메모리 뷰는 일차원 슬라이스 대입을 지
      원합니다. 크기 변경은 허용되지 않습니다:

         >>> data = bytearray(b'abcefg')
         >>> v = memoryview(data)
         >>> v.readonly
         False
         >>> v[0] = ord(b'z')
         >>> data
         bytearray(b'zbcefg')
         >>> v[1:4] = b'123'
         >>> data
         bytearray(b'z123fg')
         >>> v[2:3] = b'spam'
         Traceback (most recent call last):
           File "<stdin>", line 1, in <module>
         ValueError: memoryview assignment: lvalue and rvalue have different structures
         >>> v[2:6] = b'spam'
         >>> data
         bytearray(b'z1spam')

      One-dimensional memoryviews of *hashable* (read-only) types with
      formats 'B', 'b' or 'c' are also hashable. The hash is defined
      as "hash(m) == hash(m.tobytes())":

         >>> v = memoryview(b'abcefg')
         >>> hash(v) == hash(b'abcefg')
         True
         >>> hash(v[2:4]) == hash(b'ce')
         True
         >>> hash(v[::-2]) == hash(b'abcefg'[::-2])
         True

      버전 3.3에서 변경: One-dimensional memoryviews can now be
      sliced. One-dimensional memoryviews with formats 'B', 'b' or 'c'
      are now *hashable*.

      버전 3.4에서 변경: 이제 메모리 뷰는 자동으로
      "collections.abc.Sequence" 로 등록됩니다

      버전 3.5에서 변경: 이제 메모리 뷰는 정수의 튜플로 인덱싱될 수 있
      습니다.

      버전 3.14에서 변경: memoryview is now a *generic type*.

      "memoryview" 는 몇 가지 메서드를 가지고 있습니다:

      __eq__(exporter)

         메모리 뷰와 **PEP 3118** 제공자(exporter)는 다음과 같은 조건
         을 만족할 때 같다고 비교됩니다: 모양이 동등하고 피연산자의 각
         형식 코드가 "struct" 문법을 사용하여 해석될 때 모든 해당 값이
         같다.

         현재 "tolist()" 가 지원하는 "struct" 형식 문자열의 부분 집합
         의 경우, "v.tolist() == w.tolist()" 면 "v" 와 "w" 는 같습니다
         :

            >>> import array
            >>> a = array.array('I', [1, 2, 3, 4, 5])
            >>> b = array.array('d', [1.0, 2.0, 3.0, 4.0, 5.0])
            >>> c = array.array('b', [5, 3, 1])
            >>> x = memoryview(a)
            >>> y = memoryview(b)
            >>> x == a == y == b
            True
            >>> x.tolist() == a.tolist() == y.tolist() == b.tolist()
            True
            >>> z = y[::-2]
            >>> z == c
            True
            >>> z.tolist() == c.tolist()
            True

         형식 문자열이 "struct" 모듈에서 지원되지 않으면 객체는 항상
         같지 않다고 비교됩니다 (형식 문자열과 버퍼 내용이 같더라도 그
         렇습니다):

            >>> from ctypes import BigEndianStructure, c_long
            >>> class BEPoint(BigEndianStructure):
            ...     _fields_ = [("x", c_long), ("y", c_long)]
            ...
            >>> point = BEPoint(100, 200)
            >>> a = memoryview(point)
            >>> b = memoryview(point)
            >>> a == point
            False
            >>> a == b
            False

         Note that, as with floating-point numbers, "v is w" does
         *not* imply "v == w" for memoryview objects.

         버전 3.3에서 변경: 이전 버전에서는 항목 형식과 논리 배열 구조
         를 무시하고 원시 메모리를 비교했습니다.

      tobytes(order='C')

         버퍼의 데이터를 바이트열로 돌려줍니다. 이는 메모리 뷰에
         "bytes" 생성자를 호출하는 것과 동등합니다.

            >>> m = memoryview(b"abc")
            >>> m.tobytes()
            b'abc'
            >>> bytes(m)
            b'abc'

         불연속 배열의 경우 결과는 모든 요소를 바이트로 변환하여 평평
         한 리스트로 만든 것과 같습니다. "tobytes()" 는 "struct" 모듈
         문법에 없는 것을 포함하여 모든 형식 문자열을 지원합니다.

         Added in version 3.8: *order*는 {'C', 'F', 'A'} 일 수 있습니
         다. *order*가 'C' 나 'F' 이면, 원래 배열의 데이터가 C 나 포트
         란 순서로 변환됩니다. 연속 뷰의 경우, 'A' 는 물리적 메모리의
         정확한 사본을 반환합니다. 특히, 메모리 내 포트란 순서가 보존
         됩니다. 연속적이지 않은 뷰의 경우, 데이터는 먼저 C로 변환됩니
         다. *order=None*은 *order='C'*와 같습니다.

      hex(*, bytes_per_sep=1)
      hex(sep, bytes_per_sep=1)

         버퍼 내의 각 바이트를 두 개의 16진수로 표현한 문자열 객체를
         돌려줍니다.

            >>> m = memoryview(b"abc")
            >>> m.hex()
            '616263'

         Added in version 3.5.

         버전 3.8에서 변경: "bytes.hex()"와 비슷하게, 이제
         "memoryview.hex()"는 16진수 출력의 바이트 사이에 구분 기호를
         삽입하기 위해 선택적 *sep*과 *bytes_per_sep* 매개 변수를 지원
         합니다.

      tolist()

         버퍼 내의 데이터를 요소들의 리스트로 돌려줍니다.

            >>> memoryview(b'abc').tolist()
            [97, 98, 99]
            >>> import array
            >>> a = array.array('d', [1.1, 2.2, 3.3])
            >>> m = memoryview(a)
            >>> m.tolist()
            [1.1, 2.2, 3.3]

         버전 3.3에서 변경: "tolist()" 는 이제 "struct" 모듈 문법의 모
         든 단일 문자 네이티브 형식과 다차원 표현을 지원합니다.

      toreadonly()

         메모리 뷰 객체의 읽기 전용 버전을 반환합니다. 원래 메모리 뷰
         객체는 변경되지 않습니다.

            >>> m = memoryview(bytearray(b'abc'))
            >>> mm = m.toreadonly()
            >>> mm.tolist()
            [97, 98, 99]
            >>> mm[0] = 42
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
            TypeError: cannot modify read-only memory
            >>> m[0] = 43
            >>> mm.tolist()
            [43, 98, 99]

         Added in version 3.8.

      release()

         메모리 뷰 객체에 의해 노출된 하부 버퍼를 해제합니다. 많은 객
         체는 뷰가 그 객체에 연결될 때 특별한 조처를 합니다 (예를 들어
         , "bytearray" 는 일시적으로 크기 조절을 금지합니다); 따라서,
         release()를 호출하면 가능한 한 빨리 이 제한 사항을 제거하고
         붙잡힌 자원을 해제할 수 있습니다.

         After this method has been called, any further operation on
         the view raises a "ValueError" (except "release()" itself
         which can be called multiple times):

            >>> m = memoryview(b'abc')
            >>> m.release()
            >>> m[0]
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
            ValueError: operation forbidden on released memoryview object

         "with" 문을 사용한 컨텍스트 관리 프로토콜은 비슷한 효과를 낼
         수 있습니다:

            >>> with memoryview(b'abc') as m:
            ...     m[0]
            ...
            97
            >>> m[0]
            Traceback (most recent call last):
              File "<stdin>", line 1, in <module>
            ValueError: operation forbidden on released memoryview object

         Added in version 3.2.

      cast(format, /)
      cast(format, shape, /)

         메모리 뷰를 새로운 형식이나 모양으로 캐스팅합니다. *shape* 의
         기본값은 "[byte_length//new_itemsize]" 인데, 결과 뷰가 일차원
         이 된다는 의미입니다. 반환 값은 새로운 메모리 뷰이지만 버퍼
         자체는 복사되지 않습니다. 지원되는 캐스팅은 1D -> C-*연속* 과
         C-연속 -> 1D입니다.

         The destination format is restricted to a single element
         native format in "struct" syntax. One of the formats must be
         a byte format ('B', 'b' or 'c'). The byte length of the
         result must be the same as the original length. Note that all
         byte lengths may depend on the operating system.

         1D/long 을 1D/unsigned bytes 로 캐스트:

            >>> import array
            >>> a = array.array('l', [1,2,3])
            >>> x = memoryview(a)
            >>> x.format
            'l'
            >>> x.itemsize
            8
            >>> len(x)
            3
            >>> x.nbytes
            24
            >>> y = x.cast('B')
            >>> y.format
            'B'
            >>> y.itemsize
            1
            >>> len(y)
            24
            >>> y.nbytes
            24

         1D/unsigned bytes 를 1D/char 로 캐스트:

            >>> b = bytearray(b'zyz')
            >>> x = memoryview(b)
            >>> x[0] = b'a'
            Traceback (most recent call last):
              ...
            TypeError: memoryview: invalid type for format 'B'
            >>> y = x.cast('c')
            >>> y[0] = b'a'
            >>> b
            bytearray(b'ayz')

         1D/bytes 를 3D/ints 로 캐스트 한 후 다시 1D/signed char 로 캐
         스트:

            >>> import struct
            >>> buf = struct.pack("i"*12, *list(range(12)))
            >>> x = memoryview(buf)
            >>> y = x.cast('i', shape=[2,2,3])
            >>> y.tolist()
            [[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10, 11]]]
            >>> y.format
            'i'
            >>> y.itemsize
            4
            >>> len(y)
            2
            >>> y.nbytes
            48
            >>> z = y.cast('b')
            >>> z.format
            'b'
            >>> z.itemsize
            1
            >>> len(z)
            48
            >>> z.nbytes
            48

         1D/unsigned long 을 2D/unsigned long 으로 캐스트:

            >>> buf = struct.pack("L"*6, *list(range(6)))
            >>> x = memoryview(buf)
            >>> y = x.cast('L', shape=[2,3])
            >>> len(y)
            2
            >>> y.nbytes
            48
            >>> y.tolist()
            [[0, 1, 2], [3, 4, 5]]

         Added in version 3.3.

         버전 3.5에서 변경: 바이트 형식으로 변환할 때 소스 형식이 더는
         제한되지 않습니다.

      count(value, /)

         Count the number of occurrences of *value*.

         Added in version 3.14.

   index(value, start=0, stop=sys.maxsize, /)

         Return the index of the first occurrence of *value* (at or
         after index *start* and before index *stop*).

         Raises a "ValueError" if *value* cannot be found.

         Added in version 3.14.

      몇 가지 읽기 전용 어트리뷰트도 사용할 수 있습니다:

      obj

         메모리 뷰의 하부 객체:

            >>> b  = bytearray(b'xyz')
            >>> m = memoryview(b)
            >>> m.obj is b
            True

         Added in version 3.3.

      nbytes

         "nbytes == product(shape) * itemsize == len(m.tobytes())". 배
         열이 연속적일 때 차지하게 될 바이트 수입니다. 꼭 "len(m)"과
         같을 필요는 없습니다:

            >>> import array
            >>> a = array.array('i', [1,2,3,4,5])
            >>> m = memoryview(a)
            >>> len(m)
            5
            >>> m.nbytes
            20
            >>> y = m[::2]
            >>> len(y)
            3
            >>> y.nbytes
            12
            >>> len(y.tobytes())
            12

         다차원 배열:

            >>> import struct
            >>> buf = struct.pack("d"*12, *[1.5*x for x in range(12)])
            >>> x = memoryview(buf)
            >>> y = x.cast('d', shape=[3,4])
            >>> y.tolist()
            [[0.0, 1.5, 3.0, 4.5], [6.0, 7.5, 9.0, 10.5], [12.0, 13.5, 15.0, 16.5]]
            >>> len(y)
            3
            >>> y.nbytes
            96

         Added in version 3.3.

      readonly

         메모리가 읽기 전용인지 여부를 나타내는 논리값.

      format

         뷰의 각 요소에 대한 형식("struct" 모듈 스타일)을 포함하는 문
         자열입니다. 메모리 뷰는 제공자로부터 임의의 형식 문자열로 만
         들어질 수 있지만, 일부 메서드(예, "tolist()")는 원시 네이티브
         단일 요소 형식으로 제한됩니다.

         버전 3.3에서 변경: "'B'" 형식은 이제 struct 모듈 문법에 따라
         처리됩니다. 이것은 "memoryview(b'abc')[0] == b'abc'[0] == 97"
         이 됨을 의미합니다.

      itemsize

         메모리 뷰 각 요소의 크기 (바이트):

            >>> import array, struct
            >>> m = memoryview(array.array('H', [32000, 32001, 32002]))
            >>> m.itemsize
            2
            >>> m[0]
            32000
            >>> struct.calcsize('H') == m.itemsize
            True

      ndim

         메모리가 나타내는 다차원 배열의 차원 수를 나타내는 정수.

      shape

         N-차원 배열로서의 메모리의 모양을 가리키는, 길이 "ndim" 인 정
         수의 튜플입니다.

         버전 3.3에서 변경: ndim = 0 일 때 "None" 대신 빈 튜플을 제공
         합니다.

      strides

         배열의 각 차원에 대해 각 요소를 참조하는데 필요한 바이트 수를
         제공하는, 길이 "ndim" 인 정수의 튜플입니다.

         버전 3.3에서 변경: ndim = 0 일 때 "None" 대신 빈 튜플을 제공
         합니다.

      suboffsets

         PIL 스타일 배열에 내부적으로 사용됩니다. 값은 정보 제공용입니
         다.

      c_contiguous

         메모리가 C-*연속* 인지를 나타내는 논리값.

         Added in version 3.3.

      f_contiguous

         메모리가 포트란 *연속* 인지를 나타내는 논리값.

         Added in version 3.3.

      contiguous

         메모리가 *연속* 인지를 나타내는 논리값.

         Added in version 3.3.


집합 형 --- "set", "frozenset"
==============================

*집합 (set)* 객체는 서로 다른 *해시 가능* 객체의 순서 없는 컬렉션입니
다. 일반적인 용도는 멤버십 검사, 시퀀스에서 중복 제거와 교집합, 합집합
, 차집합, 대칭 차집합과 같은 수학 연산을 계산하는 것입니다. (다른 컨테
이너들은 내장 "dict", "list", "tuple" 클래스 및 "collections" 모듈을
참조하십시오.)

다른 컬렉션과 마찬가지로, 집합은 "x in set", "len(set)", "for x in
set" 을 지원합니다. 순서가 없는 컬렉션이므로, 집합은 원소의 위치나 삽
입 순서를 기록하지 않습니다. 따라서 집합은 인덱싱, 슬라이싱 또는 기타
시퀀스와 유사한 동작을 지원하지 않습니다.

There are currently two built-in set types, "set" and "frozenset". The
"set" type is mutable --- the contents can be changed using methods
like "add()" and "remove()". Since it is mutable, it has no hash value
and cannot be used as either a dictionary key or as an element of
another set. The "frozenset" type is immutable and *hashable* --- its
contents cannot be altered after it is created; it can therefore be
used as a dictionary key or as an element of another set.

비어 있지 않은 set은 (frozenset 은 아닙니다) "set" 생성자뿐만 아니라
중괄호 안에 쉼표로 구분된 원소 목록을 넣어서 만들 수 있습니다, 예를 들
어: "{'jack', 'sjoerd'}".

두 클래스의 생성자는 같게 작동합니다:

class set(iterable=(), /)
class frozenset(iterable=(), /)

   *iterable* 에서 요소를 취하는 새 set 또는 frozenset 객체를 돌려줍니
   다. 집합의 원소는 반드시 *해시 가능* 해야 합니다. 집합의 집합을 표
   현하려면, 포함되는 집합은 반드시 "frozenset" 객체여야 합니다.
   *iterable* 을 지정하지 않으면 새 빈 집합을 돌려줍니다.

집합은 여러 가지 방법으로 만들 수 있습니다:

* 중괄호 안에 쉼표로 구분된 요소 나열하기: "{'jack', 'sjoerd'}"

* 집합 컴프리헨션 사용하기: "{c for c in 'abracadabra' if c not in
  'abc'}"

* 형 생성자 사용하기: "set()", "set('foobar')", "set(['a', 'b',
  'foo'])"

"set"과 "frozenset" 의 인스턴스는 다음과 같은 연산을 제공합니다:

len(s)

   집합 *s* 의 원소 수(*s* 의 크기)를 돌려줍니다.

x in s

   *s* 에 대해 *x* 의 멤버십을 검사합니다.

x not in s

   *s* 에 대해 *x* 의 비 멤버십을 검사합니다.

frozenset.isdisjoint(other, /)
set.isdisjoint(other, /)

   집합이 *other* 와 공통 원소를 갖지 않는 경우 "True" 을 돌려줍니다.
   집합은 교집합이 공집합일 때, 그리고 그때만 서로소(disjoint)라고 합
   니다.

frozenset.issubset(other, /)
set.issubset(other, /)

set <= other

   집합의 모든 원소가 *other* 에 포함되는지 검사합니다.

set < other

   집합이 *other* 의 진부분집합인지 검사합니다, 즉, "set <= other and
   set != other".

frozenset.issuperset(other, /)
set.issuperset(other, /)

set >= other

   *other* 의 모든 원소가 집합에 포함되는지 검사합니다.

set > other

   집합이 *other* 의 진상위집합인지 검사합니다, 즉, "set >= other and
   set != other".

frozenset.union(*others)
set.union(*others)

set | other | ...

   집합과 모든 others에 있는 원소들로 구성된 새 집합을 돌려줍니다.

frozenset.intersection(*others)
set.intersection(*others)

set & other & ...

   집합과 모든 others의 공통 원소들로 구성된 새 집합을 돌려줍니다.

frozenset.difference(*others)
set.difference(*others)

set - other - ...

   집합에는 포함되었으나 others에는 포함되지 않은 원소들로 구성된 새
   집합을 돌려줍니다.

frozenset.symmetric_difference(other, /)
set.symmetric_difference(other, /)

set ^ other

   집합이나 other에 포함되어 있으나 둘 모두에 포함되지는 않은 원소들로
   구성된 새 집합을 돌려줍니다.

frozenset.copy()
set.copy()

   집합의 얕은 복사본을 돌려줍니다.

Note, the non-operator versions of "union()", "intersection()",
"difference()", "symmetric_difference()", "issubset()", and
"issuperset()" methods will accept any iterable as an argument.  In
contrast, their operator based counterparts require their arguments to
be sets.  This precludes error-prone constructions like "set('abc') &
'cbs'" in favor of the more readable "set('abc').intersection('cbs')".

"set"과 "frozenset" 모두 집합 간의 비교를 지원합니다. 두 집합은 각 집
합의 모든 원소가 다른 집합에 포함되어있는 경우에만 같습니다 (서로 다른
집합의 부분집합입니다). 집합이 다른 집합의 진부분집합(부분집합이지만
같지는 않은 경우)일 때만 첫 번째 집합이 두 번째 집합보다 작습니다. 집
합이 다른 집합의 진상위집합(상위집합이지만 같지는 않은 경우)일 때만 첫
번째 집합이 두 번째 집합보다 큽니다.

"set" 의 인스턴스는 그 원소를 기반으로 "frozenset" 의 인스턴스와 비교
됩니다. 예를 들어, "set('abc') == frozenset('abc')" 는 "True" 를 돌려
주고 "set('abc') in set([frozenset('abc')])" 도 마찬가지입니다.

부분 집합 및 동등 비교는 전 순서(total ordering) 함수로 일반화되지 않
습니다. 예를 들어, 비어 있지 않은 두 개의 서로소인 집합은 같지 않고 서
로의 부분 집합이 아닙니다, 그래서 다음은 *모두* "False" 를 돌려줍니다:
"a<b", "a==b", "a>b".

집합은 부분 순서(부분 집합 관계)만 정의하기 때문에, 집합의 리스트에 대
한 "list.sort()" 메서드의 결과는 정의되지 않습니다.

딕셔너리 키처럼, 집합의 원소는 반드시 *해시 가능* 해야 합니다.

"set" 인스턴스와 "frozenset" 을 혼합 한 이항 연산은 첫 번째 피연산자의
형을 돌려줍니다. 예를 들어: "frozenset('ab') | set('bc')" 는
"frozenset" 의 인스턴스를 돌려줍니다.

다음 표는 "frozenset" 의 불변 인스턴스에는 적용되지 않고 "set" 에서만
사용할 수 있는 연산들을 나열합니다:

set.update(*others)

set |= other | ...

   집합을 갱신해서, 모든 others의 원소들을 더합니다.

set.intersection_update(*others)

set &= other & ...

   집합을 갱신해서, 그 집합과 others에 공통으로 포함된 원소들만 남깁니
   다.

set.difference_update(*others)

set -= other | ...

   집합을 갱신해서, others에 있는 원소들을 제거합니다.

set.symmetric_difference_update(other, /)

set ^= other

   집합을 갱신해서, 두 집합의 어느 한 곳에만 포함된 원소들만 남깁니다.

set.add(elem, /)

   원소 *elem* 을 집합에 추가합니다.

set.remove(elem, /)

   원소 *elem* 을 집합에서 제거합니다. *elem* 가 집합에 포함되어 있지
   않으면 "KeyError" 를 일으킵니다.

set.discard(elem, /)

   원소 *elem* 이 집합에 포함되어 있으면 제거합니다.

set.pop()

   집합으로부터 임의의 원소를 제거해 돌려줍니다. 집합이 비어있는 경우
   "KeyError" 를 일으킵니다.

set.clear()

   집합의 모든 원소를 제거합니다.

Note, the non-operator versions of the "update()",
"intersection_update()", "difference_update()", and
"symmetric_difference_update()" methods will accept any iterable as an
argument.

Note, the *elem* argument to the "__contains__()", "remove()", and
"discard()" methods may be a set.  To support searching for an
equivalent frozenset, a temporary one is created from *elem*.


매핑 형 --- "dict"
==================

*매핑* 객체는 *해시 가능* 값을 임의의 객체에 대응합니다. 매핑은 가변
객체입니다. 현재 오직 하나의 표준 매핑 형이 있습니다, *딕셔너리
(dictionary)*. (다른 컨테이너들은 내장 "list", "set", "tuple" 클래스
및 "collections" 모듈을 참조하십시오.)

A dictionary's keys are *almost* arbitrary values.  Values that are
not *hashable*, that is, values containing lists, dictionaries or
other mutable types (that are compared by value rather than by object
identity) may not be used as keys. Values that compare equal (such as
"1", "1.0", and "True") can be used interchangeably to index the same
dictionary entry.

class dict(**kwargs)
class dict(mapping, /, **kwargs)
class dict(iterable, /, **kwargs)

   선택적 위치 인자와 (비어있을 수 있는) 키워드 인자들의 집합으로부터
   초기화된 새 딕셔너리를 돌려줍니다.

   딕셔너리는 여러 가지 방법으로 만들 수 있습니다:

   * 중괄호 안에 쉼표로 구분된 "key: value" 쌍을 나열하기: "{'jack':
     4098, 'sjoerd': 4127}" 또는 "{4098: 'jack', 4127: 'sjoerd'}"

   * 딕셔너리 컴프리헨션 사용하기: "{}", "{x: x ** 2 for x in
     range(10)}"

   * 형 생성자 사용하기: "dict()", "dict([('foo', 100), ('bar',
     200)])", "dict(foo=100, bar=200)"

   If no positional argument is given, an empty dictionary is created.
   If a positional argument is given and it defines a "keys()" method,
   a dictionary is created by calling "__getitem__()" on the argument
   with each returned key from the method.  Otherwise, the positional
   argument must be an *iterable* object.  Each item in the iterable
   must itself be an iterable with exactly two elements.  The first
   element of each item becomes a key in the new dictionary, and the
   second element the corresponding value.  If a key occurs more than
   once, the last value for that key becomes the corresponding value
   in the new dictionary.

   키워드 인자가 제공되면, 키워드 인자와 해당 값이 위치 인자로부터 만
   들어진 딕셔너리에 추가됩니다. 추가되는 키가 이미 존재하면, 키워드
   인자에서 온 값이 위치 인자에게서 온 값을 대체합니다.

   Dictionaries compare equal if and only if they have the same "(key,
   value)" pairs (regardless of ordering). Order comparisons ('<',
   '<=', '>=', '>') raise "TypeError".  To illustrate dictionary
   creation and equality, the following examples all return a
   dictionary equal to "{"one": 1, "two": 2, "three": 3}":

      >>> a = dict(one=1, two=2, three=3)
      >>> b = {'one': 1, 'two': 2, 'three': 3}
      >>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
      >>> d = dict([('two', 2), ('one', 1), ('three', 3)])
      >>> e = dict({'three': 3, 'one': 1, 'two': 2})
      >>> f = dict({'one': 1, 'three': 3}, two=2)
      >>> a == b == c == d == e == f
      True

   첫 번째 예제에서와같이 키워드 인자는 유효한 파이썬 식별자인 키에 대
   해서만 작동합니다. 그 외의 경우는 모든 유효한 키를 사용할 수 있습니
   다.

   딕셔너리는 삽입 순서를 유지합니다. 키를 갱신해도 순서에는 영향을 미
   치지 않습니다. 삭제 후에 추가된 키는 끝에 삽입됩니다.:

      >>> d = {"one": 1, "two": 2, "three": 3, "four": 4}
      >>> d
      {'one': 1, 'two': 2, 'three': 3, 'four': 4}
      >>> list(d)
      ['one', 'two', 'three', 'four']
      >>> list(d.values())
      [1, 2, 3, 4]
      >>> d["one"] = 42
      >>> d
      {'one': 42, 'two': 2, 'three': 3, 'four': 4}
      >>> del d["two"]
      >>> d["two"] = None
      >>> d
      {'one': 42, 'three': 3, 'four': 4, 'two': None}

   버전 3.7에서 변경: 딕셔너리 순서는 삽입 순서임이 보장됩니다. 이 동
   작은 3.6부터 CPython의 구현 세부 사항입니다.

   이것들은 딕셔너리가 지원하는 연산들입니다 (그러므로, 사용자 정의 매
   핑 형도 지원해야 합니다):

   list(d)

      딕셔너리 *d* 에 사용된 모든 키의 리스트를 돌려줍니다.

   len(d)

      딕셔너리 *d* 에 있는 항목의 수를 돌려줍니다.

   d[key]

      키 *key* 인 *d* 의 항목을 돌려줍니다. *key* 가 매핑에 없는 경우
      "KeyError" 를 일으킵니다.

      If a subclass of dict defines a method "__missing__()" and *key*
      is not present, the "d[key]" operation calls that method with
      the key *key* as argument.  The "d[key]" operation then returns
      or raises whatever is returned or raised by the
      "__missing__(key)" call. No other operations or methods invoke
      "__missing__()". If "__missing__()" is not defined, "KeyError"
      is raised. "__missing__()" must be a method; it cannot be an
      instance variable:

         >>> class Counter(dict):
         ...     def __missing__(self, key):
         ...         return 0
         ...
         >>> c = Counter()
         >>> c['red']
         0
         >>> c['red'] += 1
         >>> c['red']
         1

      The example above shows part of the implementation of
      "collections.Counter". A different "__missing__()" method is
      used by "collections.defaultdict".

   d[key] = value

      "d[key]" 를 *value* 로 설정합니다.

   del d[key]

      *d* 에서 "d[key]" 를 제거합니다. *key* 가 매핑에 없는 경우
      "KeyError" 를 일으킵니다.

   key in d

      *d* 에 키 *key* 가 있으면 "True" 를, 그렇지 않으면 "False" 를 돌
      려줍니다.

   key not in d

      "not key in d" 와 동등합니다.

   iter(d)

      딕셔너리의 키에 대한 이터레이터를 돌려줍니다. 이것은
      "iter(d.keys())" 의 단축입니다.

   clear()

      딕셔너리에서 모든 항목을 제거합니다.

   copy()

      딕셔너리의 얕은 복사본을 돌려줍니다.

   classmethod fromkeys(iterable, value=None, /)

      *iterable* 이 제공하는 값들을 키로 사용하고 모든 값을 *value* 로
      설정한 새 딕셔러리를 돌려줍니다.

      "fromkeys()" 는 새로운 딕셔너리를 돌려주는 클래스 메서드입니다.
      *value* 의 기본값은 "None" 입니다. 모든 값이 단일 인스턴스를 참
      조하므로, *value*가 빈 목록과 같은 가변 객체가 되는 것은 일반적
      으로 의미가 없습니다. 별개의 값을 얻으려면, 대신 딕셔너리 컴프리
      헨션을 사용하십시오.

   get(key, default=None, /)

      *key* 가 딕셔너리에 있는 경우 *key* 에 대응하는 값을 돌려주고,
      그렇지 않으면 *default* 를 돌려줍니다. *default* 가 주어지지 않
      으면 기본값 "None" 이 사용됩니다. 그래서 이 메서드는 절대로
      "KeyError" 를 일으키지 않습니다.

   items()

      딕셔너리 항목들("(key, value)" 쌍들)의 새 뷰를 돌려줍니다. 뷰 객
      체의 설명서 을 참조하세요.

   keys()

      딕셔너리 키들의 새 뷰를 돌려줍니다. 뷰 객체의 설명서 을 참조하세
      요.

   pop(key, /)
   pop(key, default, /)

      *key* 가 딕셔너리에 있으면 제거하고 그 값을 돌려줍니다. 그렇지
      않으면 *default* 를 돌려줍니다. *default* 가 주어지지 않고 *key*
      가 딕셔너리에 없으면 "KeyError" 를 일으킵니다.

   popitem()

      딕셔너리에서 "(key, value)" 쌍을 제거하고 돌려줍니다. 쌍은 LIFO
      (last-in, first-out) 순서로 반환됩니다.

      "popitem()" 은 집합 알고리즘에서 종종 사용되듯이 딕셔너리를 파괴
      적으로 이터레이션 하는 데 유용합니다. 딕셔너리가 비어 있으면
      "popitem()" 호출은 "KeyError" 를 일으킵니다.

      버전 3.7에서 변경: 이제 LIFO 순서가 보장됩니다. 이전 버전에서는,
      "popitem()"가 임의의 키/값 쌍을 반환합니다.

   reversed(d)

      딕셔너리의 키에 대한 역순 이터레이터를 돌려줍니다. 이것은
      "reversed(d.keys())" 의 단축입니다.

      Added in version 3.8.

   setdefault(key, default=None, /)

      *key* 가 딕셔너리에 있으면 해당 값을 돌려줍니다. 그렇지 않으면,
      *default* 값을 갖는 *key* 를 삽입한 후 *default* 를 돌려줍니다.
      *default* 의 기본값은 "None" 입니다.

   update(**kwargs)
   update(mapping, /, **kwargs)
   update(iterable, /, **kwargs)

      Update the dictionary with the key/value pairs from *mapping* or
      *iterable* and *kwargs*, overwriting existing keys.  Return
      "None".

      "update()" accepts either another object with a "keys()" method
      (in which case "__getitem__()" is called with every key returned
      from the method) or an iterable of key/value pairs (as tuples or
      other iterables of length two). If keyword arguments are
      specified, the dictionary is then updated with those key/value
      pairs: "d.update(red=1, blue=2)".

   values()

      딕셔너리 값들의 새 뷰를 돌려줍니다. 뷰 객체의 설명서 을 참조하세
      요.

      한 "dict.values()" 뷰와 다른 "dict.values()" 뷰 간의 동등 비교는
      항상 "False"를 반환합니다. 이것은 "dict.values()"를 자신과 비교
      할 때도 적용됩니다:

         >>> d = {'a': 1}
         >>> d.values() == d.values()
         False

   d | other

      *d*와 *other*의 병합된 키와 값으로 새 딕셔너리를 만듭니다. 둘 다
      딕셔너리이어야 합니다. *d*와 *other*가 키를 공유하면 *other*의
      값이 우선합니다.

      Added in version 3.9.

   d |= other

      *other*의 키와 값으로 딕셔너리 *d*를 갱신합니다. *other*는 *매핑
      *이나 키/값 쌍의 *이터러블*일 수 있습니다. *d*와 *other*가 키를
      공유하면 *other*의 값이 우선합니다.

      Added in version 3.9.

   딕셔너리와 딕셔너리 뷰는 뒤집을 수 있습니다.

      >>> d = {"one": 1, "two": 2, "three": 3, "four": 4}
      >>> d
      {'one': 1, 'two': 2, 'three': 3, 'four': 4}
      >>> list(reversed(d))
      ['four', 'three', 'two', 'one']
      >>> list(reversed(d.values()))
      [4, 3, 2, 1]
      >>> list(reversed(d.items()))
      [('four', 4), ('three', 3), ('two', 2), ('one', 1)]

   버전 3.8에서 변경: 딕셔너리는 이제 뒤집을 수 있습니다.

더 보기: "types.MappingProxyType" 를 "dict" 의 읽기 전용 뷰를 만드는 데 사용
      할 수 있습니다.


딕셔너리 뷰 객체
----------------

"dict.keys()", "dict.values()", "dict.items()" 가 돌려주는 객체는 *뷰
객체* 입니다. 딕셔너리의 항목들에 대한 동적 뷰를 제공합니다. 즉, 딕셔
너리가 변경되면 뷰는 이러한 변경 사항을 반영합니다.

딕셔너리 뷰는 이터레이션을 통해 각각의 데이터를 산출할 수 있고, 멤버십
검사를 지원합니다:

len(dictview)

   딕셔너리에 있는 항목 수를 돌려줍니다.

iter(dictview)

   딕셔너리에서 키, 값, 항목("(key, value)" 튜플로 표현됩니다)에 대한
   이터레이터를 돌려줍니다.

   키와 값은 삽입 순서로 이터레이션 됩니다. 이 때문에 "zip()"을 사용해
   서 "(value, key)" 쌍을 만들 수 있습니다: "pairs = zip(d.values(),
   d.keys())". 같은 리스트를 만드는 다른 방법은 "pairs = [(v, k) for
   (k, v) in d.items()]" 입니다.

   딕셔너리에 항목을 추가하거나 삭제하는 동안 뷰를 이터레이션 하면
   "RuntimeError" 를 일으키거나 모든 항목을 이터레이션 하지 못할 수 있
   습니다.

   버전 3.7에서 변경: 딕셔너리의 순서가 삽입 순서임이 보장됩니다.

x in dictview

   *x* 가 하부 딕셔너리의 키, 갑, 항목에 있는 경우 "True" 를 돌려줍니
   다 (마지막의 경우 *x* 는 "(key, value)" 튜플이어야 합니다).

reversed(dictview)

   딕셔너리의 키, 값 또는 항목에 대한 역방향 이터레이터를 반환합니다.
   뷰는 삽입의 역순으로 이터레이트됩니다.

   버전 3.8에서 변경: 딕셔너리 뷰는 이제 역 탐색할 수 있습니다.

dictview.mapping

   Return a "types.MappingProxyType" that wraps the original
   dictionary to which the view refers.

   Added in version 3.10.

Keys views are set-like since their entries are unique and *hashable*.
Items views also have set-like operations since the (key, value) pairs
are unique and the keys are hashable. If all values in an items view
are hashable as well, then the items view can interoperate with other
sets. (Values views are not treated as set-like since the entries are
generally not unique.)  For set-like views, all of the operations
defined for the abstract base class "collections.abc.Set" are
available (for example, "==", "<", or "^").  While using set
operators, set-like views accept any iterable as the other operand,
unlike sets which only accept sets as the input.

딕셔너리 뷰 사용의 예:

   >>> dishes = {'eggs': 2, 'sausage': 1, 'bacon': 1, 'spam': 500}
   >>> keys = dishes.keys()
   >>> values = dishes.values()

   >>> # iteration
   >>> n = 0
   >>> for val in values:
   ...     n += val
   ...
   >>> print(n)
   504

   >>> # keys and values are iterated over in the same order (insertion order)
   >>> list(keys)
   ['eggs', 'sausage', 'bacon', 'spam']
   >>> list(values)
   [2, 1, 1, 500]

   >>> # view objects are dynamic and reflect dict changes
   >>> del dishes['eggs']
   >>> del dishes['sausage']
   >>> list(keys)
   ['bacon', 'spam']

   >>> # set operations
   >>> keys & {'eggs', 'bacon', 'salad'}
   {'bacon'}
   >>> keys ^ {'sausage', 'juice'} == {'juice', 'sausage', 'bacon', 'spam'}
   True
   >>> keys | ['juice', 'juice', 'juice'] == {'bacon', 'spam', 'juice'}
   True

   >>> # get back a read-only proxy for the original dictionary
   >>> values.mapping
   mappingproxy({'bacon': 1, 'spam': 500})
   >>> values.mapping['spam']
   500


컨텍스트 관리자 형
==================

파이썬의 "with" 문은 컨텍스트 관리자가 정의한 실행 시간 컨텍스트 개념
을 지원합니다. 이는 한 쌍의 메서드를 사용해서 구현되는데, 사용자 정의
클래스가 문장 바디가 실행되기 전에 진입하고, 문장이 끝날 때 탈출하는
실행 시간 컨텍스트를 정의할 수 있게 합니다:

contextmanager.__enter__()

   실행시간 컨텍스트에 진입하고 이 객체 자신이나 실행 시간 컨텍스트와
   관련된 다른 객체를 돌려줍니다. 이 메서드가 돌려주는 값은, 이 컨텍스
   트 관리자를 사용하는 "with" 문의 "as" 절의 식별자에 연결됩니다.

   자신을 돌려주는 컨텍스트 관리자의 예는 *파일 객체* 입니다. 파일 객
   체는 __enter__() 에서 자기 자신을 돌려주는데 "with" 문의 컨텍스트
   표현식으로 "open()" 을 사용할 수 있도록 하기 위함입니다.

   관련 객체를 돌려주는 컨텍스트 관리자의 예는
   "decimal.localcontext()" 가 돌려주는 것입니다. 이 관리자들은 활성
   십진 소수 컨텍스트를 원래 십진 소수 컨텍스트의 복사본으로 설정한 다
   음 복사본을 돌려줍니다. 이것은 "with" 문 바깥의 코드에 영향을 주지
   않으면서 "with" 문 바디에 있는 현재 십진 소수 컨텍스트를 변경할 수
   있게 합니다.

contextmanager.__exit__(exc_type, exc_val, exc_tb)

   실행 시간 컨텍스트를 탈출하고 발생한 예외를 막아야 하는지를 가리키
   는 논리 플래그를 돌려줍니다. "with" 문의 바디를 실행하는 동안 예외
   가 발생하면, 인자에 예외 형, 값 및 추적 정보가 포함됩니다. 그렇지
   않으면, 세 가지 인자 모두 "None" 입니다.

   Returning a true value from this method will cause the "with"
   statement to suppress the exception and continue execution with the
   statement immediately following the "with" statement. Otherwise the
   exception continues propagating after this method has finished
   executing.

   If this method raises an exception while handling an earlier
   exception from the "with" block, the new exception is raised, and
   the original exception is stored in its "__context__" attribute.

   The exception passed in should never be reraised explicitly -
   instead, this method should return a false value to indicate that
   the method completed successfully and does not want to suppress the
   raised exception. This allows context management code to easily
   detect whether or not an "__exit__()" method has actually failed.

파이썬은 쉬운 스레드 동기화, 파일이나 다른 객체의 신속한 닫기, 그리고
활성 십진 소수 산술 컨텍스트의 보다 간단한 조작을 지원하기 위해 몇 가
지 컨텍스트 관리자를 정의합니다. 컨텍스트 관리 프로토콜의 구현을 넘어
구체적인 형은 특별히 취급되지 않습니다. 몇 가지 예제는 "contextlib" 모
듈을 보십시오.

Python's *generator*s and the "contextlib.contextmanager" decorator
provide a convenient way to implement these protocols.  If a generator
function is decorated with the "contextlib.contextmanager" decorator,
it will return a context manager implementing the necessary
"__enter__()" and "__exit__()" methods, rather than the iterator
produced by an undecorated generator function.

파이썬/C API의 파이썬 객체에 대한 형 구조체에는 이러한 메서드들을 위해
준비된 슬롯이 없다는 점에 유의하십시오. 이러한 메서드를 정의하고자 하
는 확장형은 일반적인 파이썬 액세스가 가능한 메서드로 제공해야 합니다.
실행 시간 컨텍스트를 설정하는 오버헤드와 비교할 때 한 번의 클래스 딕셔
너리 조회의 오버헤드는 무시할 수 있습니다.


Type Annotation Types --- Generic Alias, Union
==============================================

The core built-in types for *type annotations* are Generic Alias and
Union.


제네릭 에일리어스 형
--------------------

"GenericAlias" objects are generally created by subscripting a class.
They are most often used with container classes, such as "list" or
"dict". For example, "list[int]" is a "GenericAlias" object created by
subscripting the "list" class with the argument "int". "GenericAlias"
objects are intended primarily for use with *type annotations*.

참고:

  It is generally only possible to subscript a class if the class
  implements the special method "__class_getitem__()".

A "GenericAlias" object acts as a proxy for a *generic type*,
implementing *parameterized generics*.

For a container class, the argument(s) supplied to a subscription of
the class may indicate the type(s) of the elements an object contains.
For example, "set[bytes]" can be used in type annotations to signify a
"set" in which all the elements are of type "bytes".

For a class which defines "__class_getitem__()" but is not a
container, the argument(s) supplied to a subscription of the class
will often indicate the return type(s) of one or more methods defined
on an object. For example, "regular expressions" can be used on both
the "str" data type and the "bytes" data type:

* If "x = re.search('foo', 'foo')", "x" will be a re.Match object
  where the return values of "x.group(0)" and "x[0]" will both be of
  type "str". We can represent this kind of object in type annotations
  with the "GenericAlias" "re.Match[str]".

* If "y = re.search(b'bar', b'bar')", (note the "b" for "bytes"), "y"
  will also be an instance of "re.Match", but the return values of
  "y.group(0)" and "y[0]" will both be of type "bytes". In type
  annotations, we would represent this variety of re.Match objects
  with "re.Match[bytes]".

"GenericAlias" objects are instances of the class
"types.GenericAlias", which can also be used to create "GenericAlias"
objects directly.

T[X, Y, ...]

   Creates a "GenericAlias" representing a type "T" parameterized by
   types *X*, *Y*, and more depending on the "T" used. For example, a
   function expecting a "list" containing "float" elements:

      def average(values: list[float]) -> float:
          return sum(values) / len(values)

   키 형과 값 형을 나타내는 두 개의 형 매개 변수를 기대하는 제네릭 형
   인 "dict"를 사용하는 *매핑* 객체의 또 다른 예. 이 예에서, 함수는
   "str" 형의 키와 "int" 형의 값을 갖는 "dict"를 기대합니다:

      def send_post_request(url: str, body: dict[str, int]) -> None:
          ...

내장 함수 "isinstance()"와 "issubclass()"는 두 번째 인자로
"GenericAlias" 형을 받아들이지 않습니다:

   >>> isinstance([1, 2], list[str])
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: isinstance() argument 2 cannot be a parameterized generic

The Python runtime does not enforce *type annotations*. This extends
to generic types and their type parameters. When creating a container
object from a "GenericAlias", the elements in the container are not
checked against their type. For example, the following code is
discouraged, but will run without errors:

   >>> t = list[str]
   >>> t([1, 2, 3])
   [1, 2, 3]

또한, 매개 변수화된 제네릭은 객체 생성 중에 형 매개 변수를 지웁니다:

   >>> t = list[str]
   >>> type(t)
   <class 'types.GenericAlias'>

   >>> l = t()
   >>> type(l)
   <class 'list'>

제네릭에서 "repr()"이나 "str()"을 호출하면 매개 변수화된 형이 표시됩니
다:

   >>> repr(list[int])
   'list[int]'

   >>> str(list[int])
   'list[int]'

The "__getitem__()" method of generic containers will raise an
exception to disallow mistakes like "dict[str][str]":

   >>> dict[str][str]
   Traceback (most recent call last):
     ...
   TypeError: dict[str] is not a generic class

However, such expressions are valid when type variables are used.  The
index must have as many elements as there are type variable items in
the "GenericAlias" object's "__args__".

   >>> from typing import TypeVar
   >>> Y = TypeVar('Y')
   >>> dict[str, Y][int]
   dict[str, int]


Standard Generic Classes
~~~~~~~~~~~~~~~~~~~~~~~~

The following standard library classes support parameterized generics.
This list is non-exhaustive.

* "tuple"

* "list"

* "dict"

* "set"

* "frozenset"

* "type"

* "asyncio.Future"

* "asyncio.Task"

* "collections.deque"

* "collections.defaultdict"

* "collections.OrderedDict"

* "collections.Counter"

* "collections.ChainMap"

* "collections.abc.Awaitable"

* "collections.abc.Coroutine"

* "collections.abc.AsyncIterable"

* "collections.abc.AsyncIterator"

* "collections.abc.AsyncGenerator"

* "collections.abc.Iterable"

* "collections.abc.Iterator"

* "collections.abc.Generator"

* "collections.abc.Reversible"

* "collections.abc.Container"

* "collections.abc.Collection"

* "collections.abc.Callable"

* "collections.abc.Set"

* "collections.abc.MutableSet"

* "collections.abc.Mapping"

* "collections.abc.MutableMapping"

* "collections.abc.Sequence"

* "collections.abc.MutableSequence"

* "collections.abc.ByteString"

* "collections.abc.MappingView"

* "collections.abc.KeysView"

* "collections.abc.ItemsView"

* "collections.abc.ValuesView"

* "contextlib.AbstractContextManager"

* "contextlib.AbstractAsyncContextManager"

* "dataclasses.Field"

* "functools.cached_property"

* "functools.partialmethod"

* "os.PathLike"

* "queue.LifoQueue"

* "queue.Queue"

* "queue.PriorityQueue"

* "queue.SimpleQueue"

* re.Pattern

* re.Match

* "shelve.BsdDbShelf"

* "shelve.DbfilenameShelf"

* "shelve.Shelf"

* "types.MappingProxyType"

* "weakref.WeakKeyDictionary"

* "weakref.WeakMethod"

* "weakref.WeakSet"

* "weakref.WeakValueDictionary"


Special Attributes of "GenericAlias" objects
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

모든 매개 변수화된 제네릭은 특수 읽기 전용 어트리뷰트를 구현합니다.

genericalias.__origin__

   이 어트리뷰트는 매개 변수화되지 않은 제네릭 클래스를 가리킵니다:

      >>> list[int].__origin__
      <class 'list'>

genericalias.__args__

   This attribute is a "tuple" (possibly of length 1) of generic types
   passed to the original "__class_getitem__()" of the generic class:

      >>> dict[str, list[int]].__args__
      (<class 'str'>, list[int])

genericalias.__parameters__

   이 어트리뷰트는 "__args__"에서 발견된 고유한 형 변수의 게으르게
   (lazily) 계산된 튜플(비어있을 수 있습니다)입니다:

      >>> from typing import TypeVar

      >>> T = TypeVar('T')
      >>> list[T].__parameters__
      (~T,)

   참고:

     A "GenericAlias" object with "typing.ParamSpec" parameters may
     not have correct "__parameters__" after substitution because
     "typing.ParamSpec" is intended primarily for static type
     checking.

genericalias.__unpacked__

   A boolean that is true if the alias has been unpacked using the "*"
   operator (see "TypeVarTuple").

   Added in version 3.11.

더 보기:

  **PEP 484** - Type Hints
     Introducing Python's framework for type annotations.

  **PEP 585** - Type Hinting Generics In Standard Collections
     Introducing the ability to natively parameterize standard-library
     classes, provided they implement the special class method
     "__class_getitem__()".

  제네릭, user-defined generics and "typing.Generic"
     Documentation on how to implement generic classes that can be
     parameterized at runtime and understood by static type-checkers.

Added in version 3.9.


Union Type
----------

A union object holds the value of the "|" (bitwise or) operation on
multiple type objects.  These types are intended primarily for *type
annotations*. The union type expression enables cleaner type hinting
syntax compared to subscripting "typing.Union".

X | Y | ...

   Defines a union object which holds types *X*, *Y*, and so forth. "X
   | Y" means either X or Y.  It is equivalent to "typing.Union[X,
   Y]". For example, the following function expects an argument of
   type "int" or "float":

      def square(number: int | float) -> int | float:
          return number ** 2

   참고:

     The "|" operand cannot be used at runtime to define unions where
     one or more members is a forward reference. For example, "int |
     "Foo"", where ""Foo"" is a reference to a class not yet defined,
     will fail at runtime. For unions which include forward
     references, present the whole expression as a string, e.g. ""int
     | Foo"".

union_object == other

   Union objects can be tested for equality with other union objects.
   Details:

   * Unions of unions are flattened:

        (int | str) | float == int | str | float

   * Redundant types are removed:

        int | str | int == int | str

   * When comparing unions, the order is ignored:

        int | str == str | int

   * It creates instances of "typing.Union":

        int | str == typing.Union[int, str]
        type(int | str) is typing.Union

   * Optional types can be spelled as a union with "None":

        str | None == typing.Optional[str]

isinstance(obj, union_object)

issubclass(obj, union_object)

   Calls to "isinstance()" and "issubclass()" are also supported with
   a union object:

      >>> isinstance("", int | str)
      True

   However, parameterized generics in union objects cannot be checked:

      >>> isinstance(1, int | list[int])  # short-circuit evaluation
      True
      >>> isinstance([1], int | list[int])
      Traceback (most recent call last):
        ...
      TypeError: isinstance() argument 2 cannot be a parameterized generic

The user-exposed type for the union object can be accessed from
"typing.Union" and used for "isinstance()" checks:

   >>> import typing
   >>> isinstance(int | str, typing.Union)
   True
   >>> typing.Union()
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: cannot create 'typing.Union' instances

참고:

  The "__or__()" method for type objects was added to support the
  syntax "X | Y".  If a metaclass implements "__or__()", the Union may
  override it:

     >>> class M(type):
     ...     def __or__(self, other):
     ...         return "Hello"
     ...
     >>> class C(metaclass=M):
     ...     pass
     ...
     >>> C | int
     'Hello'
     >>> int | C
     int | C

더 보기:

  **PEP 604** -- PEP proposing the "X | Y" syntax and the Union type.

Added in version 3.10.

버전 3.14에서 변경: Union objects are now instances of "typing.Union".
Previously, they were instances of "types.UnionType", which remains an
alias for "typing.Union".


기타 내장형
===========

인터프리터는 여러 가지 다른 객체를 지원합니다. 이것들 대부분은 한두 가
지 연산만 지원합니다.


모듈
----

모듈에 대한 유일한 특별한 연산은 어트리뷰트 액세스입니다: "m.name". 여
기서 *m* 은 모듈이고 *name* 은 *m* 의 심볼 테이블에 정의된 이름에 액세
스합니다. 모듈 어트리뷰트는 대입할 수 있습니다. ("import" 문은 엄밀히
말하면 모듈 객체에 대한 연산이 아닙니다; "import foo" 는 *foo* 라는 이
름의 모듈 객체가 존재할 것을 요구하지 않고, 어딘가에 있는 *foo* 라는
이름의 (외부) *정의* 를 요구합니다.

모든 모듈의 특수 어트리뷰트는 "__dict__" 입니다. 이것은 모듈의 심볼 테
이블을 저장하는 딕셔너리입니다. 이 딕셔너리를 수정하면 모듈의 심볼 테
이블이 실제로 변경되지만, "__dict__" 어트리뷰트에 대한 직접 대입은 불
가능합니다 ("m.__dict__['a'] = 1" 라고 쓸 수 있고, "m.a" 가 "1" 이 되
지만, "m.__dict__ = {}" 라고 쓸 수는 없습니다). "__dict__" 의 직접적인
수정은 추천하지 않습니다.

인터프리터에 내장된 모듈은 다음과 같이 쓰입니다: "<module 'sys'
(built-in)>". 파일에서 로드되면, "<module 'os' from
'/usr/local/lib/pythonX.Y/os.pyc'>" 처럼 쓰입니다.


클래스와 클래스 인스턴스
------------------------

여기에 대해서는 객체, 값, 형와 클래스 정의를 참조하세요.


함수
----

함수 객체는 함수 정의로 만들어집니다. 함수 객체에 대한 유일한 연산은
호출하는 것입니다: "func(argument-list)".

함수 객체에는 내장 함수와 사용자 정의 함수라는 두 가지 종류가 있습니다
. 두 함수 모두 같은 연산(함수 호출)을 지원하지만, 구현이 다르므로 서로
다른 객체 형입니다.

자세한 정보는 함수 정의을 보십시오.


메서드
------

Methods are functions that are called using the attribute notation.
There are two flavors: built-in methods (such as "append()" on lists)
and class instance method. Built-in methods are described with the
types that support them.

If you access a method (a function defined in a class namespace)
through an instance, you get a special object: a *bound method* (also
called instance method) object. When called, it will add the "self"
argument to the argument list.  Bound methods have two special read-
only attributes: "m.__self__" is the object on which the method
operates, and "m.__func__" is the function implementing the method.
Calling "m(arg-1, arg-2, ..., arg-n)" is completely equivalent to
calling "m.__func__(m.__self__, arg-1, arg-2, ..., arg-n)".

Like function objects, bound method objects support getting arbitrary
attributes.  However, since method attributes are actually stored on
the underlying function object ("method.__func__"), setting method
attributes on bound methods is disallowed.  Attempting to set an
attribute on a method results in an "AttributeError" being raised.  In
order to set a method attribute, you need to explicitly set it on the
underlying function object:

   >>> class C:
   ...     def method(self):
   ...         pass
   ...
   >>> c = C()
   >>> c.method.whoami = 'my name is method'  # can't set on the method
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   AttributeError: 'method' object has no attribute 'whoami'
   >>> c.method.__func__.whoami = 'my name is method'
   >>> c.method.whoami
   'my name is method'

See 인스턴스 메서드(Instance methods) for more information.


코드 객체
---------

Code objects are used by the implementation to represent "pseudo-
compiled" executable Python code such as a function body. They differ
from function objects because they don't contain a reference to their
global execution environment.  Code objects are returned by the built-
in "compile()" function and can be extracted from function objects
through their "__code__" attribute. See also the "code" module.

Accessing "__code__" raises an auditing event "object.__getattr__"
with arguments "obj" and ""__code__"".

코드 객체는 "exec()" 또는 "eval()" 내장 함수에 (소스 문자열 대신) 전달
하여 실행하거나 값을 구할 수 있습니다.

자세한 정보는 표준형 계층를 보십시오.


형 객체
-------

형 객체는 다양한 객체 형을 나타냅니다. 객체의 형은 내장 함수 "type()"
으로 액세스할 수 있습니다. 형에는 특별한 연산이 없습니다. 표준 모듈
"types" 는 모든 표준 내장형의 이름을 정의합니다.

형은 다음과 같이 쓰입니다: "<class 'int'>".


널 객체
-------

이 객체는 명시적으로 값을 돌려주지 않는 함수에 의해 반환됩니다. 특별한
연산을 지원하지 않습니다. 정확하게 하나의 널 객체가 있으며, 이름은
"None"(내장 이름)입니다. "type(None)()" 은 같은 싱글톤을 만듭니다.

"None" 이라고 쓰입니다.


Ellipsis 객체
-------------

This object is commonly used to indicate that something is omitted. It
supports no special operations.  There is exactly one ellipsis object,
named "Ellipsis" (a built-in name).  "type(Ellipsis)()" produces the
"Ellipsis" singleton.

"Ellipsis" 나 "..." 로 쓰입니다.

In typical use, "..." as the "Ellipsis" object appears in a few
different places, for instance:

* In type annotations, such as callable arguments or tuple elements.

* As the body of a function instead of a pass statement.

* In third-party libraries, such as Numpy's slicing and striding.

Python also uses three dots in ways that are not "Ellipsis" objects,
for instance:

* Doctest's "ELLIPSIS", as a pattern for missing content.

* The default Python prompt of the *interactive* shell when partial
  input is incomplete.

Lastly, the Python documentation often uses three dots in conventional
English usage to mean omitted content, even in code examples that also
use them as the "Ellipsis".


NotImplemented 객체
-------------------

This object is returned from comparisons and binary operations when
they are asked to operate on types they don't support. See 비교 for
more information.  There is exactly one "NotImplemented" object.
"type(NotImplemented)()" produces the singleton instance.

It is written as "NotImplemented".


내부 객체
---------

See 표준형 계층 for this information.  It describes stack frame
objects, traceback objects, and slice objects.


특수 어트리뷰트
===============

관련성이 있을 때, 구현은 몇 가지 객체 유형에 몇 가지 특수 읽기 전용 어
트리뷰트를 추가합니다. 이 중 일부는 "dir()" 내장 함수에 의해 보고되지
않습니다.

definition.__name__

   클래스, 함수, 메서드, 디스크립터 또는 제너레이터 인스턴스의 이름.

definition.__qualname__

   클래스, 함수, 메서드, 디스크립터 또는 제너레이터 인스턴스의 *정규화
   된 이름*.

   Added in version 3.3.

definition.__module__

   The name of the module in which a class or function was defined.

definition.__doc__

   The documentation string of a class or function, or "None" if
   undefined.

definition.__type_params__

   The type parameters of generic classes, functions, and type
   aliases. For classes and functions that are not generic, this will
   be an empty tuple.

   Added in version 3.12.


Integer string conversion length limitation
===========================================

CPython has a global limit for converting between "int" and "str" to
mitigate denial of service attacks. This limit *only* applies to
decimal or other non-power-of-two number bases. Hexadecimal, octal,
and binary conversions are unlimited. The limit can be configured.

The "int" type in CPython is an arbitrary length number stored in
binary form (commonly known as a "bignum"). There exists no algorithm
that can convert a string to a binary integer or a binary integer to a
string in linear time, *unless* the base is a power of 2. Even the
best known algorithms for base 10 have sub-quadratic complexity.
Converting a large value such as "int('1' * 500_000)" can take over a
second on a fast CPU.

Limiting conversion size offers a practical way to avoid **CVE
2020-10735**.

The limit is applied to the number of digit characters in the input or
output string when a non-linear conversion algorithm would be
involved.  Underscores and the sign are not counted towards the limit.

When an operation would exceed the limit, a "ValueError" is raised:

   >>> import sys
   >>> sys.set_int_max_str_digits(4300)  # Illustrative, this is the default.
   >>> _ = int('2' * 5432)
   Traceback (most recent call last):
   ...
   ValueError: Exceeds the limit (4300 digits) for integer string conversion: value has 5432 digits; use sys.set_int_max_str_digits() to increase the limit
   >>> i = int('2' * 4300)
   >>> len(str(i))
   4300
   >>> i_squared = i*i
   >>> len(str(i_squared))
   Traceback (most recent call last):
   ...
   ValueError: Exceeds the limit (4300 digits) for integer string conversion; use sys.set_int_max_str_digits() to increase the limit
   >>> len(hex(i_squared))
   7144
   >>> assert int(hex(i_squared), base=16) == i*i  # Hexadecimal is unlimited.

The default limit is 4300 digits as provided in
"sys.int_info.default_max_str_digits". The lowest limit that can be
configured is 640 digits as provided in
"sys.int_info.str_digits_check_threshold".

Verification:

   >>> import sys
   >>> assert sys.int_info.default_max_str_digits == 4300, sys.int_info
   >>> assert sys.int_info.str_digits_check_threshold == 640, sys.int_info
   >>> msg = int('578966293710682886880994035146873798396722250538762761564'
   ...           '9252925514383915483333812743580549779436104706260696366600'
   ...           '571186405732').to_bytes(53, 'big')
   ...

Added in version 3.11.


Affected APIs
-------------

The limitation only applies to potentially slow conversions between
"int" and "str" or "bytes":

* "int(string)" with default base 10.

* "int(string, base)" for all bases that are not a power of 2.

* "str(integer)".

* "repr(integer)".

* any other string conversion to base 10, for example "f"{integer}"",
  ""{}".format(integer)", or "b"%d" % integer".

The limitations do not apply to functions with a linear algorithm:

* "int(string, base)" with base 2, 4, 8, 16, or 32.

* "int.from_bytes()" and "int.to_bytes()".

* "hex()", "oct()", "bin()".

* 포맷 명세 미니 언어 for hex, octal, and binary numbers.

* "str" to "float".

* "str" to "decimal.Decimal".


Configuring the limit
---------------------

Before Python starts up you can use an environment variable or an
interpreter command line flag to configure the limit:

* "PYTHONINTMAXSTRDIGITS", e.g. "PYTHONINTMAXSTRDIGITS=640 python3" to
  set the limit to 640 or "PYTHONINTMAXSTRDIGITS=0 python3" to disable
  the limitation.

* "-X int_max_str_digits", e.g. "python3 -X int_max_str_digits=640"

* "sys.flags.int_max_str_digits" contains the value of
  "PYTHONINTMAXSTRDIGITS" or "-X int_max_str_digits". If both the env
  var and the "-X" option are set, the "-X" option takes precedence. A
  value of *-1* indicates that both were unset, thus a value of
  "sys.int_info.default_max_str_digits" was used during
  initialization.

From code, you can inspect the current limit and set a new one using
these "sys" APIs:

* "sys.get_int_max_str_digits()" and "sys.set_int_max_str_digits()"
  are a getter and setter for the interpreter-wide limit.
  Subinterpreters have their own limit.

Information about the default and minimum can be found in
"sys.int_info":

* "sys.int_info.default_max_str_digits" is the compiled-in default
  limit.

* "sys.int_info.str_digits_check_threshold" is the lowest accepted
  value for the limit (other than 0 which disables it).

Added in version 3.11.

조심:

  Setting a low limit *can* lead to problems. While rare, code exists
  that contains integer constants in decimal in their source that
  exceed the minimum threshold. A consequence of setting the limit is
  that Python source code containing decimal integer literals longer
  than the limit will encounter an error during parsing, usually at
  startup time or import time or even at installation time - anytime
  an up to date ".pyc" does not already exist for the code. A
  workaround for source that contains such large constants is to
  convert them to "0x" hexadecimal form as it has no limit.Test your
  application thoroughly if you use a low limit. Ensure your tests run
  with the limit set early via the environment or flag so that it
  applies during startup and even during any installation step that
  may invoke Python to precompile ".py" sources to ".pyc" files.


Recommended configuration
-------------------------

The default "sys.int_info.default_max_str_digits" is expected to be
reasonable for most applications. If your application requires a
different limit, set it from your main entry point using Python
version agnostic code as these APIs were added in security patch
releases in versions before 3.12.

Example:

   >>> import sys
   >>> if hasattr(sys, "set_int_max_str_digits"):
   ...     upper_bound = 68000
   ...     lower_bound = 4004
   ...     current_limit = sys.get_int_max_str_digits()
   ...     if current_limit == 0 or current_limit > upper_bound:
   ...         sys.set_int_max_str_digits(upper_bound)
   ...     elif current_limit < lower_bound:
   ...         sys.set_int_max_str_digits(lower_bound)

If you need to disable it entirely, set it to "0".

-[ 각주 ]-

[1] 이 특수 메서드에 대한 추가 정보는 파이썬 레퍼런스 설명서(기본적인
    커스터마이제이션)에서 찾을 수 있습니다.

[2] 결과적으로, 리스트 "[1, 2]" 는 "[1.0, 2.0]" 과 같다고 취급되고, 튜
    플도 마찬가지입니다.

[3] 파서가 피연산자 유형을 알 수 없으므로 그럴 수밖에 없습니다.

[4] 케이스 문자는 일반 범주 속성이 "Lu" (Letter, 대문자), "Ll"
    (Letter, 소문자), "Lt" (Letter, 제목 문자) 중 한 가지인 경우입니다
    .

[5] 그래서, 튜플만을 포매팅하려면 포맷할 튜플 하나만을 포함하는 1-튜플
    을 제공해야 합니다.
