"time" --- 시간 액세스와 변환
*****************************

======================================================================

이 모듈은 다양한 시간 관련 함수를 제공합니다. 관련 기능에 대해서는,
"datetime"과 "calendar" 모듈도 참조하십시오.

이 모듈을 항상 사용할 수 있지만, 모든 플랫폼에서 모든 함수를 사용할 수
있는 것은 아닙니다. 이 모듈에 정의된 대부분의 함수는 같은 이름의 플랫
폼 C 라이브러리 함수를 호출합니다. 이러한 함수의 의미는 플랫폼마다 달
라서, 플랫폼 설명서를 참조하면 도움이 될 수 있습니다.

일부 용어와 관례에 대한 설명을 순서대로 제시합니다.

* *에포크(epoch)*는 시간이 시작되는 시점이며, "time.gmtime(0)"의 반환
  값입니다. 모든 플랫폼에서 1970년 1월 1일, 00:00:00(UTC) 입니다.

* 용어 *에포크 이후의 초(seconds since the epoch)*는 에포크 이후로 총
  지나간 초를 나타내는데, 보통 윤초는 제외합니다. 모든 POSIX 호환 플랫
  폼에서 윤초는 이 총계에서 제외됩니다.

* 이 모듈의 함수는 에포크 전이나 먼 미래의 날짜와 시간을 처리하지 못할
  수 있습니다. 미래의 컷오프 지점은 C 라이브러리에 의해 결정됩니다; 32
  비트 시스템의 경우, 일반적으로 2038년입니다.

* 함수 "strptime()"은 "%y" 포맷 코드가 제공될 때 2자리 연도를 구문 분
  석할 수 있습니다. 2자리 연도를 구문 분석할 때, POSIX와 ISO C 표준에
  따라 변환됩니다: 값 69--99는 1969--1999에, 값 0--68은 2000--2068에
  매핑됩니다.

* UTC is Coordinated Universal Time and superseded Greenwich Mean Time
  or GMT as the basis of international timekeeping. The acronym UTC is
  not a mistake but conforms to an earlier, language-agnostic naming
  scheme for time standards such as UT0, UT1, and UT2.

* DST는 일광 절약 시간(Daylight Saving Time)인데, 일 년 중 일부 기간
  시간대를 (일반적으로) 한 시간 조정합니다. DST 규칙은 매직(현지 법에
  따라 결정됩니다)이며 해가 바뀜에 따라 변경될 수 있습니다. C 라이브러
  리에는 현지 규칙이 포함된 테이블이 있으며 (종종 유연성을 위해 시스템
  파일에서 읽습니다) 이 점에서 진정한 지혜(True Wisdom)의 유일한 원천
  입니다.

* 다양한 실시간 함수의 정밀도는 값이나 인자가 표현되는 단위가 제안하는
  것보다 못할 수 있습니다. 예를 들어 대부분의 유닉스 시스템에서 시계는
  초당 50회나 100회만 "틱(ticks)"합니다.

* 반면에, "time()"과 "sleep()"의 정밀도는 그들의 유닉스의 해당하는 것
  보다 낫습니다: 시간은 부동 소수점 숫자로 표현되고, "time()"은 사용
  가능한 가장 정확한 시간을 반환하며 (사용할 수 있으면 유닉스
  "gettimeofday()"를 사용합니다), "sleep()"은 0이 아닌 소수부를 갖는
  시간을 받아들입니다 (사용할 수 있으면, 이것을 구현하는 데 유닉스
  "select()"를 사용합니다).

* "gmtime()", "localtime()" 및 "strptime()"에 의해 반환되고
  "asctime()", "mktime()" 및 "strftime()"이 받아들이는 시간 값은 9개의
  정수의 시퀀스입니다. "gmtime()", "localtime()" 및 "strptime()"의 반
  환 값은 개별 필드에 대한 어트리뷰트 이름도 제공합니다.

  이러한 객체에 대한 설명은 "struct_time"을 참조하십시오.

  버전 3.3에서 변경: 플랫폼이 해당 "struct tm" 멤버를 지원할 때
  "tm_gmtoff"와 "tm_zone" 어트리뷰트를 제공하도록 "struct_time" 형이
  확장되었습니다.

  버전 3.6에서 변경: "struct_time" 어트리뷰트 "tm_gmtoff"와 "tm_zone"
  은 이제 모든 플랫폼에서 사용 가능합니다.

* 시간 표현 간에 변환하려면 다음 함수를 사용하십시오:

  +---------------------------+---------------------------+---------------------------+
  | 변환 전                   | 변환 후                   | 변환 함수                 |
  |===========================|===========================|===========================|
  | 에포크 이후 초            | UTC의 "struct_time"       | "gmtime()"                |
  +---------------------------+---------------------------+---------------------------+
  | 에포크 이후 초            | 현지 시간의 "struct_time" | "localtime()"             |
  +---------------------------+---------------------------+---------------------------+
  | UTC의 "struct_time"       | 에포크 이후 초            | "calendar.timegm()"       |
  +---------------------------+---------------------------+---------------------------+
  | 현지 시간의 "struct_time" | 에포크 이후 초            | "mktime()"                |
  +---------------------------+---------------------------+---------------------------+


함수
====

time.asctime([t])

   "gmtime()"이나 "localtime()" 이 반환한 시간을 나타내는 튜플이나
   "struct_time"을 "'Sun Jun 20 23:21:05 1993'" 형식의 문자열로 변환합
   니다. 날짜(day) 필드는 두 문자 길이이며 날짜가 한자리이면 스페이스
   로 채워집니다, 예를 들어: "'Wed Jun  9 04:26:40 1993'".

   *t*가 제공되지 않으면, "localtime()" 에서 반환된 현재 시각이 사용됩
   니다. 로케일 정보는 "asctime()"에서 사용되지 않습니다.

   참고:

     같은 이름의 C 함수와 달리, "asctime()"은 끝에 줄 바꿈을 추가하지
     않습니다.

time.pthread_getcpuclockid(thread_id)

   지정된 *thread_id*에 대한 스레드 특정 CPU-시간 시계의 *clk_id*를 반
   환합니다.

   *thread_id*에 적합한 값을 얻으려면 "threading.get_ident()" 나
   "threading.Thread" 객체의 "ident" 어트리뷰트를 사용하십시오.

   경고:

     유효하지 않거나 만료된 *thread_id*를 전달하면 정의되지 않은 동작
     이 발생할 수 있습니다, 가령 세그먼트 폴트(segmentation fault).

   가용성: Unix

   자세한 내용은 *pthread_getcpuclockid(3)* 매뉴얼 페이지를 참조하십시
   오.

   Added in version 3.7.

time.clock_getres(clk_id)

   지정된 시계 *clk_id*의 해상도(정밀도)를 반환합니다. *clk_id*에 허용
   되는 값 리스트는 시계 ID 상수를 참조하십시오.

   가용성: Unix.

   Added in version 3.3.

time.clock_gettime(clk_id) -> float

   지정된 시계 *clk_id*의 시간을 반환합니다. *clk_id*에 허용되는 값 리
   스트는 시계 ID 상수를 참조하십시오.

   Use "clock_gettime_ns()" to avoid the precision loss caused by the
   "float" type.

   가용성: Unix.

   Added in version 3.3.

time.clock_gettime_ns(clk_id) -> int

   "clock_gettime()"과 비슷하지만, 시간을 나노초로 반환합니다.

   가용성: Unix.

   Added in version 3.7.

time.clock_settime(clk_id, time: float)

   지정된 시계 *clk_id*의 시간을 설정합니다. 현재, "CLOCK_REALTIME"이
   *clk_id*에 대해 유일하게 허용되는 값입니다.

   Use "clock_settime_ns()" to avoid the precision loss caused by the
   "float" type.

   가용성: Unix, not Android, not iOS.

   Added in version 3.3.

time.clock_settime_ns(clk_id, time: int)

   "clock_settime()"과 비슷하지만, 나노초로 시간을 설정합니다.

   가용성: Unix, not Android, not iOS.

   Added in version 3.7.

time.ctime([secs])

   에포크 이후 초로 표현된 시간을 현지 시간을 나타내는 "'Sun Jun 20
   23:21:05 1993'" 형식의 문자열로 변환합니다. 날짜(day) 필드는 두 문
   자 길이이며 날짜가 한자리이면 스페이스로 채워집니다, 예를 들어:
   "'Wed Jun  9 04:26:40 1993'".

   *secs*가 제공되지 않거나 "None"이면, "time()"이 반환하는 현재 시각
   이 사용됩니다. "ctime(secs)"는 "asctime(localtime(secs))"와 동등합
   니다. 로케일 정보는 "ctime()"에서 사용되지 않습니다.

time.get_clock_info(name)

   지정된 시계에 대한 정보를 이름 공간 객체로 가져옵니다. 지원되는 시
   계 이름과 그 값을 읽는 해당 함수는 다음과 같습니다:

   * "'monotonic'": "time.monotonic()"

   * "'perf_counter'": "time.perf_counter()"

   * "'process_time'": "time.process_time()"

   * "'thread_time'": "time.thread_time()"

   * "'time'": "time.time()"

   결과는 다음과 같은 어트리뷰트를 갖습니다:

   * *adjustable*: "True" if the clock can be set to jump forward or
     backward in time, "False" otherwise. Does not refer to gradual
     NTP rate adjustments.

   * *implementation*: 시계값을 얻는 데 사용되는 하부 C 함수의 이름.
     가능한 값은 시계 ID 상수를 참조하십시오.

   * *monotonic*: 시계가 뒤로 이동할 수 없으면 "True", 그렇지 않으면
     "False"

   * *resolution*: 초 단위의 시계 해상도 ("float")

   Added in version 3.3.

time.gmtime([secs])

   에포크 이후의 초 단위 시간을 dst 플래그가 항상 0인 UTC인
   "struct_time"으로 변환합니다. *secs*가 제공되지 않거나 "None"이면,
   "time()"에서 반환된 현재 시각이 사용됩니다. 초의 소수부는 무시됩니
   다. "struct_time" 객체에 대한 설명은 위를 참조하십시오. 이 함수의
   역에 대해서는 "calendar.timegm()"을 참조하십시오.

time.localtime([secs])

   "gmtime()"과 같지만, 현지 시간으로 변환합니다. *secs*가 제공되지 않
   거나 "None"이면 "time()"에서 반환된 현재 시각이 사용됩니다. DST가
   주어진 시간에 적용되면 dst 플래그는 "1"로 설정됩니다.

   "localtime()" may raise "OverflowError", if the timestamp is
   outside the range of values supported by the platform C
   "localtime()" or "gmtime()" functions, and "OSError" on
   "localtime()" or "gmtime()" failure. It's common for this to be
   restricted to years between 1970 and 2038.

time.mktime(t)

   이것은 "localtime()" 의 역함수입니다. 인자는 UTC가 아니라 *현지* 시
   간으로 시간을 표현하는 "struct_time"이나 전체 9-튜플 (dst 플래그가
   필요하기 때문에; 알 수 없으면 dst 플래그로 "-1"을 사용하십시오)입니
   다. "time()"과의 호환성을 위해, 부동 소수점 숫자를 반환합니다. 입력
   값을 유효한 시간으로 표현할 수 없으면, "OverflowError"나
   "ValueError"가 발생합니다 (유효하지 않은 값이 파이썬이나 하부 C 라
   이브러리 중 어디에서 잡히는지에 따라 다릅니다). 시간을 생성 할 수
   있는 가장 이른 날짜는 플랫폼에 따라 다릅니다.

time.monotonic() -> float

   단조(monotonic) 시계, 즉 뒤로 갈 수 없는 시계의 값을 (소수부가 있는
   초로) 반환합니다. 시계는 시스템 시계 갱신의 영향을 받지 않습니다.
   반환된 값의 기준점은 정의되어 있지 않아서, 두 호출 결과 간의 차이만
   유효합니다.

   Clock:

   * On Windows, call "QueryPerformanceCounter()" and
     "QueryPerformanceFrequency()".

   * On macOS, call "mach_absolute_time()" and "mach_timebase_info()".

   * On HP-UX, call "gethrtime()".

   * Call "clock_gettime(CLOCK_HIGHRES)" if available.

   * Otherwise, call "clock_gettime(CLOCK_MONOTONIC)".

   Use "monotonic_ns()" to avoid the precision loss caused by the
   "float" type.

   Added in version 3.3.

   버전 3.5에서 변경: The function is now always available and the
   clock is now the same for all processes.

   버전 3.10에서 변경: On macOS, the clock is now the same for all
   processes.

time.monotonic_ns() -> int

   "monotonic()"과 비슷하지만, 시간을 나노초로 반환합니다.

   Added in version 3.7.

time.perf_counter() -> float

   Return the value (in fractional seconds) of a performance counter,
   i.e. a clock with the highest available resolution to measure a
   short duration.  It does include time elapsed during sleep. The
   clock is the same for all processes. The reference point of the
   returned value is undefined, so that only the difference between
   the results of two calls is valid.

   **CPython 구현 상세:** On CPython, use the same clock as
   "time.monotonic()" and is a monotonic clock, i.e. a clock that
   cannot go backwards.

   Use "perf_counter_ns()" to avoid the precision loss caused by the
   "float" type.

   Added in version 3.3.

   버전 3.10에서 변경: On Windows, the clock is now the same for all
   processes.

   버전 3.13에서 변경: "time.monotonic()" 과 같은 시계를 사용합니다.

time.perf_counter_ns() -> int

   "perf_counter()"와 비슷하지만, 시간을 나노초로 반환합니다.

   Added in version 3.7.

time.process_time() -> float

   현재 프로세스의 시스템과 사용자 CPU 시간 합계의 값을 (소수부가 있는
   초로) 반환합니다. 수면 중 경과 시간은 포함되지 않습니다. 정의상 프
   로세스 수준입니다. 반환된 값의 기준점은 정의되어 있지 않아서, 두 호
   출 결과 간의 차이만 유효합니다.

   Use "process_time_ns()" to avoid the precision loss caused by the
   "float" type.

   Added in version 3.3.

time.process_time_ns() -> int

   "process_time()"과 비슷하지만, 시간을 나노초로 반환합니다.

   Added in version 3.7.

time.sleep(secs)

   Suspend execution of the calling thread for the given number of
   seconds. The argument may be a floating-point number to indicate a
   more precise sleep time.

   If the sleep is interrupted by a signal and no exception is raised
   by the signal handler, the sleep is restarted with a recomputed
   timeout.

   The suspension time may be longer than requested by an arbitrary
   amount, because of the scheduling of other activity in the system.

   -[ 윈도우 구현 ]-

   On Windows, if *secs* is zero, the thread relinquishes the
   remainder of its time slice to any other thread that is ready to
   run. If there are no other threads ready to run, the function
   returns immediately, and the thread continues execution.  On
   Windows 10 and newer the implementation uses a high-resolution
   timer which provides resolution of 100 nanoseconds. If *secs* is
   zero, "Sleep(0)" is used.

   -[ 유닉스 구현 ]-

   * Use "clock_nanosleep()" if available (resolution: 1 nanosecond);

   * Or use "nanosleep()" if available (resolution: 1 nanosecond);

   * Or use "select()" (resolution: 1 microsecond).

   참고:

     To emulate a "no-op", use "pass" instead of "time.sleep(0)".To
     voluntarily relinquish the CPU, specify a real-time scheduling
     policy and use "os.sched_yield()" instead.

   Raises an auditing event "time.sleep" with argument "secs".

   버전 3.5에서 변경: 시그널 처리기가 예외를 발생시키는 경우를 제외하
   고, 시그널에 의해 휴면이 중단되더라도 이 함수는 이제 최소한 *secs*
   동안 휴면합니다 (근거는 **PEP 475**를 참조하십시오).

   버전 3.11에서 변경: On Unix, the "clock_nanosleep()" and
   "nanosleep()" functions are now used if available. On Windows, a
   waitable timer is now used.

   버전 3.13에서 변경: Raises an auditing event.

time.strftime(format[, t])

   "gmtime()"이나 "localtime()" 에 의해 반환된 시간을 나타내는 튜플이
   나 "struct_time"을 *format* 인자로 지정된 문자열로 변환합니다. *t*
   가 제공되지 않으면, "localtime()" 에서 반환된 현재 시각이 사용됩니
   다. *format*은 문자열이어야 합니다. *t*의 필드 중 어느 것이라도 허
   용 범위를 벗어나면 "ValueError"가 발생합니다.

   0은 시간 튜플의 어느 위치에 대해서도 유효한 인자입니다; 그것이 일반
   적으로 유효하지 않으면 값이 올바른 값으로 강제 변환됩니다.

   *format* 문자열은 다음 지시자(directives)를 포함할 수 있습니다. 선
   택적 필드 너비와 정밀도 명세 없이 표시되며, "strftime()" 결과에서
   표시된 문자로 대체됩니다:

   +-------------+--------------------------------------------------+---------+
   | 지시자      | 의미                                             | 노트    |
   |=============|==================================================|=========|
   | "%a"        | 로케일의 약식 요일 이름.                         |         |
   +-------------+--------------------------------------------------+---------+
   | "%A"        | 로케일의 전체 요일 이름.                         |         |
   +-------------+--------------------------------------------------+---------+
   | "%b"        | 로케일의 약식 월 이름.                           |         |
   +-------------+--------------------------------------------------+---------+
   | "%B"        | 로케일의 전체 월 이름.                           |         |
   +-------------+--------------------------------------------------+---------+
   | "%c"        | 로케일의 적절한 날짜와 시간 표현.                |         |
   +-------------+--------------------------------------------------+---------+
   | "%d"        | 월중 일(day of the month)을 십진수로 [01,31].    |         |
   +-------------+--------------------------------------------------+---------+
   | "%f"        | 마이크로 초를 십진수로 [000000,999999].          | (1)     |
   +-------------+--------------------------------------------------+---------+
   | "%H"        | 시(24시간제)를 십진수로 [00,23].                 |         |
   +-------------+--------------------------------------------------+---------+
   | "%I"        | 시(12시간제)를 십진수로 [01,12].                 |         |
   +-------------+--------------------------------------------------+---------+
   | "%j"        | 연중 일(day of the year)을 십진수로 [001,366].   |         |
   +-------------+--------------------------------------------------+---------+
   | "%m"        | 월을 십진수로 [01,12].                           |         |
   +-------------+--------------------------------------------------+---------+
   | "%M"        | 분을 십진수로 [00,59].                           |         |
   +-------------+--------------------------------------------------+---------+
   | "%p"        | AM이나 PM에 해당하는 로케일의 값.                | (2)     |
   +-------------+--------------------------------------------------+---------+
   | "%S"        | 초를 십진수로 [00,61].                           | (3)     |
   +-------------+--------------------------------------------------+---------+
   | "%U"        | 연중 주 번호(일요일이 주의 시작)를 십진수로      | (4)     |
   |             | [00,53]. 첫 번째 일요일 에 선행하는 새해의 모든  |         |
   |             | 날은 주 0으로 간주합니다.                        |         |
   +-------------+--------------------------------------------------+---------+
   | "%u"        | 요일(월요일은 1; 일요일은 7)을 십진수로 [1, 7].  |         |
   +-------------+--------------------------------------------------+---------+
   | "%w"        | 요일을 십진수로 [0(일요일),6].                   |         |
   +-------------+--------------------------------------------------+---------+
   | "%W"        | 연중 주 번호(월요일이 주의 시작)를 십진수로      | (4)     |
   |             | [00,53]. 첫 번째 월요일 에 선행하는 새해의 모든  |         |
   |             | 말은 주 0으로 간주합니다.                        |         |
   +-------------+--------------------------------------------------+---------+
   | "%x"        | 로케일의 적절한 날짜 표현.                       |         |
   +-------------+--------------------------------------------------+---------+
   | "%X"        | 로케일의 적절한 시간 표현.                       |         |
   +-------------+--------------------------------------------------+---------+
   | "%y"        | 세기가 없는 해(year)를 십진수로 [00,99].         |         |
   +-------------+--------------------------------------------------+---------+
   | "%Y"        | 세기가 있는 해(year)를 십진수로.                 |         |
   +-------------+--------------------------------------------------+---------+
   | "%z"        | UTC/GMT로부터의 양이나 음의 시차를 +HHMM 또는    |         |
   |             | -HHMM 형식으로 나타내 는 시간대 오프셋. 여기서 H |         |
   |             | 는 십진수 시 숫자를 나타내고 M은 십진수 분 숫자  |         |
   |             | 를 나타냅니다 [-23:59, +23:59]. [1]              |         |
   +-------------+--------------------------------------------------+---------+
   | "%Z"        | 시간대 이름 (시간대가 없으면 문자가 없습니다).   |         |
   |             | 폐지되었습니다. [1]                              |         |
   +-------------+--------------------------------------------------+---------+
   | "%G"        | ISO 8601 year (similar to "%Y" but follows the   |         |
   |             | rules for the ISO 8601 calendar year). The year  |         |
   |             | starts with the week that contains the first     |         |
   |             | Thursday of the calendar year.                   |         |
   +-------------+--------------------------------------------------+---------+
   | "%V"        | ISO 8601 week number (as a decimal number        |         |
   |             | [01,53]). The first week of the year is the one  |         |
   |             | that contains the first Thursday of the year.    |         |
   |             | Weeks start on Monday.                           |         |
   +-------------+--------------------------------------------------+---------+
   | "%%"        | 리터럴 "'%'" 문자.                               |         |
   +-------------+--------------------------------------------------+---------+

   노트:

   1. The "%f" format directive only applies to "strptime()", not to
      "strftime()". However, see also "datetime.datetime.strptime()"
      and "datetime.datetime.strftime()" where the "%f" format
      directive applies to microseconds.

   2. "strptime()" 함수와 함께 사용할 때, "%I" 지시자를 사용하여 시
      (hour)를 구문 분석하면 "%p" 지시자는 출력 시(hour) 필드에만 영향
      을 줍니다.

   3. 범위는 실제로 "0"에서 "61"입니다; 값 "60"은 윤초를 나타내는 타임
      스탬프에서 유효하고 값 "61"은 역사적 이유로 지원됩니다.

   4. "strptime()" 함수와 함께 사용할 때, "%U"와 "%W"는 주중 일(day of
      the week)과 해(year)가 지정된 경우에만 계산에 사용됩니다.

   Here is an example, a format for dates compatible with that
   specified  in the **RFC 5322** Internet email standard.  [1]

      >>> from time import gmtime, strftime
      >>> strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime())
      'Thu, 28 Jun 2001 14:17:15 +0000'

   특정 플랫폼에서는 추가 지시자가 지원될 수 있지만, 여기에 나열된 지
   시자에만 ANSI C에서 표준화된 의미가 있습니다. 플랫폼에서 지원되는
   전체 포맷 코드 집합을 보려면, *strftime(3)* 설명서를 참조하십시오.

   일부 플랫폼에서, 선택적 필드 너비와 정밀도 명세는 지시자의 초기
   "'%'" 뒤에 그 순서대로 나올 수 있습니다; 이것 또한 이식성이 없습니
   다. 필드 너비는 일반적으로 2이며, "%j"는 3입니다.

time.strptime(string[, format])

   포맷(format)에 따라 시간을 나타내는 문자열을 구문 분석합니다. 반환
   값은 "gmtime()"이나 "localtime()" 에 의해 반환되는 것과 같은
   "struct_time"입니다.

   *format* 매개 변수는 "strftime()"에서 사용된 것과 같은 지시자를 사
   용합니다; 기본값은 "ctime()"이 반환한 포맷과 일치하는 ""%a %b %d
   %H:%M:%S %Y""입니다. *format*에 따라 *string*을 구문 분석할 수 없거
   나, 구문 분석 후 여분의 데이터가 있으면, "ValueError"가 발생합니다.
   더 정확한 값을 유추할 수 없을 때 누락된 데이터를 채우는 데 사용되는
   기본값은 "(1900, 1, 1, 0, 0, 0, 0, 1, -1)"입니다. *string*과
   *format*은 모두 문자열이어야 합니다.

   예를 들면:

   >>> import time
   >>> time.strptime("30 Nov 00", "%d %b %y")
   time.struct_time(tm_year=2000, tm_mon=11, tm_mday=30, tm_hour=0, tm_min=0,
                    tm_sec=0, tm_wday=3, tm_yday=335, tm_isdst=-1)

   "%Z" 지시자에 대한 지원은 "tzname"에 포함된 값과 "daylight"가 참인
   지를 기반으로 합니다. 이로 인해, 항상 알려진 (그리고 일광 절약 시간
   제가 아닌 시간대로 간주하는) UTC와 GMT를 인식하는 것을 제외하고는
   플랫폼에 따라 다릅니다.

   설명서에 지정된 지시자만 지원됩니다. "strftime()"은 플랫폼별로 구현
   되기 때문에 때로는 나열된 것보다 많은 지시자를 제공할 수 있습니다.
   그러나 "strptime()"은 플랫폼과 독립적이라서 지원된다고 설명하지 않
   은 사용 가능한 모든 지시자를 반드시 지원하지는 않습니다.

class time.struct_time

   "gmtime()", "localtime()" 및 "strptime()"이 반환하는 시간 값 시퀀스
   의 형. *네임드 튜플* 인터페이스를 갖는 객체입니다: 인덱스와 어트리
   뷰트 이름으로 값에 액세스 할 수 있습니다. 다음과 같은 값이 있습니다
   :

   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 인덱스                            | 어트리뷰트                        | 값                                |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 0                                 | tm_year                           | (예를 들어, 1993)                 |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 1                                 | tm_mon                            | 범위 [1, 12]                      |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 2                                 | tm_mday                           | 범위 [1, 31]                      |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 3                                 | tm_hour                           | 범위 [0, 23]                      |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 4                                 | tm_min                            | 범위 [0, 59]                      |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 5                                 | tm_sec                            | 범위 [0, 61]; "strftime()" 의 노  |
   |                                   |                                   | 트 (2)를 참조하십시오             |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 6                                 | tm_wday                           | 범위 [0, 6]; 월요일은 0           |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 7                                 | tm_yday                           | 범위 [1, 366]                     |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 8                                 | tm_isdst                          | 0, 1 또는 -1; 아래를 참조하십시오 |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 해당 없음                         | tm_zone                           | 시간대 이름의 약어                |
   +-----------------------------------+-----------------------------------+-----------------------------------+
   | 해당 없음                         | tm_gmtoff                         | UTC에서 동쪽으로 초 단위 오프셋   |
   +-----------------------------------+-----------------------------------+-----------------------------------+

   C 구조체와 달리, 월 값의 범위는 [0, 11]이 아니라 [1, 12] 임에 유의
   하십시오.

   "mktime()" 호출에서, 일광 절약 시간제가 발효 중이면 "tm_isdst"가 1
   로 설정되고, 그렇지 않으면 0으로 설정될 수 있습니다. 값이 -1이면 알
   수 없다는 뜻이고, 일반적으로 올바른 상태가 채워집니다.

   길이가 잘못된 튜플이 "struct_time"을 기대하는 함수에 전달되거나, 잘
   못된 형의 요소가 있으면, "TypeError"가 발생합니다.

time.time() -> float

   Return the time in seconds since the epoch as a floating-point
   number. The handling of leap seconds is platform dependent. On
   Windows and most Unix systems, the leap seconds are not counted
   towards the time in seconds since the epoch. This is commonly
   referred to as Unix time.

   시간이 항상 부동 소수점 숫자로 반환되더라도, 모든 시스템이 1초보다
   정밀한 정밀도를 제공하는 것은 아님에 유의하십시오. 이 함수는 일반적
   으로 감소하지 않는 값을 반환하지만, 두 호출 사이에 시스템 시계가 뒤
   로 설정되면 이전 호출보다 작은 값을 반환할 수 있습니다.

   "time()"에 의해 반환된 숫자는 더 일반적인 시간 형식(즉 년, 월, 일,
   시 등...)으로 변환될 수 있는데, "gmtime()" 함수에 전달하여 UTC로,
   "localtime()" 함수에 전달하여 현지 시간으로 변환할 수 있습니다. 두
   경우 모두 달력 날짜의 구성 요소를 어트리뷰트로 액세스 할 수 있는
   "struct_time" 객체가 반환됩니다.

   Clock:

   * On Windows, call "GetSystemTimePreciseAsFileTime()".

   * Call "clock_gettime(CLOCK_REALTIME)" if available.

   * Otherwise, call "gettimeofday()".

   Use "time_ns()" to avoid the precision loss caused by the "float"
   type.

버전 3.13에서 변경: On Windows, calls
"GetSystemTimePreciseAsFileTime()" instead of
"GetSystemTimeAsFileTime()".

time.time_ns() -> int

   "time()"과 비슷하지만, 시간을 에포크 이후의 나노초를 나타내는 정수
   로 반환합니다.

   Added in version 3.7.

time.thread_time() -> float

   현재 스레드의 시스템과 사용자 CPU 시간 합계의 값을 (소수부가 있는
   초로) 반환합니다. 수면 중에 지난 시간은 포함되지 않습니다. 정의상
   스레드 수준입니다. 반환된 값의 기준점은 정의되어 있지 않아서, 같은
   스레드에서 이루어지는 두 호출 결과 간의 차이만 유효합니다.

   Use "thread_time_ns()" to avoid the precision loss caused by the
   "float" type.

   가용성: Linux, Unix, Windows.

   "CLOCK_THREAD_CPUTIME_ID"를 지원하는 유닉스 시스템.

   Added in version 3.7.

time.thread_time_ns() -> int

   "thread_time()"과 비슷하지만, 시간을 나노초로 반환합니다.

   Added in version 3.7.

time.tzset()

   라이브러리 루틴이 사용하는 시간 변환 규칙을 재설정합니다. 환경 변수
   "TZ"는 이것이 수행되는 방법을 지정합니다. 또한 변수 "tzname" ("TZ"
   환경 변수에서), "timezone" (UTC에서 서쪽으로 DST가 아닌 초),
   "altzone" (UTC에서 서쪽으로 DST 초) 및 "daylight" (이 시간대가 일광
   절약 시간 규칙이 없으면 0으로, 일광 절약 시간이 적용될 때 시간, 과
   거, 현재 또는 미래가 있으면 0이 아닌 값으로)를 설정합니다.

   가용성: Unix.

   참고:

     많은 경우에, "TZ" 환경 변수를 변경하면 "tzset()"을 호출하지 않고
     도 "localtime()" 과 같은 함수의 출력에 영향을 줄 수 있지만, 이 동
     작에 의존해서는 안 됩니다."TZ" 환경 변수에는 공백이 없어야 합니다
     .

   "TZ" 환경 변수의 표준 형식은 다음과 같습니다 (명확함을 위해 공백을
   추가했습니다):

      std offset [dst [offset [,start[/time], end[/time]]]]

   구성 요소는 다음과 같습니다:

   "std"와 "dst"
      시간대 약어를 제공하는 세 개 이상의 영숫자. 이들은 time.tzname으
      로 전파됩니다

   "offset"
      오프셋은 다음과 같은 형식입니다: "± hh[:mm[:ss]]". UTC에 도달하
      기 위해 현지 시간에 더하는 값을 나타냅니다. 앞에 '-'가 있으면,
      시간대는 본초 자오선(Prime Meridian)의 동쪽입니다; 그렇지 않으면
      , 서쪽입니다. dst 다음에 오프셋이 없으면, 일광 절약 시간은 표준
      시간보다 1시간 빠르다고 가정합니다.

   "start[/time], end[/time]"
      언제 DST로 변경하고, 언제 돌아오는지를 나타냅니다. 시작(start)
      날짜와 종료(end) 날짜의 형식은 다음 중 하나입니다:

      "J*n*"
         율리우스 일 *n* (1 <= *n* <= 365). 윤일(leap days)은 계산되지
         않아서, 모든 연도에서 2월 28일은 59일이고 3월 1일은 60일입니
         다.

      "*n*"
         0부터 시작하는 율리우스 일 (0 <= *n* <= 365). 윤일(leap days)
         이 계산되며, 2월 29일을 가리킬 수 있습니다.

      "M*m*.*n*.*d*"
         연중 월 *m*의 주 *n*의 *d*번째 요일 (0 <= *d* <= 6, 1 <= *n*
         <= 5, 1 <= *m* <= 12, 여기서 주 5는 "월 *m*의 마지막 *d* 요일
         "을 뜻하는데, 4번째나 5번째 주에 발생할 수 있습니다). 주 1은
         *d*번째 요일이 등장하는 첫 주입니다. 요일 0은 일요일입니다.

      "time"은 선행 부호('-'나 '+')가 허용되지 않는다는 점을 제외하고
      "offset"과 형식이 같습니다. time이 제공되지 않으면, 기본값은
      02:00:00입니다.

      >>> os.environ['TZ'] = 'EST+05EDT,M4.1.0,M10.5.0'
      >>> time.tzset()
      >>> time.strftime('%X %x %Z')
      '02:07:36 05/08/03 EDT'
      >>> os.environ['TZ'] = 'AEST-10AEDT-11,M10.5.0,M3.5.0'
      >>> time.tzset()
      >>> time.strftime('%X %x %Z')
      '16:08:12 05/08/03 AEST'

   많은 유닉스 시스템(*BSD, 리눅스, Solaris 및 Darwin을 포함합니다)에
   서, 시스템의 zoneinfo (*tzfile(5)*) 데이터베이스를 사용하여 시간대
   규칙을 지정하는 것이 더 편리합니다. 이렇게 하려면, "TZ" 환경 변수를
   시스템 'zoneinfo' 시간대 데이터베이스의 루트(일반적으로
   "/usr/share/zoneinfo"에 있습니다)에 상대적인 필요한 시간대 데이터
   파일의 경로로 설정하십시오. 예를 들어, "'US/Eastern'",
   "'Australia/Melbourne'", "'Egypt'" 또는 "'Europe/Amsterdam'".

      >>> os.environ['TZ'] = 'US/Eastern'
      >>> time.tzset()
      >>> time.tzname
      ('EST', 'EDT')
      >>> os.environ['TZ'] = 'Egypt'
      >>> time.tzset()
      >>> time.tzname
      ('EET', 'EEST')


시계 ID 상수
============

이 상수들은 "clock_getres()"와 "clock_gettime()"의 매개 변수로 사용됩
니다.

time.CLOCK_BOOTTIME

   "CLOCK_MONOTONIC"과 동일하지만, 시스템이 일시 중단된 시간도 포함합
   니다.

   이를 통해 응용 프로그램은 "settimeofday()" 등을 사용하여 시간이 변
   경되면 불연속성이 발생할 수 있는 "CLOCK_REALTIME"의 복잡함을 다루지
   않고도 일시 중단을 인식하는 단조 시계를 얻을 수 있습니다.

   가용성: Linux >= 2.6.39.

   Added in version 3.7.

time.CLOCK_HIGHRES

   Solaris OS에는 최적의 하드웨어 소스를 사용하려고 하는
   "CLOCK_HIGHRES" 타이머가 있으며, 나노초에 가까운 해상도를 제공합니
   다. "CLOCK_HIGHRES"는 조정 불가능한 고해상도 시계입니다.

   가용성: Solaris.

   Added in version 3.3.

time.CLOCK_MONOTONIC

   설정할 수 없고 어떤 지정되지 않은 시작점 이후의 단조 시간을 나타내
   는 시계.

   가용성: Unix.

   Added in version 3.3.

time.CLOCK_MONOTONIC_RAW

   "CLOCK_MONOTONIC"과 비슷하지만, NTP 조정이 적용되지 않는 원시 하드
   웨어 기반 시간에 대한 액세스를 제공합니다.

   가용성: Linux >= 2.6.28, macOS >= 10.12.

   Added in version 3.3.

time.CLOCK_MONOTONIC_RAW_APPROX

   Similar to "CLOCK_MONOTONIC_RAW", but reads a value cached by the
   system at context switch and hence has less accuracy.

   가용성: macOS >= 10.12.

   Added in version 3.13.

time.CLOCK_PROCESS_CPUTIME_ID

   CPU의 고해상도 프로세스별 타이머.

   가용성: Unix.

   Added in version 3.3.

time.CLOCK_PROF

   CPU의 고해상도 프로세스별 타이머.

   가용성: FreeBSD, NetBSD >= 7, OpenBSD.

   Added in version 3.7.

time.CLOCK_TAI

   International Atomic Time

   이것이 정확한 답을 주려면 시스템에 최신 윤초 표가 있어야 합니다.
   PTP나 NTP 소프트웨어는 윤초 표를 유지할 수 있습니다.

   가용성: Linux.

   Added in version 3.9.

time.CLOCK_THREAD_CPUTIME_ID

   스레드별 CPU 시간 시계.

   가용성: Unix.

   Added in version 3.3.

time.CLOCK_UPTIME

   절댓값이 시스템이 실행되고 정지되지 않은 시간인 시간, 절대와 간격
   모두로, 정확한 가동 시간 측정을 제공합니다.

   가용성: FreeBSD, OpenBSD >= 5.5.

   Added in version 3.7.

time.CLOCK_UPTIME_RAW

   주파수나 시간 조정에 영향을 받지 않고 시스템이 휴면하는 중에는 증가
   하지 않는 임의의 지점 이후의 시간을 추적하면서 단조 증가 하는 시계.

   가용성: macOS >= 10.12.

   Added in version 3.8.

time.CLOCK_UPTIME_RAW_APPROX

   Like "CLOCK_UPTIME_RAW", but the value is cached by the system at
   context switches and therefore has less accuracy.

   가용성: macOS >= 10.12.

   Added in version 3.13.

다음 상수는 "clock_settime()"에 보낼 수 있는 유일한 매개 변수입니다.

time.CLOCK_REALTIME

   Real-time clock.  Setting this clock requires appropriate
   privileges. The clock is the same for all processes.

   가용성: Unix.

   Added in version 3.3.


시간대 상수
===========

time.altzone

   정의된 것이 있다면, 현지 DST 시간대의 UTC 서쪽으로 초 단위 오프셋.
   현지 DST 시간대가 UTC 동쪽이면 음수입니다 (영국을 포함한 서유럽의
   경우). "daylight"가 0이 아닌 경우에만 사용하십시오. 아래 참고 사항
   을 참조하십시오.

time.daylight

   DST 시간대가 정의되면 0이 아닙니다. 아래 참고 사항을 참조하십시오.

time.timezone

   UTC 서쪽으로 초 단위의, 현지 (DST가 아닌) 시간대의 오프셋 (대부분
   서부 유럽 지역에서는 음수, 미국에서는 양수, 영국에서는 0). 아래 참
   고 사항을 참조하십시오.

time.tzname

   두 문자열의 튜플: 첫 번째는 현지 DST가 아닌 시간대의 이름이고, 두
   번째는 현지 DST 시간대의 이름입니다. DST 시간대가 정의되어 있지 않
   으면, 두 번째 문자열을 사용하지 않아야 합니다. 아래 참고 사항을 참
   조하십시오.

참고:

  위의 시간대 상수 ("altzone", "daylight", "timezone" 및 "tzname")의
  경우, 값은 모듈 로드 시간이나 "tzset()"이 마지막으로 호출된 시간에
  적용되는 시간대 규칙에 의해 결정되며 과거의 시간에는 올바르지 않을
  수 있습니다. 시간대 정보를 얻으려면 "localtime()" 결과의 "tm_gmtoff"
  와 "tm_zone"을 사용하는 것이 좋습니다.

더 보기:

  모듈 "datetime"
     날짜와 시간에 대한 더 객체 지향적인 인터페이스.

  모듈 "locale"
     국제화 서비스. 로케일 설정은 "strftime()"과 "strptime()"의 많은
     포맷 지시자의 해석에 영향을 줍니다.

  모듈 "calendar"
     일반적인 캘린더 관련 함수. "timegm()"은 이 모듈에 있는 "gmtime()"
     의 역함수입니다.

-[ 각주 ]-

[1] The use of "%Z" is now deprecated, but the "%z" escape that
    expands to the preferred hour/minute offset is not supported by
    all ANSI C libraries. Also, a strict reading of the original 1982
    **RFC 822** standard calls for a two-digit year ("%y" rather than
    "%Y"), but practice moved to 4-digit years long before the year
    2000.  After that, **RFC 822** became obsolete and the 4-digit
    year has been first recommended by **RFC 1123** and then mandated
    by **RFC 2822**, with **RFC 5322** continuing this requirement.
