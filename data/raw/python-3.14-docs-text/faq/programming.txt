프로그래밍 FAQ
**************


일반적인 질문
=============


중단점, 단일 스테핑(single-stepping) 등을 포함하는 소스 코드 수준 디버거가 있습니까?
------------------------------------------------------------------------------------

예.

파이썬을 위한 여러 디버거가 아래에 설명되어 있으며, 내장 함수
"breakpoint()"를 사용하면 이들 중 하나로 들어갈 수 있습니다.

pdb 모듈은 간단하지만 적절한 파이썬 용 콘솔 모드 디버거입니다. 표준 파
이썬 라이브러리의 일부이며, "라이브러리 레퍼런스 매뉴얼에서 설명"하고
있습니다. pdb의 코드를 예로 사용하여 자체 디버거를 작성할 수도 있습니
다.

The IDLE interactive development environment, which is part of the
standard Python distribution (normally available as
Tools/scripts/idle3), includes a graphical debugger.

PythonWin is a Python IDE that includes a GUI debugger based on pdb.
The PythonWin debugger colors breakpoints and has quite a few cool
features such as debugging non-PythonWin programs.  PythonWin is
available as part of pywin32 project and as a part of the ActivePython
distribution.

Eric is an IDE built on PyQt and the Scintilla editing component.

trepan3k is a gdb-like debugger.

Visual Studio Code is an IDE with debugging tools that integrates with
version-control software.

그래픽 디버거를 포함하는 많은 상용 파이썬 IDE가 있습니다. 다음을 포함
합니다:

* Wing IDE

* Komodo IDE

* PyCharm


버그를 찾거나 정적 분석을 수행하는 데 도움이 되는 도구가 있습니까?
------------------------------------------------------------------

예.

Pylint and Pyflakes do basic checking that will help you catch bugs
sooner.

Static type checkers such as Mypy, Pyre, and Pytype can check type
hints in Python source code.


파이썬 스크립트로 독립 실행형 바이너리를 만들려면 어떻게 해야 합니까?
---------------------------------------------------------------------

사용자가 파이썬 배포를 먼저 설치하지 않고도 다운로드하여 실행할 수 있
는 독립 실행형 프로그램을 원하는 것이 전부라면 파이썬을 C 코드로 컴파
일하는 기능이 필요하지는 않습니다. 프로그램에 필요한 모듈 집합을 파악
하고 이러한 모듈들을 파이썬 바이너리와 결합하여 단일 실행 파일을 생성
하는 많은 도구가 있습니다.

One is to use the freeze tool, which is included in the Python source
tree as Tools/freeze. It converts Python byte code to C arrays; with a
C compiler you can embed all your modules into a new program, which is
then linked with the standard Python modules.

소스를 재귀적으로 검색하여 import 문(두 형식 모두)을 찾고 표준 파이썬
경로뿐만 아니라 소스 디렉터리에서 모듈을 찾습니다 (내장할 모듈을 위해
). 그런 다음 파이썬으로 작성된 모듈의 바이트 코드를 C 코드 (marshal 모
듈을 사용하여 코드 객체로 변환할 수 있는 배열 초기화기)로 바꾸고 프로
그램에서 실제로 사용되는 내장 모듈만 포함하는 특별한 구성 파일을 만듭
니다. 그런 다음 생성된 C 코드를 컴파일하고 이를 나머지 파이썬 인터프리
터와 링크하여 스크립트와 똑같게 작동하는 자체 포함 바이너리를 형성합니
다.

The following packages can help with the creation of console and GUI
executables:

* Nuitka (Cross-platform)

* PyInstaller (Cross-platform)

* PyOxidizer (Cross-platform)

* cx_Freeze (Cross-platform)

* py2app (macOS only)

* py2exe (Windows only)


파이썬 프로그램을 위한 코딩 표준이나 스타일 지침서가 있습니까?
--------------------------------------------------------------

예. 표준 라이브러리 모듈에 요구되는 코딩 스타일은 **PEP 8**에서 설명합
니다.


핵심 언어
=========


변수에 값이 있을 때 UnboundLocalError 가 발생하는 이유는 무엇입니까?
--------------------------------------------------------------------

It can be a surprise to get the "UnboundLocalError" in previously
working code when it is modified by adding an assignment statement
somewhere in the body of a function.

이 코드는:

>>> x = 10
>>> def bar():
...     print(x)
...
>>> bar()
10

작동하지만, 이 코드는:

>>> x = 10
>>> def foo():
...     print(x)
...     x += 1

results in an "UnboundLocalError":

>>> foo()
Traceback (most recent call last):
  ...
UnboundLocalError: local variable 'x' referenced before assignment

이는 스코프에서 변수에 대입할 때, 해당 변수가 그 스코프에 대해 지역
(local)이 되고 외부 스코프에서 비슷한 이름의 변수를 가리기 때문입니다.
foo의 마지막 문장은 "x"에 새 값을 대입하므로, 컴파일러는 이 값을 지역
변수로 인식합니다. 결과적으로 앞의 "print(x)"가 초기화되지 않은 지역
변수를 인쇄하려고 할 때 에러가 발생합니다.

위의 예에서 변수를 전역(global)으로 선언하여 외부 스코프 변수에 액세스
할 수 있습니다:

>>> x = 10
>>> def foobar():
...     global x
...     print(x)
...     x += 1
...
>>> foobar()
10

이 명시적 선언은 (클래스와 인스턴스 변수의 표면적으로 유사한 상황과 달
리) 실제로 외부 스코프에 있는 변수의 값을 수정하고 있음을 상기시키기
위해 필요합니다:

>>> print(x)
11

"nonlocal" 키워드를 사용하여 중첩된 스코프에서 비슷한 일을 할 수 있습
니다:

>>> def foo():
...    x = 10
...    def bar():
...        nonlocal x
...        print(x)
...        x += 1
...    bar()
...    print(x)
...
>>> foo()
10
11


파이썬에서 지역과 전역 변수에 대한 규칙은 무엇입니까?
-----------------------------------------------------

파이썬에서, 함수 내에서 참조되기만 하는 변수는 묵시적으로 전역입니다.
변수가 함수 본문 내 어디에서건 값을 대입하면, 명시적으로 전역으로 선언
되지 않는 한 지역으로 간주합니다.

처음에는 조금 의외지만, 잠시 생각해보면 이해가 됩니다. 한편으로, 대입
된 변수에 "global"을 요구하면 의도하지 않은 부작용에 대한 저지선을 제
공합니다. 반면에, 모든 전역 참조에 "global"이 요구된다면, 항상
"global"을 사용하게 됩니다. 내장 함수나 임포트 한 모듈의 구성 요소에
대한 모든 참조를 전역으로 선언해야 합니다. 이 혼란은 부작용을 식별하기
위한 "global" 선언의 유용성을 무효로 합니다.


다른 값으로 루프에서 정의된 람다는 왜 모두 같은 결과를 반환합니까?
------------------------------------------------------------------

for 루프를 사용하여 몇 가지 다른 람다(또는 일반 함수조차)를 정의한다고
가정하십시오, 예를 들어:

   >>> squares = []
   >>> for x in range(5):
   ...     squares.append(lambda: x**2)

이것은 "x**2"를 계산하는 5개의 람다가 포함된 리스트를 제공합니다. 호출
되면, 각각 "0", "1", "4", "9" 및 "16"을 반환할 것으로 예상할 수 있습니
다. 그러나, 실제로 시도하면 모두 "16"을 반환한다는 것을 알 수 있습니다
:

   >>> squares[2]()
   16
   >>> squares[4]()
   16

이는 "x"가 람다에 지역(local)이 아니라 외부 스코프에 정의되어 있기 때
문에 발생하며, 람다가 호출될 때 액세스 됩니다 --- 정의될 때가 아닙니다
. 루프의 끝에서, "x"의 값은 "4"이므로, 모든 함수는 이제 "4**2", 즉
"16"을 반환합니다. "x"의 값을 변경하고 람다의 결과가 어떻게 변경되는지
봄으로써 이를 확인할 수도 있습니다:

   >>> x = 8
   >>> squares[2]()
   64

이를 피하려면, 람다에 대해 지역인 변수에 값을 저장하여, 전역 "x"의 값
에 의존하지 않도록 할 필요가 있습니다:

   >>> squares = []
   >>> for x in range(5):
   ...     squares.append(lambda n=x: n**2)

여기서 "n=x"는 람다에 지역인 새 변수 "n"을 만들고, 루프의 해당 시점에
서 "x" 와 같은 값을 갖도록 람다가 정의될 때 계산됩니다. 이는 "n"의 값
이 첫 번째 람다에서 "0", 두 번째에서 "1", 세 번째에서 "2" 등이 됨을 의
미합니다. 따라서 각 람다는 이제 올바른 결과를 반환합니다:

   >>> squares[2]()
   4
   >>> squares[4]()
   16

이 동작은 람다에만 국한된 것이 아니라 일반 함수에도 적용됩니다.


모듈 간에 전역 변수를 공유하려면 어떻게 해야 합니까?
----------------------------------------------------

단일 프로그램 내에서 모듈 간에 정보를 공유하는 규범적인 방법은 특별한
모듈(종종 config나 cfg라고 불립니다)을 만드는 것입니다. 응용 프로그램
의 모든 모듈에서 config 모듈을 임포트 하기만 하면 됩니다; 그러면 모듈
이 전역 이름으로 사용 가능해집니다. 각 모듈의 인스턴스는 오직 하나이기
때문에, 모듈 객체에 대한 변경 사항은 모든 곳에 반영됩니다. 예를 들면
다음과 같습니다:

config.py:

   x = 0   # Default value of the 'x' configuration setting

mod.py:

   import config
   config.x = 1

main.py:

   import config
   import mod
   print(config.x)

Note that using a module is also the basis for implementing the
singleton design pattern, for the same reason.


모듈에서 임포트를 사용하는 "모범 사례"는 무엇입니까?
----------------------------------------------------

일반적으로, "from modulename import *"를 사용하지 마십시오. 그렇게 하
면 임포트 하는 곳의 이름 공간이 어수선해지고, 린터(linter)가 정의되지
않은 이름을 감지하기가 훨씬 어려워집니다.

파일 맨 위에서 모듈을 임포트 하십시오. 그렇게 하면 코드에 필요한 다른
모듈을 명확하게 하고 모듈 이름이 스코프에 있는지에 대한 질문을 피할 수
있습니다. 한 줄에 하나의 임포트를 사용하면 모듈 임포트를 쉽게 추가하고
삭제할 수 있지만, 한 줄에 여러 임포트를 사용하면 화면 공간을 덜 사용합
니다.

다음 순서로 모듈을 임포트 하는 것이 좋습니다:

1. standard library modules -- e.g. "sys", "os", "argparse", "re"

2. third-party library modules (anything installed in Python's site-
   packages directory) -- e.g. "dateutil", "requests", "PIL.Image"

3. locally developed modules

순환 임포트 관련 문제를 피하고자 임포트를 함수나 클래스로 이동해야 하
는 경우가 있습니다. Gordon McMillan은 다음과 같이 말했습니다:

   두 모듈 모두 "import <module>" 형식의 임포트를 사용하면 순환 임포트
   는 괜찮습니다. 두 번째 모듈이 첫 번째 모듈의 이름(name)을 붙잡으려
   고 하고 ("from module import name") 임포트가 최상위 수준에 있으면
   실패합니다. 첫 번째 모듈이 두 번째 모듈을 임포트 하는 중이라서 첫
   번째 모듈에 있는 이름을 아직 사용할 수 없기 때문입니다.

이 경우, 두 번째 모듈이 하나의 함수에서만 사용된다면, 임포트를 해당 함
수로 쉽게 이동할 수 있습니다. 임포트가 호출될 때, 첫 번째 모듈의 초기
화가 완료되었고, 두 번째 모듈은 임포트를 수행할 수 있습니다.

일부 모듈이 플랫폼 특정이면 임포트를 코드의 최상위 수준에서 다른 곳으
로 이동해야 할 수도 있습니다. 이 경우, 파일 맨 위에서 모든 모듈을 임포
트 하는 것이 가능하지 않을 수도 있습니다. 이 경우, 해당 플랫폼 특정 코
드에서 올바른 모듈을 임포트 하는 것이 좋은 선택입니다.

순환 임포트를 피하거나 모듈의 초기화 시간을 줄이려는 등의 문제를 해결
하는 데 필요할 때만, 함수 정의 내부와 같은 지역 스코프로 임포트를 옮기
십시오. 이 기법은 프로그램 실행 방법에 따라 많은 임포트가 필요하지 않
을 때 특히 유용합니다. 모듈이 해당 함수에서만 사용될 때 임포트를 함수
로 옮기고 싶을 수도 있습니다. 모듈의 일회성 초기화 때문에 모듈을 처음
로드하는 데 비용이 많이들 수 있지만, 모듈을 여러 번 로드하는 것은 사실
상 무료임에 유의하십시오, 두 번의 딕셔너리 조회만 발생합니다. 모듈 이
름이 스코프를 벗어난 경우에도, 모듈은 아마도 "sys.modules"에 있을 겁니
다.


객체 간에 기본값이 공유되는 이유는 무엇입니까?
----------------------------------------------

이 유형의 버그는 흔히 신참 프로그래머들을 깨뭅니다. 이 함수를 생각해보
십시오:

   def foo(mydict={}):  # Danger: shared reference to one dict for all calls
       ... compute something ...
       mydict[key] = value
       return mydict

이 함수를 처음 호출하면, "mydict"에 단일 항목이 포함됩니다. 두 번째는,
"foo()"가 실행되기 시작할 때, "mydict"가 이미 항목에 들어 있는 상태로
시작하기 때문에, "mydict"가 두 개의 항목을 포함합니다.

종종 함수 호출이 기본값으로 새 객체를 만들 것으로 기대합니다. 그렇게
되지 않습니다. 함수가 정의될 때, 기본값은 정확히 한 번 만들어집니다.
이 예제의 딕셔너리와 같이, 해당 객체가 변경되면, 함수에 대한 후속 호출
은 이 변경된 객체를 참조합니다.

정의에 따라, 숫자, 문자열, 튜플 및 "None"과 같은 불변 객체는 변경에 안
전합니다. 딕셔너리, 리스트 및 클래스 인스턴스와 같은 가변 객체를 변경
하면 혼란스러울 수 있습니다.

이 기능으로 인해, 가변 객체를 기본값으로 사용하지 않는 것이 좋습니다.
대신, "None"을 기본값으로 사용하고 함수 내부에서 매개변수가 "None"인지
확인한 다음 새 리스트/딕셔너리/무엇이든 새로 만드십시오. 예를 들어, 다
음과 같이 쓰지 마십시오:

   def foo(mydict={}):
       ...

대신 이렇게 쓰십시오:

   def foo(mydict=None):
       if mydict is None:
           mydict = {}  # create a new dict for local namespace

이 기능은 유용할 수 있습니다. 계산하는 데 시간이 걸리는 함수가 있을 때
, 일반적인 기법은 각 함수 호출의 매개변수와 결괏값을 캐시하고, 같은 값
이 다시 요청되면 캐시 된 값을 반환하는 것입니다. 이것을 "memoizing" 이
라고 하며, 다음과 같이 구현할 수 있습니다:

   # Callers can only provide two parameters and optionally pass _cache by keyword
   def expensive(arg1, arg2, *, _cache={}):
       if (arg1, arg2) in _cache:
           return _cache[(arg1, arg2)]

       # Calculate the value
       result = ... expensive computation ...
       _cache[(arg1, arg2)] = result           # Store result in the cache
       return result

기본값 대신 딕셔너리를 포함하는 전역 변수를 사용할 수 있습니다; 취향의
문제입니다.


한 함수에서 다른 함수로 선택적이나 키워드 매개변수를 전달하려면 어떻게 해야 합니까?
-----------------------------------------------------------------------------------

함수의 매개변수 목록에 "*"와 "**" 지정자를 사용하여 인자를 수집하십시
오; 이것은 위치 인자를 튜플로, 키워드 인자를 딕셔너리로 제공합니다. 그
런 다음 "*"와 "**"를 사용하여 다른 함수를 호출할 때 이러한 인자를 전달
할 수 있습니다:

   def f(x, *args, **kwargs):
       ...
       kwargs['width'] = '14.3c'
       ...
       g(x, *args, **kwargs)


인자와 매개변수의 차이점은 무엇입니까?
--------------------------------------

*Parameters* are defined by the names that appear in a function
definition, whereas *arguments* are the values actually passed to a
function when calling it.  Parameters define what *kind of arguments*
a function can accept.  For example, given the function definition:

   def func(foo, bar=None, **kwargs):
       pass

*foo*, *bar* 및 *kwargs*는 "func"의 매개변수입니다. 그러나, "func"를
호출할 때, 예를 들면:

   func(42, bar=314, extra=somevar)

"42", "314" 및 "somevar" 값은 인자입니다.


리스트 'y'를 변경할 때 리스트 'x'도 변경되는 이유는 무엇입니까?
---------------------------------------------------------------

다음과 같은 코드를 작성하면:

   >>> x = []
   >>> y = x
   >>> y.append(10)
   >>> y
   [10]
   >>> x
   [10]

"y"에 요소를 추가하면 "x"도 변경되는 이유가 궁금할 것입니다.

이 결과를 만드는 두 가지 요소가 있습니다:

1. 변수는 단순히 객체를 가리키는 이름입니다. "y = x"를 수행하면 리스트
   의 사본을 만들지 않습니다 -- "x"가 참조하는 것과 같은 객체를 참조하
   는 새 변수 "y"를 만듭니다. 이는 하나의 객체(리스트)만 있고, "x" 와
   "y" 모두 그 객체를 참조함을 의미합니다.

2. 리스트는 *가변*입니다, 내용을 변경할 수 있다는 뜻입니다.

After the call to "append()", the content of the mutable object has
changed from "[]" to "[10]".  Since both the variables refer to the
same object, using either name accesses the modified value "[10]".

대신 불변 객체를 "x"에 대입하면:

   >>> x = 5  # ints are immutable
   >>> y = x
   >>> x = x + 1  # 5 can't be mutated, we are creating a new object here
   >>> x
   6
   >>> y
   5

이 경우 "x" 와 "y"가 더는 같지 않다는 것을 알 수 있습니다. 이는 정수가
*불변*이기 때문이고, "x = x + 1"을 수행할 때 값을 증가시켜서 정수 "5"
를 변경하는 것이 아닙니다; 대신 새 객체(정수 "6")를 만들어 "x"에 대입
합니다 (즉, "x"가 참조하는 객체를 바꿉니다). 이 대입 후에는 두 개의 객
체(정수 "6"과 "5")와 이를 참조하는 두 개의 변수를 갖게 됩니다 ("x"는
이제 "6"을 참조하지만, "y"는 여전히 "5"를 참조합니다).

Some operations (for example "y.append(10)" and "y.sort()") mutate the
object, whereas superficially similar operations (for example "y = y +
[10]" and "sorted(y)") create a new object.  In general in Python (and
in all cases in the standard library) a method that mutates an object
will return "None" to help avoid getting the two types of operations
confused.  So if you mistakenly write "y.sort()" thinking it will give
you a sorted copy of "y", you'll instead end up with "None", which
will likely cause your program to generate an easily diagnosed error.

그러나, 같은 연산이 때때로 형에 따라 다른 동작을 갖는 한 가지 연산 클
래스가 있습니다: 증분 대입 연산자. 예를 들어, "+="는 리스트를 변경하지
만, 튜플이나 정수는 변경하지 않습니다 ("a_list += [1, 2, 3]"은
"a_list.extend([1, 2, 3])"과 동등하고 "a_list"를  변경하지만,
"some_tuple += (1, 2, 3)"과 "some_int += 1"은 새 객체를 만듭니다).

달리 표현하면:

* 가변 객체("list", "dict", "set" 등)가 있으면, 일부 특정 연산을 사용
  하여 객체를 변경하면 해당 객체를 참조하는 모든 변수가 변경을 보게 됩
  니다.

* 불변 객체("str", "int", "tuple" 등)가 있으면, 이를 참조하는 모든 변
  수는 항상 같은 값을 보게 되지만, 해당 값을 새로운 값으로 변환하는 연
  산은 항상 새로운 객체를 반환합니다.

두 변수가 같은 객체를 참조하는지를 알고 싶다면, "is" 연산자나 내장 함
수 "id()"를 사용할 수 있습니다.


출력 매개변수가 있는 함수를 작성하려면 어떻게 해야 합니까 (참조에 의한 호출)?
-----------------------------------------------------------------------------

파이썬에서 인자는 대입으로 전달됨을 기억하십시오. 대입은 단지 객체에
대한 참조를 만들기 때문에, 호출자와 피호출자의 인자 이름 간에 에일리어
스가 없고, 참조에 의한 호출도 없습니다. 여러 가지 방법으로 원하는 효과
를 얻을 수 있습니다.

1. 결과의 튜플을 반환하여:

      >>> def func1(a, b):
      ...     a = 'new-value'        # a and b are local names
      ...     b = b + 1              # assigned to new objects
      ...     return a, b            # return new values
      ...
      >>> x, y = 'old-value', 99
      >>> func1(x, y)
      ('new-value', 100)

   이것은 거의 항상 가장 명확한 해법입니다.

2. 전역 변수를 사용하여. 이것은 스레드 안전하지 않고, 권장하지 않습니
   다.

3. 가변 (제자리에서 변경할 수 있는) 객체를 전달하여:

      >>> def func2(a):
      ...     a[0] = 'new-value'     # 'a' references a mutable list
      ...     a[1] = a[1] + 1        # changes a shared object
      ...
      >>> args = ['old-value', 99]
      >>> func2(args)
      >>> args
      ['new-value', 100]

4. 변경되는 딕셔너리를 전달하여:

      >>> def func3(args):
      ...     args['a'] = 'new-value'     # args is a mutable dictionary
      ...     args['b'] = args['b'] + 1   # change it in-place
      ...
      >>> args = {'a': 'old-value', 'b': 99}
      >>> func3(args)
      >>> args
      {'a': 'new-value', 'b': 100}

5. 또는 클래스 인스턴스에 값을 묶어서:

      >>> class Namespace:
      ...     def __init__(self, /, **args):
      ...         for key, value in args.items():
      ...             setattr(self, key, value)
      ...
      >>> def func4(args):
      ...     args.a = 'new-value'        # args is a mutable Namespace
      ...     args.b = args.b + 1         # change object in-place
      ...
      >>> args = Namespace(a='old-value', b=99)
      >>> func4(args)
      >>> vars(args)
      {'a': 'new-value', 'b': 100}

   이렇게 복잡하게 만들어야 할 좋은 이유는 거의 없습니다.

최선의 선택은 여러 결과가 포함된 튜플을 반환하는 것입니다.


파이썬에서 고차 함수(higher order function)를 어떻게 만드나요?
--------------------------------------------------------------

두 가지 선택이 있습니다: 중첩된 스코프를 사용하거나 콜러블 객체를 사용
할 수 있습니다. 예를 들어, 값 "a*x+b"를 계산하는 함수 "f(x)"를 반환하
는 "linear(a,b)"를 정의하려고 한다고 가정하십시오. 중첩된 스코프를 사
용해서:

   def linear(a, b):
       def result(x):
           return a * x + b
       return result

또는 콜러블 객체를 사용해서:

   class linear:

       def __init__(self, a, b):
           self.a, self.b = a, b

       def __call__(self, x):
           return self.a * x + self.b

두 경우 모두,

   taxes = linear(0.3, 2)

"taxes(10e6) == 0.3 * 10e6 + 2"가 되도록 하는 콜러블 객체를 제공합니다
.

콜러블 객체 접근 방식은 약간 느리고 코드가 약간 길어진다는 단점이 있습
니다. 그러나, 콜러블 컬렉션은 상속을 통해 서명을 공유할 수 있습니다:

   class exponential(linear):
       # __init__ inherited
       def __call__(self, x):
           return self.a * (x ** self.b)

객체는 여러 메서드의 상태를 캡슐화 할 수 있습니다:

   class counter:

       value = 0

       def set(self, x):
           self.value = x

       def up(self):
           self.value = self.value + 1

       def down(self):
           self.value = self.value - 1

   count = counter()
   inc, dec, reset = count.up, count.down, count.set

여기서 "inc()", "dec()" 및 "reset()"은 같은 계수 변수를 공유하는 함수
처럼 작동합니다.


파이썬에서 객체를 어떻게 복사합니까?
------------------------------------

일반적으로, 일반적일 때 "copy.copy()"나 "copy.deepcopy()"를 시도하십시
오. 모든 객체를 복사할 수는 없지만, 대부분 가능합니다.

일부 객체는 더 쉽게 복사할 수 있습니다. 딕셔너리에는 "copy()" 메서드가
있습니다:

   newdict = olddict.copy()

시퀀스는 슬라이싱으로 복사할 수 있습니다:

   new_l = l[:]


객체의 메서드나 어트리뷰트를 어떻게 찾을 수 있습니까?
-----------------------------------------------------

For an instance "x" of a user-defined class, "dir(x)" returns an
alphabetized list of the names containing the instance attributes and
methods and attributes defined by its class.


코드에서 객체 이름을 어떻게 찾을 수 있습니까?
---------------------------------------------

일반적으로 말하자면, 객체에는 실제로 이름이 없기 때문에 그럴 수 없습니
다. 기본적으로, 대입은 항상 이름을 값에 연결합니다; "def"와 "class" 문
의 경우도 마찬가지이지만, 이 경우 값은 콜러블입니다. 다음 코드를 고려
하십시오:

   >>> class A:
   ...     pass
   ...
   >>> B = A
   >>> a = B()
   >>> b = a
   >>> print(b)
   <__main__.A object at 0x16D07CC>
   >>> print(a)
   <__main__.A object at 0x16D07CC>

Arguably the class has a name: even though it is bound to two names
and invoked through the name "B" the created instance is still
reported as an instance of class "A".  However, it is impossible to
say whether the instance's name is "a" or "b", since both names are
bound to the same value.

일반적으로 말해 코드가 특정 값의 "이름을 알아야" 할 필요는 없습니다.
의도적으로 내성적인(introspective) 프로그램을 작성하지 않는 한, 이는
일반적으로 접근 방식의 변경이 도움이 될 수 있다는 신호입니다.

comp.lang.python에서, Fredrik Lundh는 언젠가 이 질문에 대해 훌륭한 비
유를 했습니다:

   여러분이 현관에서 발견한 고양이의 이름을 얻는 것과 같은 방법: 고양
   이(객체) 자체는 여러분에게 자신의 이름을 말할 수 없고, 전혀 신경 쓰
   지도 않습니다 -- 따라서 그것이 어떻게 불리는지 알아내는 유일한 방법
   은 여러분 이웃 모두(이름 공간)에게 자신의 고양이(객체)인지 묻는 것
   입니다...

   .... 여러 이름으로 알려져 있거나 전혀 이름이 없다는 것을 알게 되더
   라도 놀라지 마십시오!


쉼표 연산자의 우선순위는 어떻게 되나요?
---------------------------------------

쉼표는 파이썬에서 연산자가 아닙니다. 이 세션을 고려하십시오:

   >>> "a" in "b", "a"
   (False, 'a')

쉼표는 연산자가 아니라 표현식 사이의 구분자이기 때문에 위는 다음과 같
이 입력한 것처럼 평가됩니다:

   ("a" in "b"), "a"

다음과 같이 평가되지 않습니다:

   "a" in ("b", "a")

다양한 대입 연산자("=", "+=" 등)도 마찬가지입니다. 이들은 실제로 연산
자가 아니라 대입 문의 문법 구분자입니다.


C의 "?:" 삼항 연산자와 동등한 것이 있습니까?
--------------------------------------------

예, 있습니다. 문법은 다음과 같습니다:

   [on_true] if [expression] else [on_false]

   x, y = 50, 25
   small = x if x < y else y

이 문법이 파이썬 2.5에서 소개되기 전에, 일반적인 관용구는 논리 연산자
를 사용하는 것이었습니다:

   [expression] and [on_true] or [on_false]

그러나, 이 관용구는 안전하지 않습니다. *on_true*가 거짓 불리언 값을 가
질 때 잘못된 결과가 나올 수 있습니다. 따라서, 항상 "... if ... else
..." 형식을 사용하는 것이 좋습니다.


파이썬에서 난독화된 한 줄 코드를 작성할 수 있습니까?
----------------------------------------------------

Yes.  Usually this is done by nesting "lambda" within "lambda".  See
the following three examples, slightly adapted from Ulf Bartelt:

   from functools import reduce

   # Primes < 1000
   print(list(filter(None,map(lambda y:y*reduce(lambda x,y:x*y!=0,
   map(lambda x,y=y:y%x,range(2,int(pow(y,0.5)+1))),1),range(2,1000)))))

   # First 10 Fibonacci numbers
   print(list(map(lambda x,f=lambda x,f:(f(x-1,f)+f(x-2,f)) if x>1 else 1:
   f(x,f), range(10))))

   # Mandelbrot set
   print((lambda Ru,Ro,Iu,Io,IM,Sx,Sy:reduce(lambda x,y:x+'\n'+y,map(lambda y,
   Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,Sy=Sy,L=lambda yc,Iu=Iu,Io=Io,Ru=Ru,Ro=Ro,i=IM,
   Sx=Sx,Sy=Sy:reduce(lambda x,y:x+y,map(lambda x,xc=Ru,yc=yc,Ru=Ru,Ro=Ro,
   i=i,Sx=Sx,F=lambda xc,yc,x,y,k,f=lambda xc,yc,x,y,k,f:(k<=0)or (x*x+y*y
   >=4.0) or 1+f(xc,yc,x*x-y*y+xc,2.0*x*y+yc,k-1,f):f(xc,yc,x,y,k,f):chr(
   64+F(Ru+x*(Ro-Ru)/Sx,yc,0,0,i)),range(Sx))):L(Iu+y*(Io-Iu)/Sy),range(Sy
   ))))(-2.1, 0.7, -1.2, 1.2, 30, 80, 24))
   #    \___ ___/  \___ ___/  |   |   |__ lines on screen
   #        V          V      |   |______ columns on screen
   #        |          |      |__________ maximum of "iterations"
   #        |          |_________________ range on y axis
   #        |____________________________ range on x axis

집에서 이것을 시도하지 마십시오, 어린이들!


함수의 매개변수 목록에서 슬래시(/)는 무엇을 의미합니까?
-------------------------------------------------------

A slash in the argument list of a function denotes that the parameters
prior to it are positional-only.  Positional-only parameters are the
ones without an externally usable name.  Upon calling a function that
accepts positional-only parameters, arguments are mapped to parameters
based solely on their position. For example, "divmod()" is a function
that accepts positional-only parameters. Its documentation looks like
this:

   >>> help(divmod)
   Help on built-in function divmod in module builtins:

   divmod(x, y, /)
       Return the tuple (x//y, x%y).  Invariant: div*y + mod == x.

매개변수 목록 끝의 슬래시는 두 매개변수가 위치 전용임을 의미합니다. 따
라서, 키워드 인자로 "divmod()"를 호출하면 에러가 발생합니다:

   >>> divmod(x=3, y=4)
   Traceback (most recent call last):
     File "<stdin>", line 1, in <module>
   TypeError: divmod() takes no keyword arguments


숫자와 문자열
=============


16진수와 8진수 정수는 어떻게 지정합니까?
----------------------------------------

8진수를 지정하려면, 8진수 값 앞에 0을 붙이고, 소문자나 대문자 "o"를 붙
입니다. 예를 들어, 변수 "a"를 8진수 값 "10"(10진수 8)으로 설정하려면,
이렇게 입력하십시오:

   >>> a = 0o10
   >>> a
   8

16진수도 쉽습니다. 16진수 앞에 0을 붙이고, 소문자나 대문자 "x"를 붙이
기만 하면 됩니다. 16진 숫자는 소문자나 대문자로 지정할 수 있습니다. 예
를 들어, 파이썬 인터프리터에서:

   >>> a = 0xa5
   >>> a
   165
   >>> b = 0XB2
   >>> b
   178


왜 -22 // 10 이 -3을 반환합니까?
--------------------------------

주로 "i % j"가 "j"와 같은 부호를 갖도록 하려는 것입니다. 여러분이 이것
을 원하고, 다음과 같은 것도 원한다면:

   i == (i // j) * j + (i % j)

정수 나누기는 floor를 반환해야 합니다. C 또한 이 항등식을 만족하도록
요구하고, "i // j"를 자르는(truncate) 컴파일러는 "i % j"가 "i" 와 같은
부호를 갖도록 할 필요가 있습니다.

"j"가 음수인 경우 "i % j"에 대한 실제 사용 사례는 거의 없습니다. "j"가
양수이면, 많은 사례가 있으며, 사실상 모든 경우에 "i % j"가 ">= 0"인 것
이 더 유용합니다. 시계가 지금 10을 가리킨다면, 200시간 전에는 어디를
가리키겠습니까? "-190 % 12 == 2"가 유용합니다; "-190 % 12 == -10"은 물
기를 기다리는 버그입니다.


How do I get int literal attribute instead of SyntaxError?
----------------------------------------------------------

Trying to lookup an "int" literal attribute in the normal manner gives
a "SyntaxError" because the period is seen as a decimal point:

   >>> 1.__class__
     File "<stdin>", line 1
     1.__class__
      ^
   SyntaxError: invalid decimal literal

The solution is to separate the literal from the period with either a
space or parentheses.

>>> 1 .__class__
<class 'int'>
>>> (1).__class__
<class 'int'>


문자열을 숫자로 어떻게 변환합니까?
----------------------------------

For integers, use the built-in "int()" type constructor, e.g.
"int('144') == 144".  Similarly, "float()" converts to a floating-
point number, e.g. "float('144') == 144.0".

기본적으로 이것은 숫자를 심진수로 해석합니다. 그래서 "int('0144') ==
144"는 참이고 "int('0x144')"는 "ValueError"를 발생시킵니다.
"int(string, base)"는 두 번째 선택적 인자로 변환에 사용할 진수(base)를
받아들여서, "int( '0x144', 16) == 324"입니다. base가 0으로 지정되면,
숫자는 파이썬의 규칙을 사용하여 해석됩니다: 선행 '0o'는 8진수를 나타내
고, '0x'는 16진수를 나타냅니다.

필요한 것이 문자열을 숫자로 변환하는 것뿐이라면 내장 함수 "eval()"을
사용하지 마십시오. "eval()"은 상당히 느리며 보안 위험을 초래할 수 있습
니다: 누군가 원하지 않는 부작용이 있는 파이썬 표현식을 전달할 수 있습
니다. 예를 들어, 누군가 여러분의 홈 디렉터리를 지우는
"__import__('os').system("rm -rf $HOME")"을 전달할 수 있습니다.

"eval()"은 또한 숫자를 파이썬 표현식으로 해석하는 효과가 있어서, 예를
들어 "eval('09')"는 파이썬이 ('0'을 제외한 )십진수에서 선행 '0'을 허용
하지 않기 때문에 구문 에러가 발생합니다.


숫자를 문자열로 어떻게 변환합니까?
----------------------------------

To convert, e.g., the number "144" to the string "'144'", use the
built-in type constructor "str()".  If you want a hexadecimal or octal
representation, use the built-in functions "hex()" or "oct()".  For
fancy formatting, see the 포맷 문자열 리터럴 and 포맷 문자열 문법
sections, e.g. ""{:04d}".format(144)" yields "'0144'" and
""{:.3f}".format(1.0/3.0)" yields "'0.333'".


제자리에서 문자열을 어떻게 수정합니까?
--------------------------------------

그럴 수 없습니다. 문자열은 불변이기 때문입니다. 대부분의 경우, 조립하
려는 다양한 부분으로 새 문자열을 구성해야 합니다. 그러나 제자리에서 유
니코드 데이터를 수정할 수 있는 객체가 필요하면, "io.StringIO" 객체나
"array" 모듈을 사용해보십시오:

   >>> import io
   >>> s = "Hello, world"
   >>> sio = io.StringIO(s)
   >>> sio.getvalue()
   'Hello, world'
   >>> sio.seek(7)
   7
   >>> sio.write("there!")
   6
   >>> sio.getvalue()
   'Hello, there!'

   >>> import array
   >>> a = array.array('w', s)
   >>> print(a)
   array('w', 'Hello, world')
   >>> a[0] = 'y'
   >>> print(a)
   array('w', 'yello, world')
   >>> a.tounicode()
   'yello, world'


문자열을 사용하여 어떻게 함수/메서드를 호출합니까?
--------------------------------------------------

다양한 기법이 있습니다.

* 문자열을 함수로 매핑하는 딕셔너리를 사용하는 것이 가장 좋습니다. 이
  기법의 주요 장점은 문자열이 함수 이름과 일치할 필요가 없다는 것입니
  다. 이것은 또한 case 구문을 흉내 내는 데 사용되는 기본 기법입니다:

     def a():
         pass

     def b():
         pass

     dispatch = {'go': a, 'stop': b}  # Note lack of parens for funcs

     dispatch[get_input()]()  # Note trailing parens to call function

* 내장 함수 "getattr()"을 사용하십시오:

     import foo
     getattr(foo, 'bar')()

  "getattr()"은 클래스, 클래스 인스턴스, 모듈 등을 포함하는 모든 객체
  에서 작동함에 유의하십시오.

  이것은 다음과 같이 표준 라이브러리의 여러 곳에서 사용됩니다:

     class Foo:
         def do_foo(self):
             ...

         def do_bar(self):
             ...

     f = getattr(foo_instance, 'do_' + opname)
     f()

* 함수 이름을 해석(resolve)하려면 "locals()"를 사용하십시오:

     def myFunc():
         print("hello")

     fname = "myFunc"

     f = locals()[fname]
     f()


Is there an equivalent to Perl's "chomp()" for removing trailing newlines from strings?
---------------------------------------------------------------------------------------

"S.rstrip("\r\n")"을 사용하면 다른 후행 공백을 제거하지 않고 문자열
"S"의 끝에 있는 모든 줄 종결자를 제거 할 수 있습니다. 문자열 "S"가 끝
에 빈 줄이 여러 개 붙어 한 줄 이상을 나타내면, 모든 빈 줄의 줄 종결자
가 제거됩니다:

   >>> lines = ("line 1 \r\n"
   ...          "\r\n"
   ...          "\r\n")
   >>> lines.rstrip("\n\r")
   'line 1 '

일반적으로 한 번에 한 줄씩 텍스트를 읽을 때만 필요하기 때문에,
"S.rstrip()"을 이런 식으로 사용하면 잘 작동합니다.


Is there a "scanf()" or "sscanf()" equivalent?
----------------------------------------------

그런 식으로는 없습니다.

For simple input parsing, the easiest approach is usually to split the
line into whitespace-delimited words using the "split()" method of
string objects and then convert decimal strings to numeric values
using "int()" or "float()".  "split()" supports an optional "sep"
parameter which is useful if the line uses something other than
whitespace as a separator.

For more complicated input parsing, regular expressions are more
powerful than C's "sscanf" and better suited for the task.


What does "UnicodeDecodeError" or "UnicodeEncodeError" error mean?
------------------------------------------------------------------

유니코드 HOWTO를 참조하십시오.


Can I end a raw string with an odd number of backslashes?
---------------------------------------------------------

A raw string ending with an odd number of backslashes will escape the
string's quote:

   >>> r'C:\this\will\not\work\'
     File "<stdin>", line 1
       r'C:\this\will\not\work\'
       ^
   SyntaxError: unterminated string literal (detected at line 1)

There are several workarounds for this. One is to use regular strings
and double the backslashes:

   >>> 'C:\\this\\will\\work\\'
   'C:\\this\\will\\work\\'

Another is to concatenate a regular string containing an escaped
backslash to the raw string:

   >>> r'C:\this\will\work' '\\'
   'C:\\this\\will\\work\\'

It is also possible to use "os.path.join()" to append a backslash on
Windows:

   >>> os.path.join(r'C:\this\will\work', '')
   'C:\\this\\will\\work\\'

Note that while a backslash will "escape" a quote for the purposes of
determining where the raw string ends, no escaping occurs when
interpreting the value of the raw string. That is, the backslash
remains present in the value of the raw string:

   >>> r'backslash\'preserved'
   "backslash\\'preserved"

Also see the specification in the language reference.


성능
====


내 프로그램이 너무 느립니다. 속도를 높이려면 어떻게 해야 합니까?
----------------------------------------------------------------

그것은 일반적으로 힘든 일입니다. 먼저, 더 뛰어들기 전에 기억해야 할 사
항이 있습니다:

* 성능 특성은 파이썬 구현마다 다릅니다. 이 FAQ는 *CPython*에 중점을 둡
  니다.

* 동작은 운영 체제마다 다를 수 있습니다, 특히 I/O 나 다중 스레드에 관
  해 이야기할 때 그렇습니다.

* 코드를 최적화하려고 시도하기 *전에* 프로그램에서 항상 핫스팟을 찾아
  야 합니다 ("profile" 모듈을 참조하십시오).

* 벤치마크 스크립트를 작성하면 개선 사항을 탐색할 때 빠르게 반복할 수
  있습니다 ("timeit" 모듈 참조).

* 정교한 최적화에 숨겨진 회귀(regressions)를 잠재적으로 도입하기 전에
  (단위 테스트나 기타 기법을 통해) 우수한 코드 커버리지를 갖는 것이 좋
  습니다.

이것을 전제로, 파이썬 코드 속도를 높이는 많은 트릭이 있습니다. 다음은
수용 가능한 성능 수준에 도달하기 위해 먼 길을 갈 때 도움이 되는 몇 가
지 일반적인 원칙입니다:

* 알고리즘을 더 빠르게 만들면 (또는 더 빠른 알고리즘으로 변경하면) 코
  드 전체에 미세 최적화 트릭을 뿌리는 것보다 훨씬 큰 이점을 얻을 수 있
  습니다.

* 올바른 데이터 구조를 사용하십시오. 내장형과 "collections" 모듈에 대
  한 설명서를 연구하십시오.

* 표준 라이브러리가 무언가를 하기 위한 프리미티브를 제공할 때, 여러분
  이 떠올린 다른 대안보다 빠를 가능성이 높습니다 (보장되지는 않습니다
  ). 이것은 내장과 일부 확장형과 같이 C로 작성된 프리미티브의 경우에는
  두 배로 그렇습니다. 예를 들어, 정렬하려면 "list.sort()" 내장 메서드
  나 관련 "sorted()" 함수를 사용하십시오 (그리고 약간 고급 사용법의 예
  는 정렬 기법를 참조하십시오).

* 추상화는 간접(indirections)을 만드는 경향이 있고 인터프리터가 더 많
  은 일을 하도록 강요합니다. 간접의 수준이 유용한 작업의 양을 초과하면
  , 프로그램 속도가 느려집니다. 과도한 추상화를 피해야 합니다, 특히 작
  은 함수나 메서드의 형태에서 그렇습니다 (종종 가독성에도 해롭습니다).

If you have reached the limit of what pure Python can allow, there are
tools to take you further away.  For example, Cython can compile a
slightly modified version of Python code into a C extension, and can
be used on many different platforms.  Cython can take advantage of
compilation (and optional type annotations) to make your code
significantly faster than when interpreted.  If you are confident in
your C programming skills, you can also write a C extension module
yourself.

더 보기: 성능 팁에 할당된 위키 페이지.


많은 문자열을 함께 이어붙이는 가장 효율적인 방법은 무엇입니까?
--------------------------------------------------------------

"str"과 "bytes" 객체는 불변이므로, 많은 문자열을 함께 이어붙이면 각 이
어붙이기가 새 객체를 생성하기 때문에 비효율적입니다. 일반적일 때, 총
실행 시간 비용은 전체 문자열 길이의 제곱에 비례합니다.

많은 "str" 객체를 누적하기 위해, 권장되는 관용구는 객체를 리스트에 배
치하고 마지막에 "str.join()"을 호출하는 것입니다:

   chunks = []
   for s in my_strings:
       chunks.append(s)
   result = ''.join(chunks)

(또 다른 합리적으로 효율적인 관용구는 "io.StringIO"를 사용하는 것입니
다)

많은 "bytes" 객체를 누적하기 위해, 권장되는 관용구는 제자리 이어붙이기
("+=" 연산자)을 사용하여 "bytearray" 객체를 확장하는 것입니다:

   result = bytearray()
   for b in my_bytes_objects:
       result += b


시퀀스 (튜플/리스트)
====================


튜플과 리스트를 어떻게 변환합니까?
----------------------------------

형 생성자 "tuple(seq)"는 임의의 시퀀스(실제로는, 모든 이터러블)를 같은
순서로 같은 항목을 가진 튜플로 변환합니다.

예를 들어, "tuple([1, 2, 3])"은 "(1, 2, 3)"을 산출하고 "tuple('abc')"
는 "('a', 'b', 'c')"를 산출합니다. 인자가 튜플이면 사본을 만들지 않고
같은 객체를 반환하므로, 객체가 이미 튜플인지 확실하지 않을 때
"tuple()"을 호출하는 것이 저렴합니다.

형 생성자 "list(seq)"는 임의의 시퀀스나 이터러블을 같은 순서로 같은 항
목이 있는 리스트로 변환합니다. 예를 들어, "list((1, 2, 3))"은 "[1, 2,
3]"을 산출하고 "list('abc')"는 "['a', 'b', 'c']"를 산출합니다. 인자가
리스트이면, "seq[:]"와 같이 사본을 만듭니다.


음수 인덱스는 무엇입니까?
-------------------------

파이썬 시퀀스는 양수와 음수로 인덱싱됩니다. 양수의 경우 0은 첫 번째 인
덱스이고 1은 두 번째 인덱스이고 이런 식으로 계속됩니다. 음수 인덱스의
경우 -1은 마지막 인덱스이고 -2는 끝에서 두 번째 인덱스이고 이런 식으로
계속됩니다. "seq[-n]"을 "seq[len(seq)-n]"과 같다고 생각하십시오.

음수 인덱스를 사용하면 매우 편리할 수 있습니다. 예를 들어 "S[:-1]"은
마지막 문자를 제외한 문자열의 모든 것인데, 문자열에서 후행 줄 바꿈을
제거하는 데 유용합니다.


시퀀스를 역순으로 이터레이트 하려면 어떻게 합니까?
--------------------------------------------------

"reversed()" 내장 함수를 사용하십시오:

   for x in reversed(sequence):
       ...  # do something with x ...

이것은 원본 시퀀스에는 영향을 미치지 않지만, 이터레이트 할 뒤집힌 순서
의 새 사본을 만듭니다.


리스트에서 중복을 어떻게 제거합니까?
------------------------------------

이 작업을 수행하는 여러 가지 방법에 대한 긴 논의는 파이썬 요리책을 참
조하십시오:

   https://code.activestate.com/recipes/52560/

리스트 순서를 바꿔도 상관없다면, 리스트를 정렬한 다음 리스트 끝에서 스
캔하면서 중복 항목을 삭제하십시오:

   if mylist:
       mylist.sort()
       last = mylist[-1]
       for i in range(len(mylist)-2, -1, -1):
           if last == mylist[i]:
               del mylist[i]
           else:
               last = mylist[i]

리스트의 모든 요소가 집합 키로 사용될 수 있다면 (즉, 모두 *해시 가능*
이면) 이것이 종종 더 빠릅니다

   mylist = list(set(mylist))

이것은 리스트를 집합으로 변환하여, 중복을 제거한 다음, 리스트로 되돌립
니다.


리스트에서 여러 항목을 어떻게 제거합니까?
-----------------------------------------

중복 제거와 마찬가지로, 삭제 조건을 사용하여 명시적으로 역순으로 이터
레이션 하는 것도 한 가지 가능성입니다. 그러나, 묵시적이나 명시적 순방
향 이터레이션으로 슬라이스 치환을 사용하기가 더 쉽고 빠릅니다. 다음은
세 가지 변형입니다.:

   mylist[:] = filter(keep_function, mylist)
   mylist[:] = (x for x in mylist if keep_condition)
   mylist[:] = [x for x in mylist if keep_condition]

리스트 컴프리헨션이 아마 가장 빠릅니다.


파이썬에서 어떻게 배열을 만드나요?
----------------------------------

리스트를 사용하십시오:

   ["this", 1, "is", "an", "array"]

리스트는 시간 복잡성 면에서 C나 파스칼(Pascal) 배열과 동등합니다; 가장
큰 차이점은 파이썬 리스트에 다양한 형의 객체가 포함될 수 있다는 것입니
다.

The "array" module also provides methods for creating arrays of fixed
types with compact representations, but they are slower to index than
lists.  Also note that NumPy and other third party packages define
array-like structures with various characteristics as well.

To get Lisp-style linked lists, you can emulate *cons cells* using
tuples:

   lisp_list = ("like",  ("this",  ("example", None) ) )

If mutability is desired, you could use lists instead of tuples.  Here
the analogue of a Lisp *car* is "lisp_list[0]" and the analogue of
*cdr* is "lisp_list[1]".  Only do this if you're sure you really need
to, because it's usually a lot slower than using Python lists.


다차원 리스트를 어떻게 만듭니까?
--------------------------------

다음과 같이 다차원 배열을 만들려고 했을 것입니다:

   >>> A = [[None] * 2] * 3

인쇄하면 올바르게 보입니다:

   >>> A
   [[None, None], [None, None], [None, None]]

그러나 값을 대입하면, 여러 위치에 나타납니다:

   >>> A[0][0] = 5
   >>> A
   [[5, None], [5, None], [5, None]]

그 이유는 "*"로 리스트를 복제해도 복사본을 만들지 않고 기존 객체에 대
한 참조만 만들기 때문입니다. "*3"은 길이 2의 같은 리스트에 대한 3개의
참조를 포함하는 리스트를 만듭니다. 한 행에 대한 변경 사항은 모든 행에
나타나는데, 거의 확실히 여러분이 원하는 것은 아닙니다.

제안된 방법은 원하는 길이의 리스트를 먼저 만든 다음 새로 만든 리스트로
각 요소를 채우는 것입니다:

   A = [None] * 3
   for i in range(3):
       A[i] = [None] * 2

그러면 길이가 2인 3개의 다른 리스트를 포함하는 리스트가 생성됩니다. 리
스트 컴프리헨션도 사용할 수 있습니다:

   w, h = 2, 3
   A = [[None] * w for i in range(h)]

Or, you can use an extension that provides a matrix datatype; NumPy is
the best known.


How do I apply a method or function to a sequence of objects?
-------------------------------------------------------------

To call a method or function and accumulate the return values is a
list, a *list comprehension* is an elegant solution:

   result = [obj.method() for obj in mylist]

   result = [function(obj) for obj in mylist]

To just run the method or function without saving the return values, a
plain "for" loop will suffice:

   for obj in mylist:
       obj.method()

   for obj in mylist:
       function(obj)


덧셈은 작동하는데, 왜 a_tuple[i] += ['item']이 예외를 일으킵니까?
-----------------------------------------------------------------

이는 증분 대입 연산자가 *대입* 연산자라는 사실과 파이썬에서 가변 객체
와 불변 객체의 차이점이 결합하기 때문입니다.

이 논의는 증분 대입 연산자가 가변 객체를 가리키는 튜플의 요소에 적용될
때 일반적으로 적용되지만, 우리는 "list"와 "+="를 예제로 사용합니다.

다음과 같이 작성한다면:

   >>> a_tuple = (1, 2)
   >>> a_tuple[0] += 1
   Traceback (most recent call last):
      ...
   TypeError: 'tuple' object does not support item assignment

예외의 이유는 명확합니다: "1"이 "a_tuple[0]"이 가리키는 객체("1")에 더
해져서, 결과 객체 "2"를 생성하지만, 계산 결과 "2"를 튜플의 요소 "0"에
대입하려고 하면, 튜플의 요소가 가리키는 것을 변경할 수 없기 때문에 에
러가 발생합니다.

수면 아래에서, 이 증분 대입문이 하는 일은 대략 다음과 같습니다:

   >>> result = a_tuple[0] + 1
   >>> a_tuple[0] = result
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

튜플은 불변이므로, 연산의 대입 부분이 에러를 발생시킵니다.

다음과 같이 작성하면:

   >>> a_tuple = (['foo'], 'bar')
   >>> a_tuple[0] += ['item']
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

예외는 조금 더 놀랍습니다, 더 놀라운 것은 에러가 있었지만 더하기가 동
작했다는 사실입니다:

   >>> a_tuple[0]
   ['foo', 'item']

To see why this happens, you need to know that (a) if an object
implements an "__iadd__()" magic method, it gets called when the "+="
augmented assignment is executed, and its return value is what gets
used in the assignment statement; and (b) for lists, "__iadd__()" is
equivalent to calling "extend()" on the list and returning the list.
That's why we say that for lists, "+=" is a "shorthand" for
"list.extend()":

   >>> a_list = []
   >>> a_list += [1]
   >>> a_list
   [1]

이것은 다음과 동등합니다:

   >>> result = a_list.__iadd__([1])
   >>> a_list = result

a_list가 가리키는 객체가 변경되었고, 변경된 객체에 대한 포인터가 다시
"a_list"에 대입됩니다. 대입의 최종 결과는 no-op인데, "a_list"가 이전에
가리키고 있던 것과 같은 객체에 대한 포인터이기 때문입니다, 하지만 대입
은 여전히 일어납니다.

따라서, 우리의 튜플 예제에서 일어나는 일은 다음과 동등합니다:

   >>> result = a_tuple[0].__iadd__(['item'])
   >>> a_tuple[0] = result
   Traceback (most recent call last):
     ...
   TypeError: 'tuple' object does not support item assignment

The "__iadd__()" succeeds, and thus the list is extended, but even
though "result" points to the same object that "a_tuple[0]" already
points to, that final assignment still results in an error, because
tuples are immutable.


복잡한 정렬을 하고 싶습니다: 파이썬에서 Schwartzian 변환을 할 수 있습니까?
--------------------------------------------------------------------------

Perl 커뮤니티의 Randal Schwartz에 의한 이 기법은 리스트의 각 요소를 각
요소를 "정렬 값"에 매핑하는 메트릭으로 정렬합니다. 파이썬에서는,
"list.sort()" 메서드의 "key" 인자를 사용하십시오:

   Isorted = L[:]
   Isorted.sort(key=lambda s: int(s[10:15]))


한 리스트를 다른 리스트의 값으로 정렬하려면 어떻게 해야 합니까?
---------------------------------------------------------------

그것들을 튜플의 이터레이터로 병합하고, 결과 리스트를 정렬한 다음, 원하
는 요소를 선택하십시오.

   >>> list1 = ["what", "I'm", "sorting", "by"]
   >>> list2 = ["something", "else", "to", "sort"]
   >>> pairs = zip(list1, list2)
   >>> pairs = sorted(pairs)
   >>> pairs
   [("I'm", 'else'), ('by', 'sort'), ('sorting', 'to'), ('what', 'something')]
   >>> result = [x[1] for x in pairs]
   >>> result
   ['else', 'sort', 'to', 'something']


객체
====


클래스는 무엇입니까?
--------------------

클래스는 class 문을 실행하여 만든 특정 객체 형입니다. 클래스 객체는 인
스턴스 객체를 만들기 위한 주형으로 사용되며, 데이터형과 관련된 데이터(
어트리뷰트)와 코드(메서드)를 모두 내장합니다.

클래스는 베이스 클래스라고 하는 하나 이상의 다른 클래스를 기반으로 할
수 있습니다. 그러면 베이스 클래스의 어트리뷰트와 메서드를 상속합니다.
이는 상속을 통해 객체 모델을 점진적으로 재정의할 수 있도록 합니다. 우
편함에 대한 기본 접근자 메서드를 제공하는 일반 "Mailbox" 클래스와 다양
한 특정 사서함 형식을 처리하는 "MboxMailbox", "MaildirMailbox",
"OutlookMailbox"와 같은 서브 클래스가 있을 수 있습니다.


메서드는 무엇입니까?
--------------------

메서드는 일반적으로 "x.name(arguments...)"로 호출하는 어떤 객체 "x"의
함수입니다. 메서드는 클래스 정의 내에서 함수로 정의됩니다:

   class C:
       def meth(self, arg):
           return arg * 2 + self.attribute


self는 무엇입니까?
------------------

self는 단지 메서드의 첫 번째 인자를 위한 관례적 이름입니다.
"meth(self, a, b, c)"로 정의된 메서드는 정의가 등장한 클래스의 어떤 인
스턴스 "x"에 대해 "x.meth(a, b, c)"로 호출되어야 합니다; 호출된 메서드
는 "meth(x, a, b, c)"처럼 호출되었다고 생각합니다.

메서드 정의와 호출에서 'self'를 명시적으로 사용해야 하는 이유는 무엇입
니까? 도 참조하십시오.


객체가 주어진 클래스나 그 서브 클래스의 인스턴스인지 어떻게 확인합니까?
-----------------------------------------------------------------------

Use the built-in function "isinstance(obj, cls)".  You can check if an
object is an instance of any of a number of classes by providing a
tuple instead of a single class, e.g. "isinstance(obj, (class1,
class2, ...))", and can also check whether an object is one of
Python's built-in types, e.g. "isinstance(obj, str)" or
"isinstance(obj, (int, float, complex))".

Note that "isinstance()" also checks for virtual inheritance from an
*abstract base class*.  So, the test will return "True" for a
registered class even if hasn't directly or indirectly inherited from
it.  To test for "true inheritance", scan the *MRO* of the class:

   from collections.abc import Mapping

   class P:
        pass

   class C(P):
       pass

   Mapping.register(P)

   >>> c = C()
   >>> isinstance(c, C)        # direct
   True
   >>> isinstance(c, P)        # indirect
   True
   >>> isinstance(c, Mapping)  # virtual
   True

   # Actual inheritance chain
   >>> type(c).__mro__
   (<class 'C'>, <class 'P'>, <class 'object'>)

   # Test for "true inheritance"
   >>> Mapping in type(c).__mro__
   False

대부분의 프로그램은 사용자 정의 클래스에서 "isinstance()"를 자주 사용
하지 않음에 유의하십시오. 클래스를 직접 개발하고 있다면, 더 적절한 객
체 지향 스타일은 객체의 클래스를 확인하고 클래스에 따라 다른 작업을 수
행하는 대신 특정 동작을 캡슐화하는 클래스의 메서드를 정의하는 것입니다
. 예를 들어, 무언가를 수행하는 함수가 있다면:

   def search(obj):
       if isinstance(obj, Mailbox):
           ...  # code to search a mailbox
       elif isinstance(obj, Document):
           ...  # code to search a document
       elif ...

더 나은 접근법은 모든 클래스에서 "search()" 메서드를 정의하고 단지 그
것을 호출하는 것입니다:

   class Mailbox:
       def search(self):
           ...  # code to search a mailbox

   class Document:
       def search(self):
           ...  # code to search a document

   obj.search()


위임이란 무엇입니까?
--------------------

위임(delegation)은 객체 지향 기법(디자인 패턴이라고도 합니다)입니다.
"x" 객체가 있고 메서드 중 하나의 동작을 변경하고 싶다고 가정해 봅시다.
변경하려는 메서드의 새로운 구현을 제공하고 다른 모든 메서드를 "x"의 해
당 메서드에 위임하는 새 클래스를 만들 수 있습니다.

파이썬 프로그래머는 쉽게 위임을 구현할 수 있습니다. 예를 들어, 다음 클
래스는 파일처럼 동작하지만, 기록되는 모든 데이터를 대문자로 변환하는
클래스를 구현합니다:

   class UpperOut:

       def __init__(self, outfile):
           self._outfile = outfile

       def write(self, s):
           self._outfile.write(s.upper())

       def __getattr__(self, name):
           return getattr(self._outfile, name)

Here the "UpperOut" class redefines the "write()" method to convert
the argument string to uppercase before calling the underlying
"self._outfile.write()" method.  All other methods are delegated to
the underlying "self._outfile" object.  The delegation is accomplished
via the "__getattr__()" method; consult the language reference for
more information about controlling attribute access.

Note that for more general cases delegation can get trickier. When
attributes must be set as well as retrieved, the class must define a
"__setattr__()" method too, and it must do so carefully.  The basic
implementation of "__setattr__()" is roughly equivalent to the
following:

   class X:
       ...
       def __setattr__(self, name, value):
           self.__dict__[name] = value
       ...

Many "__setattr__()" implementations call "object.__setattr__()" to
set an attribute on self without causing infinite recursion:

   class X:
       def __setattr__(self, name, value):
           # Custom logic here...
           object.__setattr__(self, name, value)

Alternatively, it is possible to set attributes by inserting entries
into "self.__dict__" directly.


How do I call a method defined in a base class from a derived class that extends it?
------------------------------------------------------------------------------------

내장 "super()" 함수를 사용하십시오:

   class Derived(Base):
       def meth(self):
           super().meth()  # calls Base.meth

In the example, "super()" will automatically determine the instance
from which it was called (the "self" value), look up the *method
resolution order* (MRO) with "type(self).__mro__", and return the next
in line after "Derived" in the MRO: "Base".


베이스 클래스를 쉽게 변경할 수 있도록 코드를 구성하려면 어떻게 해야 합니까?
---------------------------------------------------------------------------

베이스 클래스를 별칭에 대입하고 별칭에서 파생할 수 있습니다. 그러면 별
칭에 대입된 값만 변경하면 됩니다. 또한 이 트릭은 사용할 베이스 클래스
를 동적으로 (예를 들어 자원의 가용성에 따라) 결정하려는 경우에도 유용
합니다. 예:

   class Base:
       ...

   BaseAlias = Base

   class Derived(BaseAlias):
       ...


정적 클래스 데이터와 정적 클래스 메서드를 만들려면 어떻게 해야 합니까?
----------------------------------------------------------------------

(C++나 Java의 의미에서) 정적 데이터와 정적 메서드 모두 파이썬에서 지원
됩니다.

정적 데이터의 경우, 단순히 클래스 어트리뷰트를 정의하십시오. 어트리뷰
트에 새 값을 대입하려면, 대입에서 클래스 이름을 명시적으로 사용해야 합
니다:

   class C:
       count = 0   # number of times C.__init__ called

       def __init__(self):
           C.count = C.count + 1

       def getcount(self):
           return C.count  # or return self.count

"c" 자체나 "c.__class__"에서 "C"로 돌아가는 베이스 클래스 검색 경로에
놓인 일부 클래스에 의해 재정의되지 않는 한, "c.count"는 "isinstance(c,
C)"가 성립하는 모든 "c"에 대해 "C.count"를 참조합니다.

주의: C의 메서드 내에서, "self.count = 42"와 같은 대입은 "self"의 자체
딕셔너리에 "count"라는 새롭고 관련이 없는 인스턴스를 만듭니다. 클래스
정적 데이터 이름의 재연결은 항상 메서드 내부에 있는지에 관계없이 클래
스를 지정해야 합니다:

   C.count = 314

정적 메서드도 가능합니다:

   class C:
       @staticmethod
       def static(arg1, arg2, arg3):
           # No 'self' parameter!
           ...

그러나, 정적 메서드의 효과를 얻는 훨씬 간단한 방법은 단순한 모듈 수준
함수를 사용하는 것입니다:

   def getcount():
       return C.count

여러분의 코드가 모듈 당 하나의 클래스 (또는 밀접하게 관련된 클래스 계
층 구조)를 정의하도록 구조화되었다면, 이것이 원하는 캡슐화를 제공합니
다.


파이썬에서 생성자(또는 메서드)를 어떻게 재정의할 수 있습니까?
-------------------------------------------------------------

이 답변은 실제로 모든 메서드에 적용되지만, 질문은 일반적으로 생성자 문
맥에서 가장 먼저 나옵니다.

C++에서는 다음과 같이 작성합니다

   class C {
       C() { cout << "No arguments\n"; }
       C(int i) { cout << "Argument is " << i << "\n"; }
   }

파이썬에서는 기본 인자를 사용하여 모든 경우를 다루는 단일 생성자를 작
성해야 합니다. 예를 들면:

   class C:
       def __init__(self, i=None):
           if i is None:
               print("No arguments")
           else:
               print("Argument is", i)

이것은 완전히 동등하지는 않지만, 실제로는 아주 가깝습니다.

가변 길이 인자 목록을 시도할 수도 있습니다, 예를 들어:

   def __init__(self, *args):
       ...

같은 접근법이 모든 메서드 정의에서도 동작합니다.


__spam을 사용하려고 하는데 _SomeClassName__spam에 대한 에러가 발생합니다.
-------------------------------------------------------------------------

이중 선행 밑줄이 있는 변수 이름은 클래스 비공개(private) 변수를 정의하
는 간단하지만, 효과적인 방법을 제공하기 위해 "뒤섞입니다(mangled)".
"__spam" 형식(적어도 두 개의 선행 밑줄, 최대 하나의 후행 밑줄)의 모든
식별자는 "_classname__spam"으로 텍스트 대체되는데, 여기서 "classname"
은 모든 선행 밑줄이 제거된 현재 클래스 이름입니다.

The identifier can be used unchanged within the class, but to access
it outside the class, the mangled name must be used:

   class A:
       def __one(self):
           return 1
       def two(self):
           return 2 * self.__one()

   class B(A):
       def three(self):
           return 3 * self._A__one()

   four = 4 * A()._A__one()

In particular, this does not guarantee privacy since an outside user
can still deliberately access the private attribute; many Python
programmers never bother to use private variable names at all.

더 보기:

  The private name mangling specifications for details and special
  cases.


내 클래스는 __del__을 정의하지만 객체를 삭제할 때 호출되지 않습니다.
--------------------------------------------------------------------

몇 가지 가능한 이유가 있습니다.

The "del" statement does not necessarily call "__del__()" -- it simply
decrements the object's reference count, and if this reaches zero
"__del__()" is called.

If your data structures contain circular links (e.g. a tree where each
child has a parent reference and each parent has a list of children)
the reference counts will never go back to zero.  Once in a while
Python runs an algorithm to detect such cycles, but the garbage
collector might run some time after the last reference to your data
structure vanishes, so your "__del__()" method may be called at an
inconvenient and random time. This is inconvenient if you're trying to
reproduce a problem. Worse, the order in which object's "__del__()"
methods are executed is arbitrary.  You can run "gc.collect()" to
force a collection, but there *are* pathological cases where objects
will never be collected.

Despite the cycle collector, it's still a good idea to define an
explicit "close()" method on objects to be called whenever you're done
with them.  The "close()" method can then remove attributes that refer
to subobjects.  Don't call "__del__()" directly -- "__del__()" should
call "close()" and "close()" should make sure that it can be called
more than once for the same object.

순환 참조를 피하는 또 다른 방법은 "weakref" 모듈을 사용하는 것입니다.
이 모듈은 참조 횟수를 늘리지 않고 객체를 가리킬 수 있도록 합니다. 예를
들어, 트리 자료 구조는 부모와 형제 참조에 대해 약한 참조를 사용해야 합
니다 (이런 것들이 필요하다면!).

Finally, if your "__del__()" method raises an exception, a warning
message is printed to "sys.stderr".


주어진 클래스의 모든 인스턴스 목록을 어떻게 얻습니까?
-----------------------------------------------------

파이썬은 클래스(또는 내장형)의 모든 인스턴스를 추적하지 않습니다. 클래
스 생성자가 각 인스턴스에 대한 약한 참조 리스트를 유지하여 모든 인스턴
스를 추적하도록 프로그래밍 할 수 있습니다.


"id()"의 결과가 고유하지 않은 것처럼 보이는 이유는 무엇입니까?
--------------------------------------------------------------

"id()" 내장은 객체 수명 동안 고유하도록 보장되는 정수를 반환합니다.
CPython에서는 이것이 객체의 메모리 주소이므로, 객체가 메모리에서 삭제
된 후 새로 만들어진 다음 객체가 메모리의 같은 위치에 할당되는 경우가
자주 발생합니다. 다음과 같이 예시할 수 있습니다:

>>> id(1000)
13901272
>>> id(2000)
13901272

두 개의 id는 다른 정수 객체에 속하는데, "id()" 호출 실행 앞에 만들어지
고, 호출 직후 삭제됩니다. id를 검사하려는 객체가 여전히 살아 있도록 하
려면, 그 객체에 대한 다른 참조를 만드십시오:

>>> a = 1000; b = 2000
>>> id(a)
13901272
>>> id(b)
13891296


*is* 연산자를 사용한 아이덴티티 검사는 언제 신뢰할 수 있습니까?
---------------------------------------------------------------

"is" 연산자는 객체 아이덴티티를 검사합니다. 검사 "a is b"는 "id(a) ==
id(b)"와 동등합니다.

아이덴티티 검사의 가장 중요한 속성은 객체가 항상 자신과 동일하고 "a is
a"는 항상 "True"를 반환한다는 것입니다. 아이덴티티 검사는 일반적으로
동등성 검사보다 빠릅니다. 동등성 검사와 달리, 아이덴티티 테스트는 불리
언 "True"나 "False"를 반환함이 보장됩니다.

그러나, 객체 아이덴티티가 보장될 때 아이덴티티 검사가 동등성 검사를 대
체할 수 있습니다. 일반적으로, 아이덴티티가 보장되는 세 가지 상황이 있
습니다:

1. Assignments create new names but do not change object identity.
   After the assignment "new = old", it is guaranteed that "new is
   old".

2. Putting an object in a container that stores object references does
   not change object identity.  After the list assignment "s[0] = x",
   it is guaranteed that "s[0] is x".

3. If an object is a singleton, it means that only one instance of
   that object can exist.  After the assignments "a = None" and "b =
   None", it is guaranteed that "a is b" because "None" is a
   singleton.

대부분의 다른 상황에서는 아이덴티티 검사가 권장되지 않으며 동등성 테스
트가 선호됩니다. 특히, 싱글톤이 보장되지 않는 "int"와 "str"과 같은 상
수를 확인하는 데 아이덴티티 검사를 사용해서는 안 됩니다:

   >>> a = 1000
   >>> b = 500
   >>> c = b + 500
   >>> a is c
   False

   >>> a = 'Python'
   >>> b = 'Py'
   >>> c = b + 'thon'
   >>> a is c
   False

마찬가지로, 가변 컨테이너의 새 인스턴스는 절대 동일하지 않습니다:

   >>> a = []
   >>> b = []
   >>> a is b
   False

표준 라이브러리 코드에서, 아이덴티티 검사를 올바르게 사용하는 몇 가지
일반적인 패턴을 볼 수 있습니다:

1. As recommended by **PEP 8**, an identity test is the preferred way
   to check for "None".  This reads like plain English in code and
   avoids confusion with other objects that may have boolean values
   that evaluate to false.

2. Detecting optional arguments can be tricky when "None" is a valid
   input value.  In those situations, you can create a singleton
   sentinel object guaranteed to be distinct from other objects.  For
   example, here is how to implement a method that behaves like
   "dict.pop()":

      _sentinel = object()

      def pop(self, key, default=_sentinel):
          if key in self:
              value = self[key]
              del self[key]
              return value
          if default is _sentinel:
              raise KeyError(key)
          return default

3. Container implementations sometimes need to augment equality tests
   with identity tests.  This prevents the code from being confused by
   objects such as "float('NaN')" that are not equal to themselves.

For example, here is the implementation of
"collections.abc.Sequence.__contains__()":

   def __contains__(self, value):
       for v in self:
           if v is value or v == value:
               return True
       return False


How can a subclass control what data is stored in an immutable instance?
------------------------------------------------------------------------

When subclassing an immutable type, override the "__new__()" method
instead of the "__init__()" method.  The latter only runs *after* an
instance is created, which is too late to alter data in an immutable
instance.

All of these immutable classes have a different signature than their
parent class:

   from datetime import date

   class FirstOfMonthDate(date):
       "Always choose the first day of the month"
       def __new__(cls, year, month, day):
           return super().__new__(cls, year, month, 1)

   class NamedInt(int):
       "Allow text names for some numbers"
       xlat = {'zero': 0, 'one': 1, 'ten': 10}
       def __new__(cls, value):
           value = cls.xlat.get(value, value)
           return super().__new__(cls, value)

   class TitleStr(str):
       "Convert str to name suitable for a URL path"
       def __new__(cls, s):
           s = s.lower().replace(' ', '-')
           s = ''.join([c for c in s if c.isalnum() or c == '-'])
           return super().__new__(cls, s)

The classes can be used like this:

   >>> FirstOfMonthDate(2012, 2, 14)
   FirstOfMonthDate(2012, 2, 1)
   >>> NamedInt('ten')
   10
   >>> NamedInt(20)
   20
   >>> TitleStr('Blog: Why Python Rocks')
   'blog-why-python-rocks'


How do I cache method calls?
----------------------------

The two principal tools for caching methods are
"functools.cached_property()" and "functools.lru_cache()".  The former
stores results at the instance level and the latter at the class
level.

The *cached_property* approach only works with methods that do not
take any arguments.  It does not create a reference to the instance.
The cached method result will be kept only as long as the instance is
alive.

The advantage is that when an instance is no longer used, the cached
method result will be released right away.  The disadvantage is that
if instances accumulate, so too will the accumulated method results.
They can grow without bound.

The *lru_cache* approach works with methods that have *hashable*
arguments.  It creates a reference to the instance unless special
efforts are made to pass in weak references.

The advantage of the least recently used algorithm is that the cache
is bounded by the specified *maxsize*.  The disadvantage is that
instances are kept alive until they age out of the cache or until the
cache is cleared.

This example shows the various techniques:

   class Weather:
       "Lookup weather information on a government website"

       def __init__(self, station_id):
           self._station_id = station_id
           # The _station_id is private and immutable

       def current_temperature(self):
           "Latest hourly observation"
           # Do not cache this because old results
           # can be out of date.

       @cached_property
       def location(self):
           "Return the longitude/latitude coordinates of the station"
           # Result only depends on the station_id

       @lru_cache(maxsize=20)
       def historic_rainfall(self, date, units='mm'):
           "Rainfall on a given date"
           # Depends on the station_id, date, and units.

The above example assumes that the *station_id* never changes.  If the
relevant instance attributes are mutable, the *cached_property*
approach can't be made to work because it cannot detect changes to the
attributes.

To make the *lru_cache* approach work when the *station_id* is
mutable, the class needs to define the "__eq__()" and "__hash__()"
methods so that the cache can detect relevant attribute updates:

   class Weather:
       "Example with a mutable station identifier"

       def __init__(self, station_id):
           self.station_id = station_id

       def change_station(self, station_id):
           self.station_id = station_id

       def __eq__(self, other):
           return self.station_id == other.station_id

       def __hash__(self):
           return hash(self.station_id)

       @lru_cache(maxsize=20)
       def historic_rainfall(self, date, units='cm'):
           'Rainfall on a given date'
           # Depends on the station_id, date, and units.


모듈
====


.pyc 파일을 어떻게 만듭니까?
----------------------------

모듈이 처음 임포트 될 때 (또는 현재 컴파일된 파일이 만들어진 후 소스
파일이 변경되었을 때) 컴파일된 코드를 포함하는 ".pyc" 파일은 ".py" 파
일을 포함하는 디렉터리의 "__pycache__" 서브 디렉터리에 만들어져야 합니
다. ".pyc" 파일은 ".py" 파일과 같은 이름으로 시작하고, ".pyc"로 끝나며
, 파일을 만든 특정 "python" 바이너리 파일에 종속되는 중간 구성 요소를
갖는 파일명을 갖습니다. (자세한 내용은 **PEP 3147**을 참조하십시오.)

".pyc" 파일이 만들어지지 않을 수 있는 한 가지 이유는 소스 파일이 포함
된 디렉터리의 권한 문제입니다. 즉, "__pycache__" 서브 디렉터리를 만들
수 없다는 뜻입니다. 예를 들어, 한 사용자로 개발했지만 다른 사용자로 실
행하는 경우에 이런 일이 일어날 수 있습니다, 가령 웹 서버로 테스트하고
있을 때입니다.

"PYTHONDONTWRITEBYTECODE" 환경 변수가 설정되어 있지 않은 한, 모듈을 임
포트 하고 파이썬이 "__pycache__" 서브 디렉터리를 만들고 컴파일된 모듈
을 그 서브 디렉터리에 쓸 수 있는 능력(권한, 여유 공간 등)이 있으면
.pyc 파일의 생성은 자동입니다.

최상위 스크립트에서 파이썬을 실행하는 것은 임포트로 간주하지 않으며
".pyc"가 만들어지지 않습니다. 예를 들어, 다른 모듈 "xyz.py"를 임포트
하는 최상위 모듈 "foo.py"가 있을 때, ("python foo.py"를 셸 명령으로 입
력하여) "foo"를 실행하면, "xyz"를 임포트 하기 때문에 "xyz"에 대해
".pyc"가 만들어지지만, "foo.py"를 임포트 하지 않기 때문에 "foo"에 대해
서는 ".pyc" 파일이 만들어지지 않습니다.

"foo"에 대한 ".pyc" 파일을 만들 필요가 있으면 -- 즉, 임포트 되지 않는
모듈에 대한 ".pyc" 파일을 만들려면 -- "py_compile"과 "compileall" 모듈
을 사용할 수 있습니다.

"py_compile" 모듈은 임의의 모듈을 수동으로 컴파일할 수 있습니다. 한 가
지 방법은 해당 모듈에서 "compile()" 함수를 대화식으로 사용하는 것입니
다:

   >>> import py_compile
   >>> py_compile.compile('foo.py')

이것은 ".pyc"를 "foo.py"와 같은 위치에 있는 "__pycache__" 서브 디렉터
리에 기록합니다 (또는 선택적 매개변수 "cfile"로 이를 재정의할 수 있습
니다).

"compileall" 모듈을 사용하여 디렉터리의 모든 파일을 자동으로 컴파일할
수도 있습니다. "compileall.py"를 실행하고 컴파일할 파이썬 파일이 포함
된 디렉터리의 경로를 제공하여 셸 프롬프트에서 이를 수행할 수 있습니다:

   python -m compileall .


현재 모듈 이름을 어떻게 찾습니까?
---------------------------------

모듈은 사전 정의된 전역 변수 "__name__"을 봄으로써 모듈 자신의 이름을
찾을 수 있습니다. 값이 "'__main__'"이면, 프로그램이 스크립트로 실행 중
입니다. 일반적으로 모듈을 임포트 해서 사용하는 많은 모듈은 명령 줄 인
터페이스나 자체 테스트를 제공하며, "__name__"을 확인한 후에 만 이 코드
를 실행합니다:

   def main():
       print('Running test...')
       ...

   if __name__ == '__main__':
       main()


서로 임포트 하는 모듈을 어떻게 만들 수 있습니까?
------------------------------------------------

다음 모듈이 있다고 가정하십시오:

"foo.py":

   from bar import bar_var
   foo_var = 1

"bar.py":

   from foo import foo_var
   bar_var = 2

문제는 인터프리터가 다음 단계를 수행한다는 것입니다:

* main imports "foo"

* Empty globals for "foo" are created

* "foo" is compiled and starts executing

* "foo" imports "bar"

* Empty globals for "bar" are created

* "bar" is compiled and starts executing

* "bar" imports "foo" (which is a no-op since there already is a
  module named "foo")

* The import mechanism tries to read "foo_var" from "foo" globals, to
  set "bar.foo_var = foo.foo_var"

마지막 단계가 실패합니다. 파이썬이 아직 "foo"를 인터프리트 하는 것을
완료하지 않았고 "foo"의 전역 기호 딕셔너리가 여전히 비어 있기 때문입니
다.

"import foo"를 사용하고 전역 코드에서 "foo.foo_var"에 액세스하려고 할
때도 같은 일이 일어납니다.

이 문제에 대해 가능한 (최소한) 세 가지 해결 방법이 있습니다.

Guido van Rossum은 "from <module> import ..."을 아예 사용하지 말고, 모
든 코드를 함수 내에 배치할 것을 권장합니다. 전역 변수와 클래스 변수의
초기화는 상수나 내장 함수만 사용해야 합니다. 이것은 임포트 된 모듈의
모든 것이 "<module>.<name>"으로 참조됨을 의미합니다.

Jim Roskind는 각 모듈에서 다음 순서로 단계를 수행할 것을 제안합니다:

* 내보내기 (전역, 함수 및 베이스 클래스를 임포트 할 필요가 없는 클래스
  )

* "import" 문

* 활성 코드 (임포트 된 값에서 초기화된 전역 포함).

Van Rossum doesn't like this approach much because the imports appear
in a strange place, but it does work.

Matthias Urlichs는 처음부터 재귀 임포트가 필요하지 않도록 코드를 재구
성할 것을 권합니다.

이 해결 방법들은 상호 배타적이지 않습니다.


__import__('x.y.z')는 <module 'x'>를 반환합니다; z를 어떻게 얻습니까?
---------------------------------------------------------------------

"importlib"의 편의 함수 "import_module()"을 대신 사용하는 곳을 고려하
십시오:

   z = importlib.import_module('x.y.z')


임포트 된 모듈을 편집하고 다시 임포트 할 때, 변경 사항이 표시되지 않습니다. 왜 이런 일이 발생합니까?
----------------------------------------------------------------------------------------------------

효율성뿐만 아니라 일관성의 이유로, 파이썬은 모듈을 처음 임포트 할 때만
모듈 파일을 읽습니다. 그렇지 않으면, 각 모듈이 같은 기본 모듈을 임포트
하는 많은 모듈로 구성된 프로그램에서, 기본 모듈을 여러 번 구문 분석하
고 다시 구문 분석하게 됩니다. 변경된 모듈을 강제로 다시 읽으려면, 다음
과 같이 하십시오:

   import importlib
   import modname
   importlib.reload(modname)

경고: 이 기법은 100% 확실하지 않습니다. 특히, 다음과 같은 문장을 포함
하는 모듈은

   from modname import some_objects

임포트 된 객체의 이전 버전으로 계속 작업합니다. 모듈에 클래스 정의가
포함되면, 새 클래스 정의를 사용하도록 기존 클래스 인스턴스가 갱신되지
*않습니다*. 이것은 다음과 같은 역설적인 동작으로 이어집니다:

   >>> import importlib
   >>> import cls
   >>> c = cls.C()                # Create an instance of C
   >>> importlib.reload(cls)
   <module 'cls' from 'cls.py'>
   >>> isinstance(c, cls.C)       # isinstance is false?!?
   False

클래스 객체의 "아이덴티티"를 인쇄하면 문제의 본질이 분명해집니다:

   >>> hex(id(c.__class__))
   '0x7352a0'
   >>> hex(id(cls.C))
   '0x4198d0'
