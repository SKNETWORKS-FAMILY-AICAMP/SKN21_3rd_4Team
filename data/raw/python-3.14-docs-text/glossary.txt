용어집
******

">>>"
   *대화형* 셸의 기본 파이썬 프롬프트. 인터프리터에서 대화형으로 실행
   될 수 있는 코드 예에서 자주 볼 수 있습니다.

"..."
   다음과 같은 것들을 가리킬 수 있습니다:

   * 들여쓰기 된 코드 블록의 코드를 입력할 때, 쌍을 이루는 구분자 (괄
     호, 대괄호, 중괄호) 안에 코드를 입력할 때, 데코레이터 지정 후의 *
     대화형* 셸의 기본 파이썬 프롬프트.

   * The three dots form of the Ellipsis object.

abstract base class (추상 베이스 클래스)
   추상 베이스 클래스는 "hasattr()" 같은 다른 테크닉들이 불편하거나 미
   묘하게 잘못된 (예를 들어, 매직 메서드) 경우, 인터페이스를 정의하는
   방법을 제공함으로써 *덕 타이핑* 을 보완합니다. ABC는 가상 서브 클래
   스를 도입하는데, 클래스를 계승하지 않으면서도 "isinstance()" 와
   "issubclass()" 에 의해 감지될 수 있는 클래스들입니다; "abc" 모듈 설
   명서를 보세요. 파이썬에는 많은 내장 ABC 들이 따라오는데 다음과 같은
   것들이 있습니다: 자료 구조 ("collections.abc" 모듈에서), 숫자
   ("numbers" 모듈에서), 스트림 ("io" 모듈에서), 임포트 파인더와 로더
   ("importlib.abc" 모듈에서). "abc" 모듈을 사용해서 자신만의 ABC를 만
   들 수도 있습니다.

annotate function
   A function that can be called to retrieve the *annotations* of an
   object. This function is accessible as the "__annotate__" attribute
   of functions, classes, and modules. Annotate functions are a subset
   of *evaluate functions*.

annotation (어노테이션)
   관습에 따라 *형 힌트* 로 사용되는 변수, 클래스 어트리뷰트 또는 함수
   매개변수 나 반환 값과 연결된 레이블입니다.

   Annotations of local variables cannot be accessed at runtime, but
   annotations of global variables, class attributes, and functions
   can be retrieved by calling "annotationlib.get_annotations()" on
   modules, classes, and functions, respectively.

   See *variable annotation*, *function annotation*, **PEP 484**,
   **PEP 526**, and **PEP 649**, which describe this functionality.
   Also see Annotations Best Practices for best practices on working
   with annotations.

argument (인자)
   함수를 호출할 때 *함수* (또는 *메서드*) 로 전달되는 값. 두 종류의
   인자가 있습니다:

   * *키워드 인자 (keyword argument)*: 함수 호출 때 식별자가 앞에 붙은
     인자 (예를 들어, "name=") 또는 "**" 를 앞에 붙인 딕셔너리로 전달
     되는 인자. 예를 들어, 다음과 같은 "complex()" 호출에서 "3" 과 "5"
     는 모두 키워드 인자입니다:

        complex(real=3, imag=5)
        complex(**{'real': 3, 'imag': 5})

   * *위치 인자 (positional argument)*: 키워드 인자가 아닌 인자. 위치
     인자들은 인자 목록의 처음에 나오거나 *이터러블* 의 앞에 "*" 를 붙
     여 전달할 수 있습니다. 예를 들어, 다음과 같은 호출에서 "3" 과 "5"
     는 모두 위치 인자입니다.

        complex(3, 5)
        complex(*(3, 5))

   인자는 함수 바디의 이름 붙은 지역 변수에 대입됩니다. 이 대입에 적용
   되는 규칙들에 대해서는 호출 절을 보세요. 문법적으로, 어떤 표현식이
   건 인자로 사용될 수 있습니다; 구해진 값이 지역 변수에 대입됩니다.

   용어집의 *매개변수* 항목과 FAQ 질문 인자와 매개변수의 차이 와 **PEP
   362**도 보세요.

asynchronous context manager (비동기 컨텍스트 관리자)
   "__aenter__()" 와 "__aexit__()" 메서드를 정의함으로써 "async with"
   문에서 보이는 환경을 제어하는 객체. **PEP 492**로 도입되었습니다.

asynchronous generator (비동기 제너레이터)
   *비동기 제너레이터 이터레이터* 를 돌려주는 함수. "async def" 로 정
   의되는 코루틴 함수처럼 보이는데, "async for" 루프가 사용할 수 있는
   일련의 값들을 만드는 "yield" 표현식을 포함한다는 점이 다릅니다.

   보통 비동기 제너레이터 함수를 가리키지만, 어떤 문맥에서는 *비동기
   제너레이터 이터레이터* 를 가리킵니다. 의도하는 의미가 명확하지 않은
   경우는, 완전한 용어를 써서 모호함을 없앱니다.

   비동기 제너레이터 함수는 "await" 표현식과, "async for" 문과, "async
   with" 문을 포함할 수 있습니다.

asynchronous generator iterator (비동기 제너레이터 이터레이터)
   An object created by an *asynchronous generator* function.

   *비동기 이터레이터* 인데 "__anext__()" 를 호출하면 어웨이터블 객체
   를 돌려주고, 이것은 다음 "yield" 표현식 까지 비동기 제너레이터 함수
   의 바디를 실행합니다.

   각 "yield"는 일시적으로 처리를 중단하고, (지역 변수들과 대기 중인
   try-문들을 포함하는) 실행 상태를 기억합니다. *비동기 제너레이터 이
   터레이터* 가 "__anext__()" 가 돌려주는 또 하나의 어웨이터블로 재개
   되면, 떠난 곳으로 복귀합니다. **PEP 492**와 **PEP 525**를 보세요.

asynchronous iterable (비동기 이터러블)
   "async for" 문에서 사용될 수 있는 객체. "__aiter__()" 메서드는 *비
   동기 이터레이터* 를 돌려줘야 합니다. **PEP 492** 로 도입되었습니다.

asynchronous iterator (비동기 이터레이터)
   "__aiter__()" 와 "__anext__()" 메서드를 구현하는 객체.
   "__anext__()" 는 *어웨이터블* 객체를 돌려줘야 합니다. "async for"는
   "StopAsyncIteration" 예외가 발생할 때까지 비동기 이터레이터의
   "__anext__()" 메서드가 돌려주는 어웨이터블을 풉니다. **PEP 492**로
   도입되었습니다.

atomic operation
   An operation that appears to execute as a single, indivisible step:
   no other thread can observe it half-done, and its effects become
   visible all at once.  Python does not guarantee that high-level
   statements are atomic (for example, "x += 1" performs multiple
   bytecode operations and is not atomic).  Atomicity is only
   guaranteed where explicitly documented.  See also *race condition*
   and *data race*.

attached thread state
   A *thread state* that is active for the current OS thread.

   When a *thread state* is attached, the OS thread has access to the
   full Python C API and can safely invoke the bytecode interpreter.

   Unless a function explicitly notes otherwise, attempting to call
   the C API without an attached thread state will result in a fatal
   error or undefined behavior.  A thread state can be attached and
   detached explicitly by the user through the C API, or implicitly by
   the runtime, including during blocking C calls and by the bytecode
   interpreter in between calls.

   On most builds of Python, having an attached thread state implies
   that the caller holds the *GIL* for the current interpreter, so
   only one OS thread can have an attached thread state at a given
   moment. In *free-threaded* builds of Python, threads can
   concurrently hold an attached thread state, allowing for true
   parallelism of the bytecode interpreter.

attribute (어트리뷰트)
   흔히 점표현식을 사용하는 이름으로 참조되는 객체와 결합한 값. 예를
   들어, 객체 *o*가 어트리뷰트 *a*를 가지면, *o.a*처럼 참조됩니다.

   It is possible to give an object an attribute whose name is not an
   identifier as defined by Names (identifiers and keywords), for
   example using "setattr()", if the object allows it. Such an
   attribute will not be accessible using a dotted expression, and
   would instead need to be retrieved with "getattr()".

awaitable (어웨이터블)
   "await" 표현식에 사용할 수 있는 객체. *코루틴* 이나 "__await__()"
   메서드를 가진 객체가 될 수 있습니다. **PEP 492**를 보세요.

BDFL
   자비로운 종신 독재자 (Benevolent Dictator For Life), 즉 Guido van
   Rossum, 파이썬의 창시자.

binary file (바이너리 파일)
   *바이트열류 객체들*을 읽고 쓸 수 있는 *파일 객체*. 바이너리 파일의
   예로는 바이너리 모드 ("'rb'", "'wb'" 또는 "'rb+'") 로 열린 파일,
   "sys.stdin.buffer", "sys.stdout.buffer", "io.BytesIO" 와
   "gzip.GzipFile" 의 인스턴스를 들 수 있습니다.

   "str" 객체를 읽고 쓸 수 있는 파일 객체에 대해서는 *텍스트 파일* 도
   참조하세요.

borrowed reference (빌린 참조)
   In Python's C API, a borrowed reference is a reference to an
   object, where the code using the object does not own the reference.
   It becomes a dangling pointer if the object is destroyed. For
   example, a garbage collection can remove the last *strong
   reference* to the object and so destroy it.

   Calling "Py_INCREF()" on the *borrowed reference* is recommended to
   convert it to a *strong reference* in-place, except when the object
   cannot be destroyed before the last usage of the borrowed
   reference. The "Py_NewRef()" function can be used to create a new
   *strong reference*.

bytes-like object (바이트열류 객체)
   버퍼 프로토콜 를 지원하고 C-*연속* 버퍼를 익스포트 할 수 있습니다.
   여러 공통 "memoryview" 객체들은 물론이고 "bytes", "bytearray",
   "array.array" 객체들을 포함합니다. 바이트열류 객체들은 바이너리 데
   이터를 다루는 여러 가지 연산들에 사용될 수 있습니다; 압축, 바이너리
   파일로 저장, 소켓을 통한 전송 같은 것들이 있습니다.

   어떤 연산들은 바이너리 데이터가 가변적일 필요가 있습니다. 이런 경우
   에 설명서는 종종 "읽고-쓰기 바이트열류 객체"라고 표현합니다. 가변
   버퍼 객체의 예로는 "bytearray" 와 "bytearray" 의 "memoryview" 가 있
   습니다. 다른 연산들은 바이너리 데이터가 불변 객체 ("읽기 전용 바이
   트열류 객체")에 저장되도록 요구합니다; 이런 것들의 예로는 "bytes"와
   "bytes" 객체의 "memoryview" 가 있습니다.

bytecode (바이트 코드)
   파이썬 소스 코드는 바이트 코드로 컴파일되는데, CPython 인터프리터에
   서 파이썬 프로그램의 내부 표현입니다. 바이트 코드는 ".pyc" 파일에
   캐시 되어, 같은 파일을 두 번째 실행할 때 더 빨라지게 만듭니다 (소스
   에서 바이트 코드로의 재컴파일을 피할 수 있습니다). 이 "중간 언어"
   는 각 바이트 코드에 대응하는 기계를 실행하는 *가상 기계* 에서 실행
   된다고 말합니다. 바이트 코드는 서로 다른 파이썬 가상 기계에서 작동
   할 것으로 기대하지도, 파이썬 배포 간에 안정적이지도 않다는 것에 주
   의해야 합니다.

   바이트 코드 명령어들의 목록은 dis 모듈 설명서에 나옵니다.

callable (콜러블)
   A callable is an object that can be called, possibly with a set of
   arguments (see *argument*), with the following syntax:

      callable(argument1, argument2, argumentN)

   A *function*, and by extension a *method*, is a callable. An
   instance of a class that implements the "__call__()" method is also
   a callable.

callback (콜백)
   인자로 전달되는 미래의 어느 시점에서 실행될 서브 루틴 함수.

class (클래스)
   사용자 정의 객체들을 만들기 위한 주형. 클래스 정의는 보통 클래스의
   인스턴스를 대상으로 연산하는 메서드 정의들을 포함합니다.

class variable (클래스 변수)
   클래스에서 정의되고 클래스 수준 (즉, 클래스의 인스턴스에서가 아니라
   ) 에서만 수정되는 변수.

closure variable (클로저 변수)
   A *free variable* referenced from a *nested scope* that is defined
   in an outer scope rather than being resolved at runtime from the
   globals or builtin namespaces. May be explicitly defined with the
   "nonlocal" keyword to allow write access, or implicitly defined if
   the variable is only being read.

   For example, in the "inner" function in the following code, both
   "x" and "print" are *free variables*, but only "x" is a *closure
   variable*:

      def outer():
          x = 0
          def inner():
              nonlocal x
              x += 1
              print(x)
          return inner

   Due to the "codeobject.co_freevars" attribute (which, despite its
   name, only includes the names of closure variables rather than
   listing all referenced free variables), the more general *free
   variable* term is sometimes used even when the intended meaning is
   to refer specifically to closure variables.

complex number (복소수)
   익숙한 실수 시스템의 확장인데, 모든 숫자가 실수부와 허수부의 합으로
   표현됩니다. 허수부는 실수에 허수 단위("-1"의 제곱근)를 곱한 것인데,
   종종 수학에서는 "i"로, 공학에서는 "j"로 표기합니다. 파이썬은 후자의
   표기법을 쓰는 복소수를 기본 지원합니다; 허수부는 "j" 접미사를 붙여
   서 표기합니다, 예를 들어, "3+1j". "math" 모듈의 복소수 버전이 필요
   하면, "cmath"를 사용합니다. 복소수의 활용은 꽤 수준 높은 수학적 기
   능입니다. 필요하다고 느끼지 못한다면, 거의 확실히 무시해도 좋습니다
   .

concurrency
   The ability of a computer program to perform multiple tasks at the
   same time.  Python provides libraries for writing programs that
   make use of different forms of concurrency.  "asyncio" is a library
   for dealing with asynchronous tasks and coroutines.  "threading"
   provides access to operating system threads and "multiprocessing"
   to operating system processes. Multi-core processors can execute
   threads and processes on different CPU cores at the same time (see
   *parallelism*).

concurrent modification
   When multiple threads modify shared data at the same time.
   Concurrent modification without proper synchronization can cause
   *race conditions*, and might also trigger a *data race*, data
   corruption, or both.

context (컨텍스트)
   This term has different meanings depending on where and how it is
   used. Some common meanings:

   * The temporary state or environment established by a *context
     manager* via a "with" statement.

   * The collection of key­value bindings associated with a particular
     "contextvars.Context" object and accessed via "ContextVar"
     objects.  Also see *context variable*.

   * A "contextvars.Context" object.  Also see *current context*.

context management protocol (컨텍스트 관리 프로토콜)
   The "__enter__()" and "__exit__()" methods called by the "with"
   statement.  See **PEP 343**.

context manager (컨텍스트 관리자)
   *컨텍스트 관리 프로토콜*을 구현하고 "with" 문에서 보이는 환경을 제
   어하는 객체. **PEP 343**을 참조하십시오.

context variable (컨텍스트 변수)
   A variable whose value depends on which context is the *current
   context*.  Values are accessed via "contextvars.ContextVar"
   objects.  Context variables are primarily used to isolate state
   between concurrent asynchronous tasks.

contiguous (연속)
   버퍼는 정확히 *C-연속(C-contiguous)*이거나 *포트란 연속(Fortran
   contiguous)*일 때 연속이라고 여겨집니다. 영차원 버퍼는 C-연속이면서
   포트란 연속입니다. 일차원 배열에서, 항목들은 서로에 인접하고, 0에서
   시작하는 오름차순 인덱스의 순서대로 메모리에 배치되어야 합니다. 다
   차원 C-연속 배열에서, 메모리 주소의 순서대로 항목들을 방문할 때 마
   지막 인덱스가 가장 빨리 변합니다. 하지만, 포트란 연속 배열에서는,
   첫 번째 인덱스가 가장 빨리 변합니다.

coroutine (코루틴)
   코루틴은 서브루틴의 더 일반화된 형태입니다. 서브루틴은 한 지점에서
   진입하고 다른 지점에서 탈출합니다. 코루틴은 여러 다른 지점에서 진입
   하고, 탈출하고, 재개할 수 있습니다. 이것들은 "async def" 문으로 구
   현할 수 있습니다. **PEP 492**를 보세요.

coroutine function (코루틴 함수)
   *코루틴* 객체를 돌려주는 함수. 코루틴 함수는 "async def" 문으로 정
   의될 수 있고, "await" 와 "async for"와 "async with" 키워드를 포함할
   수 있습니다. 이것들은 **PEP 492** 에 의해 도입되었습니다.

CPython
   파이썬 프로그래밍 언어의 규범적인 구현인데, python.org에서 배포됩니
   다. 이 구현을 Jython 이나 IronPython 과 같은 다른 것들과 구별할 필
   요가 있을 때 용어 "CPython" 이 사용됩니다.

current context (현재 컨텍스트)
   The *context* ("contextvars.Context" object) that is currently used
   by "ContextVar" objects to access (get or set) the values of
   *context variables*.  Each thread has its own current context.
   Frameworks for executing asynchronous tasks (see "asyncio")
   associate each task with a context which becomes the current
   context whenever the task starts or resumes execution.

cyclic isolate
   A subgroup of one or more objects that reference each other in a
   reference cycle, but are not referenced by objects outside the
   group.  The goal of the *cyclic garbage collector* is to identify
   these groups and break the reference cycles so that the memory can
   be reclaimed.

data race
   A situation where multiple threads access the same memory location
   concurrently, at least one of the accesses is a write, and the
   threads do not use any synchronization to control their access.
   Data races lead to *non-deterministic* behavior and can cause data
   corruption. Proper use of *locks* and other *synchronization
   primitives* prevents data races.  Note that data races can only
   happen in native code, but that *native code* might be exposed in a
   Python API.  See also *race condition* and *thread-safe*.

deadlock
   A situation in which two or more tasks (threads, processes, or
   coroutines) wait indefinitely for each other to release resources
   or complete actions, preventing any from making progress.  For
   example, if thread A holds lock 1 and waits for lock 2, while
   thread B holds lock 2 and waits for lock 1, both threads will wait
   indefinitely.  In Python this often arises from acquiring multiple
   locks in conflicting orders or from circular join/await
   dependencies.  Deadlocks can be avoided by always acquiring
   multiple *locks* in a consistent order.  See also *lock* and
   *reentrant*.

decorator (데코레이터)
   다른 함수를 돌려주는 함수인데, 보통 "@wrapper" 문법을 사용한 함수
   변환으로 적용됩니다. 데코레이터의 흔한 예는 "classmethod()" 과
   "staticmethod()" 입니다.

   데코레이터 문법은 단지 편의 문법일 뿐입니다. 다음 두 함수 정의는 의
   미상으로 동등합니다:

      def f(arg):
          ...
      f = staticmethod(f)

      @staticmethod
      def f(arg):
          ...

   같은 개념이 클래스에도 존재하지만, 덜 자주 쓰입니다. 데코레이터에
   대한 더 자세한 내용은 함수 정의 와 클래스 정의 의 설명서를 보면 됩
   니다.

descriptor (디스크립터)
   메서드 "__get__()" 이나 "__set__()" 이나 "__delete__()"를 정의하는
   객체. 클래스 어트리뷰트가 디스크립터일 때, 어트리뷰트 조회는 특별한
   연결 작용을 일으킵니다. 보통, *a.b*를 읽거나, 쓰거나, 삭제하는데 사
   용할 때, *a*의 클래스 딕셔너리에서 *b* 라고 이름 붙여진 객체를 찾습
   니다. 하지만 *b*가 디스크립터면, 해당하는 디스크립터 메서드가 호출
   됩니다. 디스크립터를 이해하는 것은 파이썬에 대한 깊은 이해의 열쇠인
   데, 함수, 메서드, 프로퍼티, 클래스 메서드, 스태틱 메서드, 슈퍼 클래
   스 참조 등의 많은 기능의 기초를 이루고 있기 때문입니다.

   디스크립터의 메서드들에 대한 자세한 내용은 디스크립터 구현하기나 디
   스크립터 사용법 안내서에 나옵니다.

dictionary (딕셔너리)
   임의의 키를 값에 대응시키는 연관 배열 (associative array). 키는
   "__hash__()" 와 "__eq__()" 메서드를 갖는 모든 객체가 될 수 있습니다
   . 펄에서 해시라고 부릅니다.

dictionary comprehension (딕셔너리 컴프리헨션)
   이터러블에 있는 요소 전체나 일부를 처리하고 결과를 담은 딕셔너리를
   반환하는 간결한 방법. "results = {n: n ** 2 for n in range(10)}"은
   값 "n ** 2"에 매핑된 키 "n"을 포함하는 딕셔너리를 생성합니다. 리스
   트, 집합, 딕셔너리의 디스플레이(display)을 참조하십시오.

dictionary view (딕셔너리 뷰)
   "dict.keys()", "dict.values()", "dict.items()" 메서드가 돌려주는 객
   체들을 딕셔너리 뷰라고 부릅니다. 이것들은 딕셔너리 항목들에 대한 동
   적인 뷰를 제공하는데, 딕셔너리가 변경될 때, 뷰가 이 변화를 반영한다
   는 뜻입니다. 딕셔너리 뷰를 완전한 리스트로 바꾸려면
   "list(dictview)"를 사용하면 됩니다. 딕셔너리 뷰 객체를 보세요.

docstring (독스트링)
   클래스, 함수, 모듈에서 첫 번째 표현식으로 나타나는 문자열 리터럴.
   스위트가 실행될 때는 무시되지만, 컴파일러에 의해 인지되어 둘러싼 클
   래스, 함수, 모듈의 "__doc__" 어트리뷰트로 삽입됩니다. 인트로스펙션
   을 통해 사용할 수 있으므로, 객체의 설명서를 위한 규범적인 장소입니
   다.

duck-typing (덕 타이핑)
   올바른 인터페이스를 가졌는지 판단하는데 객체의 형을 보지 않는 프로
   그래밍 스타일; 대신, 단순히 메서드나 어트리뷰트가 호출되거나 사용됩
   니다 ("오리처럼 보이고 오리처럼 꽥꽥댄다면, 그것은 오리다.") 특정한
   형 대신에 인터페이스를 강조함으로써, 잘 설계된 코드는 다형적인 치환
   을 허락함으로써 유연성을 개선할 수 있습니다. 덕 타이핑은 "type()"
   이나 "isinstance()" 을 사용한 검사를 피합니다. (하지만, 덕 타이핑이
   *추상 베이스 클래스* 로 보완될 수 있음에 유의해야 합니다.) 대신에,
   "hasattr()" 검사나 *EAFP* 프로그래밍을 씁니다.

dunder
   An informal short-hand for "double underscore", used when talking
   about a *special method*. For example, "__init__" is often
   pronounced "dunder init".

EAFP
   허락보다는 용서를 구하기가 쉽다 (Easier to ask for forgiveness than
   permission). 이 흔히 볼 수 있는 파이썬 코딩 스타일은, 올바른 키나
   어트리뷰트의 존재를 가정하고, 그 가정이 틀리면 예외를 잡습니다. 이
   깔끔하고 빠른 스타일은 많은 "try"와 "except" 문의 존재로 특징지어집
   니다. 이 테크닉은 C와 같은 다른 많은 언어에서 자주 사용되는 *LBYL*
   스타일과 대비됩니다.

evaluate function
   A function that can be called to evaluate a lazily evaluated
   attribute of an object, such as the value of type aliases created
   with the "type" statement.

expression (표현식)
   어떤 값으로 구해질 수 있는 문법적인 조각. 다른 말로 표현하면, 표현
   식은 리터럴, 이름, 어트리뷰트 액세스, 연산자, 함수들과 같은 값을 돌
   려주는 표현 요소들을 쌓아 올린 것입니다. 다른 많은 언어와 대조적으
   로, 모든 언어 구성물들이 표현식인 것은 아닙니다. "while"처럼, 표현
   식으로 사용할 수 없는 *문장* 들이 있습니다. 대입 또한 문장이고, 표
   현식이 아닙니다.

extension module (확장 모듈)
   C 나 C++로 작성된 모듈인데, 파이썬의 C API를 사용해서 핵심이나 사용
   자 코드와 상호 작용합니다.

f-string (f-문자열)
f-strings
   String literals prefixed with "f" or "F" are commonly called
   "f-strings" which is short for formatted string literals.  See also
   **PEP 498**.

file object (파일 객체)
   하부 자원에 대해 파일 지향적 API("read()" 나 "write()" 같은 메서드
   들)를 드러내는 객체. 만들어진 방법에 따라, 파일 객체는 실제 디스크
   상의 파일이나 다른 저장 장치나 통신 장치 (예를 들어, 표준 입출력,
   인-메모리 버퍼, 소켓, 파이프, 등등)에 대한 액세스를 중계할 수 있습
   니다. 파일 객체는 *파일류 객체 (file-like objects)*나 *스트림
   (streams)* 이라고도 불립니다.

   실제로는 세 부류의 파일 객체들이 있습니다. 날(raw) *바이너리 파일*,
   버퍼드(buffered) *바이너리 파일*, *텍스트 파일*. 이들의 인터페이스
   는 "io" 모듈에서 정의됩니다. 파일 객체를 만드는 규범적인 방법은
   "open()" 함수를 쓰는 것입니다.

file-like object (파일류 객체)
   *파일 객체* 의 비슷한 말.

filesystem encoding and error handler (파일시스템 인코딩과 에러 처리기
)
   Encoding and error handler used by Python to decode bytes from the
   operating system and encode Unicode to the operating system.

   The filesystem encoding must guarantee to successfully decode all
   bytes below 128. If the file system encoding fails to provide this
   guarantee, API functions can raise "UnicodeError".

   The "sys.getfilesystemencoding()" and
   "sys.getfilesystemencodeerrors()" functions can be used to get the
   filesystem encoding and error handler.

   The *filesystem encoding and error handler* are configured at
   Python startup by the "PyConfig_Read()" function: see
   "filesystem_encoding" and "filesystem_errors" members of
   "PyConfig".

   *로케일 인코딩* 도 보세요.

finder (파인더)
   임포트될 모듈을 위한 *로더* 를 찾으려고 시도하는 객체.

   두 종류의 파인더가 있습니다: "sys.meta_path" 와 함께 사용하는 *메타
   경로 파인더* 와 "sys.path_hooks" 과 함께 사용하는 *경로 엔트리 파인
   더*.

   더 자세한 내용은 파인더(finder)와 로더(loader) 와 "importlib"를 참
   조하십시오.

floor division (정수 나눗셈)
   가장 가까운 정수로 내림하는 수학적 나눗셈. 정수 나눗셈 연산자는
   "//" 다. 예를 들어, 표현식 "11 // 4" 의 값은 "2"가 되지만, 실수 나
   눗셈은 "2.75"를 돌려줍니다. "(-11) // 4" 가 "-2.75"를 *내림* 한
   "-3"이 됨에 유의해야 합니다. **PEP 238**을 보세요.

free threading (자유 스레딩)
   A threading model where multiple threads can run Python bytecode
   simultaneously within the same interpreter.  This is in contrast to
   the *global interpreter lock* which allows only one thread to
   execute Python bytecode at a time.  See **PEP 703**.

free variable (자유 변수)
   Formally, as defined in the language execution model, a free
   variable is any variable used in a namespace which is not a local
   variable in that namespace. See *closure variable* for an example.
   Pragmatically, due to the name of the "codeobject.co_freevars"
   attribute, the term is also sometimes used as a synonym for
   *closure variable*.

function (함수)
   호출자에게 어떤 값을 돌려주는 일련의 문장들. 없거나 그 이상의 *인자
   * 가 전달될 수 있는데, 바디의 실행에 사용될 수 있습니다. *매개변수*
   와 *메서드* 와 함수 정의 섹션도 보세요.

function annotation (함수 어노테이션)
   함수 매개변수나 반환 값의 *어노테이션*.

   함수 어노테이션은 일반적으로 *형 힌트* 로 사용됩니다: 예를 들어, 이
   함수는 두 개의 "int" 인자를 받아들일 것으로 기대되고, 동시에 "int"
   반환 값을 줄 것으로 기대됩니다:

      def sum_two_numbers(a: int, b: int) -> int:
         return a + b

   함수 어노테이션 문법은 함수 정의 절에서 설명합니다.

   이 기능을 설명하는 *변수 어노테이션* 과 **PEP 484**를 참조하세요.
   또한 어노테이션에 대한 모범 사례는 Annotations Best Practices를 참
   조하세요.

__future__
   A future statement, "from __future__ import <feature>", directs the
   compiler to compile the current module using syntax or semantics
   that will become standard in a future release of Python. The
   "__future__" module documents the possible values of *feature*.  By
   importing this module and evaluating its variables, you can see
   when a new feature was first added to the language and when it will
   (or did) become the default:

      >>> import __future__
      >>> __future__.division
      _Feature((2, 2, 0, 'alpha', 2), (3, 0, 0, 'alpha', 0), 8192)

garbage collection (가비지 수거)
   더 사용되지 않는 메모리를 반납하는 절차. 파이썬은 참조 횟수 추적과
   참조 순환을 감지하고 끊을 수 있는 순환 가비지 수거기를 통해 가비지
   수거를 수행합니다. 가비지 수거기는 "gc" 모듈을 사용해서 제어할 수
   있습니다.

generator (제너레이터)
   *제너레이터 이터레이터* 를 돌려주는 함수. 일반 함수처럼 보이는데,
   일련의 값들을 만드는 "yield" 표현식을 포함한다는 점이 다릅니다. 이
   값들은 for-루프로 사용하거나 "next()" 함수로 한 번에 하나씩 꺼낼 수
   있습니다.

   보통 제너레이터 함수를 가리키지만, 어떤 문맥에서는 *제너레이터 이터
   레이터* 를 가리킵니다. 의도하는 의미가 명확하지 않은 경우는, 완전한
   용어를 써서 모호함을 없앱니다.

generator iterator (제너레이터 이터레이터)
   *제너레이터* 함수가 만드는 객체.

   각 "yield"는 일시적으로 처리를 중단하고, (지역 변수들과 대기 중인
   try-문들을 포함하는) 실행 상태를 기억합니다. *제너레이터 이터레이터
   * 가 재개되면, 떠난 곳으로 복귀합니다 (호출마다 새로 시작하는 함수
   와 대비됩니다).

generator expression (제너레이터 표현식)
   *이터레이터*를 돌려주는 *표현식*. 루프 변수와 범위를 정의하는 "for"
   절과 생략 가능한 "if" 절이 뒤에 붙는 일반 표현식 처럼 보입니다. 결
   합한 표현식은 둘러싼 함수를 위한 값들을 만들어냅니다:

      >>> sum(i*i for i in range(10))         # sum of squares 0, 1, 4, ... 81
      285

generic function (제네릭 함수)
   같은 연산을 서로 다른 형들에 대해 구현한 여러 함수로 구성된 함수.
   호출 때 어떤 구현이 사용될지는 디스패치 알고리즘에 의해 결정됩니다.

   *싱글 디스패치* 용어집 항목과 "functools.singledispatch()" 데코레이
   터와 **PEP 443**도 보세요.

generic type (제네릭 형)
   매개 변수화 할 수 있는 *형*; 일반적으로 "list" 나 "dict"와 같은 컨
   테이너 클래스. *형 힌트*와 *어노테이션*에 사용됩니다.

   For more details, see generic alias types, **PEP 483**, **PEP
   484**, **PEP 585**, and the "typing" module.

GIL
   *전역 인터프리터 록* 을 보세요.

global interpreter lock (전역 인터프리터 록)
   한 번에 오직 하나의 스레드가 파이썬 *바이트 코드* 를 실행하도록 보
   장하기 위해 *CPython* 인터프리터가 사용하는 메커니즘. ("dict"와 같
   은 중요한 내장형들을 포함하는) 객체 모델이 묵시적으로 동시 액세스에
   대해 안전하도록 만들어서 CPython 구현을 단순하게 만듭니다. 인터프리
   터 전체를 잠그는 것은 인터프리터를 다중스레드화하기 쉽게 만드는 대
   신, 다중 프로세서 기계가 제공하는 병렬성의 많은 부분을 희생합니다.

   하지만, 어떤 확장 모듈들은, 표준이나 제삼자 모두, 압축이나 해싱 같
   은 계산 집약적인 작업을 수행할 때는 GIL을 반납하도록 설계되었습니다
   . 또한, I/O를 할 때는 항상 GIL을 반납합니다.

   As of Python 3.13, the GIL can be disabled using the "--disable-
   gil" build configuration. After building Python with this option,
   code must be run with "-X gil=0" or after setting the
   "PYTHON_GIL=0" environment variable. This feature enables improved
   performance for multi-threaded applications and makes it easier to
   use multi-core CPUs efficiently. For more details, see **PEP 703**.

   In prior versions of Python's C API, a function might declare that
   it requires the GIL to be held in order to use it. This refers to
   having an *attached thread state*.

global state
   Data that is accessible throughout a program, such as module-level
   variables, class variables, or C static variables in *extension
   modules*.  In multi-threaded programs, global state shared between
   threads typically requires synchronization to avoid *race
   conditions* and *data races*.

hash-based pyc (해시 기반 pyc)
   유효성을 판별하기 위해 해당 소스 파일의 최종 수정 시간이 아닌 해시
   를 사용하는 바이트 코드 캐시 파일. 캐시된 바이트 코드 무효화을 참조
   하세요.

hashable (해시 가능)
   객체가 일생 그 값이 변하지 않는 해시값을 갖고 ("__hash__()" 메서드
   가 필요합니다), 다른 객체와 비교될 수 있으면 ("__eq__()" 메서드가
   필요합니다), *해시 가능*하다고 합니다. 같다고 비교되는 해시 가능한
   객체들의 해시값은 같아야 합니다.

   해시 가능성은 객체를 딕셔너리의 키나 집합의 멤버로 사용할 수 있게
   하는데, 이 자료 구조들이 내부적으로 해시값을 사용하기 때문입니다.

   대부분 파이썬의 불변 내장 객체들은 해시 가능합니다; (리스트나 딕셔
   너리 같은) 가변 컨테이너들은 그렇지 않습니다; (튜플이나 frozenset
   같은) 불변 컨테이너들은 그들의 요소들이 해시 가능할 때만 해시 가능
   합니다. 사용자 정의 클래스의 인스턴스 객체들은 기본적으로 해시 가능
   합니다. (자기 자신을 제외하고는) 모두 다르다고 비교되고, 해시값은
   "id()"로 부터 만들어집니다.

IDLE
   파이썬을 위한 통합 개발 및 학습 환경 (Integrated Development and
   Learning Environment). IDLE --- 파이썬 편집기와 셸은 파이썬의 표준
   배포판에 따라오는 기초적인 편집기와 인터프리터 환경입니다.

immortal (불멸)
   *Immortal objects* are a CPython implementation detail introduced
   in **PEP 683**.

   If an object is immortal, its *reference count* is never modified,
   and therefore it is never deallocated while the interpreter is
   running. For example, "True" and "None" are immortal in CPython.

   Immortal objects can be identified via "sys._is_immortal()", or via
   "PyUnstable_IsImmortal()" in the C API.

immutable (불변)
   An object with a fixed value.  Immutable objects include numbers,
   strings and tuples.  Such an object cannot be altered.  A new
   object has to be created if a different value has to be stored.
   They play an important role in places where a constant hash value
   is needed, for example as a key in a dictionary.  Immutable objects
   are inherently *thread-safe* because their state cannot be modified
   after creation, eliminating concerns about improperly synchronized
   *concurrent modification*.

import path (임포트 경로)
   *경로 기반 파인더* 가 임포트 할 모듈을 찾기 위해 검색하는 장소들 (
   또는 *경로 엔트리*) 의 목록. 임포트 하는 동안, 이 장소들의 목록은
   보통 "sys.path" 로부터 옵니다, 하지만 서브 패키지의 경우 부모 패키
   지의 "__path__" 어트리뷰트로부터 올 수도 있습니다.

importing (임포팅)
   한 모듈의 파이썬 코드가 다른 모듈의 파이썬 코드에서 사용될 수 있도
   록 하는 절차.

importer (임포터)
   모듈을 찾기도 하고 로드 하기도 하는 객체; 동시에 *파인더* 이자 *로
   더* 객체입니다.

interactive (대화형)
   파이썬은 대화형 인터프리터를 갖고 있는데, 인터프리터 프롬프트에서
   문장과 표현식을 입력할 수 있고, 즉각 실행된 결과를 볼 수 있다는 뜻
   입니다. 인자 없이 단지 "python"을 실행하세요 (컴퓨터의 주메뉴에서
   선택하는 것도 가능할 수 있습니다). 새 아이디어를 검사하거나 모듈과
   패키지를 들여다보는 매우 강력한 방법입니다 ("help(x)"를 기억하세요
   ). 대화형 모드에 대한 자세한 내용은 대화형 모드를 보세요.

interpreted (인터프리티드)
   바이트 코드 컴파일러의 존재 때문에 그 구분이 흐릿해지기는 하지만,
   파이썬은 컴파일 언어가 아니라 인터프리터 언어입니다. 이것은 명시적
   으로 실행 파일을 만들지 않고도, 소스 파일을 직접 실행할 수 있다는
   뜻입니다. 그 프로그램이 좀 더 천천히 실행되기는 하지만, 인터프리터
   언어는 보통 컴파일 언어보다 짧은 개발/디버깅 주기를 갖습니다. *대화
   형* 도 보세요.

interpreter shutdown (인터프리터 종료)
   종료하라는 요청을 받을 때, 파이썬 인터프리터는 특별한 시기에 진입하
   는데, 모듈이나 여러 가지 중요한 내부 구조들과 같은 모든 할당된 자원
   들을 단계적으로 반납합니다. 또한, *가비지 수거기* 를 여러 번 호출합
   니다. 사용자 정의 파괴자나 weakref 콜백에 있는 코드들의 실행을 시작
   시킬 수 있습니다. 종료 시기 동안 실행되는 코드는 다양한 예외들을 만
   날 수 있는데, 그것이 의존하는 자원들이 더 기능하지 않을 수 있기 때
   문입니다 (흔한 예는 라이브러리 모듈이나 경고 장치들입니다).

   인터프리터 종료의 주된 원인은 실행되는 "__main__" 모듈이나 스크립트
   가 실행을 끝내는 것입니다.

iterable (이터러블)
   멤버들을 한 번에 하나씩 돌려줄 수 있는 객체. 이터러블의 예로는 모든
   ("list", "str", "tuple" 같은) 시퀀스 형들, "dict" 같은 몇몇 비 시퀀
   스 형들, *파일 객체들*, "__iter__()" 나 *시퀀스* 개념을 구현하는
   "__getitem__()" 메서드를 써서 정의한 모든 클래스의 객체들이 있습니
   다.

   이터러블은 "for" 루프에 사용될 수 있고, 시퀀스를 필요로 하는 다른
   많은 곳 ("zip()", "map()", ...) 에 사용될 수 있습니다. 이터러블 객
   체가 내장 함수 "iter()" 에 인자로 전달되면, 그 객체의 이터레이터를
   돌려줍니다. 이 이터레이터는 값들의 집합을 한 번 거치는 동안 유효합
   니다. 이터러블을 사용할 때, 보통은 "iter()" 를 호출하거나, 이터레이
   터 객체를 직접 다룰 필요는 없습니다. "for" 문은 이것들을 여러분을
   대신해서 자동으로 해주는데, 루프를 도는 동안 이터레이터를 잡아둘 이
   름 없는 변수를 만듭니다. *이터레이터*, *시퀀스*, *제너레이터* 도 보
   세요.

iterator (이터레이터)
   데이터의 스트림을 표현하는 객체. 이터레이터의 "__next__()" 메서드를
   반복적으로 호출하면 (또는 내장 함수 "next()" 로 전달하면) 스트림에
   있는 항목들을 차례대로 돌려줍니다. 더 이상의 데이터가 없을 때는 대
   신 "StopIteration" 예외를 일으킵니다. 이 지점에서, 이터레이터 객체
   는 소진되고, 이후의 모든 "__next__()" 메서드 호출은 "StopIteration"
   예외를 다시 일으키기만 합니다. 이터레이터는 이터레이터 객체 자신을
   돌려주는 "__iter__()" 메서드를 가질 것이 요구되기 때문에, 이터레이
   터는 이터러블이기도 하고 다른 이터러블들을 받아들이는 대부분의 곳에
   서 사용될 수 있습니다. 중요한 예외는 여러 번의 이터레이션을 시도하
   는 코드입니다. ("list" 같은) 컨테이너 객체는 "iter()" 함수로 전달하
   거나 "for" 루프에 사용할 때마다 새 이터레이터를 만듭니다. 이런 것을
   이터레이터에 대해서 수행하려고 하면, 지난 이터레이션에 사용된 이미
   소진된 이터레이터를 돌려줘서, 빈 컨테이너처럼 보이게 만듭니다.

   이터레이터 형 에 더 자세한 내용이 있습니다.

   **CPython 구현 상세:** CPython does not consistently apply the
   requirement that an iterator define "__iter__()". And also please
   note that *free-threaded* CPython does not guarantee *thread-safe*
   behavior of iterator operations.

key function (키 함수)
   키 함수 또는 콜레이션(collation) 함수는 정렬(sorting)이나 배열
   (ordering)에 사용되는 값을 돌려주는 콜러블입니다. 예를 들어,
   "locale.strxfrm()" 은 로케일 특정 방식을 따르는 정렬 키를 만드는 데
   사용됩니다.

   파이썬의 많은 도구가 요소들이 어떻게 순서 지어지고 묶이는지를 제어
   하기 위해 키 함수를 받아들입니다. 이런 것들에는 "min()", "max()",
   "sorted()", "list.sort()", "heapq.merge()", "heapq.nsmallest()",
   "heapq.nlargest()", "itertools.groupby()" 이 있습니다.

   There are several ways to create a key function.  For example. the
   "str.casefold()" method can serve as a key function for case
   insensitive sorts.  Alternatively, a key function can be built from
   a "lambda" expression such as "lambda r: (r[0], r[2])".  Also,
   "operator.attrgetter()", "operator.itemgetter()", and
   "operator.methodcaller()" are three key function constructors.  See
   the Sorting HOW TO for examples of how to create and use key
   functions.

keyword argument (키워드 인자)
   *인자* 를 보세요.

lambda (람다)
   호출될 때 값이 구해지는 하나의 *표현식* 으로 구성된 이름 없는 인라
   인 함수. 람다 함수를 만드는 문법은 "lambda [parameters]:
   expression" 입니다.

LBYL
   뛰기 전에 보라 (Look before you leap). 이 코딩 스타일은 호출이나 조
   회를 하기 전에 명시적으로 사전 조건들을 검사합니다. 이 스타일은
   *EAFP* 접근법과 대비되고, 많은 "if" 문의 존재로 특징지어집니다.

   In a multi-threaded environment, the LBYL approach can risk
   introducing a *race condition* between "the looking" and "the
   leaping".  For example, the code, "if key in mapping: return
   mapping[key]" can fail if another thread removes *key* from
   *mapping* after the test, but before the lookup. This issue can be
   solved with *locks* or by using the *EAFP* approach.  See also
   *thread-safe*.

lexical analyzer (어휘 분석기)
   Formal name for the *tokenizer*; see *token*.

list (리스트)
   내장 파이썬 *시퀀스*. 그 이름에도 불구하고, 원소에 대한 액세스가
   *O*(1)이기 때문에, 연결 리스트(linked list)보다는 다른 언어의 배열
   과 유사합니다.

list comprehension (리스트 컴프리헨션)
   시퀀스의 요소들 전부 또는 일부를 처리하고 그 결과를 리스트로 돌려주
   는 간결한 방법. "result = ['{:#04x}'.format(x) for x in range(256)
   if x % 2 == 0]" 는 0에서 255 사이에 있는 짝수들의 16진수 (0x..) 들
   을 포함하는 문자열의 리스트를 만듭니다. "if" 절은 생략할 수 있습니
   다. 생략하면, "range(256)"에 있는 모든 요소가 처리됩니다.

lock
   A *synchronization primitive* that allows only one thread at a time
   to access a shared resource.  A thread must acquire a lock before
   accessing the protected resource and release it afterward.  If a
   thread attempts to acquire a lock that is already held by another
   thread, it will block until the lock becomes available.  Python's
   "threading" module provides "Lock" (a basic lock) and "RLock" (a
   *reentrant* lock).  Locks are used to prevent *race conditions* and
   ensure *thread-safe* access to shared data.  Alternative design
   patterns to locks exist such as queues, producer/consumer patterns,
   and thread-local state. See also *deadlock*, and *reentrant*.

loader (로더)
   An object that loads a module. It must define the "exec_module()"
   and "create_module()" methods to implement the "Loader" interface.
   A loader is typically returned by a *finder*. See also:

   * 파인더(finder)와 로더(loader)

   * "importlib.abc.Loader"

   * **PEP 302**

locale encoding (로케일 인코딩)
   On Unix, it is the encoding of the LC_CTYPE locale. It can be set
   with "locale.setlocale(locale.LC_CTYPE, new_locale)".

   On Windows, it is the ANSI code page (ex: ""cp1252"").

   On Android and VxWorks, Python uses ""utf-8"" as the locale
   encoding.

   "locale.getencoding()" can be used to get the locale encoding.

   See also the *filesystem encoding and error handler*.

magic method (매직 메서드)
   *특수 메서드* 의 비공식적인 비슷한 말.

mapping (매핑)
   임의의 키 조회를 지원하고 "collections.abc.Mapping" 이나
   "collections.abc.MutableMapping" 추상 베이스 클래스 에 지정된 메서
   드들을 구현하는 컨테이너 객체. 예로는 "dict",
   "collections.defaultdict", "collections.OrderedDict",
   "collections.Counter" 를 들 수 있습니다.

meta path finder (메타 경로 파인더)
   "sys.meta_path" 의 검색이 돌려주는 *파인더*. 메타 경로 파인더는 *경
   로 엔트리 파인더* 와 관련되어 있기는 하지만 다릅니다.

   메타 경로 파인더가 구현하는 메서드들에 대해서는
   "importlib.abc.MetaPathFinder" 를 보면 됩니다.

metaclass (메타 클래스)
   클래스의 클래스. 클래스 정의는 클래스 이름, 클래스 딕셔너리, 베이스
   클래스들의 목록을 만듭니다. 메타 클래스는 이 세 인자를 받아서 클래
   스를 만드는 책임을 집니다. 대부분의 객체 지향형 프로그래밍 언어들은
   기본 구현을 제공합니다. 파이썬을 특별하게 만드는 것은 커스텀 메타
   클래스를 만들 수 있다는 것입니다. 대부분 사용자에게는 이 도구가 전
   혀 필요 없지만, 필요가 생길 때, 메타 클래스는 강력하고 우아한 해법
   을 제공합니다. 어트리뷰트 액세스의 로깅(logging), 스레드 안전성의
   추가, 객체 생성 추적, 싱글톤 구현과 많은 다른 작업에 사용됐습니다.

   메타 클래스 에서 더 자세한 내용을 찾을 수 있습니다.

method (메서드)
   클래스 바디 안에서 정의되는 함수. 그 클래스의 인스턴스의 어트리뷰트
   로서 호출되면, 그 메서드는 첫 번째 *인자* (보통 "self" 라고 불린다)
   로 인스턴스 객체를 받습니다. *함수* 와 *중첩된 스코프* 를 보세요.

method resolution order (메서드 결정 순서)
   메서드 결정 순서는 조회하는 동안 멤버를 검색하는 베이스 클래스들의
   순서입니다. 2.3 릴리스부터 파이썬 인터프리터에 사용된 알고리즘의 상
   세한 내용은 The Python 2.3 Method Resolution Order를 보세요.

module (모듈)
   파이썬 코드의 조직화 단위를 담당하는 객체. 모듈은 임의의 파이썬 객
   체들을 담는 이름 공간을 갖습니다. 모듈은 *임포팅* 절차에 의해 파이
   썬으로 로드됩니다.

   *패키지* 도 보세요.

module spec (모듈 스펙)
   모듈을 로드하는데 사용되는 임포트 관련 정보들을 담고 있는 이름 공간
   . "importlib.machinery.ModuleSpec" 의 인스턴스.

   모듈 스펙 도 보세요.

MRO
   *메서드 결정 순서* 를 보세요.

mutable (가변)
   An *object* with state that is allowed to change during the course
   of the program.  In multi-threaded programs, mutable objects that
   are shared between threads require careful synchronization to avoid
   *race conditions*.  See also *immutable*, *thread-safe*, and
   *concurrent modification*.

named tuple (네임드 튜플)
   "named tuple(네임드 튜플)"이라는 용어는 튜플에서 상속하고 이름 붙은
   어트리뷰트를 사용하여 인덱스 할 수 있는 요소에 액세스 할 수 있는 모
   든 형이나 클래스에 적용됩니다. 형이나 클래스에는 다른 기능도 있을
   수 있습니다.

   "time.localtime()"과 "os.stat()"가 반환한 값을 포함하여, 여러 내장
   형이 네임드 튜플입니다. 또 다른 예는 "sys.float_info"입니다:

      >>> sys.float_info[1]                   # indexed access
      1024
      >>> sys.float_info.max_exp              # named field access
      1024
      >>> isinstance(sys.float_info, tuple)   # kind of tuple
      True

   일부 네임드 튜플은 내장형(위의 예)입니다. 또는, "tuple"에서 상속하
   고 이름 붙은 필드를 정의하는 일반 클래스 정의로 네임드 튜플을 만들
   수 있습니다. 이러한 클래스는 직접 작성하거나, "typing.NamedTuple"를
   계승하거나 팩토리 함수 "collections.namedtuple()"로 만들 수 있습니
   다. 후자의 기법은 직접 작성하거나 내장 네임드 튜플에서는 찾을 수 없
   는 몇 가지 추가 메서드를 추가하기도 합니다.

namespace (이름 공간)
   변수가 저장되는 장소. 이름 공간은 딕셔너리로 구현됩니다. 객체에 중
   첩된 이름 공간 (메서드 에서) 뿐만 아니라 지역, 전역, 내장 이름 공간
   이 있습니다. 이름 공간은 이름 충돌을 방지해서 모듈성을 지원합니다.
   예를 들어, 함수 "builtins.open" 과 "os.open()" 은 그들의 이름 공간
   에 의해 구별됩니다. 또한, 이름 공간은 어떤 모듈이 함수를 구현하는지
   를 분명하게 만들어서 가독성과 유지 보수성에 도움을 줍니다. 예를 들
   어, "random.seed()" 또는 "itertools.islice()" 라고 쓰면 그 함수들이
   각각 "random" 과 "itertools" 모듈에 의해 구현되었음이 명확해집니다.

namespace package (이름 공간 패키지)
   오직 서브 패키지들의 컨테이너로만 기능하는 *패키지*. 이름 공간 패키
   지는 물리적인 실체가 없을 수도 있고, 특히 "__init__.py" 파일이 없으
   므로 *정규 패키지* 와는 다릅니다.

   Namespace packages allow several individually installable packages
   to have a common parent package. Otherwise, it is recommended to
   use a *regular package*.

   For more information, see **PEP 420** and 이름 공간 패키지.

   *모듈* 도 보세요.

native code
   Code that is compiled to machine instructions and runs directly on
   the processor, as opposed to code that is interpreted or runs in a
   virtual machine.  In the context of Python, native code typically
   refers to C, C++, Rust or Fortran code in *extension modules* that
   can be called from Python.  See also *extension module*.

nested scope (중첩된 스코프)
   둘러싼 정의에서 변수를 참조하는 능력. 예를 들어, 다른 함수 내부에서
   정의된 함수는 바깥 함수에 있는 변수들을 참조할 수 있습니다. 중첩된
   스코프는 기본적으로는 참조만 가능할 뿐, 대입은 되지 않는다는 것에
   주의해야 합니다. 지역 변수들은 가장 내부의 스코프에서 읽고 씁니다.
   마찬가지로, 전역 변수들은 전역 이름 공간에서 읽고 씁니다.
   "nonlocal" 은 바깥 스코프에 쓰는 것을 허락합니다.

new-style class (뉴스타일 클래스)
   지금은 모든 클래스 객체에 사용되고 있는 클래스 버전의 예전 이름. 초
   기의 파이썬 버전에서는, 오직 뉴스타일 클래스만 "__slots__", 디스크
   립터, 프라퍼티, "__getattribute__()", 클래스 메서드, 스태틱 메서드
   와 같은 파이썬의 새롭고 다양한 기능들을 사용할 수 있었습니다.

non-deterministic
   Behavior where the outcome of a program can vary between executions
   with the same inputs.  In multi-threaded programs, non-
   deterministic behavior often results from *race conditions* where
   the relative timing or interleaving of threads affects the result.
   Proper synchronization using *locks* and other *synchronization
   primitives* helps ensure deterministic behavior.

object (객체)
   상태 (어트리뷰트나 값) 를 갖고 동작 (메서드) 이 정의된 모든 데이터.
   또한, 모든 *뉴스타일 클래스* 의 최종적인 베이스 클래스입니다.

optimized scope (최적화된 스코프)
   A scope where target local variable names are reliably known to the
   compiler when the code is compiled, allowing optimization of read
   and write access to these names. The local namespaces for
   functions, generators, coroutines, comprehensions, and generator
   expressions are optimized in this fashion. Note: most interpreter
   optimizations are applied to all scopes, only those relying on a
   known set of local and nonlocal variable names are restricted to
   optimized scopes.

optional module
   An *extension module* that is part of the *standard library*, but
   may be absent in some builds of *CPython*, usually due to missing
   third-party libraries or because the module is not available for a
   given platform.

   See Requirements for optional modules for a list of optional
   modules that require third-party libraries.

package (패키지)
   서브 모듈들이나, 재귀적으로 서브 패키지들을 포함할 수 있는 파이썬 *
   모듈*. 기술적으로, 패키지는 "__path__" 어트리뷰트가 있는 파이썬 모
   듈입니다.

   *정규 패키지* 와 *이름 공간 패키지* 도 보세요.

parallelism
   Executing multiple operations at the same time (e.g. on multiple
   CPU cores).  In Python builds with the *global interpreter lock
   (GIL)*, only one thread runs Python bytecode at a time, so taking
   advantage of multiple CPU cores typically involves multiple
   processes (e.g. "multiprocessing") or native extensions that
   release the GIL. In *free-threaded* Python, multiple Python threads
   can run Python code simultaneously on different cores.

parameter (매개변수)
   *함수* (또는 메서드) 정의에서 함수가 받을 수 있는 *인자* (또는 어떤
   경우 인자들) 를 지정하는 이름 붙은 엔티티. 다섯 종류의 매개변수가
   있습니다:

   * *위치-키워드 (positional-or-keyword)*: *위치 인자* 나 *키워드 인
     자* 로 전달될 수 있는 인자를 지정합니다. 이것이 기본 형태의 매개
     변수입니다, 예를 들어 다음에서 *foo* 와 *bar*:

        def func(foo, bar=None): ...

   * *위치-전용 (positional-only)*: 위치로만 제공될 수 있는 인자를 지
     정합니다. 위치 전용 매개변수는 함수 정의의 매개변수 목록에 "/" 문
     자를 포함하고 그 뒤에 정의할 수 있습니다, 예를 들어 다음에서
     *posonly1*과 *posonly2*:

        def func(posonly1, posonly2, /, positional_or_keyword): ...

   * *키워드-전용 (keyword-only)*: 키워드로만 제공될 수 있는 인자를 지
     정합니다. 키워드-전용 매개변수는 함수 정의의 매개변수 목록에서 앞
     에 하나의 가변-위치 매개변수나 "*"를 그대로 포함해서 정의할 수 있
     습니다. 예를 들어, 다음에서 *kw_only1* 와 *kw_only2*:

        def func(arg, *, kw_only1, kw_only2): ...

   * *가변-위치 (var-positional)*: (다른 매개변수들에 의해서 이미 받아
     들여진 위치 인자들에 더해) 제공될 수 있는 위치 인자들의 임의의 시
     퀀스를 지정합니다. 이런 매개변수는 매개변수 이름에 "*" 를 앞에 붙
     여서 정의될 수 있습니다, 예를 들어 다음에서 *args*:

        def func(*args, **kwargs): ...

   * *가변-키워드 (var-keyword)*: (다른 매개변수들에 의해서 이미 받아
     들여진 키워드 인자들에 더해) 제공될 수 있는 임의의 개수 키워드 인
     자들을 지정합니다. 이런 매개변수는 매개변수 이름에 "**"를 앞에 붙
     여서 정의될 수 있습니다, 예를 들어 위의 예에서 *kwargs*.

   매개변수는 선택적 인자들을 위한 기본값뿐만 아니라 선택적이거나 필수
   인자들을 지정할 수 있습니다.

   *인자* 용어집 항목, 인자와 매개변수의 차이에 나오는 FAQ 질문,
   "inspect.Parameter" 클래스, 함수 정의 절, **PEP 362**도 보세요.

path entry (경로 엔트리)
   *경로 기반 파인더* 가 임포트 할 모듈들을 찾기 위해 참고하는 *임포트
   경로* 상의 하나의 장소.

path entry finder (경로 엔트리 파인더)
   "sys.path_hooks" 에 있는 콜러블 (즉, *경로 엔트리 훅*) 이 돌려주는
   *파인더* 인데, 주어진 *경로 엔트리* 로 모듈을 찾는 방법을 알고 있습
   니다.

   경로 엔트리 파인더들이 구현하는 메서드들은
   "importlib.abc.PathEntryFinder" 에 나옵니다.

path entry hook (경로 엔트리 훅)
   "sys.path_hooks" 리스트에 있는 콜러블인데, 특정 *경로 엔트리* 에서
   모듈을 찾는 법을 알고 있다면 *경로 엔트리 파인더* 를 돌려줍니다.

path based finder (경로 기반 파인더)
   기본 *메타 경로 파인더들* 중 하나인데, *임포트 경로* 에서 모듈을 찾
   습니다.

path-like object (경로류 객체)
   파일 시스템 경로를 나타내는 객체. 경로류 객체는 경로를 나타내는
   "str" 나 "bytes" 객체이거나 "os.PathLike" 프로토콜을 구현하는 객체
   입니다. "os.PathLike" 프로토콜을 지원하는 객체는 "os.fspath()" 함수
   를 호출해서 "str" 나 "bytes" 파일 시스템 경로로 변환될 수 있습니다;
   대신 "os.fsdecode()" 와 "os.fsencode()" 는 각각 "str" 나 "bytes" 결
   과를 보장하는데 사용될 수 있습니다. **PEP 519**로 도입되었습니다.

PEP
   파이썬 개선 제안. PEP는 파이썬 커뮤니티에 정보를 제공하거나 파이썬
   또는 그 프로세스 또는 환경에 대한 새로운 기능을 설명하는 설계 문서
   입니다. PEP는 제안된 기능에 대한 간결한 기술 사양 및 근거를 제공해
   야 합니다.

   PEP는 주요 새로운 기능을 제안하고 문제에 대한 커뮤니티 입력을 수집
   하며 파이썬에 들어간 설계 결정을 문서로 만들기 위한 기본 메커니즘입
   니다. PEP 작성자는 커뮤니티 내에서 합의를 구축하고 반대 의견을 문서
   화 할 책임이 있습니다.

   **PEP 1** 참조하세요.

portion (포션)
   **PEP 420** 에서 정의한 것처럼, 이름 공간 패키지에 이바지하는 하나
   의 디렉터리에 들어있는 파일들의 집합 (zip 파일에 저장되는 것도 가능
   합니다).

positional argument (위치 인자)
   *인자* 를 보세요.

provisional API (잠정 API)
   잠정 API는 표준 라이브러리의 과거 호환성 보장으로부터 신중히 제외된
   것입니다. 인터페이스의 큰 변화가 예상되지는 않지만, 잠정적이라고 표
   시되는 한, 코어 개발자들이 필요하다고 생각한다면 과거 호환성이 유지
   되지 않는 변경이 일어날 수 있습니다. 그런 변경은 불필요한 방식으로
   일어나지는 않을 것입니다 --- API를 포함하기 전에 놓친 중대하고 근본
   적인 결함이 발견된 경우에만 일어날 것입니다.

   잠정 API에서조차도, 과거 호환성이 유지되지 않는 변경은 "최후의 수단
   "으로 여겨집니다 - 모든 식별된 문제들에 대해 과거 호환성을 유지하는
   해법을 찾으려는 모든 시도가 선행됩니다.

   이 절차는 표준 라이브러리가 오랜 시간 동안 잘못된 설계 오류에 발목
   잡히지 않고 발전할 수 있도록 만듭니다. 더 자세한 내용은 **PEP 411**
   을 보면 됩니다.

provisional package (잠정 패키지)
   *잠정 API* 를 보세요.

Python 3000 (파이썬 3000)
   파이썬 3.x 배포 라인의 별명 (버전 3의 배포가 먼 미래의 이야기던 시
   절에 만들어진 이름이다.) 이것을 "Py3k" 로 줄여 쓰기도 합니다.

Pythonic (파이썬다운)
   다른 언어들에서 일반적인 개념들을 사용해서 코드를 구현하는 대신, 파
   이썬 언어에서 가장 자주 사용되는 이디엄들을 가까이 따르는 아이디어
   나 코드 조각. 예를 들어, 파이썬에서 자주 쓰는 이디엄은 "for" 문을
   사용해서 이터러블의 모든 요소로 루핑하는 것입니다. 다른 많은 언어에
   는 이런 종류의 구성물이 없으므로, 파이썬에 익숙하지 않은 사람들은
   대신에 숫자 카운터를 사용하기도 합니다:

      for i in range(len(food)):
          print(food[i])

   더 깔끔한, 파이썬다운 방법은 이렇습니다:

      for piece in food:
          print(piece)

qualified name (정규화된 이름)
   모듈의 전역 스코프에서 모듈에 정의된 클래스, 함수, 메서드에 이르는
   "경로"를 보여주는 점으로 구분된 이름. **PEP 3155** 에서 정의됩니다.
   최상위 함수와 클래스의 경우에, 정규화된 이름은 객체의 이름과 같습니
   다:

      >>> class C:
      ...     class D:
      ...         def meth(self):
      ...             pass
      ...
      >>> C.__qualname__
      'C'
      >>> C.D.__qualname__
      'C.D'
      >>> C.D.meth.__qualname__
      'C.D.meth'

   모듈을 가리키는데 사용될 때, *완전히 정규화된 이름(fully qualified
   name)*은 모든 부모 패키지들을 포함해서 모듈로 가는 점으로 분리된 이
   름을 의미합니다, 예를 들어, "email.mime.text":

      >>> import email.mime.text
      >>> email.mime.text.__name__
      'email.mime.text'

race condition
   A condition of a program where the its behavior depends on the
   relative timing or ordering of events, particularly in multi-
   threaded programs.  Race conditions can lead to *non-deterministic*
   behavior and bugs that are difficult to reproduce.  A *data race*
   is a specific type of race condition involving unsynchronized
   access to shared memory.  The *LBYL* coding style is particularly
   susceptible to race conditions in multi-threaded code.  Using
   *locks* and other *synchronization primitives* helps prevent race
   conditions.

reference count (참조 횟수)
   객체에 대한 참조의 개수. 객체의 참조 횟수가 0으로 떨어지면, 메모리
   가 반납됩니다. 일부 객체는 *불멸*이며 참조 횟수가 수정되지 않아서,
   객체가 할당 해제되지 않습니다. 참조 횟수 추적은 일반적으로 파이썬
   코드에 노출되지는 않지만, *CPython* 구현의 핵심 요소입니다. 프로그
   래머는 특정 객체의 참조 횟수를 돌려주는 "sys.getrefcount()" 함수를
   호출할 수 있습니다.

   In *CPython*, reference counts are not considered to be stable or
   well-defined values; the number of references to an object, and how
   that number is affected by Python code, may be different between
   versions.

regular package (정규 패키지)
   "__init__.py" 파일을 포함하는 디렉터리와 같은 전통적인 *패키지*.

   *이름 공간 패키지* 도 보세요.

reentrant
   A property of a function or *lock* that allows it to be called or
   acquired multiple times by the same thread without causing errors
   or a *deadlock*.

   For functions, reentrancy means the function can be safely called
   again before a previous invocation has completed, which is
   important when functions may be called recursively or from signal
   handlers. Thread-unsafe functions may be *non-deterministic* if
   they're called reentrantly in a multithreaded program.

   For locks, Python's "threading.RLock" (reentrant lock) is
   reentrant, meaning a thread that already holds the lock can acquire
   it again without blocking.  In contrast, "threading.Lock" is not
   reentrant - attempting to acquire it twice from the same thread
   will cause a deadlock.

   See also *lock* and *deadlock*.

REPL
   An acronym for the "read–eval–print loop", another name for the
   *interactive* interpreter shell.

__slots__
   클래스 내부의 선언인데, 인스턴스 어트리뷰트들을 위한 공간을 미리 선
   언하고 인스턴스 딕셔너리를 제거함으로써 메모리를 절감하는 효과를 줍
   니다. 인기 있기는 하지만, 이 테크닉은 올바르게 사용하기가 좀 까다로
   운 편이라서, 메모리에 민감한 응용 프로그램에서 많은 수의 인스턴스가
   있는 특별한 경우로 한정하는 것이 좋습니다.

sequence (시퀀스)
   "__getitem__()" 특수 메서드를 통해 정수 인덱스를 사용한 빠른 요소
   액세스를 지원하고, 시퀀스의 길이를 돌려주는 "__len__()" 메서드를 정
   의하는 *이터러블*. 몇몇 내장 시퀀스들을 나열해보면, "list", "str",
   "tuple", "bytes" 가 있습니다. "dict" 또한 "__getitem__()" 과
   "__len__()" 을 지원하지만, 조회에 정수 대신 임의의 *해시 가능* 키를
   사용하기 때문에 시퀀스가 아니라 매핑으로 취급된다는 것에 주의해야
   합니다.

   The "collections.abc.Sequence" abstract base class defines a much
   richer interface that goes beyond just "__getitem__()" and
   "__len__()", adding "count()", "index()", "__contains__()", and
   "__reversed__()". Types that implement this expanded interface can
   be registered explicitly using "register()". For more documentation
   on sequence methods generally, see Common Sequence Operations.

set comprehension (집합 컴프리헨션)
   이터러블에 있는 요소 전체나 일부를 처리하고 결과를 담은 집합을 반환
   하는 간결한 방법. "results = {c for c in 'abracadabra' if c not in
   'abc'}"는 문자열의 집합 "{'r', 'd'}"를 생성합니다. 리스트, 집합, 딕
   셔너리의 디스플레이(display)을 참조하십시오.

single dispatch (싱글 디스패치)
   구현이 하나의 인자의 형에 기초해서 결정되는 *제네릭 함수* 디스패치
   의 한 형태.

slice (슬라이스)
   보통 *시퀀스* 의 일부를 포함하는 객체. 슬라이스는 서브 스크립트 표
   기법을 사용해서 만듭니다. "variable_name[1:3:5]" 처럼, "[]" 안에서
   여러 개의 숫자를 콜론으로 분리합니다. 대괄호 (서브 스크립트) 표기법
   은 내부적으로 "slice" 객체를 사용합니다.

soft deprecated (약하게 폐지된)
   A soft deprecated API should not be used in new code, but it is
   safe for already existing code to use it. The API remains
   documented and tested, but will not be enhanced further.

   Soft deprecation, unlike normal deprecation, does not plan on
   removing the API and will not emit warnings.

   See PEP 387: Soft Deprecation.

special method (특수 메서드)
   파이썬이 형에 어떤 연산을, 덧셈 같은, 실행할 때 묵시적으로 호출되는
   메서드. 이런 메서드는 두 개의 밑줄로 시작하고 끝나는 이름을 갖고 있
   습니다. 특수 메서드는 특수 메서드 이름들 에 문서로 만들어져 있습니
   다.

standard library
   The collection of *packages*, *modules* and *extension modules*
   distributed as a part of the official Python interpreter package.
   The exact membership of the collection may vary based on platform,
   available system libraries, or other criteria.  Documentation can
   be found at 파이썬 표준 라이브러리.

   See also "sys.stdlib_module_names" for a list of all possible
   standard library module names.

statement (문장)
   문장은 스위트 (코드의 "블록(block)") 를 구성하는 부분입니다. 문장은
   *표현식* 이거나 키워드를 사용하는 여러 가지 구조물 중의 하나입니다.
   가령 "if", "while", "for".

static type checker (정적 형 검사기)
   An external tool that reads Python code and analyzes it, looking
   for issues such as incorrect types. See also *type hints* and the
   "typing" module.

stdlib
   An abbreviation of *standard library*.

strong reference (강한 참조)
   In Python's C API, a strong reference is a reference to an object
   which is owned by the code holding the reference.  The strong
   reference is taken by calling "Py_INCREF()" when the reference is
   created and released with "Py_DECREF()" when the reference is
   deleted.

   The "Py_NewRef()" function can be used to create a strong reference
   to an object. Usually, the "Py_DECREF()" function must be called on
   the strong reference before exiting the scope of the strong
   reference, to avoid leaking one reference.

   *빌린 참조* 도 보세요.

synchronization primitive
   A basic building block for coordinating (synchronizing) the
   execution of multiple threads to ensure *thread-safe* access to
   shared resources. Python's "threading" module provides several
   synchronization primitives including "Lock", "RLock", "Semaphore",
   "Condition", "Event", and "Barrier".  Additionally, the "queue"
   module provides multi-producer, multi-consumer queues that are
   especially useful in multithreaded programs. These primitives help
   prevent *race conditions* and coordinate thread execution.  See
   also *lock*.

t-string
t-strings
   String literals prefixed with "t" or "T" are commonly called
   "t-strings" which is short for template string literals.

text encoding (텍스트 인코딩)
   A string in Python is a sequence of Unicode code points (in range
   "U+0000"--"U+10FFFF"). To store or transfer a string, it needs to
   be serialized as a sequence of bytes.

   Serializing a string into a sequence of bytes is known as
   "encoding", and recreating the string from the sequence of bytes is
   known as "decoding".

   There are a variety of different text serialization codecs, which
   are collectively referred to as "text encodings".

text file (텍스트 파일)
   "str" 객체를 읽고 쓸 수 있는 *파일 객체*. 종종, 텍스트 파일은 실제
   로는 바이트 지향 데이터스트림을 액세스하고 *텍스트 인코딩* 을 자동
   처리합니다. 텍스트 파일의 예로는 텍스트 모드 ("'r'" 또는 "'w'") 로
   열린 파일, "sys.stdin", "sys.stdout", "io.StringIO" 의 인스턴스를
   들 수 있습니다.

   *바이트열류 객체* 를 읽고 쓸 수 있는 파일 객체에 대해서는 *바이너리
   파일* 도 참조하세요.

thread state
   The information used by the *CPython* runtime to run in an OS
   thread. For example, this includes the current exception, if any,
   and the state of the bytecode interpreter.

   Each thread state is bound to a single OS thread, but threads may
   have many thread states available.  At most, one of them may be
   *attached* at once.

   An *attached thread state* is required to call most of Python's C
   API, unless a function explicitly documents otherwise. The bytecode
   interpreter only runs under an attached thread state.

   Each thread state belongs to a single interpreter, but each
   interpreter may have many thread states, including multiple for the
   same OS thread. Thread states from multiple interpreters may be
   bound to the same thread, but only one can be *attached* in that
   thread at any given moment.

   See Thread State and the Global Interpreter Lock for more
   information.

thread-safe
   A module, function, or class that behaves correctly when used by
   multiple threads concurrently.  Thread-safe code uses appropriate
   *synchronization primitives* like *locks* to protect shared mutable
   state, or is designed to avoid shared mutable state entirely.  In
   the *free-threaded* build, built-in types like "dict", "list", and
   "set" use internal locking to make many operations thread-safe,
   although thread safety is not necessarily guaranteed.  Code that is
   not thread-safe may experience *race conditions* and *data races*
   when used in multi-threaded programs.

token (토큰)
   A small unit of source code, generated by the lexical analyzer
   (also called the *tokenizer*). Names, numbers, strings, operators,
   newlines and similar are represented by tokens.

   The "tokenize" module exposes Python's lexical analyzer. The
   "token" module contains information on the various types of tokens.

triple-quoted string (삼중 따옴표 된 문자열)
   따옴표 (") 나 작은따옴표 (') 세 개로 둘러싸인 문자열. 그냥 따옴표
   하나로 둘러싸인 문자열에 없는 기능을 제공하지는 않지만, 여러 가지
   이유에서 쓸모가 있습니다. 이스케이프 되지 않은 작은따옴표나 큰따옴
   표를 문자열 안에 포함할 수 있도록 하고, 연결 문자를 쓰지 않고도 여
   러 줄에 걸칠 수 있는데, 독스트링을 쓸 때 특히 쓸모 있습니다.

type (형)
   파이썬 객체의 형은 그것이 어떤 종류의 객체인지를 결정합니다; 모든
   객체는 형이 있습니다. 객체의 형은 "__class__" 어트리뷰트로 액세스할
   수 있거나 "type(obj)"로 얻을 수 있습니다.

type alias (형 에일리어스)
   형을 식별자에 대입하여 만들어지는 형의 동의어.

   형 에일리어스는 *형 힌트*를 단순화하는 데 유용합니다. 예를 들면:

      def remove_gray_shades(
              colors: list[tuple[int, int, int]]) -> list[tuple[int, int, int]]:
          pass

   는 다음과 같이 더 읽기 쉽게 만들 수 있습니다:

      Color = tuple[int, int, int]

      def remove_gray_shades(colors: list[Color]) -> list[Color]:
          pass

   이 기능을 설명하는 "typing"과 **PEP 484**를 참조하세요.

type hint (형 힌트)
   변수, 클래스 어트리뷰트 및 함수 매개변수 나 반환 값의 기대되는 형을
   지정하는 *어노테이션*.

   형 힌트는 선택 사항이고 파이썬에서 강제되지는 않지만, *정적 형 검사
   기*에 유용합니다. 또한 IDE의 코드 완성 및 리팩토링을 돕습니다.

   지역 변수를 제외하고, 전역 변수, 클래스 어트리뷰트 및 함수의 형 힌
   트는 "typing.get_type_hints()"를 사용하여 액세스할 수 있습니다.

   이 기능을 설명하는 "typing"과 **PEP 484**를 참조하세요.

universal newlines (유니버설 줄 넘김)
   다음과 같은 것들을 모두 줄의 끝으로 인식하는, 텍스트 스트림을 해석
   하는 태도: 유닉스 개행 문자 관례 "'\n'", 윈도우즈 관례 "'\r\n'", 예
   전의 매킨토시 관례 "'\r'". 추가적인 사용에 관해서는
   "bytes.splitlines()" 뿐만 아니라 **PEP 278** 와 **PEP 3116** 도 보
   세요.

variable annotation (변수 어노테이션)
   변수 또는 클래스 어트리뷰트의 *어노테이션*.

   변수 또는 클래스 어트리뷰트에 어노테이션을 달 때 대입은 선택 사항입
   니다:

      class C:
          field: 'annotation'

   변수 어노테이션은 일반적으로 *형 힌트*로 사용됩니다: 예를 들어, 이
   변수는 "int" 값을 가질 것으로 기대됩니다:

      count: int = 0

   변수 어노테이션 문법은 섹션 어노테이트된 대입문(Annotated
   assignment statements) 에서 설명합니다.

   이 기능을 설명하는 *함수 어노테이션*, **PEP 484** 및 **PEP 526**을
   참조하세요. 또한 어노테이션 작업에 대한 모범 사례는 Annotations
   Best Practices를 참조하세요.

virtual environment (가상 환경)
   파이썬 사용자와 응용 프로그램이, 같은 시스템에서 실행되는 다른 파이
   썬 응용 프로그램들의 동작에 영향을 주지 않으면서, 파이썬 배포 패키
   지들을 설치하거나 업그레이드하는 것을 가능하게 하는, 협력적으로 격
   리된 실행 환경.

   "venv" 도 보세요.

virtual machine (가상 기계)
   소프트웨어만으로 정의된 컴퓨터. 파이썬의 가상 기계는 바이트 코드 컴
   파일러가 출력하는 *바이트 코드*를 실행합니다.

walrus operator
   A light-hearted way to refer to the assignment expression operator
   ":=" because it looks a bit like a walrus if you turn your head.

Zen of Python (파이썬 젠)
   파이썬 디자인 원리와 철학들의 목록인데, 언어를 이해하고 사용하는 데
   도움이 됩니다. 이 목록은 대화형 프롬프트에서 ""import this"" 를 입
   력하면 보입니다.
