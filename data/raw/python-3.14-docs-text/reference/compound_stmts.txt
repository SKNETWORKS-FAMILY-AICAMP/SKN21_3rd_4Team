8. 복합문(Compound statements)
******************************

복합문은 다른 문장들(의 그룹들)을 포함합니다; 어떤 방법으로 그 다른 문
장들의 실행에 영향을 주거나 제어합니다. 간단하게 표현할 때, 전체 복합
문을 한 줄로 쓸 수 있기는 하지만, 일반적으로 복합문은 여러 줄에 걸칩니
다.

"if", "while", "for" 문장은 전통적인 제어 흐름 구조를 구현합니다. 문장
들의 그룹에 대해 "try" 는 예외 처리기나 정리(cleanup) 코드 또는 그 둘
모두를 지정하는 반면, "with" 문은 코드 블록 주변으로 초기화와 파이널리
제이션 코드를 실행할 수 있도록 합니다. 함수와 클래스 정의 또한 문법적
으로 복합문입니다.

복합문은 하나나 그 이상의 '절'로 구성됩니다. 절은 헤더와 '스위트
(suite)'로 구성됩니다. 특정 복합문의 절 헤더들은 모두 같은 들여쓰기 수
준을 갖습니다. 각 절 헤더는 특별하게 식별되는 키워드로 시작하고 콜론으
로 끝납니다. 스위트는 절에 의해 제어되는 문장들의 그룹입니다. 스위트는
헤더의 콜론 뒤에서 같은 줄에 세미콜론으로 분리된 하나나 그 이상의 단순
문일 수 있습니다. 또는 그다음 줄에 들여쓰기 된 하나나 그 이상의 문장들
일 수도 있습니다. 오직 후자의 형태만 중첩된 복합문을 포함할 수 있습니
다; 다음과 같은 것은 올바르지 않은데, 대체로 뒤따르는 "else" 절이 있다
면 어떤 "if" 절에 속하는지 명확하지 않기 때문입니다.

   if test1: if test2: print(x)

또한, 이 문맥에서 세미콜론이 콜론보다 더 강하게 결합해서, 다음과 같은
예에서, "print()" 호출들은 모두 실행되거나 어느 하나도 실행되지 않습니
다는 것에 주의해야 합니다:

   if x < y < z: print(x); print(y); print(z)

요약하면:

   compound_stmt: if_stmt
                  | while_stmt
                  | for_stmt
                  | try_stmt
                  | with_stmt
                  | match_stmt
                  | funcdef
                  | classdef
                  | async_with_stmt
                  | async_for_stmt
                  | async_funcdef
   suite:         stmt_list NEWLINE | NEWLINE INDENT statement+ DEDENT
   statement:     stmt_list NEWLINE | compound_stmt
   stmt_list:     simple_stmt (";" simple_stmt)* [";"]

문장들이 항상 "NEWLINE" 으로 끝나고 "DEDENT" 가 그 뒤를 따를 수 있음에
주목해야 합니다. 또한, 생략 가능한 연결 절들이 항상 문장을 시작시킬 수
없는 키워드로 시작하기 때문에, 모호함이 없다는 것도 주목하세요 (파이썬
에서는 중첩된 "if" 문이 들여쓰기 되는 것을 요구함으로써 '매달린
(dangling) "else"' 문제를 해결합니다).

명확함을 위해 다음에 오는 절들에서 나오는 문법 규칙들은 각 절을 별도의
줄에 놓도록 포매팅합니다.


8.1. "if" 문
============

"if" 문은 조건부 실행에 사용됩니다:

   if_stmt: "if" assignment_expression ":" suite
            ("elif" assignment_expression ":" suite)*
            ["else" ":" suite]

참이 되는 것을 발견할 때까지 표현식들의 값을 하나씩 차례대로 구해서 정
확히 하나의 스위트를 선택합니다 (참과 거짓의 정의는 논리 연산(Boolean
operations) 섹션을 보세요); 그런 다음 그 스위트를 실행합니다 (그리고는
"if" 문의 다른 어떤 부분도 실행되거나 값이 구해지지 않습니다). 모든 표
현식들이 거짓이면 "else" 절의 스위트가 (있다면) 실행됩니다.


8.2. "while" 문
===============

"while" 문은 표현식이 참인 동안 실행을 반복하는 데 사용됩니다:

   while_stmt: "while" assignment_expression ":" suite
               ["else" ":" suite]

이것은 표현식을 반복적으로 검사하고, 참이면, 첫 번째 스위트를 실행합니
다; 표현식이 거짓이면 (처음부터 거짓일 수도 있습니다) "else" 절의 스위
트가 (있다면) 실행되고 루프를 종료합니다.

첫 번째 스위트에서 실행되는 "break" 문은 "else" 절을 실행하지 않고 루
프를 종료합니다. 첫 번째 스위트에서 실행되는 "continue" 문은 스위트의
나머지 부분을 건너뛰고 표현식의 검사로 돌아갑니다.


8.3. "for" 문
=============

"for" 문은 (문자열, 튜플, 리스트 같은) 시퀀스 나 다른 이터러블 객체의
요소들을 이터레이트하는데 사용됩니다:

   for_stmt: "for" target_list "in" starred_expression_list ":" suite
             ["else" ":" suite]

The "starred_expression_list" expression is evaluated once; it should
yield an *iterable* object. An *iterator* is created for that
iterable. The first item provided by the iterator is then assigned to
the target list using the standard rules for assignments (see 대입문),
and the suite is executed. This repeats for each item provided by the
iterator. When the iterator is exhausted, the suite in the "else"
clause, if present, is executed, and the loop terminates.

첫 번째 스위트에서 실행되는 "break" 문은 "else" 절을 실행하지 않고 루
프를 종료합니다. 첫 번째 스위트에서 실행되는 "continue" 문은 스위트의
나머지 부분을 건너뛰고 다음 항목으로 넘어가거나, 다음 항목이 없으면
"else" 절로 갑니다.

for-루프는 타깃 목록의 변수들에 대입합니다. for-루프의 스위트에서 이루
어진 것들도 포함해서, 그 변수에 앞서 대입된 값들을 모두 덮어씁니다:

   for i in range(10):
       print(i)
       i = 5             # this will not affect the for-loop
                         # because i will be overwritten with the next
                         # index in the range

Names in the target list are not deleted when the loop is finished,
but if the sequence is empty, they will not have been assigned to at
all by the loop.  Hint: the built-in type "range()" represents
immutable arithmetic sequences of integers. For instance, iterating
"range(3)" successively yields 0, 1, and then 2.

버전 3.11에서 변경: Starred elements are now allowed in the expression
list.


8.4. "try" 문
=============

The "try" statement specifies exception handlers and/or cleanup code
for a group of statements:

   try_stmt:  try1_stmt | try2_stmt | try3_stmt
   try1_stmt: "try" ":" suite
              ("except" [expression ["as" identifier]] ":" suite)+
              ["else" ":" suite]
              ["finally" ":" suite]
   try2_stmt: "try" ":" suite
              ("except" "*" expression ["as" identifier] ":" suite)+
              ["else" ":" suite]
              ["finally" ":" suite]
   try3_stmt: "try" ":" suite
              "finally" ":" suite

예외에 관한 추가의 정보는 예외 섹션에서 찾을 수 있고, 예외를 일으키기
위해 "raise" 문을 사용하는 것에 관한 정보는 raise 문 섹션에서 찾을 수
있습니다.

버전 3.14에서 변경: Support for optionally dropping grouping
parentheses when using multiple exception types. See **PEP 758**.


8.4.1. "except" clause
----------------------

The "except" clause(s) specify one or more exception handlers. When no
exception occurs in the "try" clause, no exception handler is
executed. When an exception occurs in the "try" suite, a search for an
exception handler is started. This search inspects the "except"
clauses in turn until one is found that matches the exception. An
expression-less "except" clause, if present, must be last; it matches
any exception.

For an "except" clause with an expression, the expression must
evaluate to an exception type or a tuple of exception types.
Parentheses can be dropped if multiple exception types are provided
and the "as" clause is not used. The raised exception matches an
"except" clause whose expression evaluates to the class or a *non-
virtual base class* of the exception object, or to a tuple that
contains such a class.

If no "except" clause matches the exception, the search for an
exception handler continues in the surrounding code and on the
invocation stack.  [1]

If the evaluation of an expression in the header of an "except" clause
raises an exception, the original search for a handler is canceled and
a search starts for the new exception in the surrounding code and on
the call stack (it is treated as if the entire "try" statement raised
the exception).

When a matching "except" clause is found, the exception is assigned to
the target specified after the "as" keyword in that "except" clause,
if present, and the "except" clause's suite is executed. All "except"
clauses must have an executable block. When the end of this block is
reached, execution continues normally after the entire "try"
statement. (This means that if two nested handlers exist for the same
exception, and the exception occurs in the "try" clause of the inner
handler, the outer handler will not handle the exception.)

When an exception has been assigned using "as target", it is cleared
at the end of the "except" clause.  This is as if

   except E as N:
       foo

가 이렇게 변환되는 것과 같습니다

   except E as N:
       try:
           foo
       finally:
           del N

This means the exception must be assigned to a different name to be
able to refer to it after the "except" clause. Exceptions are cleared
because with the traceback attached to them, they form a reference
cycle with the stack frame, keeping all locals in that frame alive
until the next garbage collection occurs.

Before an "except" clause's suite is executed, the exception is stored
in the "sys" module, where it can be accessed from within the body of
the "except" clause by calling "sys.exception()". When leaving an
exception handler, the exception stored in the "sys" module is reset
to its previous value:

   >>> print(sys.exception())
   None
   >>> try:
   ...     raise TypeError
   ... except:
   ...     print(repr(sys.exception()))
   ...     try:
   ...          raise ValueError
   ...     except:
   ...         print(repr(sys.exception()))
   ...     print(repr(sys.exception()))
   ...
   TypeError()
   ValueError()
   TypeError()
   >>> print(sys.exception())
   None


8.4.2. "except*" clause
-----------------------

The "except*" clause(s) specify one or more handlers for groups of
exceptions ("BaseExceptionGroup" instances). A "try" statement can
have either "except" or "except*" clauses, but not both. The exception
type for matching is mandatory in the case of "except*", so "except*:"
is a syntax error. The type is interpreted as in the case of "except",
but matching is performed on the exceptions contained in the group
that is being handled. An "TypeError" is raised if a matching type is
a subclass of "BaseExceptionGroup", because that would have ambiguous
semantics.

When an exception group is raised in the try block, each "except*"
clause splits (see "split()") it into the subgroups of matching and
non-matching exceptions. If the matching subgroup is not empty, it
becomes the handled exception (the value returned from
"sys.exception()") and assigned to the target of the "except*" clause
(if there is one). Then, the body of the "except*" clause executes. If
the non-matching subgroup is not empty, it is processed by the next
"except*" in the same manner. This continues until all exceptions in
the group have been matched, or the last "except*" clause has run.

After all "except*" clauses execute, the group of unhandled exceptions
is merged with any exceptions that were raised or re-raised from
within "except*" clauses. This merged exception group propagates on.:

   >>> try:
   ...     raise ExceptionGroup("eg",
   ...         [ValueError(1), TypeError(2), OSError(3), OSError(4)])
   ... except* TypeError as e:
   ...     print(f'caught {type(e)} with nested {e.exceptions}')
   ... except* OSError as e:
   ...     print(f'caught {type(e)} with nested {e.exceptions}')
   ...
   caught <class 'ExceptionGroup'> with nested (TypeError(2),)
   caught <class 'ExceptionGroup'> with nested (OSError(3), OSError(4))
     + Exception Group Traceback (most recent call last):
     |   File "<doctest default[0]>", line 2, in <module>
     |     raise ExceptionGroup("eg",
     |         [ValueError(1), TypeError(2), OSError(3), OSError(4)])
     | ExceptionGroup: eg (1 sub-exception)
     +-+---------------- 1 ----------------
       | ValueError: 1
       +------------------------------------

If the exception raised from the "try" block is not an exception group
and its type matches one of the "except*" clauses, it is caught and
wrapped by an exception group with an empty message string. This
ensures that the type of the target "e" is consistently
"BaseExceptionGroup":

   >>> try:
   ...     raise BlockingIOError
   ... except* BlockingIOError as e:
   ...     print(repr(e))
   ...
   ExceptionGroup('', (BlockingIOError(),))

"break", "continue" and "return" cannot appear in an "except*" clause.


8.4.3. "else" clause
--------------------

생략 가능한 "else" 절은 제어 흐름이 "try" 스위트를 빠져나가고, 예외가
발생하지 않았고, "return", "continue" 또는 "break" 문이 실행되지 않으
면 실행됩니다. "else" 절에서 발생하는 예외는 앞에 나오는 "except" 절에
서 처리되지 않습니다.


8.4.4. "finally" clause
-----------------------

If "finally" is present, it specifies a 'cleanup' handler.  The "try"
clause is executed, including any "except" and "else" clauses. If an
exception occurs in any of the clauses and is not handled, the
exception is temporarily saved. The "finally" clause is executed.  If
there is a saved exception it is re-raised at the end of the "finally"
clause. If the "finally" clause raises another exception, the saved
exception is set as the context of the new exception. If the "finally"
clause executes a "return", "break" or "continue" statement, the saved
exception is discarded. For example, this function returns 42.

   def f():
       try:
           1/0
       finally:
           return 42

The exception information is not available to the program during
execution of the "finally" clause.

When a "return", "break" or "continue" statement is executed in the
"try" suite of a "try"..."finally" statement, the "finally" clause is
also executed 'on the way out.'

The return value of a function is determined by the last "return"
statement executed.  Since the "finally" clause always executes, a
"return" statement executed in the "finally" clause will always be the
last one executed. The following function returns 'finally'.

   def foo():
       try:
           return 'try'
       finally:
           return 'finally'

버전 3.8에서 변경: Prior to Python 3.8, a "continue" statement was
illegal in the "finally" clause due to a problem with the
implementation.

버전 3.14에서 변경: The compiler emits a "SyntaxWarning" when a
"return", "break" or "continue" appears in a "finally" block (see
**PEP 765**).


8.5. "with" 문
==============

"with" 문은 블록의 실행을 컨텍스트 관리자 (with 문 컨텍스트 관리자 섹
션을 보세요) 가 정의한 메서드들로 감싸는 데 사용됩니다. 이것은 흔한
"try"..."except"..."finally" 사용 패턴을 편리하게 재사용할 수 있도록
캡슐화할 수 있도록 합니다.

   with_stmt:          "with" ( "(" with_stmt_contents ","? ")" | with_stmt_contents ) ":" suite
   with_stmt_contents: with_item ("," with_item)*
   with_item:          expression ["as" target]

하나의 "item" 을 사용하는 "with" 문의 실행은 다음과 같이 진행됩니다:

1. The context expression (the expression given in the "with_item") is
   evaluated to obtain a context manager.

2. The context manager's "__enter__()" is loaded for later use.

3. The context manager's "__exit__()" is loaded for later use.

4. The context manager's "__enter__()" method is invoked.

5. If a target was included in the "with" statement, the return value
   from "__enter__()" is assigned to it.

   참고:

     The "with" statement guarantees that if the "__enter__()" method
     returns without an error, then "__exit__()" will always be
     called. Thus, if an error occurs during the assignment to the
     target list, it will be treated the same as an error occurring
     within the suite would be. See step 7 below.

6. 스위트가 실행됩니다.

7. The context manager's "__exit__()" method is invoked.  If an
   exception caused the suite to be exited, its type, value, and
   traceback are passed as arguments to "__exit__()". Otherwise, three
   "None" arguments are supplied.

   If the suite was exited due to an exception, and the return value
   from the "__exit__()" method was false, the exception is reraised.
   If the return value was true, the exception is suppressed, and
   execution continues with the statement following the "with"
   statement.

   If the suite was exited for any reason other than an exception, the
   return value from "__exit__()" is ignored, and execution proceeds
   at the normal location for the kind of exit that was taken.

다음과 같은 코드는:

   with EXPRESSION as TARGET:
       SUITE

의미상으로 다음과 동등합니다:

   manager = (EXPRESSION)
   enter = type(manager).__enter__
   exit = type(manager).__exit__
   value = enter(manager)
   hit_except = False

   try:
       TARGET = value
       SUITE
   except:
       hit_except = True
       if not exit(manager, *sys.exc_info()):
           raise
   finally:
       if not hit_except:
           exit(manager, None, None, None)

하나 보다 많은 항목을 주면, 컨텍스트 관리자는 "with" 문이 중첩된 것처
럼 진행합니다:

   with A() as a, B() as b:
       SUITE

의미상으로 다음과 동등합니다:

   with A() as a:
       with B() as b:
           SUITE

You can also write multi-item context managers in multiple lines if
the items are surrounded by parentheses. For example:

   with (
       A() as a,
       B() as b,
   ):
       SUITE

버전 3.1에서 변경: 다중 컨텍스트 표현식의 지원

버전 3.10에서 변경: Support for using grouping parentheses to break
the statement in multiple lines.

더 보기:

  **PEP 343** - "with" 문
     파이썬 "with" 문의 규격, 배경, 예.


8.6. The "match" statement
==========================

Added in version 3.10.

The match statement is used for pattern matching.  Syntax:

   match_stmt:   'match' subject_expr ":" NEWLINE INDENT case_block+ DEDENT
   subject_expr: `!star_named_expression` "," `!star_named_expressions`?
                 | `!named_expression`
   case_block:   'case' patterns [guard] ":" `!block`

참고:

  This section uses single quotes to denote soft keywords.

Pattern matching takes a pattern as input (following "case") and a
subject value (following "match").  The pattern (which may contain
subpatterns) is matched against the subject value.  The outcomes are:

* A match success or failure (also termed a pattern success or
  failure).

* Possible binding of matched values to a name.  The prerequisites for
  this are further discussed below.

The "match" and "case" keywords are soft keywords.

더 보기:

  * **PEP 634** -- Structural Pattern Matching: Specification

  * **PEP 636** -- Structural Pattern Matching: Tutorial


8.6.1. Overview
---------------

Here's an overview of the logical flow of a match statement:

1. The subject expression "subject_expr" is evaluated and a resulting
   subject value obtained. If the subject expression contains a comma,
   a tuple is constructed using the standard rules.

2. Each pattern in a "case_block" is attempted to match with the
   subject value. The specific rules for success or failure are
   described below. The match attempt can also bind some or all of the
   standalone names within the pattern. The precise pattern binding
   rules vary per pattern type and are specified below.  **Name
   bindings made during a successful pattern match outlive the
   executed block and can be used after the match statement**.

   참고:

     During failed pattern matches, some subpatterns may succeed.  Do
     not rely on bindings being made for a failed match.  Conversely,
     do not rely on variables remaining unchanged after a failed
     match.  The exact behavior is dependent on implementation and may
     vary.  This is an intentional decision made to allow different
     implementations to add optimizations.

3. If the pattern succeeds, the corresponding guard (if present) is
   evaluated. In this case all name bindings are guaranteed to have
   happened.

   * If the guard evaluates as true or is missing, the "block" inside
     "case_block" is executed.

   * Otherwise, the next "case_block" is attempted as described above.

   * If there are no further case blocks, the match statement is
     completed.

참고:

  Users should generally never rely on a pattern being evaluated.
  Depending on implementation, the interpreter may cache values or use
  other optimizations which skip repeated evaluations.

A sample match statement:

   >>> flag = False
   >>> match (100, 200):
   ...    case (100, 300):  # Mismatch: 200 != 300
   ...        print('Case 1')
   ...    case (100, 200) if flag:  # Successful match, but guard fails
   ...        print('Case 2')
   ...    case (100, y):  # Matches and binds y to 200
   ...        print(f'Case 3, y: {y}')
   ...    case _:  # Pattern not attempted
   ...        print('Case 4, I match anything!')
   ...
   Case 3, y: 200

In this case, "if flag" is a guard.  Read more about that in the next
section.


8.6.2. Guards
-------------

   guard: "if" `!named_expression`

A "guard" (which is part of the "case") must succeed for code inside
the "case" block to execute.  It takes the form: "if" followed by an
expression.

The logical flow of a "case" block with a "guard" follows:

1. Check that the pattern in the "case" block succeeded.  If the
   pattern failed, the "guard" is not evaluated and the next "case"
   block is checked.

2. If the pattern succeeded, evaluate the "guard".

   * If the "guard" condition evaluates as true, the case block is
     selected.

   * If the "guard" condition evaluates as false, the case block is
     not selected.

   * If the "guard" raises an exception during evaluation, the
     exception bubbles up.

Guards are allowed to have side effects as they are expressions.
Guard evaluation must proceed from the first to the last case block,
one at a time, skipping case blocks whose pattern(s) don't all
succeed. (I.e., guard evaluation must happen in order.) Guard
evaluation must stop once a case block is selected.


8.6.3. Irrefutable Case Blocks
------------------------------

An irrefutable case block is a match-all case block.  A match
statement may have at most one irrefutable case block, and it must be
last.

A case block is considered irrefutable if it has no guard and its
pattern is irrefutable.  A pattern is considered irrefutable if we can
prove from its syntax alone that it will always succeed.  Only the
following patterns are irrefutable:

* AS Patterns whose left-hand side is irrefutable

* OR Patterns containing at least one irrefutable pattern

* Capture Patterns

* Wildcard Patterns

* parenthesized irrefutable patterns


8.6.4. Patterns
---------------

참고:

  This section uses grammar notations beyond standard EBNF:

  * the notation "SEP.RULE+" is shorthand for "RULE (SEP RULE)*"

  * the notation "!RULE" is shorthand for a negative lookahead
    assertion

The top-level syntax for "patterns" is:

   patterns:       open_sequence_pattern | pattern
   pattern:        as_pattern | or_pattern
   closed_pattern: | literal_pattern
                   | capture_pattern
                   | wildcard_pattern
                   | value_pattern
                   | group_pattern
                   | sequence_pattern
                   | mapping_pattern
                   | class_pattern

The descriptions below will include a description "in simple terms" of
what a pattern does for illustration purposes (credits to Raymond
Hettinger for a document that inspired most of the descriptions). Note
that these descriptions are purely for illustration purposes and **may
not** reflect the underlying implementation.  Furthermore, they do not
cover all valid forms.


8.6.4.1. OR Patterns
~~~~~~~~~~~~~~~~~~~~

An OR pattern is two or more patterns separated by vertical bars "|".
Syntax:

   or_pattern: "|".closed_pattern+

Only the final subpattern may be irrefutable, and each subpattern must
bind the same set of names to avoid ambiguity.

An OR pattern matches each of its subpatterns in turn to the subject
value, until one succeeds.  The OR pattern is then considered
successful.  Otherwise, if none of the subpatterns succeed, the OR
pattern fails.

In simple terms, "P1 | P2 | ..." will try to match "P1", if it fails
it will try to match "P2", succeeding immediately if any succeeds,
failing otherwise.


8.6.4.2. AS Patterns
~~~~~~~~~~~~~~~~~~~~

An AS pattern matches an OR pattern on the left of the "as" keyword
against a subject.  Syntax:

   as_pattern: or_pattern "as" capture_pattern

If the OR pattern fails, the AS pattern fails.  Otherwise, the AS
pattern binds the subject to the name on the right of the as keyword
and succeeds. "capture_pattern" cannot be a "_".

In simple terms "P as NAME" will match with "P", and on success it
will set "NAME = <subject>".


8.6.4.3. Literal Patterns
~~~~~~~~~~~~~~~~~~~~~~~~~

A literal pattern corresponds to most literals in Python.  Syntax:

   literal_pattern: signed_number
                    | signed_number "+" NUMBER
                    | signed_number "-" NUMBER
                    | strings
                    | "None"
                    | "True"
                    | "False"
   signed_number:   ["-"] NUMBER

The rule "strings" and the token "NUMBER" are defined in the standard
Python grammar.  Triple-quoted strings are supported.  Raw strings and
byte strings are supported.  포맷 문자열 리터럴 and t-strings are not
supported.

The forms "signed_number '+' NUMBER" and "signed_number '-' NUMBER"
are for expressing complex numbers; they require a real number on the
left and an imaginary number on the right. E.g. "3 + 4j".

In simple terms, "LITERAL" will succeed only if "<subject> ==
LITERAL". For the singletons "None", "True" and "False", the "is"
operator is used.


8.6.4.4. Capture Patterns
~~~~~~~~~~~~~~~~~~~~~~~~~

A capture pattern binds the subject value to a name. Syntax:

   capture_pattern: !'_' NAME

A single underscore "_" is not a capture pattern (this is what "!'_'"
expresses). It is instead treated as a "wildcard_pattern".

In a given pattern, a given name can only be bound once.  E.g. "case
x, x: ..." is invalid while "case [x] | x: ..." is allowed.

Capture patterns always succeed.  The binding follows scoping rules
established by the assignment expression operator in **PEP 572**; the
name becomes a local variable in the closest containing function scope
unless there's an applicable "global" or "nonlocal" statement.

In simple terms "NAME" will always succeed and it will set "NAME =
<subject>".


8.6.4.5. Wildcard Patterns
~~~~~~~~~~~~~~~~~~~~~~~~~~

A wildcard pattern always succeeds (matches anything) and binds no
name.  Syntax:

   wildcard_pattern: '_'

"_" is a soft keyword within any pattern, but only within patterns.
It is an identifier, as usual, even within "match" subject
expressions, "guard"s, and "case" blocks.

In simple terms, "_" will always succeed.


8.6.4.6. Value Patterns
~~~~~~~~~~~~~~~~~~~~~~~

A value pattern represents a named value in Python. Syntax:

   value_pattern: attr
   attr:          name_or_attr "." NAME
   name_or_attr:  attr | NAME

The dotted name in the pattern is looked up using standard Python name
resolution rules.  The pattern succeeds if the value found compares
equal to the subject value (using the "==" equality operator).

In simple terms "NAME1.NAME2" will succeed only if "<subject> ==
NAME1.NAME2"

참고:

  If the same value occurs multiple times in the same match statement,
  the interpreter may cache the first value found and reuse it rather
  than repeat the same lookup.  This cache is strictly tied to a given
  execution of a given match statement.


8.6.4.7. Group Patterns
~~~~~~~~~~~~~~~~~~~~~~~

A group pattern allows users to add parentheses around patterns to
emphasize the intended grouping.  Otherwise, it has no additional
syntax. Syntax:

   group_pattern: "(" pattern ")"

In simple terms "(P)" has the same effect as "P".


8.6.4.8. Sequence Patterns
~~~~~~~~~~~~~~~~~~~~~~~~~~

A sequence pattern contains several subpatterns to be matched against
sequence elements. The syntax is similar to the unpacking of a list or
tuple.

   sequence_pattern:       "[" [maybe_sequence_pattern] "]"
                           | "(" [open_sequence_pattern] ")"
   open_sequence_pattern:  maybe_star_pattern "," [maybe_sequence_pattern]
   maybe_sequence_pattern: ",".maybe_star_pattern+ ","?
   maybe_star_pattern:     star_pattern | pattern
   star_pattern:           "*" (capture_pattern | wildcard_pattern)

There is no difference if parentheses  or square brackets are used for
sequence patterns (i.e. "(...)" vs "[...]" ).

참고:

  A single pattern enclosed in parentheses without a trailing comma
  (e.g. "(3 | 4)") is a group pattern. While a single pattern enclosed
  in square brackets (e.g. "[3 | 4]") is still a sequence pattern.

At most one star subpattern may be in a sequence pattern.  The star
subpattern may occur in any position. If no star subpattern is
present, the sequence pattern is a fixed-length sequence pattern;
otherwise it is a variable-length sequence pattern.

The following is the logical flow for matching a sequence pattern
against a subject value:

1. If the subject value is not a sequence [2], the sequence pattern
   fails.

2. If the subject value is an instance of "str", "bytes" or
   "bytearray" the sequence pattern fails.

3. The subsequent steps depend on whether the sequence pattern is
   fixed or variable-length.

   If the sequence pattern is fixed-length:

   1. If the length of the subject sequence is not equal to the number
      of subpatterns, the sequence pattern fails

   2. Subpatterns in the sequence pattern are matched to their
      corresponding items in the subject sequence from left to right.
      Matching stops as soon as a subpattern fails.  If all
      subpatterns succeed in matching their corresponding item, the
      sequence pattern succeeds.

   Otherwise, if the sequence pattern is variable-length:

   1. If the length of the subject sequence is less than the number of
      non-star subpatterns, the sequence pattern fails.

   2. The leading non-star subpatterns are matched to their
      corresponding items as for fixed-length sequences.

   3. If the previous step succeeds, the star subpattern matches a
      list formed of the remaining subject items, excluding the
      remaining items corresponding to non-star subpatterns following
      the star subpattern.

   4. Remaining non-star subpatterns are matched to their
      corresponding subject items, as for a fixed-length sequence.

   참고:

     The length of the subject sequence is obtained via "len()" (i.e.
     via the "__len__()" protocol). This length may be cached by the
     interpreter in a similar manner as value patterns.

In simple terms "[P1, P2, P3," ... ", P<N>]" matches only if all the
following happens:

* check "<subject>" is a sequence

* "len(subject) == <N>"

* "P1" matches "<subject>[0]" (note that this match can also bind
  names)

* "P2" matches "<subject>[1]" (note that this match can also bind
  names)

* ... and so on for the corresponding pattern/element.


8.6.4.9. Mapping Patterns
~~~~~~~~~~~~~~~~~~~~~~~~~

A mapping pattern contains one or more key-value patterns.  The syntax
is similar to the construction of a dictionary. Syntax:

   mapping_pattern:     "{" [items_pattern] "}"
   items_pattern:       ",".key_value_pattern+ ","?
   key_value_pattern:   (literal_pattern | value_pattern) ":" pattern
                        | double_star_pattern
   double_star_pattern: "**" capture_pattern

At most one double star pattern may be in a mapping pattern.  The
double star pattern must be the last subpattern in the mapping
pattern.

Duplicate keys in mapping patterns are disallowed. Duplicate literal
keys will raise a "SyntaxError". Two keys that otherwise have the same
value will raise a "ValueError" at runtime.

The following is the logical flow for matching a mapping pattern
against a subject value:

1. If the subject value is not a mapping [3],the mapping pattern
   fails.

2. If every key given in the mapping pattern is present in the subject
   mapping, and the pattern for each key matches the corresponding
   item of the subject mapping, the mapping pattern succeeds.

3. If duplicate keys are detected in the mapping pattern, the pattern
   is considered invalid. A "SyntaxError" is raised for duplicate
   literal values; or a "ValueError" for named keys of the same value.

참고:

  Key-value pairs are matched using the two-argument form of the
  mapping subject's "get()" method.  Matched key-value pairs must
  already be present in the mapping, and not created on-the-fly via
  "__missing__()" or "__getitem__()".

In simple terms "{KEY1: P1, KEY2: P2, ... }" matches only if all the
following happens:

* check "<subject>" is a mapping

* "KEY1 in <subject>"

* "P1" matches "<subject>[KEY1]"

* ... and so on for the corresponding KEY/pattern pair.


8.6.4.10. Class Patterns
~~~~~~~~~~~~~~~~~~~~~~~~

A class pattern represents a class and its positional and keyword
arguments (if any).  Syntax:

   class_pattern:       name_or_attr "(" [pattern_arguments ","?] ")"
   pattern_arguments:   positional_patterns ["," keyword_patterns]
                        | keyword_patterns
   positional_patterns: ",".pattern+
   keyword_patterns:    ",".keyword_pattern+
   keyword_pattern:     NAME "=" pattern

The same keyword should not be repeated in class patterns.

The following is the logical flow for matching a class pattern against
a subject value:

1. If "name_or_attr" is not an instance of the builtin "type" , raise
   "TypeError".

2. If the subject value is not an instance of "name_or_attr" (tested
   via "isinstance()"), the class pattern fails.

3. If no pattern arguments are present, the pattern succeeds.
   Otherwise, the subsequent steps depend on whether keyword or
   positional argument patterns are present.

   For a number of built-in types (specified below), a single
   positional subpattern is accepted which will match the entire
   subject; for these types keyword patterns also work as for other
   types.

   If only keyword patterns are present, they are processed as
   follows, one by one:

   1. The keyword is looked up as an attribute on the subject.

      * If this raises an exception other than "AttributeError", the
        exception bubbles up.

      * If this raises "AttributeError", the class pattern has failed.

      * Else, the subpattern associated with the keyword pattern is
        matched against the subject's attribute value.  If this fails,
        the class pattern fails; if this succeeds, the match proceeds
        to the next keyword.

   2. If all keyword patterns succeed, the class pattern succeeds.

   If any positional patterns are present, they are converted to
   keyword patterns using the "__match_args__" attribute on the class
   "name_or_attr" before matching:

   1. The equivalent of "getattr(cls, "__match_args__", ())" is
      called.

      * If this raises an exception, the exception bubbles up.

      * If the returned value is not a tuple, the conversion fails and
        "TypeError" is raised.

      * If there are more positional patterns than
        "len(cls.__match_args__)", "TypeError" is raised.

      * Otherwise, positional pattern "i" is converted to a keyword
        pattern using "__match_args__[i]" as the keyword.
        "__match_args__[i]" must be a string; if not "TypeError" is
        raised.

      * If there are duplicate keywords, "TypeError" is raised.

      더 보기: Customizing positional arguments in class pattern matching

   2. Once all positional patterns have been converted to keyword
      patterns, the match proceeds as if there were only keyword
      patterns.

   For the following built-in types the handling of positional
   subpatterns is different:

   * "bool"

   * "bytearray"

   * "bytes"

   * "dict"

   * "float"

   * "frozenset"

   * "int"

   * "list"

   * "set"

   * "str"

   * "tuple"

   These classes accept a single positional argument, and the pattern
   there is matched against the whole object rather than an attribute.
   For example "int(0|1)" matches the value "0", but not the value
   "0.0".

In simple terms "CLS(P1, attr=P2)" matches only if the following
happens:

* "isinstance(<subject>, CLS)"

* convert "P1" to a keyword pattern using "CLS.__match_args__"

* For each keyword argument "attr=P2":

  * "hasattr(<subject>, "attr")"

  * "P2" matches "<subject>.attr"

* ... and so on for the corresponding keyword argument/pattern pair.

더 보기:

  * **PEP 634** -- Structural Pattern Matching: Specification

  * **PEP 636** -- Structural Pattern Matching: Tutorial


8.7. 함수 정의
==============

함수 정의는 사용자 정의 함수 객체 (표준형 계층 섹션을 보세요) 를 정의
합니다:

   funcdef:                   [decorators] "def" funcname [type_params] "(" [parameter_list] ")"
                              ["->" expression] ":" suite
   decorators:                decorator+
   decorator:                 "@" assignment_expression NEWLINE
   parameter_list:            defparameter ("," defparameter)* "," "/" ["," [parameter_list_no_posonly]]
                                | parameter_list_no_posonly
   parameter_list_no_posonly: defparameter ("," defparameter)* ["," [parameter_list_starargs]]
                              | parameter_list_starargs
   parameter_list_starargs:   "*" [star_parameter] ("," defparameter)* ["," [parameter_star_kwargs]]
                              | "*" ("," defparameter)+ ["," [parameter_star_kwargs]]
                              | parameter_star_kwargs
   parameter_star_kwargs:     "**" parameter [","]
   parameter:                 identifier [":" expression]
   star_parameter:            identifier [":" ["*"] expression]
   defparameter:              parameter ["=" expression]
   funcname:                  identifier

함수 정의는 실행할 수 있는 문장입니다. 실행하면 현재 지역 이름 공간의
함수 이름을 함수 객체 (함수의 실행 가능한 코드를 둘러싼 래퍼
(wrapper)). 이 함수 객체는 현재의 이름 공간에 대한 참조를 포함하는데,
함수가 호출될 때 전역 이름 공간으로 사용됩니다.

함수 정의는 함수의 바디를 실행하지 않습니다. 함수가 호출될 때 실행됩니
다. [4]

함수 정의는 하나나 그 이상의 *데코레이터* 표현식으로 감싸질 수 있습니
다. 데코레이터 표현식은 함수가 정의될 때, 함수 정의를 포함하는 스코프
에서 값을 구합니다. 그 결과는 콜러블이어야 하는데, 함수 객체만을 인자
로 사용해서 호출됩니다. 반환 값이 함수 객체 대신 함수의 이름에 연결됩
니다. 여러 개의 데코레이터는 중첩되는 방식으로 적용됩니다. 예를 들어,
다음과 같은 코드

   @f1(arg)
   @f2
   def func(): pass

는 대략 다음과 동등합니다

   def func(): pass
   func = f1(arg)(f2(func))

원래의 함수가 임시로 이름 "func" 에 연결되지 않는다는 점만 다릅니다.

버전 3.9에서 변경: Functions may be decorated with any valid
"assignment_expression". Previously, the grammar was much more
restrictive; see **PEP 614** for details.

A list of type parameters may be given in square brackets between the
function's name and the opening parenthesis for its parameter list.
This indicates to static type checkers that the function is generic.
At runtime, the type parameters can be retrieved from the function's
"__type_params__" attribute. See Generic functions for more.

버전 3.12에서 변경: Type parameter lists are new in Python 3.12.

하나나 그 이상의 *매개변수* 들이 *parameter* "=" *expression* 형태를
가질 때, 함수가 "기본 매개변수 값"을 갖는다고 말합니다. 기본값이 있는
매개변수의 경우, 호출할 때 대응하는 *인자* 를 생략할 수 있고, 그럴 때
매개변수의 기본값이 적용됩니다. 만약 매개변수가 기본값을 가지면, ""*""
까지 그 뒤를 따르는 모든 매개변수도 기본값을 가져야 합니다 --- 이것은
문법 규칙에서 표현되지 않는 문법적 제약입니다.

**Default parameter values are evaluated from left to right when the
function definition is executed.** This means that the expression is
evaluated once, when the function is defined, and that the same "pre-
computed" value is used for each call.  This is especially important
to understand when a default parameter value is a mutable object, such
as a list or a dictionary: if the function modifies the object (e.g.
by appending an item to a list), the default parameter value is in
effect modified.  This is generally not what was intended.  A way
around this is to use "None" as the default, and explicitly test for
it in the body of the function, e.g.:

   def whats_on_the_telly(penguin=None):
       if penguin is None:
           penguin = []
       penguin.append("property of the zoo")
       return penguin

Function call semantics are described in more detail in section 호출.
A function call always assigns values to all parameters mentioned in
the parameter list, either from positional arguments, from keyword
arguments, or from default values.  If the form ""*identifier"" is
present, it is initialized to a tuple receiving any excess positional
parameters, defaulting to the empty tuple. If the form
""**identifier"" is present, it is initialized to a new ordered
mapping receiving any excess keyword arguments, defaulting to a new
empty mapping of the same type.  Parameters after ""*"" or
""*identifier"" are keyword-only parameters and may only be passed by
keyword arguments.  Parameters before ""/"" are positional-only
parameters and may only be passed by positional arguments.

버전 3.8에서 변경: The "/" function parameter syntax may be used to
indicate positional-only parameters. See **PEP 570** for details.

Parameters may have an *annotation* of the form "": expression""
following the parameter name.  Any parameter may have an annotation,
even those of the form "*identifier" or "**identifier". (As a special
case, parameters of the form "*identifier" may have an annotation "":
*expression"".) Functions may have "return" annotation of the form
""-> expression"" after the parameter list.  These annotations can be
any valid Python expression.  The presence of annotations does not
change the semantics of a function. See Annotations for more
information on annotations.

버전 3.11에서 변경: Parameters of the form ""*identifier"" may have an
annotation "": *expression"". See **PEP 646**.

표현식에서 즉시 사용하기 위해, 이름 없는 함수(이름에 연결되지 않은 함
수)를 만드는 것도 가능합니다. 이것은 람다 표현식을 사용하는데, 람다
(Lambdas) 섹션에서 설명합니다. 람다 표현식은 단순화된 함수 정의를 위한
줄임 표현에 지나지 않는다는 것에 주의하세요; ""def"" 문장에서 정의된
함수는 람다 표현식으로 정의된 함수처럼 전달되거나 다른 이름에 대입될
수 있습니다. 여러 개의 문장을 실행하는 것과 어노테이션을 허락하기 때문
에, ""def"" 형태가 사실 더 강력합니다.

**프로그래머 유의 사항:** 함수는 퍼스트 클래스(first-class) 객체다. 함
수 정의 안에서 실행되는 ""def"" 문은 돌려주거나 전달할 수 있는 지역 함
수를 정의합니다. 중첩된 함수에서 사용되는 자유 변수들은 그 def 를 포함
하는 함수의 지역 변수들을 액세스할 수 있습니다. 더 자세한 내용은 이름
과 연결(binding) 섹션을 보세요.

더 보기:

  **PEP 3107** - 함수 어노테이션
     함수 어노테이션의 최초 규격.

  **PEP 484** - 형 힌트
     어노테이션에 대한 표준 의미 정의: 형 힌트.

  **PEP 526** - 변수 어노테이션 문법
     Ability to type hint variable declarations, including class
     variables and instance variables.

  **PEP 563** - 어노테이션의 지연된 평가
     즉시 평가하는 대신 실행시간에 어노테이션을 문자열 형식으로 보존하
     여 어노테이션 내에서의 전방 참조를 지원합니다.

  **PEP 318** - Decorators for Functions and Methods
     Function and method decorators were introduced. Class decorators
     were introduced in **PEP 3129**.


8.8. 클래스 정의
================

클래스 정의는 클래스 객체(표준형 계층 섹션을 보세요)를 정의합니다:

   classdef:    [decorators] "class" classname [type_params] [inheritance] ":" suite
   inheritance: "(" [argument_list] ")"
   classname:   identifier

클래스 정의는 실행 가능한 문장입니다. 계승(inheritance) 목록은 보통 베
이스 클래스들의 목록을 제공하는데 (더 고급 사용에 대해서는 메타 클래스
를 보세요), 목록의 각 항목은 값을 구할 때 서브 클래싱을 허락하는 클래
스 객체가 되어야 합니다. 계승 목록이 없는 클래스는, 기본적으로, 베이스
클래스 "object" 를 계승합니다; 그래서

   class Foo:
       pass

는 다음과 동등합니다

   class Foo(object):
       pass

클래스의 스위트는 새로 만들어진 지역 이름 공간과 원래의 전역 이름 공간
을 사용하는 새 실행 프레임 (이름과 연결(binding) 을 보세요)에서 실행됩
니다. (보통, 스위트는 대부분 함수 정의들을 포함합니다.) 클래스의 스위
트가 실행을 마치면, 실행 프레임은 파기하지만, 그것의 지역 이름 공간은
보존합니다. [5] 그런 다음, 계승 목록을 베이스 클래스들로, 보존된 지역
이름 공간을 어트리뷰트 딕셔너리로 사용해서 새 클래스 객체를 만듭니다.
클래스의 이름은 원래의 지역 이름 공간에서 이 클래스 객체와 연결됩니다.

The order in which attributes are defined in the class body is
preserved in the new class's "__dict__".  Note that this is reliable
only right after the class is created and only for classes that were
defined using the definition syntax.

클래스 생성은 메타 클래스 를 사용해서 심하게 커스터마이즈할 수 있습니
다.

클래스 역시 함수를 데코레이팅할 때처럼 테코레이트할 수 있습니다,

   @f1(arg)
   @f2
   class Foo: pass

는 대략 다음과 동등합니다

   class Foo: pass
   Foo = f1(arg)(f2(Foo))

데코레이터 표현식의 값을 구하는 규칙은 함수 데코레이터와 같습니다. 그
런 다음 그 결과가 클래스 이름에 연결됩니다.

버전 3.9에서 변경: Classes may be decorated with any valid
"assignment_expression". Previously, the grammar was much more
restrictive; see **PEP 614** for details.

A list of type parameters may be given in square brackets immediately
after the class's name. This indicates to static type checkers that
the class is generic. At runtime, the type parameters can be retrieved
from the class's "__type_params__" attribute. See Generic classes for
more.

버전 3.12에서 변경: Type parameter lists are new in Python 3.12.

**프로그래머 유의 사항:** 클래스 정의에서 정의되는 변수들은 클래스 어
트리뷰트입니다; 이것들은 인스턴스 간에 공유됩니다. 인스턴스 어트리뷰트
는 메서드에서 "self.name = value" 로 설정될 수 있습니다. 클래스와 인스
턴스 어트리뷰트 모두 ""self.name"" 표기법으로 액세스할 수 있고, 이런
식으로 액세스할 때 인스턴스 어트리뷰트는 같은 이름의 클래스 어트리뷰트
를 가립니다. 클래스 어트리뷰트는 인스턴스 어트리뷰트의 기본값으로 사용
될 수 있지만, 가변 값을 사용하는 것은 예상하지 않은 결과를 줄 수 있습
니다. 디스크립터 를 다른 구현 상세를 갖는 인스턴스 변수를 만드는데 사
용할 수 있습니다.

더 보기:

  **PEP 3115** - 파이썬 3000의 메타 클래스
     메타 클래스 선언을 현재 문법으로 변경하고, 메타 클래스가 있는 클
     래스를 구성하는 방법의 의미를 변경하는 제안.

  **PEP 3129** - 클래스 데코레이터
     클래스 데코레이터를 추가하는 제안. 함수와 메서드 데코레이터는
     **PEP 318**에서 도입되었습니다.


8.9. 코루틴
===========

Added in version 3.5.


8.9.1. 코루틴 함수 정의
-----------------------

   async_funcdef: [decorators] "async" "def" funcname "(" [parameter_list] ")"
                  ["->" expression] ":" suite

Execution of Python coroutines can be suspended and resumed at many
points (see *coroutine*). "await" expressions, "async for" and "async
with" can only be used in the body of a coroutine function.

"async def" 문법으로 정의된 함수는 항상 코루틴 함수인데, "await" 나
"async" 키워드를 포함하지 않는 경우도 그렇습니다.

코루틴 함수의 바디 안에서 "yield from" 표현식을 사용하는 것은
"SyntaxError" 입니다.

코루틴 함수의 예:

   async def func(param1, param2):
       do_stuff()
       await some_coroutine()

버전 3.7에서 변경: "await" and "async" are now keywords; previously
they were only treated as such inside the body of a coroutine
function.


8.9.2. "async for" 문
---------------------

   async_for_stmt: "async" for_stmt

*비동기 이터러블* 은 *비동기 이터레이터* 를 직접 반환하는 "__aiter__"
메서드를 제공하고, 비동기 이터레이터는 자신의 "__anext__" 메서드에서
비동기 코드를 호출할 수 있습니다.

"async for" 문은 비동기 이터러블에 대한 편리한 이터레이션을 허락합니다
.

다음과 같은 코드는:

   async for TARGET in ITER:
       SUITE
   else:
       SUITE2

의미상으로 다음과 동등합니다:

   iter = (ITER)
   iter = type(iter).__aiter__(iter)
   running = True

   while running:
       try:
           TARGET = await type(iter).__anext__(iter)
       except StopAsyncIteration:
           running = False
       else:
           SUITE
   else:
       SUITE2

See also "__aiter__()" and "__anext__()" for details.

코루틴 함수의 바디 밖에서 "async for" 문을 사용하는 것은 "SyntaxError"
입니다.


8.9.3. "async with" 문
----------------------

   async_with_stmt: "async" with_stmt

*비동기 컨텍스트 관리자* 는 *enter* 와 *exit* 메서드에서 실행을 일시
중지할 수 있는 *컨텍스트 관리자* 입니다.

다음과 같은 코드는:

   async with EXPRESSION as TARGET:
       SUITE

의미상으로 다음과 동등합니다:

   manager = (EXPRESSION)
   aenter = type(manager).__aenter__
   aexit = type(manager).__aexit__
   value = await aenter(manager)
   hit_except = False

   try:
       TARGET = value
       SUITE
   except:
       hit_except = True
       if not await aexit(manager, *sys.exc_info()):
           raise
   finally:
       if not hit_except:
           await aexit(manager, None, None, None)

See also "__aenter__()" and "__aexit__()" for details.

코루틴 함수의 바디 밖에서 "async with" 문을 사용하는 것은
"SyntaxError" 입니다.

더 보기:

  **PEP 492** - async 와 await 문법을 사용하는 코루틴
     코루틴을 파이썬에서 적절한 독립적인 개념으로 만들고, 문법 지원을
     추가한 제안.


8.10. Type parameter lists
==========================

Added in version 3.12.

버전 3.13에서 변경: Support for default values was added (see **PEP
696**).

   type_params:  "[" type_param ("," type_param)* "]"
   type_param:   typevar | typevartuple | paramspec
   typevar:      identifier (":" expression)? ("=" expression)?
   typevartuple: "*" identifier ("=" expression)?
   paramspec:    "**" identifier ("=" expression)?

Functions (including coroutines), classes and type aliases may contain
a type parameter list:

   def max[T](args: list[T]) -> T:
       ...

   async def amax[T](args: list[T]) -> T:
       ...

   class Bag[T]:
       def __iter__(self) -> Iterator[T]:
           ...

       def add(self, arg: T) -> None:
           ...

   type ListOrSet[T] = list[T] | set[T]

Semantically, this indicates that the function, class, or type alias
is generic over a type variable. This information is primarily used by
static type checkers, and at runtime, generic objects behave much like
their non-generic counterparts.

Type parameters are declared in square brackets ("[]") immediately
after the name of the function, class, or type alias. The type
parameters are accessible within the scope of the generic object, but
not elsewhere. Thus, after a declaration "def func[T](): pass", the
name "T" is not available in the module scope. Below, the semantics of
generic objects are described with more precision. The scope of type
parameters is modeled with a special function (technically, an
annotation scope) that wraps the creation of the generic object.

Generic functions, classes, and type aliases have a "__type_params__"
attribute listing their type parameters.

Type parameters come in three kinds:

* "typing.TypeVar", introduced by a plain name (e.g., "T").
  Semantically, this represents a single type to a type checker.

* "typing.TypeVarTuple", introduced by a name prefixed with a single
  asterisk (e.g., "*Ts"). Semantically, this stands for a tuple of any
  number of types.

* "typing.ParamSpec", introduced by a name prefixed with two asterisks
  (e.g., "**P"). Semantically, this stands for the parameters of a
  callable.

"typing.TypeVar" declarations can define *bounds* and *constraints*
with a colon (":") followed by an expression. A single expression
after the colon indicates a bound (e.g. "T: int"). Semantically, this
means that the "typing.TypeVar" can only represent types that are a
subtype of this bound. A parenthesized tuple of expressions after the
colon indicates a set of constraints (e.g. "T: (str, bytes)"). Each
member of the tuple should be a type (again, this is not enforced at
runtime). Constrained type variables can only take on one of the types
in the list of constraints.

For "typing.TypeVar"s declared using the type parameter list syntax,
the bound and constraints are not evaluated when the generic object is
created, but only when the value is explicitly accessed through the
attributes "__bound__" and "__constraints__". To accomplish this, the
bounds or constraints are evaluated in a separate annotation scope.

"typing.TypeVarTuple"s and "typing.ParamSpec"s cannot have bounds or
constraints.

All three flavors of type parameters can also have a *default value*,
which is used when the type parameter is not explicitly provided. This
is added by appending a single equals sign ("=") followed by an
expression. Like the bounds and constraints of type variables, the
default value is not evaluated when the object is created, but only
when the type parameter's "__default__" attribute is accessed. To this
end, the default value is evaluated in a separate annotation scope. If
no default value is specified for a type parameter, the "__default__"
attribute is set to the special sentinel object "typing.NoDefault".

The following example indicates the full set of allowed type parameter
declarations:

   def overly_generic[
      SimpleTypeVar,
      TypeVarWithDefault = int,
      TypeVarWithBound: int,
      TypeVarWithConstraints: (str, bytes),
      *SimpleTypeVarTuple = (int, float),
      **SimpleParamSpec = (str, bytearray),
   ](
      a: SimpleTypeVar,
      b: TypeVarWithDefault,
      c: TypeVarWithBound,
      d: Callable[SimpleParamSpec, TypeVarWithConstraints],
      *e: SimpleTypeVarTuple,
   ): ...


8.10.1. Generic functions
-------------------------

Generic functions are declared as follows:

   def func[T](arg: T): ...

This syntax is equivalent to:

   annotation-def TYPE_PARAMS_OF_func():
       T = typing.TypeVar("T")
       def func(arg: T): ...
       func.__type_params__ = (T,)
       return func
   func = TYPE_PARAMS_OF_func()

Here "annotation-def" indicates an annotation scope, which is not
actually bound to any name at runtime. (One other liberty is taken in
the translation: the syntax does not go through attribute access on
the "typing" module, but creates an instance of "typing.TypeVar"
directly.)

The annotations of generic functions are evaluated within the
annotation scope used for declaring the type parameters, but the
function's defaults and decorators are not.

The following example illustrates the scoping rules for these cases,
as well as for additional flavors of type parameters:

   @decorator
   def func[T: int, *Ts, **P](*args: *Ts, arg: Callable[P, T] = some_default):
       ...

Except for the lazy evaluation of the "TypeVar" bound, this is
equivalent to:

   DEFAULT_OF_arg = some_default

   annotation-def TYPE_PARAMS_OF_func():

       annotation-def BOUND_OF_T():
           return int
       # In reality, BOUND_OF_T() is evaluated only on demand.
       T = typing.TypeVar("T", bound=BOUND_OF_T())

       Ts = typing.TypeVarTuple("Ts")
       P = typing.ParamSpec("P")

       def func(*args: *Ts, arg: Callable[P, T] = DEFAULT_OF_arg):
           ...

       func.__type_params__ = (T, Ts, P)
       return func
   func = decorator(TYPE_PARAMS_OF_func())

The capitalized names like "DEFAULT_OF_arg" are not actually bound at
runtime.


8.10.2. Generic classes
-----------------------

Generic classes are declared as follows:

   class Bag[T]: ...

This syntax is equivalent to:

   annotation-def TYPE_PARAMS_OF_Bag():
       T = typing.TypeVar("T")
       class Bag(typing.Generic[T]):
           __type_params__ = (T,)
           ...
       return Bag
   Bag = TYPE_PARAMS_OF_Bag()

Here again "annotation-def" (not a real keyword) indicates an
annotation scope, and the name "TYPE_PARAMS_OF_Bag" is not actually
bound at runtime.

Generic classes implicitly inherit from "typing.Generic". The base
classes and keyword arguments of generic classes are evaluated within
the type scope for the type parameters, and decorators are evaluated
outside that scope. This is illustrated by this example:

   @decorator
   class Bag(Base[T], arg=T): ...

This is equivalent to:

   annotation-def TYPE_PARAMS_OF_Bag():
       T = typing.TypeVar("T")
       class Bag(Base[T], typing.Generic[T], arg=T):
           __type_params__ = (T,)
           ...
       return Bag
   Bag = decorator(TYPE_PARAMS_OF_Bag())


8.10.3. Generic type aliases
----------------------------

The "type" statement can also be used to create a generic type alias:

   type ListOrSet[T] = list[T] | set[T]

Except for the lazy evaluation of the value, this is equivalent to:

   annotation-def TYPE_PARAMS_OF_ListOrSet():
       T = typing.TypeVar("T")

       annotation-def VALUE_OF_ListOrSet():
           return list[T] | set[T]
       # In reality, the value is lazily evaluated
       return typing.TypeAliasType("ListOrSet", VALUE_OF_ListOrSet(), type_params=(T,))
   ListOrSet = TYPE_PARAMS_OF_ListOrSet()

Here, "annotation-def" (not a real keyword) indicates an annotation
scope. The capitalized names like "TYPE_PARAMS_OF_ListOrSet" are not
actually bound at runtime.


8.11. Annotations
=================

버전 3.14에서 변경: Annotations are now lazily evaluated by default.

Variables and function parameters may carry *annotations*, created by
adding a colon after the name, followed by an expression:

   x: annotation = 1
   def f(param: annotation): ...

Functions may also carry a return annotation following an arrow:

   def f() -> annotation: ...

Annotations are conventionally used for *type hints*, but this is not
enforced by the language, and in general annotations may contain
arbitrary expressions. The presence of annotations does not change the
runtime semantics of the code, except if some mechanism is used that
introspects and uses the annotations (such as "dataclasses" or
"functools.singledispatch()").

By default, annotations are lazily evaluated in an annotation scope.
This means that they are not evaluated when the code containing the
annotation is evaluated. Instead, the interpreter saves information
that can be used to evaluate the annotation later if requested. The
"annotationlib" module provides tools for evaluating annotations.

If the future statement "from __future__ import annotations" is
present, all annotations are instead stored as strings:

   >>> from __future__ import annotations
   >>> def f(param: annotation): ...
   >>> f.__annotations__
   {'param': 'annotation'}

This future statement will be deprecated and removed in a future
version of Python, but not before Python 3.13 reaches its end of life
(see **PEP 749**). When it is used, introspection tools like
"annotationlib.get_annotations()" and "typing.get_type_hints()" are
less likely to be able to resolve annotations at runtime.

-[ 각주 ]-

[1] 다른 예외를 일으키는 "finally" 절이 있지 않은 한 예외는 호출 스택
    으로 퍼집니다. 그 새 예외는 예전의 것을 잃어버리게 만듭니다.

[2] In pattern matching, a sequence is defined as one of the
    following:

    * a class that inherits from "collections.abc.Sequence"

    * a Python class that has been registered as
      "collections.abc.Sequence"

    * a builtin class that has its (CPython) "Py_TPFLAGS_SEQUENCE" bit
      set

    * a class that inherits from any of the above

    The following standard library classes are sequences:

    * "array.array"

    * "collections.deque"

    * "list"

    * "memoryview"

    * "range"

    * "tuple"

    참고:

      Subject values of type "str", "bytes", and "bytearray" do not
      match sequence patterns.

[3] In pattern matching, a mapping is defined as one of the following:

    * a class that inherits from "collections.abc.Mapping"

    * a Python class that has been registered as
      "collections.abc.Mapping"

    * a builtin class that has its (CPython) "Py_TPFLAGS_MAPPING" bit
      set

    * a class that inherits from any of the above

    The standard library classes "dict" and "types.MappingProxyType"
    are mappings.

[4] A string literal appearing as the first statement in the function
    body is transformed into the function's "__doc__" attribute and
    therefore the function's *docstring*.

[5] A string literal appearing as the first statement in the class
    body is transformed into the namespace's "__doc__" item and
    therefore the class's *docstring*.
