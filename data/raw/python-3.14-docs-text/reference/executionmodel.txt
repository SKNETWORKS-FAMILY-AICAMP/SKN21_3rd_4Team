4. 실행 모델
************


4.1. 프로그램의 구조
====================

파이썬 프로그램은 코드 블록으로 만들어집니다. *블록 (block)* 은 한 단
위로 실행되는 한 조각의 파이썬 프로그램 텍스트입니다. 다음과 같은 것들
이 블록입니다: 모듈, 함수 바디, 클래스 정의. 대화형으로 입력되는 각 명
령은 블록입니다. 스크립트 파일(표준 입력을 통해 인터프리터로 제공되는
파일이나 인터프리터에 명령행 인자로 지정된 파일)은 코드 블록입니다. 스
크립트 명령("-c" 옵션으로 인터프리터 명령행에 지정된 명령)은 코드 블록
입니다. "-m" 인자를 사용하여 명령 줄에서 최상위 수준 스크립트로 (모듈
"__main__"으로) 실행되는 모듈도 코드 블록입니다. 내장함수 "eval()" 과
"exec()" 로 전달되는 문자열 인자도 코드 블록입니다.

코드 블록은 *실행 프레임 (execution frame)* 에서 실행됩니다. 프레임은
몇몇 관리를 위한 정보(디버깅에 사용됩니다)를 포함하고, 코드 블록의 실
행이 끝난 후에 어디서 어떻게 실행을 계속할 것인지를 결정합니다.


4.2. 이름과 연결(binding)
=========================


4.2.1. 이름의 연결
------------------

*이름 (Names)* 은 객체를 가리킵니다. 이름은 이름 연결 연산 때문에 만들
어집니다.

The following constructs bind names:

* formal parameters to functions,

* class definitions,

* function definitions,

* assignment expressions,

* targets that are identifiers if occurring in an assignment:

  * "for" loop header,

  * after "as" in a "with" statement, "except" clause, "except*"
    clause, or in the as-pattern in structural pattern matching,

  * in a capture pattern in structural pattern matching

* "import" statements.

* "type" statements.

* type parameter lists.

The "import" statement of the form "from ... import *" binds all names
defined in the imported module, except those beginning with an
underscore. This form may only be used at the module level.

"del" 문에 나오는 대상 역시 이 목적에서 연결된 것으로 간주합니다(실제
의미가 이름을 연결 해제하는 것이기는 해도).

각 대입이나 임포트 문은 클래스나 함수 정의 때문에 정의되는 블록 내에
등장할 수 있고, 모듈 수준(최상위 코드 블록)에서 등장할 수도 있습니다.

만약 이름이 블록 내에서 연결되면, "nonlocal" 이나 "global" 로 선언되지
않는 이상, 그 블록의 지역 변수입니다. 만약 이름이 모듈 수준에서 연결되
면, 전역 변수입니다. (모듈 코드 블록의 변수들 지역이면서 전역입니다.)
만약 변수가 코드 블록에서 사용되지만, 거기에서 정의되지 않았으면 *자유
변수* 입니다.

프로그램 텍스트에 등장하는 각각의 이름들은 다음에 나오는 이름 검색
(name resolution) 규칙에 따라 확정되는 이름의 *연결 (binding)* 을 가리
킵니다.


4.2.2. 이름의 검색(resolution)
------------------------------

*스코프 (scope)* 는 블록 내에서 이름의 가시성(visibility)을 정의합니다
. 지역 변수가 블록에서 정의되면, 그것의 스코프는 그 블록을 포함합니다.
만약 정의가 함수 블록에서 이루어지면, 포함된 블록이 그 이름에 대해 다
른 결합을 만들지 않는 이상, 스코프는 정의하고 있는 것 안에 포함된 모든
블록으로 확대됩니다.

이름이 코드 블록 내에서 사용될 때, 가장 가깝게 둘러싸고 있는 스코프에
있는 것으로 검색됩니다. 코드 블록이 볼 수 있는 모든 스코프의 집합을 블
록의 *환경 (environment)* 이라고 부릅니다.

이름이 어디에서도 발견되지 않으면 "NameError" 예외가 발생합니다. 만약
현재 스코프가 함수 스코프이고, 그 이름이 사용되는 시점에 아직 연결되지
않은 지역 변수면 "UnboundLocalError" 예외가 발생합니다.
"UnboundLocalError" 는 "NameError" 의 서브 클래스입니다.

만약 이름 연결 연산이 코드 블록 내의 어디에서 건 일어난다면, 그 블록
내에서 그 이름의 모든 사용은 현재 블록을 가리키는 것으로 취급됩니다.
이것은 연결되기 전에 블록에서 사용될 때 에러로 이어질 수 있습니다. 이
규칙은 미묘합니다. 파이썬에는 선언(declaration)이 없고, 이름 연결 연산
이 코드 블록 내의 어디에서나 일어날 수 있도록 허락합니다. 코드 블록의
지역 변수는 블록의 텍스트 전체에서 이름 연결 연산을 찾아야 결정될 수
있습니다. 예제는 UnboundLocalError 에 관한 FAQ 항목을 참조하세요.

만약 "global" 문이 블록 내에서 나오면, 문장에서 지정한 이름의 모든 사
용은 최상위 이름 공간(top-level namespace)에 연결된 것을 가리키게 됩니
다. 최상위 이름 공간에서 이름을 검색한다는 것은, 전역 이름 공간, 즉 코
드 블록을 포함하는 모듈의 이름 공간, 과 내장 이름 공간, 모듈
"builtins" 의 이름 공간, 을 검색한다는 뜻입니다. 전역 이름 공간이 먼저
검색됩니다. 거기에서 이름이 발견되지 않으면, 내장 이름 공간을 다음에
검색합니다. 내장 이름 공간에서도 이름이 발견되지 않으면, 전역 이름 공
간에 새 변수가 만들어집니다. global 문은 나열된 이름을 사용하기 전에
나와야 합니다.

"global" 문은 같은 블록의 이름 연결 연산과 같은 스코프를 갖습니다. 자
유 변수의 경우 가장 가까이서 둘러싸는 스코프가 global 문을 포함한다면,
그 자유 변수는 전역으로 취급됩니다.

"nonlocal" 문은 대응하는 이름이 가장 가까이서 둘러싸는 함수 스코프에서
이미 연결된 이름을 가리키도록 만듭니다. 만약 주어진 이름이 둘러싸는 함
수 스코프 어디에도 없다면 컴파일 시점에 "SyntaxError" 를 일으킵니다.
형 매개 변수는 "nonlocal" 문으로 재연결할 수 없습니다.

모듈의 이름 공간은 모듈이 처음 임포트될 때 자동으로 만들어집니다. 스크
립트의 메인 모듈은 항상 "__main__" 이라고 불립니다.

클래스 정의 블록과 "exec()" 와 "eval()" 로 전달되는 인자는 특별한 이름
검색 문맥을 갖습니다. 클래스 정의는 이름을 사용하고 정의할 수 있는 실
행 가능한 문장입니다. 이 참조들은 연결되지 않은 지역 변수를 전역 이름
공간에서 찾는다는 점을 제외하고는 이름 검색의 일반적인 규칙을 따릅니다
. 클래스 정의의 이름 공간은 클래스의 어트리뷰트 딕셔너리가 됩니다. 클
래스 블록에서 정의된 이름들의 스코프는 클래스 블록으로 제한됩니다; 메
서드들의 코드 블록으로 확대되지 않습니다. 이것은 컴프리헨션과 제너레이
터 표현을 포함하지만, 둘러싸는 클래스 스코프에 액세스하는 어노테이션
스코프는 포함하지 않습니다. 이것은 다음과 같은 것이 실패한다는 뜻입니
다:

   class A:
       a = 42
       b = list(a + i for i in range(10))

However, the following will succeed:

   class A:
       type Alias = Nested
       class Nested: pass

   print(A.Alias.__value__)  # <type 'A.Nested'>


4.2.3. Annotation scopes
------------------------

*Annotations*, type parameter lists and "type" statements introduce
*annotation scopes*, which behave mostly like function scopes, but
with some exceptions discussed below.

Annotation scopes are used in the following contexts:

* *Function annotations*.

* *Variable annotations*.

* Type parameter lists for generic type aliases.

* Type parameter lists for generic functions. A generic function's
  annotations are executed within the annotation scope, but its
  defaults and decorators are not.

* Type parameter lists for generic classes. A generic class's base
  classes and keyword arguments are executed within the annotation
  scope, but its decorators are not.

* The bounds, constraints, and default values for type parameters
  (lazily evaluated).

* The value of type aliases (lazily evaluated).

Annotation scopes differ from function scopes in the following ways:

* Annotation scopes have access to their enclosing class namespace. If
  an annotation scope is immediately within a class scope, or within
  another annotation scope that is immediately within a class scope,
  the code in the annotation scope can use names defined in the class
  scope as if it were executed directly within the class body. This
  contrasts with regular functions defined within classes, which
  cannot access names defined in the class scope.

* Expressions in annotation scopes cannot contain "yield", "yield
  from", "await", or ":=" expressions. (These expressions are allowed
  in other scopes contained within the annotation scope.)

* Names defined in annotation scopes cannot be rebound with "nonlocal"
  statements in inner scopes. This includes only type parameters, as
  no other syntactic elements that can appear within annotation scopes
  can introduce new names.

* While annotation scopes have an internal name, that name is not
  reflected in the *qualified name* of objects defined within the
  scope. Instead, the "__qualname__" of such objects is as if the
  object were defined in the enclosing scope.

Added in version 3.12: Annotation scopes were introduced in Python
3.12 as part of **PEP 695**.

버전 3.13에서 변경: Annotation scopes are also used for type parameter
defaults, as introduced by **PEP 696**.

버전 3.14에서 변경: Annotation scopes are now also used for
annotations, as specified in **PEP 649** and **PEP 749**.


4.2.4. Lazy evaluation
----------------------

Most annotation scopes are *lazily evaluated*. This includes
annotations, the values of type aliases created through the "type"
statement, and the bounds, constraints, and default values of type
variables created through the type parameter syntax. This means that
they are not evaluated when the type alias or type variable is
created, or when the object carrying annotations is created. Instead,
they are only evaluated when necessary, for example when the
"__value__" attribute on a type alias is accessed.

Example:

   >>> type Alias = 1/0
   >>> Alias.__value__
   Traceback (most recent call last):
     ...
   ZeroDivisionError: division by zero
   >>> def func[T: 1/0](): pass
   >>> T = func.__type_params__[0]
   >>> T.__bound__
   Traceback (most recent call last):
     ...
   ZeroDivisionError: division by zero

Here the exception is raised only when the "__value__" attribute of
the type alias or the "__bound__" attribute of the type variable is
accessed.

This behavior is primarily useful for references to types that have
not yet been defined when the type alias or type variable is created.
For example, lazy evaluation enables creation of mutually recursive
type aliases:

   from typing import Literal

   type SimpleExpr = int | Parenthesized
   type Parenthesized = tuple[Literal["("], Expr, Literal[")"]]
   type Expr = SimpleExpr | tuple[SimpleExpr, Literal["+", "-"], Expr]

Lazily evaluated values are evaluated in annotation scope, which means
that names that appear inside the lazily evaluated value are looked up
as if they were used in the immediately enclosing scope.

Added in version 3.12.


4.2.5. builtins 와 제한된 실행
------------------------------

사용자는 "__builtins__" 를 건드리지 말아야 합니다; 이것은 구현 세부사
항입니다. 내장 이름 공간의 값을 변경하고 싶은 사용자는 "builtins" 모듈
을 "import" 하고 그것의 어트리뷰트를 적절하게 수정해야 합니다.

코드 블록의 실행과 연관된 내장 이름 공간은, 사실 전역 이름 공간의 이름
"__builtins__" 를 조회함으로써 발견됩니다. 이것은 딕셔너리나 모듈이어
야 합니다(후자의 경우 모듈의 딕셔너리가 사용됩니다). 기본적으로,
"__main__" 모듈에 있을 때는 "__builtins__" 가 내장 모듈 "builtins" 이
고, 다른 모듈에 있을 때는 "__builtins__" 는 "builtins" 모듈의 딕셔너리
에 대한 별칭입니다.


4.2.6. 동적 기능과의 상호작용
-----------------------------

자유 변수에 대해 이름 검색은 컴파일 시점이 아니라 실행 시점에 이루어집
니다. 이것은 다음과 같은 코드가 42를 출력한다는 것을 뜻합니다:

   i = 10
   def f():
       print(i)
   i = 42
   f()

"eval()" 과 "exec()" 함수는 이름 검색을 위한 완전한 환경에 대한 접근권
이 없습니다. 이름은 호출자의 지역과 전역 이름 공간에서 검색될 수 있습
니다. 자유 변수는 가장 가까이 둘러싼 이름 공간이 아니라 전역 이름 공간
에서 검색됩니다. [1] "exec()" 과 "eval()" 함수에는 전역과 지역 이름 공
간을 재정의할 수 있는 생략 가능한 인자가 있습니다. 만약 단지 한 이름
공간만 주어지면, 그것이 두 가지 모두로 사용됩니다.


4.3. 예외
=========

예외는 에러나 예외적인 조건을 처리하기 위해 코드 블록의 일반적인 제어
흐름을 깨는 수단입니다. 에러가 감지된 지점에서 예외를 *일으킵니다
(raised)*; 둘러싼 코드 블록이나 직접적 혹은 간접적으로 에러가 발생한
코드 블록을 호출한 어떤 코드 블록에서건 예외는 처리될 수 있습니다.

파이썬 인터프리터는 실행 시간 에러(0으로 나누는 것 같은)를 감지할 때
예외를 일으킵니다. 파이썬 프로그램은 "raise" 문을 사용해서 명시적으로
예외를 일으킬 수 있습니다. 예외 처리기는 "try" ... "except" 문으로 지
정됩니다. 그런 문장에서 "finally" 구는 정리(cleanup) 코드를 지정하는
데 사용되는데, 예외를 처리하는 것이 아니라 앞선 코드에서 예외가 발생하
건 그렇지 않건 실행됩니다.

파이썬은 에러 처리에 "종결 (termination)" 모델을 사용합니다; 예외 처리
기가 뭐가 발생했는지 발견할 수 있고, 바깥 단계에서 실행을 계속할 수는
있지만, 에러의 원인을 제거한 후에 실패한 연산을 재시도할 수는 없습니다
(문제의 코드 조각을 처음부터 다시 시작시키는 것은 예외입니다).

예외가 어디서도 처리되지 않을 때, 인터프리터는 프로그램의 실행을 종료
하거나, 대화형 메인 루프로 돌아갑니다. 두 경우 모두, 예외가
"SystemExit" 인 경우를 제외하고, 스택 트레이스백을 인쇄합니다.

예외는 클래스 인스턴스로 구분됩니다. "except" 절은 인스턴스의 클래스에
따라 선택됩니다: 인스턴스의 클래스나 그것의 *비가상(non-virtual) 베이
스 클래스*를 가리켜야 합니다. 인스턴스는 핸들러가 수신할 수 있고 예외
적인 조건에 대한 추가적인 정보를 포함할 수 있습니다.

참고:

  예외 메시지는 파이썬 API 일부가 아닙니다. 그 내용은 파이썬의 버전이
  바뀔 때 경고 없이 변경될 수 있고, 코드는 여러 버전의 인터프리터에서
  실행될 수 있는 코드는 이것에 의존하지 말아야 합니다.

섹션 try 문 에서 "try" 문, raise 문 에서 "raise" 문에 대한 설명이 제공
됩니다.


4.4. Runtime Components
=======================


4.4.1. General Computing Model
------------------------------

Python's execution model does not operate in a vacuum.  It runs on a
host machine and through that host's runtime environment, including
its operating system (OS), if there is one.  When a program runs, the
conceptual layers of how it runs on the host look something like this:

      **host machine**
         **process** (global resources)
            **thread** (runs machine code)

Each process represents a program running on the host.  Think of each
process itself as the data part of its program.  Think of the process'
threads as the execution part of the program.  This distinction will
be important to understand the conceptual Python runtime.

The process, as the data part, is the execution context in which the
program runs.  It mostly consists of the set of resources assigned to
the program by the host, including memory, signals, file handles,
sockets, and environment variables.

Processes are isolated and independent from one another.  (The same is
true for hosts.)  The host manages the process' access to its assigned
resources, in addition to coordinating between processes.

Each thread represents the actual execution of the program's machine
code, running relative to the resources assigned to the program's
process.  It's strictly up to the host how and when that execution
takes place.

From the point of view of Python, a program always starts with exactly
one thread.  However, the program may grow to run in multiple
simultaneous threads.  Not all hosts support multiple threads per
process, but most do.  Unlike processes, threads in a process are not
isolated and independent from one another.  Specifically, all threads
in a process share all of the process' resources.

The fundamental point of threads is that each one does *run*
independently, at the same time as the others.  That may be only
conceptually at the same time ("concurrently") or physically ("in
parallel").  Either way, the threads effectively run at a non-
synchronized rate.

참고:

  That non-synchronized rate means none of the process' memory is
  guaranteed to stay consistent for the code running in any given
  thread.  Thus multi-threaded programs must take care to coordinate
  access to intentionally shared resources.  Likewise, they must take
  care to be absolutely diligent about not accessing any *other*
  resources in multiple threads; otherwise two threads running at the
  same time might accidentally interfere with each other's use of some
  shared data.  All this is true for both Python programs and the
  Python runtime.The cost of this broad, unstructured requirement is
  the tradeoff for the kind of raw concurrency that threads provide.
  The alternative to the required discipline generally means dealing
  with non-deterministic bugs and data corruption.


4.4.2. Python Runtime Model
---------------------------

The same conceptual layers apply to each Python program, with some
extra data layers specific to Python:

      **host machine**
         **process** (global resources)
            Python global runtime (*state*)
               Python interpreter (*state*)
                  **thread** (runs Python bytecode and "C-API")
                     Python thread *state*

At the conceptual level: when a Python program starts, it looks
exactly like that diagram, with one of each.  The runtime may grow to
include multiple interpreters, and each interpreter may grow to
include multiple thread states.

참고:

  A Python implementation won't necessarily implement the runtime
  layers distinctly or even concretely.  The only exception is places
  where distinct layers are directly specified or exposed to users,
  like through the "threading" module.

참고:

  The initial interpreter is typically called the "main" interpreter.
  Some Python implementations, like CPython, assign special roles to
  the main interpreter.Likewise, the host thread where the runtime was
  initialized is known as the "main" thread.  It may be different from
  the process' initial thread, though they are often the same.  In
  some cases "main thread" may be even more specific and refer to the
  initial thread state. A Python runtime might assign specific
  responsibilities to the main thread, such as handling signals.

As a whole, the Python runtime consists of the global runtime state,
interpreters, and thread states.  The runtime ensures all that state
stays consistent over its lifetime, particularly when used with
multiple host threads.

The global runtime, at the conceptual level, is just a set of
interpreters.  While those interpreters are otherwise isolated and
independent from one another, they may share some data or other
resources.  The runtime is responsible for managing these global
resources safely.  The actual nature and management of these resources
is implementation-specific.  Ultimately, the external utility of the
global runtime is limited to managing interpreters.

In contrast, an "interpreter" is conceptually what we would normally
think of as the (full-featured) "Python runtime".  When machine code
executing in a host thread interacts with the Python runtime, it calls
into Python in the context of a specific interpreter.

참고:

  The term "interpreter" here is not the same as the "bytecode
  interpreter", which is what regularly runs in threads, executing
  compiled Python code.In an ideal world, "Python runtime" would refer
  to what we currently call "interpreter".  However, it's been called
  "interpreter" at least since introduced in 1997 (CPython:a027efa5b).

Each interpreter completely encapsulates all of the non-process-
global, non-thread-specific state needed for the Python runtime to
work. Notably, the interpreter's state persists between uses.  It
includes fundamental data like "sys.modules".  The runtime ensures
multiple threads using the same interpreter will safely share it
between them.

A Python implementation may support using multiple interpreters at the
same time in the same process.  They are independent and isolated from
one another.  For example, each interpreter has its own "sys.modules".

For thread-specific runtime state, each interpreter has a set of
thread states, which it manages, in the same way the global runtime
contains a set of interpreters.  It can have thread states for as many
host threads as it needs.  It may even have multiple thread states for
the same host thread, though that isn't as common.

Each thread state, conceptually, has all the thread-specific runtime
data an interpreter needs to operate in one host thread.  The thread
state includes the current raised exception and the thread's Python
call stack.  It may include other thread-specific resources.

참고:

  The term "Python thread" can sometimes refer to a thread state, but
  normally it means a thread created using the "threading" module.

Each thread state, over its lifetime, is always tied to exactly one
interpreter and exactly one host thread.  It will only ever be used in
that thread and with that interpreter.

Multiple thread states may be tied to the same host thread, whether
for different interpreters or even the same interpreter.  However, for
any given host thread, only one of the thread states tied to it can be
used by the thread at a time.

Thread states are isolated and independent from one another and don't
share any data, except for possibly sharing an interpreter and objects
or other resources belonging to that interpreter.

Once a program is running, new Python threads can be created using the
"threading" module (on platforms and Python implementations that
support threads).  Additional processes can be created using the "os",
"subprocess", and "multiprocessing" modules. Interpreters can be
created and used with the "interpreters" module.  Coroutines (async)
can be run using "asyncio" in each interpreter, typically only in a
single thread (often the main thread).

-[ 각주 ]-

[1] 이 한계는 이 연산들 때문에 실행되는 코드가 모듈이 컴파일되는 시점
    에는 존재하지 않았기 때문입니다.
