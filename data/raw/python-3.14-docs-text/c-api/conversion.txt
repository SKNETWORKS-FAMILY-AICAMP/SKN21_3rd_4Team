문자열 변환과 포매팅
********************

숫자 변환과 포맷된 문자열 출력을 위한 함수.

int PyOS_snprintf(char *str, size_t size, const char *format, ...)
    * Part of the 안정 ABI.*

   포맷 문자열 *format* 과 추가 인자에 따라 *size* 바이트를 넘지 않도
   록 *str*로 출력합니다. 유닉스 매뉴얼 페이지 *snprintf(3)*를 보십시
   오.

int PyOS_vsnprintf(char *str, size_t size, const char *format, va_list va)
    * Part of the 안정 ABI.*

   포맷 문자열 *format* 과 가변 인자 목록 *va*에 따라 *size* 바이트를
   넘지 않도록 *str*로 출력합니다. 유닉스 매뉴얼 페이지 *vsnprintf(3)*
   를 보십시오.

"PyOS_snprintf()"와 "PyOS_vsnprintf()"는 표준 C 라이브러리 함수
"snprintf()"와 "vsnprintf()"를 감쌉니다. 그들의 목적은 경계 조건에서
표준 C 함수가 제공하지 않는 수준의 일관된 동작을 보장하는 것입니다.

래퍼는 반환 시 "str[size-1]"이 항상 "'\0'"이 되도록 합니다. str에
*size* 바이트(후행 "'\0'" 포함)를 초과해서 쓰지 않습니다. 두 함수 모두
"str != NULL", "size > 0", "format != NULL" 및 "size < INT_MAX"를 요구
합니다. 이는 필요한 버퍼 크기를 결정하는 C99 "n = snprintf(NULL, 0,
...)"에 해당하는 것이 없다는 뜻임에 유의하십시오.

이 함수들의 반환 값(*rv*)은 다음과 같이 해석되어야 합니다:

* "0 <= rv < size" 일 때, 출력 변환에 성공했으며 *rv* 문자가 *str*에
  기록되었습니다 ("str[rv]"의 후행 "'\0'" 바이트 제외).

* "rv >= size" 일 때, 출력 변환이 잘렸고 성공하려면 "rv + 1" 바이트의
  버퍼가 필요합니다. "str[size-1]"은 이때 "'\0'"입니다.

* When "rv < 0", the output conversion failed and "str[size-1]" is
  "'\0'" in this case too, but the rest of *str* is undefined. The
  exact cause of the error depends on the underlying platform.

다음 함수는 로케일 독립적인 문자열에서 숫자로의 변환을 제공합니다.

unsigned long PyOS_strtoul(const char *str, char **ptr, int base)
    * Part of the 안정 ABI.*

   Convert the initial part of the string in "str" to an unsigned long
   value according to the given "base", which must be between "2" and
   "36" inclusive, or be the special value "0".

   Leading white space and case of characters are ignored.  If "base"
   is zero it looks for a leading "0b", "0o" or "0x" to tell which
   base.  If these are absent it defaults to "10".  Base must be 0 or
   between 2 and 36 (inclusive).  If "ptr" is non-"NULL" it will
   contain a pointer to the end of the scan.

   If the converted value falls out of range of corresponding return
   type, range error occurs ("errno" is set to "ERANGE") and
   "ULONG_MAX" is returned.  If no conversion can be performed, "0" is
   returned.

   See also the Unix man page *strtoul(3)*.

   Added in version 3.2.

long PyOS_strtol(const char *str, char **ptr, int base)
    * Part of the 안정 ABI.*

   Convert the initial part of the string in "str" to an long value
   according to the given "base", which must be between "2" and "36"
   inclusive, or be the special value "0".

   Same as "PyOS_strtoul()", but return a long value instead and
   "LONG_MAX" on overflows.

   See also the Unix man page *strtol(3)*.

   Added in version 3.2.

double PyOS_string_to_double(const char *s, char **endptr, PyObject *overflow_exception)
    * Part of the 안정 ABI.*

   문자열 "s"를 double로 변환하고, 실패 시 파이썬 예외를 발생시킵니다.
   허용되는 문자열 집합은 "s"가 선행이나 후행 공백을 가질 수 없다는 점
   을 제외하고는 파이썬의 "float()" 생성자가 허용하는 문자열 집합에 대
   응합니다. 변환은 현재 로케일과 독립적입니다.

   "endptr"이 "NULL"이면, 전체 문자열을 변환합니다. 문자열이 부동 소수
   점 숫자의 유효한 표현이 아니면 "ValueError"를 발생시키고 "-1.0"을
   반환합니다.

   endptr이 "NULL"이 아니면, 가능한 한 많은 문자열을 변환하고
   "*endptr"이 변환되지 않은 첫 번째 문자를 가리키도록 설정합니다. 문
   자열의 초기 세그먼트가 부동 소수점 숫자의 유효한 표현이 아니면,
   "*endptr"이 문자열의 시작을 가리키도록 설정하고, ValueError를 발생
   시키고 "-1.0"을 반환합니다.

   If "s" represents a value that is too large to store in a float
   (for example, ""1e500"" is such a string on many platforms) then if
   "overflow_exception" is "NULL" return "Py_INFINITY" (with an
   appropriate sign) and don't set any exception.  Otherwise,
   "overflow_exception" must point to a Python exception object; raise
   that exception and return "-1.0".  In both cases, set "*endptr" to
   point to the first character after the converted value.

   변환 중 다른 에러가 발생하면 (예를 들어 메모리 부족 에러), 적절한
   파이썬 예외를 설정하고 "-1.0"을 반환합니다.

   Added in version 3.1.

char *PyOS_double_to_string(double val, char format_code, int precision, int flags, int *ptype)
    * Part of the 안정 ABI.*

   제공된 *format_code*, *precision* 및 *flags*를 사용하여 double
   *val*을 문자열로 변환합니다.

   *format_code*는 "'e'", "'E'", "'f'", "'F'", "'g'", "'G'" 또는 "'r'"
   중 하나여야 합니다. "'r'"의 경우, 제공된 *precision*은 0이어야 하며
   무시됩니다. "'r'" 포맷 코드는 표준 "repr()" 형식을 지정합니다.

   *flags* can be zero or more of the following values or-ed together:

   Py_DTSF_SIGN

      Always precede the returned string with a sign character, even
      if *val* is non-negative.

   Py_DTSF_ADD_DOT_0

      Ensure that the returned string will not look like an integer.

   Py_DTSF_ALT

      Apply "alternate" formatting rules. See the documentation for
      the "PyOS_snprintf()" "'#'" specifier for details.

   Py_DTSF_NO_NEG_0

      Negative zero is converted to positive zero.

      Added in version 3.11.

   *ptype*이 "NULL"이 아니면, 포인터가 가리키는 값은 "Py_DTST_FINITE",
   "Py_DTST_INFINITE" 또는 "Py_DTST_NAN" 중 하나로 설정되어, *val*가
   각각 유한 수, 무한 수 또는 NaN임을 나타냅니다.

   반환 값은 변환된 문자열이 있는 *buffer*에 대한 포인터이거나, 변환에
   실패하면 "NULL"입니다. 호출자는 "PyMem_Free()"를 호출하여 반환된 문
   자열을 해제해야 합니다.

   Added in version 3.1.

int PyOS_mystricmp(const char *str1, const char *str2)
int PyOS_mystrnicmp(const char *str1, const char *str2, Py_ssize_t size)
    * Part of the 안정 ABI.*

   Case insensitive comparison of strings. These functions work almost
   identically to "strcmp()" and "strncmp()" (respectively), except
   that they ignore the case of ASCII characters.

   Return "0" if the strings are equal, a negative value if *str1*
   sorts lexicographically before *str2*, or a positive value if it
   sorts after.

   In the *str1* or *str2* arguments, a NUL byte marks the end of the
   string. For "PyOS_mystrnicmp()", the *size* argument gives the
   maximum size of the string, as if NUL was present at the index
   given by *size*.

   These functions do not use the locale.

int PyOS_stricmp(const char *str1, const char *str2)
int PyOS_strnicmp(const char *str1, const char *str2, Py_ssize_t size)

   Case insensitive comparison of strings.

   On Windows, these are aliases of "stricmp()" and "strnicmp()",
   respectively.

   On other platforms, they are aliases of "PyOS_mystricmp()" and
   "PyOS_mystrnicmp()", respectively.


Character classification and conversion
***************************************

The following macros provide locale-independent (unlike the C standard
library "ctype.h") character classification and conversion. The
argument must be a signed or unsigned char.

Py_ISALNUM(c)

   Return true if the character *c* is an alphanumeric character.

Py_ISALPHA(c)

   Return true if the character *c* is an alphabetic character ("a-z"
   and "A-Z").

Py_ISDIGIT(c)

   Return true if the character *c* is a decimal digit ("0-9").

Py_ISLOWER(c)

   Return true if the character *c* is a lowercase ASCII letter
   ("a-z").

Py_ISUPPER(c)

   Return true if the character *c* is an uppercase ASCII letter
   ("A-Z").

Py_ISSPACE(c)

   Return true if the character *c* is a whitespace character (space,
   tab, carriage return, newline, vertical tab, or form feed).

Py_ISXDIGIT(c)

   Return true if the character *c* is a hexadecimal digit ("0-9",
   "a-f", and "A-F").

Py_TOLOWER(c)

   Return the lowercase equivalent of the character *c*.

Py_TOUPPER(c)

   Return the uppercase equivalent of the character *c*.
