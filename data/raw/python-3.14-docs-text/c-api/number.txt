숫자 프로토콜
*************

int PyNumber_Check(PyObject *o)
    * Part of the 안정 ABI.*

   객체 *o*가 숫자 프로토콜을 제공하면 "1"을 반환하고, 그렇지 않으면
   거짓을 반환합니다. 이 함수는 항상 성공합니다.

   버전 3.8에서 변경: *o*가 인덱스 정수면 "1"을 반환합니다.

PyObject *PyNumber_Add(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*과 *o2*를 더한 결과나, 실패 시 "NULL"을 반환합니다. 이것은 파이
   썬 표현식 "o1 + o2"와 동등합니다.

PyObject *PyNumber_Subtract(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*에서 *o2*를 뺀 결과나, 실패 시 "NULL"을 반환합니다. 이것은 파이
   썬 표현식 "o1 - o2"와 동등합니다.

PyObject *PyNumber_Multiply(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*과 *o2*를 곱한 결과나, 실패 시 "NULL"을 반환합니다. 이것은 파이
   썬 표현식 "o1 * o2"와 동등합니다.

PyObject *PyNumber_MatrixMultiply(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI 버전 3.7 이후로.*

   *o1*과 *o2*를 행렬 곱셈한 결과나, 실패 시 "NULL"을 반환합니다. 이것
   은 파이썬 표현식 "o1 @ o2"와 동등합니다.

   Added in version 3.5.

PyObject *PyNumber_FloorDivide(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*을 *o2*로 정수 나눗셈한 몫을, 실패 시 "NULL"을 반환합니다. 이것
   은 파이썬 표현식 "o1 // o2"와 동등합니다.

PyObject *PyNumber_TrueDivide(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*을 *o2*로 나눈 수학적 값의 적절한 근삿값이나, 실패 시 "NULL"을
   반환합니다. 반환 값은 "근사치" 인데, 이진 부동 소수점 수가 근사치이
   기 때문입니다; 이진수로 모든 실수를 표현할 수는 없습니다. 이 함수는
   두 개의 정수를 전달할 때 부동 소수점 수를 반환할 수 있습니다.

PyObject *PyNumber_Remainder(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*을 *o2*로 나눈 나머지나, 실패 시 "NULL"을 반환합니다. 이것은 파
   이썬 표현식 "o1 % o2"와 동등합니다.

PyObject *PyNumber_Divmod(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   내장 함수 "divmod()"를 참조하십시오. 실패하면 "NULL"을 반환합니다.
   이것은 파이썬 표현식 "divmod(o1, o2)"와 동등합니다.

PyObject *PyNumber_Power(PyObject *o1, PyObject *o2, PyObject *o3)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   내장 함수 "pow()"를 참조하십시오. 실패하면 "NULL"을 반환합니다. 이
   것은 파이썬 표현식 "pow(o1, o2, o3)"와 동등합니다, 여기서 *o3*는 선
   택적입니다. *o3*를 무시하려면, 그 자리에 "Py_None"을 전달하십시오
   (*o3*에 "NULL"을 전달하면 잘못된 메모리 액세스가 발생합니다).

PyObject *PyNumber_Negative(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o*의 음의 값(negation)을, 실패 시 "NULL"을 반환합니다. 이
   것은 파이썬 표현식 "-o"와 동등합니다.

PyObject *PyNumber_Positive(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o*를, 실패 시 "NULL"을 반환합니다. 이것은 파이썬 표현식
   "+o"와 동등합니다.

PyObject *PyNumber_Absolute(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o*의 절댓값이나, 실패 시 "NULL"을 반환합니다. 이것은 파이썬 표현식
   "abs(o)"와 동등합니다.

PyObject *PyNumber_Invert(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o*의 비트 반전(bitwise negation)을, 실패 시 "NULL"을 반환
   합니다. 이것은 파이썬 표현식 "~o"와 동등합니다.

PyObject *PyNumber_Lshift(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*을 *o2*만큼 왼쪽으로 시프트 한 결과를, 실패 시 "NULL"을
   반환합니다. 이것은 파이썬 표현식 "o1 << o2"와 동등합니다.

PyObject *PyNumber_Rshift(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*을 *o2*만큼 오른쪽으로 시프트 한 결과를, 실패 시 "NULL"
   을 반환합니다. 이것은 파이썬 표현식 "o1 >> o2"와 동등합니다.

PyObject *PyNumber_And(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*과 *o2*의 "비트별 논리곱(bitwise and)"을, 실패 시
   "NULL"을 반환합니다. 이것은 파이썬 표현식 "o1 & o2"와 동등합니다.

PyObject *PyNumber_Xor(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*과 *o2*의 "비트별 배타적 논리합(bitwise exclusive or)"
   을, 실패 시 "NULL"을 반환합니다. 이것은 파이썬 표현식 "o1 ^ o2"와
   동등합니다.

PyObject *PyNumber_Or(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*과 *o2*의 "비트별 논리합(bitwise or)"을, 실패 시 "NULL"
   을 반환합니다. 이것은 파이썬 표현식 "o1 | o2"와 동등합니다.

PyObject *PyNumber_InPlaceAdd(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*과 *o2*를 더한 결과나, 실패 시 "NULL"을 반환합니다. 이 연산은
   *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 파이썬 문
   장 "o1 += o2"와 동등합니다.

PyObject *PyNumber_InPlaceSubtract(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*에서 *o2*를 뺀 결과나, 실패 시 "NULL"을 반환합니다. 이 연산은
   *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 파이썬 문
   장 "o1 -= o2"와 동등합니다.

PyObject *PyNumber_InPlaceMultiply(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*과 *o2*를 곱한 결과나, 실패 시 "NULL"을 반환합니다. 이 연산은
   *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 파이썬 문
   장 "o1 *= o2"와 동등합니다.

PyObject *PyNumber_InPlaceMatrixMultiply(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI 버전 3.7 이후로.*

   *o1*과 *o2*를 행렬 곱셈한 결과나, 실패 시 "NULL"을 반환합니다. 이
   연산은 *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 파
   이썬 문장 "o1 @= o2"와 동등합니다.

   Added in version 3.5.

PyObject *PyNumber_InPlaceFloorDivide(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*을 *o2*로 나눈 수학적 플로어(floor)나, 실패 시 "NULL"을 반환합
   니다. 이 연산은 *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다.
   이것은 파이썬 문장 "o1 //= o2"와 동등합니다.

PyObject *PyNumber_InPlaceTrueDivide(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*을 *o2*로 나눈 수학적 값의 적절한 근삿값이나, 실패 시 "NULL"을
   반환합니다. 반환 값은 "근사치" 인데, 이진 부동 소수점 수가 근사치이
   기 때문입니다; 이진수로 모든 실수를 표현할 수는 없습니다. 이 함수는
   두 개의 정수를 전달할 때 부동 소수점 수를 반환할 수 있습니다. 이 연
   산은 *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 파이
   썬 문장 "o1 /= o2"와 동등합니다.

PyObject *PyNumber_InPlaceRemainder(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o1*을 *o2*로 나눈 나머지나, 실패 시 "NULL"을 반환합니다. 이 연산은
   *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 파이썬 문
   장 "o1 %= o2"와 동등합니다.

PyObject *PyNumber_InPlacePower(PyObject *o1, PyObject *o2, PyObject *o3)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   내장 함수 "pow()"를 참조하십시오. 실패하면 "NULL"을 반환합니다. 이
   연산은 *o1*이 지원하면 *제자리에서(in-place)* 수행됩니다. 이것은 o3
   가 "Py_None"일 때 파이썬 문장 "o1 **= o2"와, 그렇지 않으면 "pow(o1,
   o2, o3)"의 제자리 변형과 동등합니다. *o3*를 무시하려면, 그 자리에
   "Py_None"을 전달하십시오 (*o3*에 "NULL"을 전달하면 잘못된 메모리 액
   세스가 발생합니다).

PyObject *PyNumber_InPlaceLshift(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*을 *o2*만큼 왼쪽으로 시프트 한 결과를, 실패 시 "NULL"을
   반환합니다. 이 연산은 *o1*이 지원하면 *제자리에서(in-place)* 수행됩
   니다. 이것은 파이썬 문장 "o1 <<= o2"와 동등합니다.

PyObject *PyNumber_InPlaceRshift(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*을 *o2*만큼 오른쪽으로 시프트 한 결과를, 실패 시 "NULL"
   을 반환합니다. 이 연산은 *o1*이 지원하면 *제자리에서(in-place)* 수
   행됩니다. 이것은 파이썬 문장 "o1 >>= o2"와 동등합니다.

PyObject *PyNumber_InPlaceAnd(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*과 *o2*의 "비트별 논리곱(bitwise and)"을, 실패 시
   "NULL"을 반환합니다. 이 연산은 *o1*이 지원하면 *제자리에서(in-
   place)* 수행됩니다. 이것은 파이썬 문장 "o1 &= o2"와 동등합니다.

PyObject *PyNumber_InPlaceXor(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*과 *o2*의 "비트별 배타적 논리합(bitwise exclusive or)"
   을, 실패 시 "NULL"을 반환합니다. 이 연산은 *o1*이 지원하면 *제자리
   에서(in-place)* 수행됩니다. 이것은 파이썬 문장 "o1 ^= o2"와 동등합
   니다.

PyObject *PyNumber_InPlaceOr(PyObject *o1, PyObject *o2)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 *o1*과 *o2*의 "비트별 논리합(bitwise or)"을, 실패 시 "NULL"
   을 반환합니다. 이 연산은 *o1*이 지원하면 *제자리에서(in-place)* 수
   행됩니다. 이것은 파이썬 문장 "o1 |= o2"와 동등합니다.

PyObject *PyNumber_Long(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 정수 객체로 변환된 *o*를, 실패 시 "NULL"을 반환합니다. 이것
   은 파이썬 표현식 "int(o)"와 동등합니다.

PyObject *PyNumber_Float(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 float 객체로 변환된 *o*를, 실패 시 "NULL"을 반환합니다. 이
   것은 파이썬 표현식 "float(o)"와 동등합니다.

PyObject *PyNumber_Index(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   성공 시 파이썬 int로 변환된 *o*를, 실패 시 "NULL"을 반환합니다. 실
   패 시 "TypeError" 예외가 발생합니다.

   버전 3.10에서 변경: The result always has exact type "int".
   Previously, the result could have been an instance of a subclass of
   "int".

PyObject *PyNumber_ToBase(PyObject *n, int base)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   정수 *n*을 진수 *base*를 사용해서 변환한 문자열을 반환합니다.
   *base* 인자는 2, 8, 10 또는 16중 하나여야 합니다. 진수 2, 8 또는 16
   의 경우, 반환된 문자열은 "'0b'", "'0o'" 또는 "'0x'"의 진수 표시자가
   각각 앞에 붙습니다. *n*이 파이썬 int가 아니면, 먼저
   "PyNumber_Index()"로 변환됩니다.

Py_ssize_t PyNumber_AsSsize_t(PyObject *o, PyObject *exc)
    * Part of the 안정 ABI.*

   *o*가 정수로 해석될 수 있으면, *o*를 "Py_ssize_t" 값으로 변환하여
   반환합니다. 호출이 실패하면, 예외가 발생하고 "-1"이 반환됩니다.

   *o*가 파이썬 int로 변환될 수 있지만 "Py_ssize_t" 값으로 변환하려는
   시도가 "OverflowError"를 발생시키면, *exc* 인자는 발생할 예외의 형(
   일반적으로 "IndexError"나 "OverflowError")입니다. *exc*가 "NULL"이
   면, 예외가 지워지고 값은 음의 정수는 "PY_SSIZE_T_MIN"으로, 양의 정
   수는 "PY_SSIZE_T_MAX"로 잘립니다.

int PyIndex_Check(PyObject *o)
    * Part of the 안정 ABI 버전 3.8 이후로.*

   *o*가 인덱스 정수("tp_as_number" 구조의 "nb_index" 슬롯이 채워져 있
   습니다)면 "1"을 반환하고, 그렇지 않으면 "0"을 반환합니다. 이 함수는
   항상 성공합니다.
