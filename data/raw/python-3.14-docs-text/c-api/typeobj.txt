Type Object Structures
**********************

Perhaps one of the most important structures of the Python object
system is the structure that defines a new type: the "PyTypeObject"
structure.  Type objects can be handled using any of the "PyObject_*"
or "PyType_*" functions, but do not offer much that's interesting to
most Python applications. These objects are fundamental to how objects
behave, so they are very important to the interpreter itself and to
any extension module that implements new types.

형 객체는 대부분 표준형보다 상당히 큽니다. 크기가 큰 이유는 각 형 객체
가 많은 수의 값을 저장하기 때문인데, 주로 C 함수 포인터이고 각기 형의
기능 중 작은 부분을 구현합니다. 이 섹션에서는 형 객체의 필드를 자세히
살펴봅니다. 필드는 구조체에서 나타나는 순서대로 설명됩니다.

다음의 간략 참조 외에도, 예 섹션은 "PyTypeObject"의 의미와 사용에 대한
통찰을 제공합니다.


간략 참조
=========


"tp 슬롯"
---------

+--------------------+--------------------+--------------------+----+----+----+----+
| PyTypeObject 슬롯  | 형                 | 특수 메서드/어트리 | 정보 [2]          |
| [1]                |                    | 뷰트               |                   |
|                    |                    |                    +----+----+----+----+
|                    |                    |                    | O  | T  | D  | I  |
|                    |                    |                    |    |    |    |    |
|====================|====================|====================|====|====|====|====|
| <R> "tp_name"      | const char *       | __name__           | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_basicsize"     | "Py_ssize_t"       |                    | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_itemsize"      | "Py_ssize_t"       |                    |    | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_dealloc"       | "destructor"       |                    | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_vectorcall_off | "Py_ssize_t"       |                    |    | X  |    | X  |
| set"               |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_getattr")     | "getattrfunc"      | __getattribute__,  |    |    |    | G  |
|                    |                    | __getattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_setattr")     | "setattrfunc"      | __setattr__,       |    |    |    | G  |
|                    |                    | __delattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_async"      | "PyAsyncMethods" * | 서브 슬롯          |    |    |    | %  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_repr"          | "reprfunc"         | __repr__           | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_number"     | "PyNumberMethods"  | 서브 슬롯          |    |    |    | %  |
|                    | *                  |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_sequence"   | "PySequenceMethods | 서브 슬롯          |    |    |    | %  |
|                    | " *                |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_mapping"    | "PyMappingMethods" | 서브 슬롯          |    |    |    | %  |
|                    | *                  |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_hash"          | "hashfunc"         | __hash__           | X  |    |    | G  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_call"          | "ternaryfunc"      | __call__           |    | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_str"           | "reprfunc"         | __str__            | X  |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_getattro"      | "getattrofunc"     | __getattribute__,  | X  | X  |    | G  |
|                    |                    | __getattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_setattro"      | "setattrofunc"     | __setattr__,       | X  | X  |    | G  |
|                    |                    | __delattr__        |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_as_buffer"     | "PyBufferProcs" *  | 서브 슬롯          |    |    |    | %  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_flags"         | unsigned long      |                    | X  | X  |    | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_doc"           | const char *       | __doc__            | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_traverse"      | "traverseproc"     |                    |    | X  |    | G  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_clear"         | "inquiry"          |                    |    | X  |    | G  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_richcompare"   | "richcmpfunc"      | __lt__, __le__,    | X  |    |    | G  |
|                    |                    | __eq__, __ne__,    |    |    |    |    |
|                    |                    | __gt__, __ge__     |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_weaklistoffse | "Py_ssize_t"       |                    |    | X  |    | ?  |
| t")                |                    |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_iter"          | "getiterfunc"      | __iter__           |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_iternext"      | "iternextfunc"     | __next__           |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_methods"       | "PyMethodDef" []   |                    | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_members"       | "PyMemberDef" []   |                    |    | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_getset"        | "PyGetSetDef" []   |                    | X  | X  |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_base"          | "PyTypeObject" *   | __base__           |    |    | X  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_dict"          | "PyObject" *       | __dict__           |    |    | ?  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_descr_get"     | "descrgetfunc"     | __get__            |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_descr_set"     | "descrsetfunc"     | __set__,           |    |    |    | X  |
|                    |                    | __delete__         |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_dictoffset")  | "Py_ssize_t"       |                    |    | X  |    | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_init"          | "initproc"         | __init__           | X  | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_alloc"         | "allocfunc"        |                    | X  |    | ?  | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_new"           | "newfunc"          | __new__            | X  | X  | ?  | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_free"          | "freefunc"         |                    | X  | X  | ?  | ?  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_is_gc"         | "inquiry"          |                    |    | X  |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| <"tp_bases">       | "PyObject" *       | __bases__          |    |    | ~  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| <"tp_mro">         | "PyObject" *       | __mro__            |    |    | ~  |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_cache"]       | "PyObject" *       |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_subclasses"]  | void *             | __subclasses__     |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_weaklist"]    | "PyObject" *       |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| ("tp_del")         | "destructor"       |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_version_tag"] | unsigned int       |                    |    |    |         |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_finalize"      | "destructor"       | __del__            |    |    |    | X  |
+--------------------+--------------------+--------------------+----+----+----+----+
| "tp_vectorcall"    | "vectorcallfunc"   |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+
| ["tp_watched"]     | unsigned char      |                    |    |    |    |    |
+--------------------+--------------------+--------------------+----+----+----+----+

[1] **()**: A slot name in parentheses indicates it is (effectively)
    deprecated.

    **<>**: Names in angle brackets should be initially set to "NULL"
    and treated as read-only.

    **[]**: Names in square brackets are for internal use only.

    **<R>** (as a prefix) means the field is required (must be
    non-"NULL").

[2] 열:

    **"O"**:  set on "PyBaseObject_Type"

    **"T"**:  set on "PyType_Type"

    **"D"**: 기본값 (슬롯이 "NULL"로 설정된 경우)

       X - PyType_Ready sets this value if it is NULL
       ~ - PyType_Ready always sets this value (it should be NULL)
       ? - PyType_Ready may set this value depending on other slots

       Also see the inheritance column ("I").

    **"I"**: 상속

       X - type slot is inherited via *PyType_Ready* if defined with a *NULL* value
       % - the slots of the sub-struct are inherited individually
       G - inherited, but only in combination with other slots; see the slot's description
       ? - it's complicated; see the slot's description

    일부 슬롯은 일반 어트리뷰트 조회 체인을 통해 효과적으로 상속됨에
    유의하십시오.


서브 슬롯
---------

+----------------------------+-------------------+--------------+
| 슬롯                       | 형                | 특수 메서드  |
|============================|===================|==============|
| "am_await"                 | "unaryfunc"       | __await__    |
+----------------------------+-------------------+--------------+
| "am_aiter"                 | "unaryfunc"       | __aiter__    |
+----------------------------+-------------------+--------------+
| "am_anext"                 | "unaryfunc"       | __anext__    |
+----------------------------+-------------------+--------------+
| "am_send"                  | "sendfunc"        |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "nb_add"                   | "binaryfunc"      | __add__      |
|                            |                   | __radd__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_add"           | "binaryfunc"      | __iadd__     |
+----------------------------+-------------------+--------------+
| "nb_subtract"              | "binaryfunc"      | __sub__      |
|                            |                   | __rsub__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_subtract"      | "binaryfunc"      | __isub__     |
+----------------------------+-------------------+--------------+
| "nb_multiply"              | "binaryfunc"      | __mul__      |
|                            |                   | __rmul__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_multiply"      | "binaryfunc"      | __imul__     |
+----------------------------+-------------------+--------------+
| "nb_remainder"             | "binaryfunc"      | __mod__      |
|                            |                   | __rmod__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_remainder"     | "binaryfunc"      | __imod__     |
+----------------------------+-------------------+--------------+
| "nb_divmod"                | "binaryfunc"      | __divmod__   |
|                            |                   | __rdivmod__  |
+----------------------------+-------------------+--------------+
| "nb_power"                 | "ternaryfunc"     | __pow__      |
|                            |                   | __rpow__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_power"         | "ternaryfunc"     | __ipow__     |
+----------------------------+-------------------+--------------+
| "nb_negative"              | "unaryfunc"       | __neg__      |
+----------------------------+-------------------+--------------+
| "nb_positive"              | "unaryfunc"       | __pos__      |
+----------------------------+-------------------+--------------+
| "nb_absolute"              | "unaryfunc"       | __abs__      |
+----------------------------+-------------------+--------------+
| "nb_bool"                  | "inquiry"         | __bool__     |
+----------------------------+-------------------+--------------+
| "nb_invert"                | "unaryfunc"       | __invert__   |
+----------------------------+-------------------+--------------+
| "nb_lshift"                | "binaryfunc"      | __lshift__   |
|                            |                   | __rlshift__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_lshift"        | "binaryfunc"      | __ilshift__  |
+----------------------------+-------------------+--------------+
| "nb_rshift"                | "binaryfunc"      | __rshift__   |
|                            |                   | __rrshift__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_rshift"        | "binaryfunc"      | __irshift__  |
+----------------------------+-------------------+--------------+
| "nb_and"                   | "binaryfunc"      | __and__      |
|                            |                   | __rand__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_and"           | "binaryfunc"      | __iand__     |
+----------------------------+-------------------+--------------+
| "nb_xor"                   | "binaryfunc"      | __xor__      |
|                            |                   | __rxor__     |
+----------------------------+-------------------+--------------+
| "nb_inplace_xor"           | "binaryfunc"      | __ixor__     |
+----------------------------+-------------------+--------------+
| "nb_or"                    | "binaryfunc"      | __or__       |
|                            |                   | __ror__      |
+----------------------------+-------------------+--------------+
| "nb_inplace_or"            | "binaryfunc"      | __ior__      |
+----------------------------+-------------------+--------------+
| "nb_int"                   | "unaryfunc"       | __int__      |
+----------------------------+-------------------+--------------+
| "nb_reserved"              | void *            |              |
+----------------------------+-------------------+--------------+
| "nb_float"                 | "unaryfunc"       | __float__    |
+----------------------------+-------------------+--------------+
| "nb_floor_divide"          | "binaryfunc"      | __floordiv__ |
+----------------------------+-------------------+--------------+
| "nb_inplace_floor_divide"  | "binaryfunc"      | __ifloordiv_ |
|                            |                   | _            |
+----------------------------+-------------------+--------------+
| "nb_true_divide"           | "binaryfunc"      | __truediv__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_true_divide"   | "binaryfunc"      | __itruediv__ |
+----------------------------+-------------------+--------------+
| "nb_index"                 | "unaryfunc"       | __index__    |
+----------------------------+-------------------+--------------+
| "nb_matrix_multiply"       | "binaryfunc"      | __matmul__   |
|                            |                   | __rmatmul__  |
+----------------------------+-------------------+--------------+
| "nb_inplace_matrix_multipl | "binaryfunc"      | __imatmul__  |
| y"                         |                   |              |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "mp_length"                | "lenfunc"         | __len__      |
+----------------------------+-------------------+--------------+
| "mp_subscript"             | "binaryfunc"      | __getitem__  |
+----------------------------+-------------------+--------------+
| "mp_ass_subscript"         | "objobjargproc"   | __setitem__, |
|                            |                   | __delitem__  |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "sq_length"                | "lenfunc"         | __len__      |
+----------------------------+-------------------+--------------+
| "sq_concat"                | "binaryfunc"      | __add__      |
+----------------------------+-------------------+--------------+
| "sq_repeat"                | "ssizeargfunc"    | __mul__      |
+----------------------------+-------------------+--------------+
| "sq_item"                  | "ssizeargfunc"    | __getitem__  |
+----------------------------+-------------------+--------------+
| "sq_ass_item"              | "ssizeobjargproc" | __setitem__  |
|                            |                   | __delitem__  |
+----------------------------+-------------------+--------------+
| "sq_contains"              | "objobjproc"      | __contains__ |
+----------------------------+-------------------+--------------+
| "sq_inplace_concat"        | "binaryfunc"      | __iadd__     |
+----------------------------+-------------------+--------------+
| "sq_inplace_repeat"        | "ssizeargfunc"    | __imul__     |
+----------------------------+-------------------+--------------+
|                                                               |
+----------------------------+-------------------+--------------+
| "bf_getbuffer"             | "getbufferproc()" | __buffer__   |
+----------------------------+-------------------+--------------+
| "bf_releasebuffer"         | "releasebufferpro | __release_bu |
|                            | c()"              | ffer__       |
+----------------------------+-------------------+--------------+


슬롯 typedef
------------

+-------------------------------+-------------------------------+------------------------+
| typedef                       | 매개 변수 형                  | 반환형                 |
|===============================|===============================|========================|
| "allocfunc"                   | "PyTypeObject" * "Py_ssize_t" | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "destructor"                  | "PyObject" *                  | void                   |
+-------------------------------+-------------------------------+------------------------+
| "freefunc"                    | void *                        | void                   |
+-------------------------------+-------------------------------+------------------------+
| "traverseproc"                | "PyObject" * "visitproc" void | int                    |
|                               | *                             |                        |
+-------------------------------+-------------------------------+------------------------+
| "newfunc"                     | "PyTypeObject" * "PyObject" * | "PyObject" *           |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "initproc"                    | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "reprfunc"                    | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "getattrfunc"                 | "PyObject" * const char *     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "setattrfunc"                 | "PyObject" * const char *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "getattrofunc"                | "PyObject" * "PyObject" *     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "setattrofunc"                | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "descrgetfunc"                | "PyObject" * "PyObject" *     | "PyObject" *           |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "descrsetfunc"                | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "hashfunc"                    | "PyObject" *                  | Py_hash_t              |
+-------------------------------+-------------------------------+------------------------+
| "richcmpfunc"                 | "PyObject" * "PyObject" * int | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "getiterfunc"                 | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "iternextfunc"                | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "lenfunc"                     | "PyObject" *                  | "Py_ssize_t"           |
+-------------------------------+-------------------------------+------------------------+
| "getbufferproc"               | "PyObject" * "Py_buffer" *    | int                    |
|                               | int                           |                        |
+-------------------------------+-------------------------------+------------------------+
| "releasebufferproc"           | "PyObject" * "Py_buffer" *    | void                   |
+-------------------------------+-------------------------------+------------------------+
| "inquiry"                     | "PyObject" *                  | int                    |
+-------------------------------+-------------------------------+------------------------+
| "unaryfunc"                   | "PyObject" *                  | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "binaryfunc"                  | "PyObject" * "PyObject" *     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "ternaryfunc"                 | "PyObject" * "PyObject" *     | "PyObject" *           |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "ssizeargfunc"                | "PyObject" * "Py_ssize_t"     | "PyObject" *           |
+-------------------------------+-------------------------------+------------------------+
| "ssizeobjargproc"             | "PyObject" * "Py_ssize_t"     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+
| "objobjproc"                  | "PyObject" * "PyObject" *     | int                    |
+-------------------------------+-------------------------------+------------------------+
| "objobjargproc"               | "PyObject" * "PyObject" *     | int                    |
|                               | "PyObject" *                  |                        |
+-------------------------------+-------------------------------+------------------------+

자세한 내용은 아래 슬롯 형 typedef를 참조하십시오.


PyTypeObject 정의
=================

The structure definition for "PyTypeObject" can be found in
"Include/cpython/object.h".  For convenience of reference, this
repeats the definition found there:

   typedef struct _typeobject {
       PyObject_VAR_HEAD
       const char *tp_name; /* For printing, in format "<module>.<name>" */
       Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */

       /* Methods to implement standard operations */

       destructor tp_dealloc;
       Py_ssize_t tp_vectorcall_offset;
       getattrfunc tp_getattr;
       setattrfunc tp_setattr;
       PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2)
                                       or tp_reserved (Python 3) */
       reprfunc tp_repr;

       /* Method suites for standard classes */

       PyNumberMethods *tp_as_number;
       PySequenceMethods *tp_as_sequence;
       PyMappingMethods *tp_as_mapping;

       /* More standard operations (here for binary compatibility) */

       hashfunc tp_hash;
       ternaryfunc tp_call;
       reprfunc tp_str;
       getattrofunc tp_getattro;
       setattrofunc tp_setattro;

       /* Functions to access object as input/output buffer */
       PyBufferProcs *tp_as_buffer;

       /* Flags to define presence of optional/expanded features */
       unsigned long tp_flags;

       const char *tp_doc; /* Documentation string */

       /* Assigned meaning in release 2.0 */
       /* call function for all accessible objects */
       traverseproc tp_traverse;

       /* delete references to contained objects */
       inquiry tp_clear;

       /* Assigned meaning in release 2.1 */
       /* rich comparisons */
       richcmpfunc tp_richcompare;

       /* weak reference enabler */
       Py_ssize_t tp_weaklistoffset;

       /* Iterators */
       getiterfunc tp_iter;
       iternextfunc tp_iternext;

       /* Attribute descriptor and subclassing stuff */
       PyMethodDef *tp_methods;
       PyMemberDef *tp_members;
       PyGetSetDef *tp_getset;
       // Strong reference on a heap type, borrowed reference on a static type
       PyTypeObject *tp_base;
       PyObject *tp_dict;
       descrgetfunc tp_descr_get;
       descrsetfunc tp_descr_set;
       Py_ssize_t tp_dictoffset;
       initproc tp_init;
       allocfunc tp_alloc;
       newfunc tp_new;
       freefunc tp_free; /* Low-level free-memory routine */
       inquiry tp_is_gc; /* For PyObject_IS_GC */
       PyObject *tp_bases;
       PyObject *tp_mro; /* method resolution order */
       PyObject *tp_cache; /* no longer used */
       void *tp_subclasses;  /* for static builtin types this is an index */
       PyObject *tp_weaklist; /* not used for static builtin types */
       destructor tp_del;

       /* Type attribute cache version tag. Added in version 2.6.
        * If zero, the cache is invalid and must be initialized.
        */
       unsigned int tp_version_tag;

       destructor tp_finalize;
       vectorcallfunc tp_vectorcall;

       /* bitset of which type-watchers care about this type */
       unsigned char tp_watched;

       /* Number of tp_version_tag values used.
        * Set to _Py_ATTR_CACHE_UNUSED if the attribute cache is
        * disabled for this type (e.g. due to custom MRO entries).
        * Otherwise, limited to MAX_VERSIONS_PER_CLASS (defined elsewhere).
        */
       uint16_t tp_versions_used;
   } PyTypeObject;


PyObject 슬롯
=============

The type object structure extends the "PyVarObject" structure. The
"ob_size" field is used for dynamic types (created by "type_new()",
usually called from a class statement). Note that "PyType_Type" (the
metatype) initializes "tp_itemsize", which means that its instances
(i.e. type objects) *must* have the "ob_size" field.

"PyObject.ob_refcnt"

   The type object's reference count is initialized to "1" by the
   "PyObject_HEAD_INIT" macro.  Note that for statically allocated
   type objects, the type's instances (objects whose "ob_type" points
   back to the type) do *not* count as references.  But for
   dynamically allocated type objects, the instances *do* count as
   references.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다.

"PyObject.ob_type"

   이것은 형의 형, 즉 메타 형(metatype)입니다. "PyObject_HEAD_INIT" 매
   크로에 대한 인자로 초기화되며, 값은 일반적으로 "&PyType_Type"이어야
   합니다. 그러나, (적어도) 윈도우에서 사용 가능해야 하는 동적으로 로
   드 가능한 확장 모듈의 경우, 컴파일러는 유효한 초기화자가 아니라고
   불평합니다. 따라서, 규칙은 "NULL"을 "PyObject_HEAD_INIT" 매크로로
   전달하고, 다른 작업을 수행하기 전에 모듈의 초기화 함수 시작에서 필
   드를 명시적으로 초기화하는 것입니다. 이것은 일반적으로 다음과 같이
   수행됩니다:

      Foo_Type.ob_type = &PyType_Type;

   This should be done before any instances of the type are created.
   "PyType_Ready()" checks if "ob_type" is "NULL", and if so,
   initializes it to the "ob_type" field of the base class.
   "PyType_Ready()" will not change this field if it is non-zero.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.


PyVarObject 슬롯
================

"PyVarObject.ob_size"

   For statically allocated type objects, this should be initialized
   to zero. For dynamically allocated type objects, this field has a
   special internal meaning.

   This field should be accessed using the "Py_SIZE()" macro.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다.


PyTypeObject 슬롯
=================

Each slot has a section describing inheritance.  If "PyType_Ready()"
may set a value when the field is set to "NULL" then there will also
be a "Default" section.  (Note that many fields set on
"PyBaseObject_Type" and "PyType_Type" effectively act as defaults.)

const char *PyTypeObject.tp_name

   Pointer to a NUL-terminated string containing the name of the type.
   For types that are accessible as module globals, the string should
   be the full module name, followed by a dot, followed by the type
   name; for built-in types, it should be just the type name.  If the
   module is a submodule of a package, the full package name is part
   of the full module name.  For example, a type named "T" defined in
   module "M" in subpackage "Q" in package "P" should have the
   "tp_name" initializer ""P.Q.M.T"".

   For dynamically allocated type objects, this should just be the
   type name, and the module name explicitly stored in the type dict
   as the value for key "'__module__'".

   For statically allocated type objects, the *tp_name* field should
   contain a dot. Everything before the last dot is made accessible as
   the "__module__" attribute, and everything after the last dot is
   made accessible as the "__name__" attribute.

   If no dot is present, the entire "tp_name" field is made accessible
   as the "__name__" attribute, and the "__module__" attribute is
   undefined (unless explicitly set in the dictionary, as explained
   above).  This means your type will be impossible to pickle.
   Additionally, it will not be listed in module documentations
   created with pydoc.

   이 필드는 "NULL"이 아니어야 합니다. "PyTypeObject()"에서 유일하게
   필요한 필드입니다 (잠재적인 "tp_itemsize"를 제외하고).

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다.

Py_ssize_t PyTypeObject.tp_basicsize
Py_ssize_t PyTypeObject.tp_itemsize

   이 필드를 사용하면 형 인스턴스의 크기를 바이트 단위로 계산할 수 있
   습니다.

   There are two kinds of types: types with fixed-length instances
   have a zero "tp_itemsize" field, types with variable-length
   instances have a non-zero "tp_itemsize" field.  For a type with
   fixed-length instances, all instances have the same size, given in
   "tp_basicsize". (Exceptions to this rule can be made using
   "PyUnstable_Object_GC_NewWithExtraData()".)

   For a type with variable-length instances, the instances must have
   an "ob_size" field, and the instance size is "tp_basicsize" plus N
   times "tp_itemsize", where N is the "length" of the object.

   Functions like "PyObject_NewVar()" will take the value of N as an
   argument, and store in the instance's "ob_size" field. Note that
   the "ob_size" field may later be used for other purposes. For
   example, "int" instances use the bits of "ob_size" in an
   implementation-defined way; the underlying storage and its size
   should be accessed using "PyLong_Export()".

   참고:

     The "ob_size" field should be accessed using the "Py_SIZE()" and
     "Py_SET_SIZE()" macros.

   Also, the presence of an "ob_size" field in the instance layout
   doesn't mean that the instance structure is variable-length. For
   example, the "list" type has fixed-length instances, yet those
   instances have a "ob_size" field. (As with "int", avoid reading
   lists' "ob_size" directly. Call "PyList_Size()" instead.)

   The "tp_basicsize" includes size needed for data of the type's
   "tp_base", plus any extra data needed by each instance.

   The  correct way to set "tp_basicsize" is to use the "sizeof"
   operator on the struct used to declare the instance layout. This
   struct must include the struct used to declare the base type. In
   other words, "tp_basicsize" must be greater than or equal to the
   base's "tp_basicsize".

   Since every type is a subtype of "object", this struct must include
   "PyObject" or "PyVarObject" (depending on whether "ob_size" should
   be included). These are usually defined by the macro
   "PyObject_HEAD" or "PyObject_VAR_HEAD", respectively.

   The basic size does not include the GC header size, as that header
   is not part of "PyObject_HEAD".

   For cases where struct used to declare the base type is unknown,
   see "PyType_Spec.basicsize" and "PyType_FromMetaclass()".

   Notes about alignment:

   * "tp_basicsize" must be a multiple of "_Alignof(PyObject)". When
     using "sizeof" on a "struct" that includes "PyObject_HEAD", as
     recommended, the compiler ensures this. When not using a C
     "struct", or when using compiler extensions like
     "__attribute__((packed))", it is up to you.

   * If the variable items require a particular alignment,
     "tp_basicsize" and "tp_itemsize" must each be a multiple of that
     alignment. For example, if a type's variable part stores a
     "double", it is your responsibility that both fields are a
     multiple of "_Alignof(double)".

   **계승:**

   These fields are inherited separately by subtypes. (That is, if the
   field is set to zero, "PyType_Ready()" will copy the value from the
   base type, indicating that the instances do not need additional
   storage.)

   If the base type has a non-zero "tp_itemsize", it is generally not
   safe to set "tp_itemsize" to a different non-zero value in a
   subtype (though this depends on the implementation of the base
   type).

destructor PyTypeObject.tp_dealloc

   * The corresponding slot ID "Py_tp_dealloc" is part of the 안정
   ABI.*

   A pointer to the instance destructor function.  The function
   signature is:

      void tp_dealloc(PyObject *self);

   The destructor function should remove all references which the
   instance owns (e.g., call "Py_CLEAR()"), free all memory buffers
   owned by the instance, and call the type's "tp_free" function to
   free the object itself.

   If you may call functions that may set the error indicator, you
   must use "PyErr_GetRaisedException()" and
   "PyErr_SetRaisedException()" to ensure you don't clobber a
   preexisting error indicator (the deallocation could have occurred
   while processing a different error):

      static void
      foo_dealloc(foo_object *self)
      {
          PyObject *et, *ev, *etb;
          PyObject *exc = PyErr_GetRaisedException();
          ...
          PyErr_SetRaisedException(exc);
      }

   The dealloc handler itself must not raise an exception; if it hits
   an error case it should call "PyErr_FormatUnraisable()" to log (and
   clear) an unraisable exception.

   No guarantees are made about when an object is destroyed, except:

   * Python will destroy an object immediately or some time after the
     final reference to the object is deleted, unless its finalizer
     ("tp_finalize") subsequently resurrects the object.

   * An object will not be destroyed while it is being automatically
     finalized ("tp_finalize") or automatically cleared ("tp_clear").

   CPython currently destroys an object immediately from "Py_DECREF()"
   when the new reference count is zero, but this may change in a
   future version.

   It is recommended to call "PyObject_CallFinalizerFromDealloc()" at
   the beginning of "tp_dealloc" to guarantee that the object is
   always finalized before destruction.

   If the type supports garbage collection (the "Py_TPFLAGS_HAVE_GC"
   flag is set), the destructor should call "PyObject_GC_UnTrack()"
   before clearing any member fields.

   It is permissible to call "tp_clear" from "tp_dealloc" to reduce
   code duplication and to guarantee that the object is always cleared
   before destruction.  Beware that "tp_clear" might have already been
   called.

   If the type is heap allocated ("Py_TPFLAGS_HEAPTYPE"), the
   deallocator should release the owned reference to its type object
   (via "Py_DECREF()") after calling the type deallocator.  See the
   example code below.:

      static void
      foo_dealloc(PyObject *op)
      {
         foo_object *self = (foo_object *) op;
         PyObject_GC_UnTrack(self);
         Py_CLEAR(self->ref);
         Py_TYPE(self)->tp_free(self);
      }

   "tp_dealloc" must leave the exception status unchanged.  If it
   needs to call something that might raise an exception, the
   exception state must be backed up first and restored later (after
   logging any exceptions with "PyErr_WriteUnraisable()").

   Example:

      static void
      foo_dealloc(PyObject *self)
      {
          PyObject *exc = PyErr_GetRaisedException();

          if (PyObject_CallFinalizerFromDealloc(self) < 0) {
              // self was resurrected.
              goto done;
          }

          PyTypeObject *tp = Py_TYPE(self);

          if (tp->tp_flags & Py_TPFLAGS_HAVE_GC) {
              PyObject_GC_UnTrack(self);
          }

          // Optional, but convenient to avoid code duplication.
          if (tp->tp_clear && tp->tp_clear(self) < 0) {
              PyErr_WriteUnraisable(self);
          }

          // Any additional destruction goes here.

          tp->tp_free(self);
          self = NULL;  // In case PyErr_WriteUnraisable() is called below.

          if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE) {
              Py_CLEAR(tp);
          }

      done:
          // Optional, if something was called that might have raised an
          // exception.
          if (PyErr_Occurred()) {
              PyErr_WriteUnraisable(self);
          }
          PyErr_SetRaisedException(exc);
      }

   "tp_dealloc" may be called from any Python thread, not just the
   thread which created the object (if the object becomes part of a
   refcount cycle, that cycle might be collected by a garbage
   collection on any thread).  This is not a problem for Python API
   calls, since the thread on which "tp_dealloc" is called with an
   *attached thread state*.  However, if the object being destroyed in
   turn destroys objects from some other C library, care should be
   taken to ensure that destroying those objects on the thread which
   called "tp_dealloc" will not violate any assumptions of the
   library.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   더 보기:

     Object Life Cycle for details about how this slot relates to
     other slots.

Py_ssize_t PyTypeObject.tp_vectorcall_offset

   간단한 "tp_call"의 더 효율적인 대안인 벡터콜(vectorcall) 프로토콜을
   사용하여 객체를 호출하는 것을 구현하는 인스턴스별 함수에 대한 선택
   적 오프셋입니다.

   This field is only used if the flag "Py_TPFLAGS_HAVE_VECTORCALL" is
   set. If so, this must be a positive integer containing the offset
   in the instance of a "vectorcallfunc" pointer.

   The *vectorcallfunc* pointer may be "NULL", in which case the
   instance behaves as if "Py_TPFLAGS_HAVE_VECTORCALL" was not set:
   calling the instance falls back to "tp_call".

   "Py_TPFLAGS_HAVE_VECTORCALL"을 설정하는 모든 클래스는 "tp_call"도
   설정해야 하고, 해당 동작이 *vectorcallfunc* 함수와 일관되도록 만들
   어야 합니다. *tp_call*을 "PyVectorcall_Call()"로 설정하면 됩니다:

   버전 3.8에서 변경: 버전 3.8 이전에는, 이 슬롯의 이름이 "tp_print"였
   습니다. 파이썬 2.x에서는, 파일로 인쇄하는 데 사용되었습니다. 파이썬
   3.0에서 3.7까지는, 사용되지 않았습니다.

   버전 3.12에서 변경: Before version 3.12, it was not recommended for
   mutable heap types to implement the vectorcall protocol. When a
   user sets "__call__" in Python code, only *tp_call* is updated,
   likely making it inconsistent with the vectorcall function. Since
   3.12, setting "__call__" will disable vectorcall optimization by
   clearing the "Py_TPFLAGS_HAVE_VECTORCALL" flag.

   **계승:**

   This field is always inherited. However, the
   "Py_TPFLAGS_HAVE_VECTORCALL" flag is not always inherited. If it's
   not set, then the subclass won't use vectorcall, except when
   "PyVectorcall_Call()" is explicitly called.

getattrfunc PyTypeObject.tp_getattr

   * The corresponding slot ID "Py_tp_getattr" is part of the 안정
   ABI.*

   get-attribute-string 함수에 대한 선택적 포인터.

   이 필드는 폐지되었습니다. 정의될 때, "tp_getattro" 함수와 같게 작동
   하지만, 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C
   문자열을 받아들이는 함수를 가리켜야 합니다.

   **계승:**

   Group: "tp_getattr", "tp_getattro"

   이 필드는 "tp_getattro"와 함께 서브 형에 의해 상속됩니다: 서브 형은
   서브 형의 "tp_getattr"과 "tp_getattro"가 모두 "NULL"일 때 베이스형
   에서 "tp_getattr"과 "tp_getattro"를 모두 상속합니다.

setattrfunc PyTypeObject.tp_setattr

   * The corresponding slot ID "Py_tp_setattr" is part of the 안정
   ABI.*

   어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터.

   이 필드는 폐지되었습니다. 정의될 때, "tp_setattro" 함수와 같게 작동
   하지만, 어트리뷰트 이름을 제공하기 위해 파이썬 문자열 객체 대신 C
   문자열을 받아들이는 함수를 가리켜야 합니다.

   **계승:**

   Group: "tp_setattr", "tp_setattro"

   이 필드는 "tp_setattro"와 함께 서브 형에 의해 상속됩니다. 서브 형은
   서브 형의 "tp_setattr"과 "tp_setattro"가 모두 "NULL"일 때 베이스형
   에서 "tp_setattr"과 "tp_setattro"를 모두 상속합니다.

PyAsyncMethods *PyTypeObject.tp_as_async

   C 수준에서 *어웨이터블*과 *비동기 이터레이터* 프로토콜을 구현하는
   객체에만 관련된 필드를 포함하는 추가 구조체에 대한 포인터. 자세한
   내용은 비동기 객체 구조체를 참조하십시오.

   Added in version 3.5: 이전에는 "tp_compare"와 "tp_reserved"라고 했
   습니다.

   **계승:**

   "tp_as_async" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상속
   됩니다.

reprfunc PyTypeObject.tp_repr

   * The corresponding slot ID "Py_tp_repr" is part of the 안정 ABI.*

   내장 함수 "repr()"을 구현하는 함수에 대한 선택적 포인터.

   서명은 "PyObject_Repr()"과 같습니다:

      PyObject *tp_repr(PyObject *self);

   함수는 문자열이나 유니코드 객체를 반환해야 합니다. 이상적으로, 이
   함수는 "eval()"에 전달될 때 적합한 환경이 주어지면 같은 값을 가진
   객체를 반환하는 문자열을 반환해야 합니다. 이것이 가능하지 않으면,
   "'<'"로 시작하고 "'>'"로 끝나는 문자열을 반환해야 하는데, 이 문자열
   에서 객체의 형과 값을 모두 추론할 수 있어야 합니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   이 필드를 설정하지 않으면, "<%s object at %p>" 형식의 문자열이 반환
   됩니다. 여기서 "%s"는 형 이름으로, "%p"는 객체의 메모리 주소로 치환
   됩니다.

PyNumberMethods *PyTypeObject.tp_as_number

   숫자 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조
   체에 대한 포인터. 이 필드는 숫자 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_number" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상
   속됩니다.

PySequenceMethods *PyTypeObject.tp_as_sequence

   시퀀스 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구
   조체에 대한 포인터. 이 필드는 시퀀스 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_sequence" 필드는 상속되지 않지만, 포함된 필드는 개별적으로
   상속됩니다.

PyMappingMethods *PyTypeObject.tp_as_mapping

   매핑 프로토콜을 구현하는 객체에만 관련된 필드를 포함하는 추가 구조
   체에 대한 포인터. 이 필드는 매핑 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_mapping" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상
   속됩니다.

hashfunc PyTypeObject.tp_hash

   * The corresponding slot ID "Py_tp_hash" is part of the 안정 ABI.*

   내장 함수 "hash()"를 구현하는 함수에 대한 선택적 포인터.

   서명은 "PyObject_Hash()"와 같습니다:

      Py_hash_t tp_hash(PyObject *);

   "-1" 값은 정상적인 반환 값으로 반환되지 않아야 합니다; 해시값을 계
   산하는 동안 에러가 발생하면 함수는 예외를 설정하고 "-1"을 반환해야
   합니다.

   When this field is not set (*and* "tp_richcompare" is not set), an
   attempt to take the hash of the object raises "TypeError". This is
   the same as setting it to "PyObject_HashNotImplemented()".

   이 필드는 부모 형에서 해시 메서드의 상속을 차단하기 위해
   "PyObject_HashNotImplemented()"로 명시적으로 설정할 수 있습니다. 이
   것은 파이썬 수준에서의 "__hash__ = None"과 동등한 것으로 해석되어,
   "isinstance(o, collections.Hashable)"이 "False"를 올바르게 반환하게
   합니다. 반대의 경우도 마찬가지입니다 - 파이썬 수준의 클래스에서
   "__hash__ = None"을 설정하면 "tp_hash" 슬롯이
   "PyObject_HashNotImplemented()"로 설정됩니다.

   **계승:**

   Group: "tp_hash", "tp_richcompare"

   이 필드는 "tp_richcompare"와 함께 서브 형에 의해 상속됩니다: 서브
   형의 "tp_richcompare"와 "tp_hash"가 모두 "NULL"일 때, 서브 형은
   "tp_richcompare"와 "tp_hash"를 모두 상속합니다.

   **기본값:**

   "PyBaseObject_Type" uses "PyObject_GenericHash()".

ternaryfunc PyTypeObject.tp_call

   * The corresponding slot ID "Py_tp_call" is part of the 안정 ABI.*

   객체 호출을 구현하는 함수에 대한 선택적 포인터. 객체가 콜러블이 아
   니면 "NULL"이어야 합니다. 서명은 "PyObject_Call()"과 같습니다:

      PyObject *tp_call(PyObject *self, PyObject *args, PyObject *kwargs);

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

reprfunc PyTypeObject.tp_str

   * The corresponding slot ID "Py_tp_str" is part of the 안정 ABI.*

   내장 연산 "str()"을 구현하는 함수에 대한 선택적 포인터. ("str"는 이
   제 형이며, "str()"은 그 형의 생성자를 호출함에 유의하십시오. 이 생
   성자는 "PyObject_Str()"를 호출하여 실제 작업을 수행하고,
   "PyObject_Str()"은 이 처리기를 호출합니다.)

   서명은 "PyObject_Str()"과 같습니다:

      PyObject *tp_str(PyObject *self);

   함수는 문자열이나 유니코드 객체를 반환해야 합니다. 다른 것 중에서도
   , "print()" 함수에 의해 사용될 표현이기 때문에, 객체의 "친숙한" 문
   자열 표현이어야 합니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   이 필드를 설정하지 않으면, 문자열 표현을 반환하기 위해
   "PyObject_Repr()"이 호출됩니다.

getattrofunc PyTypeObject.tp_getattro

   * The corresponding slot ID "Py_tp_getattro" is part of the 안정
   ABI.*

   어트리뷰트 읽기(get-attribute) 함수에 대한 선택적 포인터.

   서명은 "PyObject_GetAttr()"과 같습니다:

      PyObject *tp_getattro(PyObject *self, PyObject *attr);

   일반적으로 이 필드를 "PyObject_GenericGetAttr()"로 설정하는 것이 편
   리합니다, 객체 어트리뷰트를 찾는 일반적인 방법을 구현합니다.

   **계승:**

   Group: "tp_getattr", "tp_getattro"

   이 필드는 "tp_getattr"과 함께 서브 형에 의해 상속됩니다: 서브 형의
   "tp_getattr"과 "tp_getattro"가 모두 "NULL"일 때 서브 형은 베이스형
   에서 "tp_getattr"과 "tp_getattro"를 모두 상속합니다.

   **기본값:**

   "PyBaseObject_Type" uses "PyObject_GenericGetAttr()".

setattrofunc PyTypeObject.tp_setattro

   * The corresponding slot ID "Py_tp_setattro" is part of the 안정
   ABI.*

   어트리뷰트 설정과 삭제를 위한 함수에 대한 선택적 포인터.

   서명은 "PyObject_SetAttr()"과 같습니다:

      int tp_setattro(PyObject *self, PyObject *attr, PyObject *value);

   또한, *value*를 "NULL"로 설정하여 어트리뷰트를 삭제하는 것을 반드시
   지원해야 합니다. 일반적으로 이 필드를 "PyObject_GenericSetAttr()"로
   설정하는 것이 편리합니다, 객체 어트리뷰트를 설정하는 일반적인 방법
   을 구현합니다.

   **계승:**

   Group: "tp_setattr", "tp_setattro"

   이 필드는 "tp_setattr"과 함께 서브 형에 의해 상속됩니다: 서브 형의
   "tp_setattr"과 "tp_setattro"가 모두 "NULL"일 때, 서브 형은 베이스형
   에서 "tp_setattr"과 "tp_setattro"를 모두 상속합니다.

   **기본값:**

   "PyBaseObject_Type" uses "PyObject_GenericSetAttr()".

PyBufferProcs *PyTypeObject.tp_as_buffer

   버퍼 인터페이스를 구현하는 객체에만 관련된 필드를 포함하는 추가 구
   조체에 대한 포인터. 이 필드는 버퍼 객체 구조체에서 설명합니다.

   **계승:**

   "tp_as_buffer" 필드는 상속되지 않지만, 포함된 필드는 개별적으로 상
   속됩니다.

unsigned long PyTypeObject.tp_flags

   이 필드는 다양한 플래그의 비트 마스크입니다. 일부 플래그는 특정 상
   황에 대한 변형 의미론을 나타냅니다; 다른 것들은 역사적으로 항상 존
   재하지는 않았던 형 객체(또는 "tp_as_number", "tp_as_sequence",
   "tp_as_mapping" 및 "tp_as_buffer"를 통해 참조되는 확장 구조체)의 특
   정 필드가 유효함을 나타내는 데 사용됩니다; 이러한 플래그 비트가 없
   으면, 이것이 보호하는 형 필드에 액세스하지 말아야 하며 대신 0이나
   "NULL" 값을 갖는 것으로 간주해야 합니다.

   **계승:**

   Inheritance of this field is complicated.  Most flag bits are
   inherited individually, i.e. if the base type has a flag bit set,
   the subtype inherits this flag bit.  The flag bits that pertain to
   extension structures are strictly inherited if the extension
   structure is inherited, i.e. the base type's value of the flag bit
   is copied into the subtype together with a pointer to the extension
   structure.  The "Py_TPFLAGS_HAVE_GC" flag bit is inherited together
   with the "tp_traverse" and "tp_clear" fields, i.e. if the
   "Py_TPFLAGS_HAVE_GC" flag bit is clear in the subtype and the
   "tp_traverse" and "tp_clear" fields in the subtype exist and have
   "NULL" values.

   **기본값:**

   "PyBaseObject_Type" uses "Py_TPFLAGS_DEFAULT |
   Py_TPFLAGS_BASETYPE".

   **비트 마스크:**

   다음 비트 마스크가 현재 정의되어 있습니다; 이들은 "|" 연산자로 함께
   OR 하여 "tp_flags" 필드의 값을 형성할 수 있습니다. 매크로
   "PyType_HasFeature()"는 형과 플래그 값 *tp*와 *f*를 취하고
   "tp->tp_flags & f"가 0이 아닌지 확인합니다.

   Py_TPFLAGS_HEAPTYPE

      This bit is set when the type object itself is allocated on the
      heap, for example, types created dynamically using
      "PyType_FromSpec()".  In this case, the "ob_type" field of its
      instances is considered a reference to the type, and the type
      object is INCREF'ed when a new instance is created, and
      DECREF'ed when an instance is destroyed (this does not apply to
      instances of subtypes; only the type referenced by the
      instance's ob_type gets INCREF'ed or DECREF'ed). Heap types
      should also support garbage collection as they can form a
      reference cycle with their own module object.

      **계승:**

      ???

   Py_TPFLAGS_BASETYPE
       * Part of the 안정 ABI.*

      이 비트는 형을 다른 형의 베이스형으로 사용할 수 있을 때 설정됩니
      다. 이 비트가 설정되지 않으면 이 형으로 서브 형을 만들 수 없습니
      다 (Java의 "final" 클래스와 유사합니다).

      **계승:**

      ???

   Py_TPFLAGS_READY

      이 비트는 "PyType_Ready()"에 의해 형 객체가 완전히 초기화될 때
      설정됩니다.

      **계승:**

      ???

   Py_TPFLAGS_READYING

      이 비트는 "PyType_Ready()"가 형 객체를 초기화하는 동안 설정됩니
      다.

      **계승:**

      ???

   Py_TPFLAGS_HAVE_GC
       * Part of the 안정 ABI.*

      This bit is set when the object supports garbage collection.  If
      this bit is set, memory for new instances (see "tp_alloc") must
      be allocated using "PyObject_GC_New" or "PyType_GenericAlloc()"
      and deallocated (see "tp_free") using "PyObject_GC_Del()".  More
      information in section 순환 가비지 수집 지원.

      **계승:**

      Group: "Py_TPFLAGS_HAVE_GC", "tp_traverse", "tp_clear"

      The "Py_TPFLAGS_HAVE_GC" flag bit is inherited together with the
      "tp_traverse" and "tp_clear" fields, i.e.  if the
      "Py_TPFLAGS_HAVE_GC" flag bit is clear in the subtype and the
      "tp_traverse" and "tp_clear" fields in the subtype exist and
      have "NULL" values.

   Py_TPFLAGS_DEFAULT
       * Part of the 안정 ABI.*

      This is a bitmask of all the bits that pertain to the existence
      of certain fields in the type object and its extension
      structures. Currently, it includes the following bits:
      "Py_TPFLAGS_HAVE_STACKLESS_EXTENSION".

      **계승:**

      ???

   Py_TPFLAGS_METHOD_DESCRIPTOR
       * Part of the 안정 ABI 버전 3.8 이후로.*

      이 비트는 객체가 연결되지 않은 메서드(unbound method)처럼 동작함
      을 나타냅니다.

      이 플래그가 "type(meth)"에 설정되면:

      * "meth.__get__(obj, cls)(*args, **kwds)"("obj"가 None이 아닐 때
        )는 "meth(obj, *args, **kwds)"와 동등해야 합니다.

      * "meth.__get__(None, cls)(*args, **kwds)"는 "meth(*args,
        **kwds)"와 동등해야 합니다.

      이 플래그는 "obj.meth()"와 같은 일반적인 메서드 호출에 대한 최적
      화를 가능하게 합니다: "obj.meth"에 대한 임시 "연결된 메서드
      (bound method)" 객체를 만들지 않습니다.

      Added in version 3.8.

      **계승:**

      This flag is never inherited by types without the
      "Py_TPFLAGS_IMMUTABLETYPE" flag set.  For extension types, it is
      inherited whenever "tp_descr_get" is inherited.

   Py_TPFLAGS_MANAGED_DICT

      This bit indicates that instances of the class have a "__dict__"
      attribute, and that the space for the dictionary is managed by
      the VM.

      If this flag is set, "Py_TPFLAGS_HAVE_GC" should also be set.

      The type traverse function must call
      "PyObject_VisitManagedDict()" and its clear function must call
      "PyObject_ClearManagedDict()".

      Added in version 3.12.

      **계승:**

      This flag is inherited unless the "tp_dictoffset" field is set
      in a superclass.

   Py_TPFLAGS_MANAGED_WEAKREF

      This bit indicates that instances of the class should be weakly
      referenceable.

      Added in version 3.12.

      **계승:**

      This flag is inherited unless the "tp_weaklistoffset" field is
      set in a superclass.

   Py_TPFLAGS_ITEMS_AT_END
       * Part of the 안정 ABI 버전 3.12 이후로.*

      Only usable with variable-size types, i.e. ones with non-zero
      "tp_itemsize".

      Indicates that the variable-sized portion of an instance of this
      type is at the end of the instance's memory area, at an offset
      of "Py_TYPE(obj)->tp_basicsize" (which may be different in each
      subclass).

      When setting this flag, be sure that all superclasses either use
      this memory layout, or are not variable-sized. Python does not
      check this.

      Added in version 3.12.

      **계승:**

      This flag is inherited.

   Py_TPFLAGS_LONG_SUBCLASS

   Py_TPFLAGS_LIST_SUBCLASS

   Py_TPFLAGS_TUPLE_SUBCLASS

   Py_TPFLAGS_BYTES_SUBCLASS

   Py_TPFLAGS_UNICODE_SUBCLASS

   Py_TPFLAGS_DICT_SUBCLASS

   Py_TPFLAGS_BASE_EXC_SUBCLASS

   Py_TPFLAGS_TYPE_SUBCLASS

      Functions such as "PyLong_Check()" will call
      "PyType_FastSubclass()" with one of these flags to quickly
      determine if a type is a subclass of a built-in type; such
      specific checks are faster than a generic check, like
      "PyObject_IsInstance()". Custom types that inherit from built-
      ins should have their "tp_flags" set appropriately, or the code
      that interacts with such types will behave differently depending
      on what kind of check is used.

   Py_TPFLAGS_HAVE_FINALIZE

      이 비트는 "tp_finalize" 슬롯이 형 구조체에 있을 때 설정됩니다.

      Added in version 3.4.

      버전 3.8부터 폐지됨: 인터프리터는 "tp_finalize" 슬롯이 항상 형
      구조체에 있다고 가정하기 때문에, 이 플래그는 더는 필요하지 않습
      니다.

   Py_TPFLAGS_HAVE_VECTORCALL
       * Part of the 안정 ABI 버전 3.12 이후로.*

      이 비트는 클래스가 벡터콜 프로토콜을 구현할 때 설정됩니다. 자세
      한 내용은 "tp_vectorcall_offset"을 참조하십시오.

      **계승:**

      This bit is inherited if "tp_call" is also inherited.

      Added in version 3.9.

      버전 3.12에서 변경: This flag is now removed from a class when
      the class's "__call__()" method is reassigned.This flag can now
      be inherited by mutable classes.

   Py_TPFLAGS_IMMUTABLETYPE

      This bit is set for type objects that are immutable: type
      attributes cannot be set nor deleted.

      "PyType_Ready()" automatically applies this flag to static
      types.

      **계승:**

      This flag is not inherited.

      Added in version 3.10.

   Py_TPFLAGS_DISALLOW_INSTANTIATION

      Disallow creating instances of the type: set "tp_new" to NULL
      and don't create the "__new__" key in the type dictionary.

      The flag must be set before creating the type, not after. For
      example, it must be set before "PyType_Ready()" is called on the
      type.

      The flag is set automatically on static types if "tp_base" is
      NULL or "&PyBaseObject_Type" and "tp_new" is NULL.

      **계승:**

      This flag is not inherited. However, subclasses will not be
      instantiable unless they provide a non-NULL "tp_new" (which is
      only possible via the C API).

      참고:

        To disallow instantiating a class directly but allow
        instantiating its subclasses (e.g. for an *abstract base
        class*), do not use this flag. Instead, make "tp_new" only
        succeed for subclasses.

      Added in version 3.10.

   Py_TPFLAGS_MAPPING

      This bit indicates that instances of the class may match mapping
      patterns when used as the subject of a "match" block. It is
      automatically set when registering or subclassing
      "collections.abc.Mapping", and unset when registering
      "collections.abc.Sequence".

      참고:

        "Py_TPFLAGS_MAPPING" and "Py_TPFLAGS_SEQUENCE" are mutually
        exclusive; it is an error to enable both flags simultaneously.

      **계승:**

      This flag is inherited by types that do not already set
      "Py_TPFLAGS_SEQUENCE".

      더 보기: **PEP 634** -- Structural Pattern Matching: Specification

      Added in version 3.10.

   Py_TPFLAGS_SEQUENCE

      This bit indicates that instances of the class may match
      sequence patterns when used as the subject of a "match" block.
      It is automatically set when registering or subclassing
      "collections.abc.Sequence", and unset when registering
      "collections.abc.Mapping".

      참고:

        "Py_TPFLAGS_MAPPING" and "Py_TPFLAGS_SEQUENCE" are mutually
        exclusive; it is an error to enable both flags simultaneously.

      **계승:**

      This flag is inherited by types that do not already set
      "Py_TPFLAGS_MAPPING".

      더 보기: **PEP 634** -- Structural Pattern Matching: Specification

      Added in version 3.10.

   Py_TPFLAGS_VALID_VERSION_TAG

      Internal. Do not set or unset this flag. To indicate that a
      class has changed call "PyType_Modified()"

      경고:

        This flag is present in header files, but is not be used. It
        will be removed in a future version of CPython

const char *PyTypeObject.tp_doc

   * The corresponding slot ID "Py_tp_doc" is part of the 안정 ABI.*

   An optional pointer to a NUL-terminated C string giving the
   docstring for this type object.  This is exposed as the "__doc__"
   attribute on the type and instances of the type.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 *않습니다*.

traverseproc PyTypeObject.tp_traverse

   * The corresponding slot ID "Py_tp_traverse" is part of the 안정
   ABI.*

   An optional pointer to a traversal function for the garbage
   collector.  This is only used if the "Py_TPFLAGS_HAVE_GC" flag bit
   is set.  The signature is:

      int tp_traverse(PyObject *self, visitproc visit, void *arg);

   파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 순환 가비지 수
   집 지원에서 찾을 수 있습니다.

   The "tp_traverse" pointer is used by the garbage collector to
   detect reference cycles. A typical implementation of a
   "tp_traverse" function simply calls "Py_VISIT()" on each of the
   instance's members that are Python objects that the instance owns.
   For example, this is function "local_traverse()" from the "_thread"
   extension module:

      static int
      local_traverse(PyObject *op, visitproc visit, void *arg)
      {
          localobject *self = (localobject *) op;
          Py_VISIT(self->args);
          Py_VISIT(self->kw);
          Py_VISIT(self->dict);
          return 0;
      }

   "Py_VISIT()"는 참조 순환에 참여할 수 있는 멤버에 대해서만 호출됨에
   유의하십시오. "self->key" 멤버도 있지만, "NULL"이나 파이썬 문자열만
   가능해서 참조 순환의 일부가 될 수 없습니다.

   반면에, 멤버가 사이클의 일부가 될 수 없다는 것을 알고 있더라도, 디
   버깅 지원을 위해 "gc" 모듈의 "get_referents()" 함수가 그것을 포함하
   도록 어쨌거나 방문하고 싶을 수 있습니다.

   Heap types ("Py_TPFLAGS_HEAPTYPE") must visit their type with:

      Py_VISIT(Py_TYPE(self));

   It is only needed since Python 3.9. To support Python 3.8 and
   older, this line must be conditional:

      #if PY_VERSION_HEX >= 0x03090000
          Py_VISIT(Py_TYPE(self));
      #endif

   If the "Py_TPFLAGS_MANAGED_DICT" bit is set in the "tp_flags"
   field, the traverse function must call
   "PyObject_VisitManagedDict()" like this:

      PyObject_VisitManagedDict((PyObject*)self, visit, arg);

   경고:

     When implementing "tp_traverse", only the members that the
     instance *owns* (by having *strong references* to them) must be
     visited. For instance, if an object supports weak references via
     the "tp_weaklist" slot, the pointer supporting the linked list
     (what *tp_weaklist* points to) must **not** be visited as the
     instance does not directly own the weak references to itself (the
     weakreference list is there to support the weak reference
     machinery, but the instance has no strong reference to the
     elements inside it, as they are allowed to be removed even if the
     instance is still alive).

   경고:

     The traversal function must not have any side effects.  It must
     not modify the reference counts of any Python objects nor create
     or destroy any Python objects.

   Note that "Py_VISIT()" requires the *visit* and *arg* parameters to
   "local_traverse()" to have these specific names; don't name them
   just anything.

   Instances of heap-allocated types hold a reference to their type.
   Their traversal function must therefore either visit
   "Py_TYPE(self)", or delegate this responsibility by calling
   "tp_traverse" of another heap-allocated type (such as a heap-
   allocated superclass). If they do not, the type object may not be
   garbage-collected.

   참고:

     The "tp_traverse" function can be called from any thread.

   버전 3.9에서 변경: 힙 할당 형은 "tp_traverse"에서 "Py_TYPE(self)"를
   방문할 것으로 기대됩니다. 이전 버전의 파이썬에서는, 버그 40217로 인
   해, 이렇게 하면 서브 클래스에서 충돌이 발생할 수 있습니다.

   **계승:**

   Group: "Py_TPFLAGS_HAVE_GC", "tp_traverse", "tp_clear"

   This field is inherited by subtypes together with "tp_clear" and
   the "Py_TPFLAGS_HAVE_GC" flag bit: the flag bit, "tp_traverse", and
   "tp_clear" are all inherited from the base type if they are all
   zero in the subtype.

inquiry PyTypeObject.tp_clear

   * The corresponding slot ID "Py_tp_clear" is part of the 안정 ABI.*

   An optional pointer to a clear function.  The signature is:

      int tp_clear(PyObject *);

   The purpose of this function is to break reference cycles that are
   causing a *cyclic isolate* so that the objects can be safely
   destroyed.  A cleared object is a partially destroyed object; the
   object is not obligated to satisfy design invariants held during
   normal use.

   "tp_clear" does not need to delete references to objects that can't
   participate in reference cycles, such as Python strings or Python
   integers.  However, it may be convenient to clear all references,
   and write the type's "tp_dealloc" function to invoke "tp_clear" to
   avoid code duplication.  (Beware that "tp_clear" might have already
   been called. Prefer calling idempotent functions like
   "Py_CLEAR()".)

   Any non-trivial cleanup should be performed in "tp_finalize"
   instead of "tp_clear".

   참고:

     If "tp_clear" fails to break a reference cycle then the objects
     in the *cyclic isolate* may remain indefinitely uncollectable
     ("leak").  See "gc.garbage".

   참고:

     Referents (direct and indirect) might have already been cleared;
     they are not guaranteed to be in a consistent state.

   참고:

     The "tp_clear" function can be called from any thread.

   참고:

     An object is not guaranteed to be automatically cleared before
     its destructor ("tp_dealloc") is called.

   This function differs from the destructor ("tp_dealloc") in the
   following ways:

   * The purpose of clearing an object is to remove references to
     other objects that might participate in a reference cycle.  The
     purpose of the destructor, on the other hand, is a superset: it
     must release *all* resources it owns, including references to
     objects that cannot participate in a reference cycle (e.g.,
     integers) as well as the object's own memory (by calling
     "tp_free").

   * When "tp_clear" is called, other objects might still hold
     references to the object being cleared.  Because of this,
     "tp_clear" must not deallocate the object's own memory
     ("tp_free").  The destructor, on the other hand, is only called
     when no (strong) references exist, and as such, must safely
     destroy the object itself by deallocating it.

   * "tp_clear" might never be automatically called.  An object's
     destructor, on the other hand, will be automatically called some
     time after the object becomes unreachable (i.e., either there are
     no references to the object or the object is a member of a
     *cyclic isolate*).

   No guarantees are made about when, if, or how often Python
   automatically clears an object, except:

   * Python will not automatically clear an object if it is reachable,
     i.e., there is a reference to it and it is not a member of a
     *cyclic isolate*.

   * Python will not automatically clear an object if it has not been
     automatically finalized (see "tp_finalize").  (If the finalizer
     resurrected the object, the object may or may not be
     automatically finalized again before it is cleared.)

   * If an object is a member of a *cyclic isolate*, Python will not
     automatically clear it if any member of the cyclic isolate has
     not yet been automatically finalized ("tp_finalize").

   * Python will not destroy an object until after any automatic calls
     to its "tp_clear" function have returned.  This ensures that the
     act of breaking a reference cycle does not invalidate the "self"
     pointer while "tp_clear" is still executing.

   * Python will not automatically call "tp_clear" multiple times
     concurrently.

   CPython currently only automatically clears objects as needed to
   break reference cycles in a *cyclic isolate*, but future versions
   might clear objects regularly before their destruction.

   Taken together, all "tp_clear" functions in the system must combine
   to break all reference cycles.  This is subtle, and if in any doubt
   supply a "tp_clear" function.  For example, the tuple type does not
   implement a "tp_clear" function, because it's possible to prove
   that no reference cycle can be composed entirely of tuples.
   Therefore the "tp_clear" functions of other types are responsible
   for breaking any cycle containing a tuple.  This isn't immediately
   obvious, and there's rarely a good reason to avoid implementing
   "tp_clear".

   "tp_clear"의 구현은 다음 예제와 같이 파이썬 객체일 수 있는 자신의
   멤버에 대한 인스턴스의 참조를 삭제하고 해당 멤버에 대한 포인터를
   "NULL"로 설정해야 합니다:

      static int
      local_clear(PyObject *op)
      {
          localobject *self = (localobject *) op;
          Py_CLEAR(self->key);
          Py_CLEAR(self->args);
          Py_CLEAR(self->kw);
          Py_CLEAR(self->dict);
          return 0;
      }

   The "Py_CLEAR()" macro should be used, because clearing references
   is delicate:  the reference to the contained object must not be
   released (via "Py_DECREF()") until after the pointer to the
   contained object is set to "NULL".  This is because releasing the
   reference may cause the contained object to become trash,
   triggering a chain of reclamation activity that may include
   invoking arbitrary Python code (due to finalizers, or weakref
   callbacks, associated with the contained object). If it's possible
   for such code to reference *self* again, it's important that the
   pointer to the contained object be "NULL" at that time, so that
   *self* knows the contained object can no longer be used.  The
   "Py_CLEAR()" macro performs the operations in a safe order.

   If the "Py_TPFLAGS_MANAGED_DICT" bit is set in the "tp_flags"
   field, the clear function must call "PyObject_ClearManagedDict()"
   like this:

      PyObject_ClearManagedDict((PyObject*)self);

   파이썬의 가비지 수집 체계에 대한 자세한 정보는 섹션 순환 가비지 수
   집 지원에서 찾을 수 있습니다.

   **계승:**

   Group: "Py_TPFLAGS_HAVE_GC", "tp_traverse", "tp_clear"

   This field is inherited by subtypes together with "tp_traverse" and
   the "Py_TPFLAGS_HAVE_GC" flag bit: the flag bit, "tp_traverse", and
   "tp_clear" are all inherited from the base type if they are all
   zero in the subtype.

   더 보기:

     Object Life Cycle for details about how this slot relates to
     other slots.

richcmpfunc PyTypeObject.tp_richcompare

   * The corresponding slot ID "Py_tp_richcompare" is part of the 안정
   ABI.*

   풍부한 비교 함수(rich comparison function)에 대한 선택적 포인터. 서
   명은 다음과 같습니다:

      PyObject *tp_richcompare(PyObject *self, PyObject *other, int op);

   첫 번째 매개 변수는 "PyTypeObject"에 의해 정의된 형의 인스턴스임이
   보장됩니다.

   이 함수는 비교 결과(일반적으로 "Py_True"나 "Py_False")를 반환해야
   합니다. 비교가 정의되어 있지 않으면, "Py_NotImplemented"를 반환하고
   , 다른 에러가 발생하면 "NULL"을 반환하고 예외 조건을 설정해야 합니
   다.

   다음 상수는 "tp_richcompare"와 "PyObject_RichCompare()"의 세 번째
   인자로 사용되도록 정의됩니다:

   +----------------------+--------------+
   | 상수                 | 비교         |
   |======================|==============|
   | Py_LT                | "<"          |
   +----------------------+--------------+
   | Py_LE                | "<="         |
   +----------------------+--------------+
   | Py_EQ                | "=="         |
   +----------------------+--------------+
   | Py_NE                | "!="         |
   +----------------------+--------------+
   | Py_GT                | ">"          |
   +----------------------+--------------+
   | Py_GE                | ">="         |
   +----------------------+--------------+

   풍부한 비교 함수를 쉽게 작성할 수 있도록 다음 매크로가 정의됩니다:

   Py_RETURN_RICHCOMPARE(VAL_A, VAL_B, op)

      비교 결과에 따라, 함수에서 "Py_True"나 "Py_False"를 반환합니다.
      VAL_A와 VAL_B는 C 비교 연산자로 순서를 정할 수 있어야 합니다 (예
      를 들어, C int나 float일 수 있습니다). 세 번째 인자는
      "PyObject_RichCompare()"에서처럼 요청된 연산을 지정합니다.

      The returned value is a new *strong reference*.

      에러가 발생하면, 예외를 설정하고 함수에서 "NULL"을 반환합니다.

      Added in version 3.7.

   **계승:**

   Group: "tp_hash", "tp_richcompare"

   이 필드는 "tp_hash"와 함께 서브 형에 의해 상속됩니다. 서브 형의
   "tp_richcompare"와 "tp_hash"가 모두 "NULL"이면 서브 형은
   "tp_richcompare"와 "tp_hash"를 상속합니다.

   **기본값:**

   "PyBaseObject_Type" provides a "tp_richcompare" implementation,
   which may be inherited.  However, if only "tp_hash" is defined, not
   even the inherited function is used and instances of the type will
   not be able to participate in any comparisons.

Py_ssize_t PyTypeObject.tp_weaklistoffset

   While this field is still supported, "Py_TPFLAGS_MANAGED_WEAKREF"
   should be used instead, if at all possible.

   If the instances of this type are weakly referenceable, this field
   is greater than zero and contains the offset in the instance
   structure of the weak reference list head (ignoring the GC header,
   if present); this offset is used by "PyObject_ClearWeakRefs()" and
   the "PyWeakref_*" functions.  The instance structure needs to
   include a field of type PyObject* which is initialized to "NULL".

   이 필드를 "tp_weaklist"와 혼동하지 마십시오; 그것은 형 객체 자체에
   대한 약한 참조의 리스트 헤드입니다.

   It is an error to set both the "Py_TPFLAGS_MANAGED_WEAKREF" bit and
   "tp_weaklistoffset".

   **계승:**

   이 필드는 서브 형에 의해 상속되지만, 아래 나열된 규칙을 참조하십시
   오. 서브 형이 이 오프셋을 재정의할 수 있습니다; 이는 서브 형이 베이
   스형과 다른 약한 참조 리스트 헤드를 사용함을 의미합니다. 리스트 헤
   드는 항상 "tp_weaklistoffset"을 통해 발견되므로, 문제가 되지 않습니
   다.

   **기본값:**

   If the "Py_TPFLAGS_MANAGED_WEAKREF" bit is set in the "tp_flags"
   field, then "tp_weaklistoffset" will be set to a negative value, to
   indicate that it is unsafe to use this field.

getiterfunc PyTypeObject.tp_iter

   * The corresponding slot ID "Py_tp_iter" is part of the 안정 ABI.*

   An optional pointer to a function that returns an *iterator* for
   the object.  Its presence normally signals that the instances of
   this type are *iterable* (although sequences may be iterable
   without this function).

   이 함수는 "PyObject_GetIter()"와 같은 서명을 갖습니다:

      PyObject *tp_iter(PyObject *self);

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

iternextfunc PyTypeObject.tp_iternext

   * The corresponding slot ID "Py_tp_iternext" is part of the 안정
   ABI.*

   An optional pointer to a function that returns the next item in an
   *iterator*. The signature is:

      PyObject *tp_iternext(PyObject *self);

   이터레이터가 소진되면 "NULL"을 반환해야 합니다; "StopIteration" 예
   외가 설정될 수도, 그렇지 않을 수도 있습니다. 다른 에러가 발생하면,
   역시 "NULL"을 반환해야 합니다. 그 존재는 이 형의 인스턴스가 이터레
   이터라는 신호입니다.

   이터레이터 형은 "tp_iter" 함수도 정의해야 하며, 해당 함수는 (새 이
   터레이터 인스턴스가 아닌) 이터레이터 인스턴스 자체를 반환해야 합니
   다.

   이 함수는 "PyIter_Next()"와 같은 서명을 갖습니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

struct PyMethodDef *PyTypeObject.tp_methods

   * The corresponding slot ID "Py_tp_methods" is part of the 안정
   ABI.*

   이 형의 일반 메서드를 선언하는 "PyMethodDef" 구조체의 정적 "NULL"-
   종료 배열에 대한 선택적 포인터.

   배열의 항목마다, 메서드 디스크립터를 포함하는 형의 딕셔너리(아래
   "tp_dict"를 참조하십시오)에 항목이 추가됩니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (메서드는 다른 메커니즘
   을 통해 상속됩니다).

struct PyMemberDef *PyTypeObject.tp_members

   * The corresponding slot ID "Py_tp_members" is part of the 안정
   ABI.*

   이 형의 인스턴스의 일반 데이터 멤버(필드나 슬롯)를 선언하는
   "PyMemberDef" 구조체의 정적 "NULL"-종료 배열에 대한 선택적 포인터.

   배열의 항목마다, 멤버 디스크립터를 포함하는 형의 딕셔너리(아래
   "tp_dict"를 참조하십시오)에 항목이 추가됩니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (멤버는 다른 메커니즘을
   통해 상속됩니다).

struct PyGetSetDef *PyTypeObject.tp_getset

   * The corresponding slot ID "Py_tp_getset" is part of the 안정
   ABI.*

   이 형의 인스턴스의 계산된 어트리뷰트를 선언하는 "PyGetSetDef" 구조
   체의 정적 "NULL"-종료 배열에 대한 선택적 포인터.

   배열의 항목마다, getset 디스크립터를 포함하는 형의 딕셔너리(아래
   "tp_dict"를 참조하십시오)에 항목이 추가됩니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (계산된 어트리뷰트는 다
   른 메커니즘을 통해 상속됩니다).

PyTypeObject *PyTypeObject.tp_base

   * The corresponding slot ID "Py_tp_base" is part of the 안정 ABI.*

   형 속성이 상속되는 베이스형에 대한 선택적 포인터. 이 수준에서는, 단
   일 상속만 지원됩니다; 다중 상속은 메타 형을 호출하여 형 객체를 동적
   으로 작성해야 합니다.

   참고:

     슬롯 초기화에는 전역 초기화 규칙이 적용됩니다. C99에서는 초기화자
     가 "주소 상수(address constants)"여야 합니다. 포인터로 묵시적으로
     변환되는 "PyType_GenericNew()"와 같은 함수 지정자는 유효한 C99 주
     소 상수입니다.However, the unary '&' operator applied to a non-
     static variable like "PyBaseObject_Type" is not required to
     produce an address constant.  Compilers may support this (gcc
     does), MSVC does not. Both compilers are strictly standard
     conforming in this particular behavior.결과적으로, "tp_base"는 확
     장 모듈의 초기화 함수에서 설정되어야 합니다.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (명백히).

   **기본값:**

   이 필드의 기본값은 "&PyBaseObject_Type"입니다 (파이썬 프로그래머에
   게는 "object" 형으로 알려져 있습니다).

PyObject *PyTypeObject.tp_dict

   형의 딕셔너리는 "PyType_Ready()"에 의해 여기에 저장됩니다.

   This field should normally be initialized to "NULL" before
   PyType_Ready is called; it may also be initialized to a dictionary
   containing initial attributes for the type.  Once "PyType_Ready()"
   has initialized the type, extra attributes for the type may be
   added to this dictionary only if they don't correspond to
   overloaded operations (like "__add__()").  Once initialization for
   the type has finished, this field should be treated as read-only.

   Some types may not store their dictionary in this slot. Use
   "PyType_GetDict()" to retrieve the dictionary for an arbitrary
   type.

   버전 3.12에서 변경: Internals detail: For static builtin types,
   this is always "NULL". Instead, the dict for such types is stored
   on "PyInterpreterState". Use "PyType_GetDict()" to get the dict for
   an arbitrary type.

   **계승:**

   이 필드는 서브 형에 의해 상속되지 않습니다 (여기에 정의된 어트리뷰
   트는 다른 메커니즘을 통해 상속됩니다).

   **기본값:**

   이 필드가 "NULL"이면, "PyType_Ready()"는 새 딕셔너리를 할당합니다.

   경고:

     "PyDict_SetItem()"을 사용하거나 다른 식으로 딕셔너리 C-API로
     "tp_dict"를 수정하는 것은 안전하지 않습니다.

descrgetfunc PyTypeObject.tp_descr_get

   * The corresponding slot ID "Py_tp_descr_get" is part of the 안정
   ABI.*

   "디스크립터 get" 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      PyObject * tp_descr_get(PyObject *self, PyObject *obj, PyObject *type);

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

descrsetfunc PyTypeObject.tp_descr_set

   * The corresponding slot ID "Py_tp_descr_set" is part of the 안정
   ABI.*

   디스크립터 값을 설정하고 삭제하기 위한 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      int tp_descr_set(PyObject *self, PyObject *obj, PyObject *value);

   *value* 인자는 값을 삭제하기 위해 "NULL"로 설정됩니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

Py_ssize_t PyTypeObject.tp_dictoffset

   While this field is still supported, "Py_TPFLAGS_MANAGED_DICT"
   should be used instead, if at all possible.

   이 형의 인스턴스에 인스턴스 변수를 포함하는 딕셔너리가 있으면, 이
   필드는 0이 아니며 인스턴스 변수 딕셔너리 형의 인스턴스에서의 오프셋
   을 포함합니다; 이 오프셋은 "PyObject_GenericGetAttr()"에서 사용됩니
   다.

   이 필드를 "tp_dict"와 혼동하지 마십시오; 그것은 형 객체 자체의 어트
   리뷰트에 대한 딕셔너리입니다.

   The value specifies the offset of the dictionary from the start of
   the instance structure.

   The "tp_dictoffset" should be regarded as write-only. To get the
   pointer to the dictionary call "PyObject_GenericGetDict()". Calling
   "PyObject_GenericGetDict()" may need to allocate memory for the
   dictionary, so it is may be more efficient to call
   "PyObject_GetAttr()" when accessing an attribute on the object.

   It is an error to set both the "Py_TPFLAGS_MANAGED_DICT" bit and
   "tp_dictoffset".

   **계승:**

   This field is inherited by subtypes. A subtype should not override
   this offset; doing so could be unsafe, if C code tries to access
   the dictionary at the previous offset. To properly support
   inheritance, use "Py_TPFLAGS_MANAGED_DICT".

   **기본값:**

   This slot has no default.  For static types, if the field is "NULL"
   then no "__dict__" gets created for instances.

   If the "Py_TPFLAGS_MANAGED_DICT" bit is set in the "tp_flags"
   field, then "tp_dictoffset" will be set to "-1", to indicate that
   it is unsafe to use this field.

initproc PyTypeObject.tp_init

   * The corresponding slot ID "Py_tp_init" is part of the 안정 ABI.*

   인스턴스 초기화 함수에 대한 선택적 포인터.

   This function corresponds to the "__init__()" method of classes.
   Like "__init__()", it is possible to create an instance without
   calling "__init__()", and it is possible to reinitialize an
   instance by calling its "__init__()" method again.

   함수 서명은 다음과 같습니다:

      int tp_init(PyObject *self, PyObject *args, PyObject *kwds);

   The self argument is the instance to be initialized; the *args* and
   *kwds* arguments represent positional and keyword arguments of the
   call to "__init__()".

   "NULL"이 아닐 때, "tp_init" 함수는 형을 호출하여 인스턴스를 정상적
   으로 만들 때, 형의 "tp_new" 함수가 형의 인스턴스를 반환한 후 호출됩
   니다. "tp_new" 함수가 원래 형의 서브 형이 아닌 다른 형의 인스턴스를
   반환하면, 아무런 "tp_init" 함수도 호출되지 않습니다; "tp_new"가 원
   래 형의 서브 형 인스턴스를 반환하면, 서브 형의 "tp_init"가 호출됩니
   다.

   성공하면 "0"을 반환하고, 에러 시에는 "-1"을 반환하고 예외를 설정합
   니다.

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   For static types this field does not have a default.

allocfunc PyTypeObject.tp_alloc

   * The corresponding slot ID "Py_tp_alloc" is part of the 안정 ABI.*

   인스턴스 할당 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      PyObject *tp_alloc(PyTypeObject *self, Py_ssize_t nitems);

   **계승:**

   Static subtypes inherit this slot, which will be
   "PyType_GenericAlloc()" if inherited from "object".

   Heap subtypes do not inherit this slot.

   **기본값:**

   For heap subtypes, this field is always set to
   "PyType_GenericAlloc()".

   For static subtypes, this slot is inherited (see above).

newfunc PyTypeObject.tp_new

   * The corresponding slot ID "Py_tp_new" is part of the 안정 ABI.*

   인스턴스 생성 함수에 대한 선택적 포인터.

   함수 서명은 다음과 같습니다:

      PyObject *tp_new(PyTypeObject *subtype, PyObject *args, PyObject *kwds);

   *subtype* 인자는 만들어지고 있는 객체의 형입니다; *args*와 *kwds*
   인자는 형 호출의 위치와 키워드 인자를 나타냅니다. *subtype*이
   "tp_new" 함수가 호출되는 형과 같을 필요는 없음에 유의하십시오; 이
   형의 서브 형일 수 있습니다 (하지만 관련이 없는 형은 아닙니다).

   "tp_new" 함수는 객체에 공간을 할당하기 위해
   "subtype->tp_alloc(subtype, nitems)"를 호출해야 하고, 그런 다음 꼭
   필요한 만큼만 추가 초기화를 수행해야 합니다. 안전하게 무시하거나 반
   복할 수 있는 초기화는 "tp_init" 처리기에 배치해야 합니다. 간단한 규
   칙은, 불변 형의 경우 모든 초기화가 "tp_new"에서 수행되어야 하고, 가
   변형의 경우 대부분 초기화는 "tp_init"로 미뤄져야 합니다.

   Set the "Py_TPFLAGS_DISALLOW_INSTANTIATION" flag to disallow
   creating instances of the type in Python.

   **계승:**

   This field is inherited by subtypes, except it is not inherited by
   static types whose "tp_base" is "NULL" or "&PyBaseObject_Type".

   **기본값:**

   For static types this field has no default. This means if the slot
   is defined as "NULL", the type cannot be called to create new
   instances; presumably there is some other way to create instances,
   like a factory function.

freefunc PyTypeObject.tp_free

   * The corresponding slot ID "Py_tp_free" is part of the 안정 ABI.*

   인스턴스 할당 해제 함수에 대한 선택적 포인터. 서명은 다음과 같습니
   다:

      void tp_free(void *self);

   This function must free the memory allocated by "tp_alloc".

   **계승:**

   Static subtypes inherit this slot, which will be "PyObject_Free()"
   if inherited from "object".  Exception: If the type supports
   garbage collection (i.e., the "Py_TPFLAGS_HAVE_GC" flag is set in
   "tp_flags") and it would inherit "PyObject_Free()", then this slot
   is not inherited but instead defaults to "PyObject_GC_Del()".

   Heap subtypes do not inherit this slot.

   **기본값:**

   For heap subtypes, this slot defaults to a deallocator suitable to
   match "PyType_GenericAlloc()" and the value of the
   "Py_TPFLAGS_HAVE_GC" flag.

   For static subtypes, this slot is inherited (see above).

inquiry PyTypeObject.tp_is_gc

   * The corresponding slot ID "Py_tp_is_gc" is part of the 안정 ABI.*

   가비지 수집기에서 호출되는 함수에 대한 선택적 포인터.

   The garbage collector needs to know whether a particular object is
   collectible or not.  Normally, it is sufficient to look at the
   object's type's "tp_flags" field, and check the
   "Py_TPFLAGS_HAVE_GC" flag bit.  But some types have a mixture of
   statically and dynamically allocated instances, and the statically
   allocated instances are not collectible.  Such types should define
   this function; it should return "1" for a collectible instance, and
   "0" for a non-collectible instance. The signature is:

      int tp_is_gc(PyObject *self);

   (The only example of this are types themselves.  The metatype,
   "PyType_Type", defines this function to distinguish between
   statically and dynamically allocated types.)

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   **기본값:**

   This slot has no default.  If this field is "NULL",
   "Py_TPFLAGS_HAVE_GC" is used as the functional equivalent.

PyObject *PyTypeObject.tp_bases

   * The corresponding slot ID "Py_tp_bases" is part of the 안정 ABI.*

   베이스형의 튜플.

   This field should be set to "NULL" and treated as read-only. Python
   will fill it in when the type is "initialized".

   For dynamically created classes, the "Py_tp_bases" "slot" can be
   used instead of the *bases* argument of
   "PyType_FromSpecWithBases()". The argument form is preferred.

   경고:

     Multiple inheritance does not work well for statically defined
     types. If you set "tp_bases" to a tuple, Python will not raise an
     error, but some slots will only be inherited from the first base.

   **계승:**

   이 필드는 상속되지 않습니다.

PyObject *PyTypeObject.tp_mro

   형 자체에서 시작하여 "object"로 끝나는 확장된 베이스형 집합을 포함
   하는 튜플.

   This field should be set to "NULL" and treated as read-only. Python
   will fill it in when the type is "initialized".

   **계승:**

   이 필드는 상속되지 않습니다; "PyType_Ready()"에 의해 새로 계산됩니
   다.

PyObject *PyTypeObject.tp_cache

   사용되지 않습니다. 내부 전용.

   **계승:**

   이 필드는 상속되지 않습니다.

void *PyTypeObject.tp_subclasses

   A collection of subclasses.  Internal use only.  May be an invalid
   pointer.

   To get a list of subclasses, call the Python method
   "__subclasses__()".

   버전 3.12에서 변경: For some types, this field does not hold a
   valid PyObject*. The type was changed to void* to indicate this.

   **계승:**

   이 필드는 상속되지 않습니다.

PyObject *PyTypeObject.tp_weaklist

   이 형 객체에 대한 약한 참조를 위한 약한 참조 리스트 헤드. 상속되지
   않습니다. 내부 전용.

   버전 3.12에서 변경: Internals detail: For the static builtin types
   this is always "NULL", even if weakrefs are added.  Instead, the
   weakrefs for each are stored on "PyInterpreterState".  Use the
   public C-API or the internal "_PyObject_GET_WEAKREFS_LISTPTR()"
   macro to avoid the distinction.

   **계승:**

   이 필드는 상속되지 않습니다.

destructor PyTypeObject.tp_del

   * The corresponding slot ID "Py_tp_del" is part of the 안정 ABI.*

   이 필드는 폐지되었습니다. 대신 "tp_finalize"를 사용하십시오.

unsigned int PyTypeObject.tp_version_tag

   메서드 캐시에 인덱싱하는 데 사용됩니다. 내부 전용.

   **계승:**

   이 필드는 상속되지 않습니다.

destructor PyTypeObject.tp_finalize

   * The corresponding slot ID "Py_tp_finalize" is part of the 안정
   ABI 버전 3.5 이후로.*

   An optional pointer to an instance finalization function.  This is
   the C implementation of the "__del__()" special method.  Its
   signature is:

      void tp_finalize(PyObject *self);

   The primary purpose of finalization is to perform any non-trivial
   cleanup that must be performed before the object is destroyed,
   while the object and any other objects it directly or indirectly
   references are still in a consistent state.  The finalizer is
   allowed to execute arbitrary Python code.

   Before Python automatically finalizes an object, some of the
   object's direct or indirect referents might have themselves been
   automatically finalized. However, none of the referents will have
   been automatically cleared ("tp_clear") yet.

   Other non-finalized objects might still be using a finalized
   object, so the finalizer must leave the object in a sane state
   (e.g., invariants are still met).

   참고:

     After Python automatically finalizes an object, Python might
     start automatically clearing ("tp_clear") the object and its
     referents (direct and indirect).  Cleared objects are not
     guaranteed to be in a consistent state; a finalized object must
     be able to tolerate cleared referents.

   참고:

     An object is not guaranteed to be automatically finalized before
     its destructor ("tp_dealloc") is called.  It is recommended to
     call "PyObject_CallFinalizerFromDealloc()" at the beginning of
     "tp_dealloc" to guarantee that the object is always finalized
     before destruction.

   참고:

     The "tp_finalize" function can be called from any thread,
     although the *GIL* will be held.

   참고:

     The "tp_finalize" function can be called during shutdown, after
     some global variables have been deleted.  See the documentation
     of the "__del__()" method for details.

   When Python finalizes an object, it behaves like the following
   algorithm:

   1. Python might mark the object as *finalized*.  Currently, Python
      always marks objects whose type supports garbage collection
      (i.e., the "Py_TPFLAGS_HAVE_GC" flag is set in "tp_flags") and
      never marks other types of objects; this might change in a
      future version.

   2. If the object is not marked as *finalized* and its "tp_finalize"
      finalizer function is non-"NULL", the finalizer function is
      called.

   3. If the finalizer function was called and the finalizer made the
      object reachable (i.e., there is a reference to the object and
      it is not a member of a *cyclic isolate*), then the finalizer is
      said to have *resurrected* the object.  It is unspecified
      whether the finalizer can also resurrect the object by adding a
      new reference to the object that does not make it reachable,
      i.e., the object is (still) a member of a cyclic isolate.

   4. If the finalizer resurrected the object, the object's pending
      destruction is canceled and the object's *finalized* mark might
      be removed if present.  Currently, Python never removes the
      *finalized* mark; this might change in a future version.

   *Automatic finalization* refers to any finalization performed by
   Python except via calls to "PyObject_CallFinalizer()" or
   "PyObject_CallFinalizerFromDealloc()".  No guarantees are made
   about when, if, or how often an object is automatically finalized,
   except:

   * Python will not automatically finalize an object if it is
     reachable, i.e., there is a reference to it and it is not a
     member of a *cyclic isolate*.

   * Python will not automatically finalize an object if finalizing it
     would not mark the object as *finalized*.  Currently, this
     applies to objects whose type does not support garbage
     collection, i.e., the "Py_TPFLAGS_HAVE_GC" flag is not set.  Such
     objects can still be manually finalized by calling
     "PyObject_CallFinalizer()" or
     "PyObject_CallFinalizerFromDealloc()".

   * Python will not automatically finalize any two members of a
     *cyclic isolate* concurrently.

   * Python will not automatically finalize an object after it has
     automatically cleared ("tp_clear") the object.

   * If an object is a member of a *cyclic isolate*, Python will not
     automatically finalize it after automatically clearing (see
     "tp_clear") any other member.

   * Python will automatically finalize every member of a *cyclic
     isolate* before it automatically clears (see "tp_clear") any of
     them.

   * If Python is going to automatically clear an object ("tp_clear"),
     it will automatically finalize the object first.

   Python currently only automatically finalizes objects that are
   members of a *cyclic isolate*, but future versions might finalize
   objects regularly before their destruction.

   To manually finalize an object, do not call this function directly;
   call "PyObject_CallFinalizer()" or
   "PyObject_CallFinalizerFromDealloc()" instead.

   "tp_finalize" should leave the current exception status unchanged.
   The recommended way to write a non-trivial finalizer is to back up
   the exception at the beginning by calling
   "PyErr_GetRaisedException()" and restore the exception at the end
   by calling "PyErr_SetRaisedException()".  If an exception is
   encountered in the middle of the finalizer, log and clear it with
   "PyErr_WriteUnraisable()" or "PyErr_FormatUnraisable()".  For
   example:

      static void
      foo_finalize(PyObject *self)
      {
          // Save the current exception, if any.
          PyObject *exc = PyErr_GetRaisedException();

          // ...

          if (do_something_that_might_raise() != success_indicator) {
              PyErr_WriteUnraisable(self);
              goto done;
          }

      done:
          // Restore the saved exception.  This silently discards any exception
          // raised above, so be sure to call PyErr_WriteUnraisable first if
          // necessary.
          PyErr_SetRaisedException(exc);
      }

   **계승:**

   이 필드는 서브 형으로 상속됩니다.

   Added in version 3.4.

   버전 3.8에서 변경: Before version 3.8 it was necessary to set the
   "Py_TPFLAGS_HAVE_FINALIZE" flags bit in order for this field to be
   used.  This is no longer required.

   더 보기:

     * **PEP 442**: "Safe object finalization"

     * Object Life Cycle for details about how this slot relates to
       other slots.

     * "PyObject_CallFinalizer()"

     * "PyObject_CallFinalizerFromDealloc()"

vectorcallfunc PyTypeObject.tp_vectorcall

   * The corresponding slot ID "Py_tp_vectorcall" is part of the 안정
   ABI 버전 3.14 이후로.*

   A vectorcall function to use for calls of this type object (rather
   than instances). In other words, "tp_vectorcall" can be used to
   optimize "type.__call__", which typically returns a new instance of
   *type*.

   As with any vectorcall function, if "tp_vectorcall" is "NULL", the
   *tp_call* protocol ("Py_TYPE(type)->tp_call") is used instead.

   참고:

     The vectorcall protocol requires that the vectorcall function has
     the same behavior as the corresponding "tp_call". This means that
     "type->tp_vectorcall" must match the behavior of
     "Py_TYPE(type)->tp_call".Specifically, if *type* uses the default
     metaclass, "type->tp_vectorcall" must behave the same as
     PyType_Type->tp_call, which:

     * calls "type->tp_new",

     * if the result is a subclass of *type*, calls "type->tp_init" on
       the result of "tp_new", and

     * returns the result of "tp_new".

     Typically, "tp_vectorcall" is overridden to optimize this process
     for specific "tp_new" and "tp_init". When doing this for user-
     subclassable types, note that both can be overridden (using
     "__new__()" and "__init__()", respectively).

   **계승:**

   이 필드는 상속되지 않습니다.

   Added in version 3.9: (필드는 3.8부터 존재하지만 3.9부터 사용됩니다
   )

unsigned char PyTypeObject.tp_watched

   Internal. Do not use.

   Added in version 3.12.


Static Types
============

전통적으로, C 코드에서 정의된 형은 *정적(static)*입니다. 즉 정적
"PyTypeObject" 구조체는 코드에서 직접 정의되고 "PyType_Ready()"를 사용
하여 초기화됩니다.

결과적으로 파이썬에서 정의된 형에 비해 형이 제한됩니다:

* 정적 형은 하나의 베이스로 제한됩니다. 즉, 다중 상속을 사용할 수 없습
  니다.

* 정적 형 객체(그러나 이들의 인스턴스는 아닙니다)는 불변입니다. 파이썬
  에서 형 객체의 어트리뷰트를 추가하거나 수정할 수 없습니다.

* 정적 형 객체는 서브 인터프리터에서 공유되므로, 서브 인터프리터 관련
  상태를 포함하지 않아야 합니다.

Also, since "PyTypeObject" is only part of the Limited API as an
opaque struct, any extension modules using static types must be
compiled for a specific Python minor version.


힙 형
=====

An alternative to static types is *heap-allocated types*, or *heap
types* for short, which correspond closely to classes created by
Python's "class" statement. Heap types have the "Py_TPFLAGS_HEAPTYPE"
flag set.

This is done by filling a "PyType_Spec" structure and calling
"PyType_FromSpec()", "PyType_FromSpecWithBases()",
"PyType_FromModuleAndSpec()", or "PyType_FromMetaclass()".


숫자 객체 구조체
================

type PyNumberMethods

   이 구조체는 객체가 숫자 프로토콜을 구현하는 데 사용하는 함수에 대한
   포인터를 담습니다. 각 함수는 숫자 프로토콜 섹션에서 설명하는 유사한
   이름의 함수가 사용합니다.

   구조체 정의는 다음과 같습니다:

      typedef struct {
           binaryfunc nb_add;
           binaryfunc nb_subtract;
           binaryfunc nb_multiply;
           binaryfunc nb_remainder;
           binaryfunc nb_divmod;
           ternaryfunc nb_power;
           unaryfunc nb_negative;
           unaryfunc nb_positive;
           unaryfunc nb_absolute;
           inquiry nb_bool;
           unaryfunc nb_invert;
           binaryfunc nb_lshift;
           binaryfunc nb_rshift;
           binaryfunc nb_and;
           binaryfunc nb_xor;
           binaryfunc nb_or;
           unaryfunc nb_int;
           void *nb_reserved;
           unaryfunc nb_float;

           binaryfunc nb_inplace_add;
           binaryfunc nb_inplace_subtract;
           binaryfunc nb_inplace_multiply;
           binaryfunc nb_inplace_remainder;
           ternaryfunc nb_inplace_power;
           binaryfunc nb_inplace_lshift;
           binaryfunc nb_inplace_rshift;
           binaryfunc nb_inplace_and;
           binaryfunc nb_inplace_xor;
           binaryfunc nb_inplace_or;

           binaryfunc nb_floor_divide;
           binaryfunc nb_true_divide;
           binaryfunc nb_inplace_floor_divide;
           binaryfunc nb_inplace_true_divide;

           unaryfunc nb_index;

           binaryfunc nb_matrix_multiply;
           binaryfunc nb_inplace_matrix_multiply;
      } PyNumberMethods;

   참고:

     이항과 삼항 함수는 모든 피연산자의 형을 확인하고, 필요한 변환을
     구현해야합니다 (적어도 피연산자 중 하나는 정의된 형의 인스턴스입
     니다). 주어진 피연산자에 대해 연산이 정의되지 않으면, 이항과 삼항
     함수는 "Py_NotImplemented"를 반환해야하며, 다른 에러가 발생하면
     "NULL"을 반환하고 예외를 설정해야 합니다.

   참고:

     The "nb_reserved" field should always be "NULL".  It was
     previously called "nb_long", and was renamed in Python 3.0.1.

binaryfunc PyNumberMethods.nb_add

   * The corresponding slot ID "Py_nb_add" is part of the 안정 ABI.*

binaryfunc PyNumberMethods.nb_subtract

   * The corresponding slot ID "Py_nb_subtract" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_multiply

   * The corresponding slot ID "Py_nb_multiply" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_remainder

   * The corresponding slot ID "Py_nb_remainder" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_divmod

   * The corresponding slot ID "Py_nb_divmod" is part of the 안정
   ABI.*

ternaryfunc PyNumberMethods.nb_power

   * The corresponding slot ID "Py_nb_power" is part of the 안정 ABI.*

unaryfunc PyNumberMethods.nb_negative

   * The corresponding slot ID "Py_nb_negative" is part of the 안정
   ABI.*

unaryfunc PyNumberMethods.nb_positive

   * The corresponding slot ID "Py_nb_positive" is part of the 안정
   ABI.*

unaryfunc PyNumberMethods.nb_absolute

   * The corresponding slot ID "Py_nb_absolute" is part of the 안정
   ABI.*

inquiry PyNumberMethods.nb_bool

   * The corresponding slot ID "Py_nb_bool" is part of the 안정 ABI.*

unaryfunc PyNumberMethods.nb_invert

   * The corresponding slot ID "Py_nb_invert" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_lshift

   * The corresponding slot ID "Py_nb_lshift" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_rshift

   * The corresponding slot ID "Py_nb_rshift" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_and

   * The corresponding slot ID "Py_nb_and" is part of the 안정 ABI.*

binaryfunc PyNumberMethods.nb_xor

   * The corresponding slot ID "Py_nb_xor" is part of the 안정 ABI.*

binaryfunc PyNumberMethods.nb_or

   * The corresponding slot ID "Py_nb_or" is part of the 안정 ABI.*

unaryfunc PyNumberMethods.nb_int

   * The corresponding slot ID "Py_nb_int" is part of the 안정 ABI.*

void *PyNumberMethods.nb_reserved

unaryfunc PyNumberMethods.nb_float

   * The corresponding slot ID "Py_nb_float" is part of the 안정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_add

   * The corresponding slot ID "Py_nb_inplace_add" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_inplace_subtract

   * The corresponding slot ID "Py_nb_inplace_subtract" is part of the
   안정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_multiply

   * The corresponding slot ID "Py_nb_inplace_multiply" is part of the
   안정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_remainder

   * The corresponding slot ID "Py_nb_inplace_remainder" is part of
   the 안정 ABI.*

ternaryfunc PyNumberMethods.nb_inplace_power

   * The corresponding slot ID "Py_nb_inplace_power" is part of the 안
   정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_lshift

   * The corresponding slot ID "Py_nb_inplace_lshift" is part of the
   안정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_rshift

   * The corresponding slot ID "Py_nb_inplace_rshift" is part of the
   안정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_and

   * The corresponding slot ID "Py_nb_inplace_and" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_inplace_xor

   * The corresponding slot ID "Py_nb_inplace_xor" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_inplace_or

   * The corresponding slot ID "Py_nb_inplace_or" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_floor_divide

   * The corresponding slot ID "Py_nb_floor_divide" is part of the 안
   정 ABI.*

binaryfunc PyNumberMethods.nb_true_divide

   * The corresponding slot ID "Py_nb_true_divide" is part of the 안정
   ABI.*

binaryfunc PyNumberMethods.nb_inplace_floor_divide

   * The corresponding slot ID "Py_nb_inplace_floor_divide" is part of
   the 안정 ABI.*

binaryfunc PyNumberMethods.nb_inplace_true_divide

   * The corresponding slot ID "Py_nb_inplace_true_divide" is part of
   the 안정 ABI.*

unaryfunc PyNumberMethods.nb_index

   * The corresponding slot ID "Py_nb_index" is part of the 안정 ABI.*

binaryfunc PyNumberMethods.nb_matrix_multiply

   * The corresponding slot ID "Py_nb_matrix_multiply" is part of the
   안정 ABI 버전 3.5 이후로.*

binaryfunc PyNumberMethods.nb_inplace_matrix_multiply

   * The corresponding slot ID "Py_nb_inplace_matrix_multiply" is part
   of the 안정 ABI 버전 3.5 이후로.*


매핑 객체 구조체
================

type PyMappingMethods

   이 구조체에는 객체가 매핑 프로토콜을 구현하는 데 사용하는 함수에 대
   한 포인터를 담습니다. 세 개의 멤버가 있습니다:

lenfunc PyMappingMethods.mp_length

   * The corresponding slot ID "Py_mp_length" is part of the 안정
   ABI.*

   이 함수는 "PyMapping_Size()"와 "PyObject_Size()"에서 사용되며, 같은
   서명을 갖습니다. 객체에 길이가 정의되어 있지 않으면 이 슬롯을
   "NULL"로 설정할 수 있습니다.

binaryfunc PyMappingMethods.mp_subscript

   * The corresponding slot ID "Py_mp_subscript" is part of the 안정
   ABI.*

   이 함수는 "PyObject_GetItem()"과 "PySequence_GetSlice()"에서 사용되
   며, "PyObject_GetItem()"과 같은 서명을 갖습니다.
   "PyMapping_Check()" 함수가 "1"을 반환하려면, 이 슬롯을 채워야합니다
   , 그렇지 않으면 "NULL"일 수 있습니다.

objobjargproc PyMappingMethods.mp_ass_subscript

   * The corresponding slot ID "Py_mp_ass_subscript" is part of the 안
   정 ABI.*

   This function is used by "PyObject_SetItem()",
   "PyObject_DelItem()", "PySequence_SetSlice()" and
   "PySequence_DelSlice()".  It has the same signature as
   "PyObject_SetItem()", but *v* can also be set to "NULL" to delete
   an item.  If this slot is "NULL", the object does not support item
   assignment and deletion.


시퀀스 객체 구조체
==================

type PySequenceMethods

   이 구조체는 객체가 시퀀스 프로토콜을 구현하는 데 사용하는 함수에 대
   한 포인터를 담습니다.

lenfunc PySequenceMethods.sq_length

   * The corresponding slot ID "Py_sq_length" is part of the 안정
   ABI.*

   이 함수는 "PySequence_Size()"와 "PyObject_Size()"에서 사용되며, 같
   은 서명을 갖습니다. 또한 "sq_item"과 "sq_ass_item" 슬롯을 통해 음수
   인덱스를 처리하는 데 사용됩니다.

binaryfunc PySequenceMethods.sq_concat

   * The corresponding slot ID "Py_sq_concat" is part of the 안정
   ABI.*

   이 함수는 "PySequence_Concat()"에서 사용되며 같은 서명을 갖습니다.
   "nb_add" 슬롯을 통해 숫자 덧셈을 시도한 후, "+" 연산자에서도 사용됩
   니다.

ssizeargfunc PySequenceMethods.sq_repeat

   * The corresponding slot ID "Py_sq_repeat" is part of the 안정
   ABI.*

   이 함수는 "PySequence_Repeat()"에서 사용되며 같은 서명을 갖습니다.
   "nb_multiply" 슬롯을 통해 숫자 곱셈을 시도한 후, "*" 연산자에서도
   사용됩니다.

ssizeargfunc PySequenceMethods.sq_item

   * The corresponding slot ID "Py_sq_item" is part of the 안정 ABI.*

   이 함수는 "PySequence_GetItem()"에서 사용되며 같은 서명을 갖습니다.
   "mp_subscript" 슬롯을 통해 서브스크립션(subscription)을 시도한 후,
   "PyObject_GetItem()"에서도 사용됩니다. "PySequence_Check()" 함수가
   "1"을 반환하려면, 이 슬롯을 채워야합니다, 그렇지 않으면 "NULL"일 수
   있습니다.

   Negative indexes are handled as follows: if the "sq_length" slot is
   filled, it is called and the sequence length is used to compute a
   positive index which is passed to  "sq_item".  If "sq_length" is
   "NULL", the index is passed as is to the function.

ssizeobjargproc PySequenceMethods.sq_ass_item

   * The corresponding slot ID "Py_sq_ass_item" is part of the 안정
   ABI.*

   이 함수는 "PySequence_SetItem()"에서 사용되며 같은 서명을 갖습니다.
   "mp_ass_subscript" 슬롯을 통해 항목 대입과 삭제를 시도한 후,
   "PyObject_SetItem()"과 "PyObject_DelItem()"에서도 사용됩니다. 객체
   가 항목 대입과 삭제를 지원하지 않으면 이 슬롯은 "NULL"로 남겨 둘 수
   있습니다.

objobjproc PySequenceMethods.sq_contains

   * The corresponding slot ID "Py_sq_contains" is part of the 안정
   ABI.*

   이 함수는 "PySequence_Contains()"에서 사용될 수 있으며 같은 서명을
   갖습니다. 이 슬롯은 "NULL"로 남겨 둘 수 있습니다, 이때
   "PySequence_Contains()"는 일치하는 것을 찾을 때까지 시퀀스를 단순히
   탐색합니다.

binaryfunc PySequenceMethods.sq_inplace_concat

   * The corresponding slot ID "Py_sq_inplace_concat" is part of the
   안정 ABI.*

   이 함수는 "PySequence_InPlaceConcat()"에서 사용되며 같은 서명을 갖
   습니다. 첫 번째 피연산자를 수정하고 그것을 반환해야 합니다. 이 슬롯
   은 "NULL"로 남겨 둘 수 있으며, 이때 "PySequence_InPlaceConcat()"은
   "PySequence_Concat()"으로 폴백 됩니다. "nb_inplace_add" 슬롯을 통해
   숫자 제자리 덧셈을 시도한 후, 증분 대입 "+="에서 사용됩니다.

ssizeargfunc PySequenceMethods.sq_inplace_repeat

   * The corresponding slot ID "Py_sq_inplace_repeat" is part of the
   안정 ABI.*

   이 함수는 "PySequence_InPlaceRepeat()"에서 사용되며 같은 서명을 갖
   습니다. 첫 번째 피연산자를 수정하고 그것을 반환해야 합니다. 이 슬롯
   은 "NULL"로 남겨 둘 수 있으며, 이때 "PySequence_InPlaceRepeat()"는
   "PySequence_Repeat()"로 폴백 됩니다. "nb_inplace_multiply" 슬롯을
   통해 숫자 제자리 곱셈을 시도한 후, 증분 대입 "*="에서도 사용됩니다.


버퍼 객체 구조체
================

type PyBufferProcs

   이 구조체는 버퍼 프로토콜에 필요한 함수에 대한 포인터를 담습니다.
   프로토콜은 제공자(exporter) 객체가 내부 데이터를 소비자 객체에 노출
   하는 방법을 정의합니다.

getbufferproc PyBufferProcs.bf_getbuffer

   * The corresponding slot ID "Py_bf_getbuffer" is part of the 안정
   ABI 버전 3.11 이후로.*

   이 함수의 서명은 다음과 같습니다:

      int (PyObject *exporter, Py_buffer *view, int flags);

   *view*를 채우기 위해 *exporter*에 대한 *flags*에 지정된 요청을 처리
   합니다. 포인트 (3) 을 제외하고, 이 함수의 구현은 다음 단계를 반드시
   수행해야 합니다:

   1. Check if the request can be met. If not, raise "BufferError",
      set view->obj to "NULL" and return "-1".

   2. 요청된 필드를 채웁니다.

   3. 내보내기 횟수에 대한 내부 카운터를 증가시킵니다.

   4. Set view->obj to *exporter* and increment view->obj.

   5. "0"을 반환합니다.

   *exporter*가 버퍼 공급자의 체인이나 트리의 일부이면, 두 가지 주요
   체계를 사용할 수 있습니다:

   * Re-export: Each member of the tree acts as the exporting object
     and sets view->obj to a new reference to itself.

   * Redirect: The buffer request is redirected to the root object of
     the tree. Here, view->obj will be a new reference to the root
     object.

   *view*의 개별 필드는 섹션 버퍼 구조체에 설명되어 있으며, 제공자가
   특정 요청에 응답해야 하는 규칙은 섹션 버퍼 요청 유형에 있습니다.

   "Py_buffer" 구조체에서 가리키는 모든 메모리는 제공자에게 속하며 남
   은 소비자가 없어질 때까지 유효해야 합니다. "format", "shape",
   "strides", "suboffsets" 및 "internal"은 소비자에게는 읽기 전용입니
   다.

   "PyBuffer_FillInfo()"는 모든 요청 유형을 올바르게 처리하면서 간단한
   바이트열 버퍼를 쉽게 노출 할 수 있는 방법을 제공합니다.

   "PyObject_GetBuffer()"는 이 함수를 감싸는 소비자 용 인터페이스입니
   다.

releasebufferproc PyBufferProcs.bf_releasebuffer

   * The corresponding slot ID "Py_bf_releasebuffer" is part of the 안
   정 ABI 버전 3.11 이후로.*

   이 함수의 서명은 다음과 같습니다:

      void (PyObject *exporter, Py_buffer *view);

   버퍼 자원 해제 요청을 처리합니다. 자원을 해제할 필요가 없으면,
   "PyBufferProcs.bf_releasebuffer"는 "NULL"일 수 있습니다. 그렇지 않
   으면, 이 함수의 표준 구현은 다음과 같은 선택적 단계를 수행합니다:

   1. 내보내기 횟수에 대한 내부 카운터를 줄입니다.

   2. 카운터가 "0"이면, *view*와 관련된 모든 메모리를 해제합니다.

   제공자는 반드시 "internal" 필드를 사용하여 버퍼 특정 자원을 추적해
   야 합니다. 이 필드는 변경되지 않고 유지됨이 보장되지만, 소비자는 원
   래 버퍼의 사본을 *view* 인자로 전달할 수 있습니다.

   This function MUST NOT decrement view->obj, since that is done
   automatically in "PyBuffer_Release()" (this scheme is useful for
   breaking reference cycles).

   "PyBuffer_Release()"는 이 기능을 감싸는 소비자 용 인터페이스입니다.


비동기 객체 구조체
==================

Added in version 3.5.

type PyAsyncMethods

   이 구조체는 *어웨이터블*와 *비동기 이터레이터* 객체를 구현하는 데
   필요한 함수에 대한 포인터를 담습니다.

   구조체 정의는 다음과 같습니다:

      typedef struct {
          unaryfunc am_await;
          unaryfunc am_aiter;
          unaryfunc am_anext;
          sendfunc am_send;
      } PyAsyncMethods;

unaryfunc PyAsyncMethods.am_await

   * The corresponding slot ID "Py_am_await" is part of the 안정 ABI
   버전 3.5 이후로.*

   이 함수의 서명은 다음과 같습니다:

      PyObject *am_await(PyObject *self);

   The returned object must be an *iterator*, i.e. "PyIter_Check()"
   must return "1" for it.

   객체가 *어웨이터블*이 아니면 이 슬롯을 "NULL"로 설정할 수 있습니다.

unaryfunc PyAsyncMethods.am_aiter

   * The corresponding slot ID "Py_am_aiter" is part of the 안정 ABI
   버전 3.5 이후로.*

   이 함수의 서명은 다음과 같습니다:

      PyObject *am_aiter(PyObject *self);

   Must return an *asynchronous iterator* object. See "__anext__()"
   for details.

   객체가 비동기 이터레이션 프로토콜을 구현하지 않으면 이 슬롯은
   "NULL"로 설정될 수 있습니다.

unaryfunc PyAsyncMethods.am_anext

   * The corresponding slot ID "Py_am_anext" is part of the 안정 ABI
   버전 3.5 이후로.*

   이 함수의 서명은 다음과 같습니다:

      PyObject *am_anext(PyObject *self);

   Must return an *awaitable* object. See "__anext__()" for details.
   This slot may be set to "NULL".

sendfunc PyAsyncMethods.am_send

   * The corresponding slot ID "Py_am_send" is part of the 안정 ABI 버
   전 3.10 이후로.*

   이 함수의 서명은 다음과 같습니다:

      PySendResult am_send(PyObject *self, PyObject *arg, PyObject **result);

   See "PyIter_Send()" for details. This slot may be set to "NULL".

   Added in version 3.10.


슬롯 형 typedef
===============

typedef PyObject *(*allocfunc)(PyTypeObject *cls, Py_ssize_t nitems)
    * Part of the 안정 ABI.*

   The purpose of this function is to separate memory allocation from
   memory initialization.  It should return a pointer to a block of
   memory of adequate length for the instance, suitably aligned, and
   initialized to zeros, but with "ob_refcnt" set to "1" and "ob_type"
   set to the type argument.  If the type's "tp_itemsize" is non-zero,
   the object's "ob_size" field should be initialized to *nitems* and
   the length of the allocated memory block should be "tp_basicsize +
   nitems*tp_itemsize", rounded up to a multiple of "sizeof(void*)";
   otherwise, *nitems* is not used and the length of the block should
   be "tp_basicsize".

   이 함수는 다른 인스턴스 초기화를 수행하지 않아야 합니다, 추가 메모
   리를 할당도 안 됩니다; 그것은 "tp_new"에 의해 수행되어야 합니다.

typedef void (*destructor)(PyObject*)
    * Part of the 안정 ABI.*

typedef void (*freefunc)(void*)

   "tp_free"를 참조하십시오.

typedef PyObject *(*newfunc)(PyTypeObject*, PyObject*, PyObject*)
    * Part of the 안정 ABI.*

   "tp_new"를 참조하십시오.

typedef int (*initproc)(PyObject*, PyObject*, PyObject*)
    * Part of the 안정 ABI.*

   "tp_init"를 참조하십시오.

typedef PyObject *(*reprfunc)(PyObject*)
    * Part of the 안정 ABI.*

   "tp_repr"을 참조하십시오.

typedef PyObject *(*getattrfunc)(PyObject *self, char *attr)
    * Part of the 안정 ABI.*

   객체의 명명된 어트리뷰트 값을 반환합니다.

typedef int (*setattrfunc)(PyObject *self, char *attr, PyObject *value)
    * Part of the 안정 ABI.*

   객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면
   value 인자가 "NULL"로 설정됩니다.

typedef PyObject *(*getattrofunc)(PyObject *self, PyObject *attr)
    * Part of the 안정 ABI.*

   객체의 명명된 어트리뷰트 값을 반환합니다.

   "tp_getattro"를 참조하십시오.

typedef int (*setattrofunc)(PyObject *self, PyObject *attr, PyObject *value)
    * Part of the 안정 ABI.*

   객체의 명명된 어트리뷰트 값을 설정합니다. 어트리뷰트를 삭제하려면
   value 인자가 "NULL"로 설정됩니다.

   "tp_setattro"를 참조하십시오.

typedef PyObject *(*descrgetfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the 안정 ABI.*

   See "tp_descr_get".

typedef int (*descrsetfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the 안정 ABI.*

   See "tp_descr_set".

typedef Py_hash_t (*hashfunc)(PyObject*)
    * Part of the 안정 ABI.*

   "tp_hash"를 참조하십시오.

typedef PyObject *(*richcmpfunc)(PyObject*, PyObject*, int)
    * Part of the 안정 ABI.*

   "tp_richcompare"를 참조하십시오.

typedef PyObject *(*getiterfunc)(PyObject*)
    * Part of the 안정 ABI.*

   "tp_iter"를 참조하십시오.

typedef PyObject *(*iternextfunc)(PyObject*)
    * Part of the 안정 ABI.*

   "tp_iternext"를 참조하십시오.

typedef Py_ssize_t (*lenfunc)(PyObject*)
    * Part of the 안정 ABI.*

typedef int (*getbufferproc)(PyObject*, Py_buffer*, int)
    * Part of the 안정 ABI 버전 3.12 이후로.*

typedef void (*releasebufferproc)(PyObject*, Py_buffer*)
    * Part of the 안정 ABI 버전 3.12 이후로.*

typedef PyObject *(*unaryfunc)(PyObject*)
    * Part of the 안정 ABI.*

typedef PyObject *(*binaryfunc)(PyObject*, PyObject*)
    * Part of the 안정 ABI.*

typedef PySendResult (*sendfunc)(PyObject*, PyObject*, PyObject**)

   See "am_send".

typedef PyObject *(*ternaryfunc)(PyObject*, PyObject*, PyObject*)
    * Part of the 안정 ABI.*

typedef PyObject *(*ssizeargfunc)(PyObject*, Py_ssize_t)
    * Part of the 안정 ABI.*

typedef int (*ssizeobjargproc)(PyObject*, Py_ssize_t, PyObject*)
    * Part of the 안정 ABI.*

typedef int (*objobjproc)(PyObject*, PyObject*)
    * Part of the 안정 ABI.*

typedef int (*objobjargproc)(PyObject*, PyObject*, PyObject*)
    * Part of the 안정 ABI.*


예
==

다음은 파이썬 형 정의의 간단한 예입니다. 여기에는 여러분이 만날 수 있
는 일반적인 사용법이 포함됩니다. 일부는 까다로운 코너 사례를 보여줍니
다. 더 많은 예제, 실용 정보 및 자습서는 확장형 정의하기: 자습서와 확장
형 정의하기: 여러 가지 주제를 참조하십시오.

A basic static type:

   typedef struct {
       PyObject_HEAD
       const char *data;
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
       .tp_basicsize = sizeof(MyObject),
       .tp_doc = PyDoc_STR("My objects"),
       .tp_new = myobj_new,
       .tp_dealloc = (destructor)myobj_dealloc,
       .tp_repr = (reprfunc)myobj_repr,
   };

더 상세한 초기화자를 사용하는 이전 코드(특히 CPython 코드 베이스에서)
를 찾을 수도 있습니다:

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       "mymod.MyObject",               /* tp_name */
       sizeof(MyObject),               /* tp_basicsize */
       0,                              /* tp_itemsize */
       (destructor)myobj_dealloc,      /* tp_dealloc */
       0,                              /* tp_vectorcall_offset */
       0,                              /* tp_getattr */
       0,                              /* tp_setattr */
       0,                              /* tp_as_async */
       (reprfunc)myobj_repr,           /* tp_repr */
       0,                              /* tp_as_number */
       0,                              /* tp_as_sequence */
       0,                              /* tp_as_mapping */
       0,                              /* tp_hash */
       0,                              /* tp_call */
       0,                              /* tp_str */
       0,                              /* tp_getattro */
       0,                              /* tp_setattro */
       0,                              /* tp_as_buffer */
       0,                              /* tp_flags */
       PyDoc_STR("My objects"),        /* tp_doc */
       0,                              /* tp_traverse */
       0,                              /* tp_clear */
       0,                              /* tp_richcompare */
       0,                              /* tp_weaklistoffset */
       0,                              /* tp_iter */
       0,                              /* tp_iternext */
       0,                              /* tp_methods */
       0,                              /* tp_members */
       0,                              /* tp_getset */
       0,                              /* tp_base */
       0,                              /* tp_dict */
       0,                              /* tp_descr_get */
       0,                              /* tp_descr_set */
       0,                              /* tp_dictoffset */
       0,                              /* tp_init */
       0,                              /* tp_alloc */
       myobj_new,                      /* tp_new */
   };

약한 참조, 인스턴스 딕셔너리 및 해싱을 지원하는 형:

   typedef struct {
       PyObject_HEAD
       const char *data;
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
       .tp_basicsize = sizeof(MyObject),
       .tp_doc = PyDoc_STR("My objects"),
       .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
            Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_MANAGED_DICT |
            Py_TPFLAGS_MANAGED_WEAKREF,
       .tp_new = myobj_new,
       .tp_traverse = (traverseproc)myobj_traverse,
       .tp_clear = (inquiry)myobj_clear,
       .tp_alloc = PyType_GenericNew,
       .tp_dealloc = (destructor)myobj_dealloc,
       .tp_repr = (reprfunc)myobj_repr,
       .tp_hash = (hashfunc)myobj_hash,
       .tp_richcompare = PyBaseObject_Type.tp_richcompare,
   };

A str subclass that cannot be subclassed and cannot be called to
create instances (e.g. uses a separate factory func) using
"Py_TPFLAGS_DISALLOW_INSTANTIATION" flag:

   typedef struct {
       PyUnicodeObject raw;
       char *extra;
   } MyStr;

   static PyTypeObject MyStr_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyStr",
       .tp_basicsize = sizeof(MyStr),
       .tp_base = NULL,  // set to &PyUnicode_Type in module init
       .tp_doc = PyDoc_STR("my custom str"),
       .tp_flags = Py_TPFLAGS_DEFAULT | Py_TPFLAGS_DISALLOW_INSTANTIATION,
       .tp_repr = (reprfunc)myobj_repr,
   };

The simplest static type with fixed-length instances:

   typedef struct {
       PyObject_HEAD
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
   };

The simplest static type with variable-length instances:

   typedef struct {
       PyObject_VAR_HEAD
       const char *data[1];
   } MyObject;

   static PyTypeObject MyObject_Type = {
       PyVarObject_HEAD_INIT(NULL, 0)
       .tp_name = "mymod.MyObject",
       .tp_basicsize = sizeof(MyObject) - sizeof(char *),
       .tp_itemsize = sizeof(char *),
   };
