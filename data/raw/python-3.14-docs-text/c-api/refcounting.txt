참조 횟수
*********

이 섹션의 함수와 매크로는 파이썬 객체의 참조 횟수를 관리하는 데 사용됩
니다.

Py_ssize_t Py_REFCNT(PyObject *o)
    * Part of the 안정 ABI 버전 3.14 이후로.*

   Get the reference count of the Python object *o*.

   Note that the returned value may not actually reflect how many
   references to the object are actually held.  For example, some
   objects are *immortal* and have a very high refcount that does not
   reflect the actual number of references.  Consequently, do not rely
   on the returned value to be accurate, other than a value of 0 or 1.

   Use the "Py_SET_REFCNT()" function to set an object reference
   count.

   참고:

     On *free threaded* builds of Python, returning 1 isn't sufficient
     to determine if it's safe to treat *o* as having no access by
     other threads. Use "PyUnstable_Object_IsUniquelyReferenced()" for
     that instead.See also the function
     "PyUnstable_Object_IsUniqueReferencedTemporary()".

   버전 3.10에서 변경: "Py_REFCNT()" is changed to the inline static
   function.

   버전 3.11에서 변경: The parameter type is no longer const
   PyObject*.

void Py_SET_REFCNT(PyObject *o, Py_ssize_t refcnt)

   Set the object *o* reference counter to *refcnt*.

   On Python build with Free Threading, if *refcnt* is larger than
   "UINT32_MAX", the object is made *immortal*.

   This function has no effect on *immortal* objects.

   Added in version 3.9.

   버전 3.12에서 변경: Immortal objects are not modified.

void Py_INCREF(PyObject *o)

   Indicate taking a new *strong reference* to object *o*, indicating
   it is in use and should not be destroyed.

   This function has no effect on *immortal* objects.

   This function is usually used to convert a *borrowed reference* to
   a *strong reference* in-place. The "Py_NewRef()" function can be
   used to create a new *strong reference*.

   When done using the object, release is by calling "Py_DECREF()".

   객체는 "NULL" 일 수 없습니다; "NULL"이 아닌지 확실하지 않으면,
   "Py_XINCREF()"를 사용하십시오.

   Do not expect this function to actually modify *o* in any way. For
   at least **some objects**, this function has no effect.

   버전 3.12에서 변경: Immortal objects are not modified.

void Py_XINCREF(PyObject *o)

   Similar to "Py_INCREF()", but the object *o* can be "NULL", in
   which case this has no effect.

   See also "Py_XNewRef()".

PyObject *Py_NewRef(PyObject *o)
    * Part of the 안정 ABI 버전 3.10 이후로.*

   Create a new *strong reference* to an object: call "Py_INCREF()" on
   *o* and return the object *o*.

   When the *strong reference* is no longer needed, "Py_DECREF()"
   should be called on it to release the reference.

   The object *o* must not be "NULL"; use "Py_XNewRef()" if *o* can be
   "NULL".

   예를 들어:

      Py_INCREF(obj);
      self->attr = obj;

   can be written as:

      self->attr = Py_NewRef(obj);

   See also "Py_INCREF()".

   Added in version 3.10.

PyObject *Py_XNewRef(PyObject *o)
    * Part of the 안정 ABI 버전 3.10 이후로.*

   Similar to "Py_NewRef()", but the object *o* can be NULL.

   If the object *o* is "NULL", the function just returns "NULL".

   Added in version 3.10.

void Py_DECREF(PyObject *o)

   Release a *strong reference* to object *o*, indicating the
   reference is no longer used.

   This function has no effect on *immortal* objects.

   마지막 *강한 참조*가 해제되면 (즉 객체의 참조 횟수가 0이 되면), 객
   체 형의 할당 해제 함수 (반드시 "NULL"이 아니어야 합니다)가 호출됩니
   다.

   This function is usually used to delete a *strong reference* before
   exiting its scope.

   객체는 "NULL" 일 수 없습니다; "NULL"이 아닌지 확실하지 않으면,
   "Py_XDECREF()"를 사용하십시오.

   Do not expect this function to actually modify *o* in any way. For
   at least **some objects**, this function has no effect.

   경고:

     할당 해제 함수는 임의의 파이썬 코드가 호출되도록 할 수 있습니다 (
     예를 들어, "__del__()" 메서드가 있는 클래스 인스턴스가 할당 해제
     될 때). 이러한 코드에서의 예외는 전파되지 않지만, 실행된 코드는
     모든 파이썬 전역 변수에 자유롭게 액세스할 수 있습니다. 이것은
     "Py_DECREF()"가 호출되기 전에 전역 변수에서 도달할 수 있는 모든
     객체가 일관성 있는 상태에 있어야 함을 뜻합니다. 예를 들어, 리스트
     에서 객체를 삭제하는 코드는 삭제된 객체에 대한 참조를 임시 변수에
     복사하고, 리스트 데이터 구조를 갱신한 다음, 임시 변수에 대해
     "Py_DECREF()"를 호출해야 합니다.

   버전 3.12에서 변경: Immortal objects are not modified.

void Py_XDECREF(PyObject *o)

   Similar to "Py_DECREF()", but the object *o* can be "NULL", in
   which case this has no effect. The same warning from "Py_DECREF()"
   applies here as well.

void Py_CLEAR(PyObject *o)

   객체 *o*에 대한 *강한 참조*를 해제합니다. 객체는 "NULL" 일 수 있습
   니다, 이때 매크로는 효과가 없습니다; 그렇지 않으면 인자도 "NULL"로
   설정된다는 점을 제외하고는, 효과가 "Py_DECREF()"와 같습니다. 매크로
   가 임시 변수를 신중하게 사용하고, 참조를 해제하기 전에 인자를
   "NULL"로 설정하기 때문에, "Py_DECREF()"에 대한 경고는 전달된 객체와
   관련하여 적용되지 않습니다.

   가비지 수집 중에 탐색 될 수 있는 객체에 대한 참조를 해제할 때마다
   이 매크로를 사용하는 것이 좋습니다.

   버전 3.12에서 변경: The macro argument is now only evaluated once.
   If the argument has side effects, these are no longer duplicated.

void Py_IncRef(PyObject *o)
    * Part of the 안정 ABI.*

   Indicate taking a new *strong reference* to object *o*. A function
   version of "Py_XINCREF()". It can be used for runtime dynamic
   embedding of Python.

void Py_DecRef(PyObject *o)
    * Part of the 안정 ABI.*

   Release a *strong reference* to object *o*. A function version of
   "Py_XDECREF()". It can be used for runtime dynamic embedding of
   Python.

Py_SETREF(dst, src)

   Macro safely releasing a *strong reference* to object *dst* and
   setting *dst* to *src*.

   As in case of "Py_CLEAR()", "the obvious" code can be deadly:

      Py_DECREF(dst);
      dst = src;

   The safe way is:

      Py_SETREF(dst, src);

   That arranges to set *dst* to *src* *before* releasing the
   reference to the old value of *dst*, so that any code triggered as
   a side-effect of *dst* getting torn down no longer believes *dst*
   points to a valid object.

   Added in version 3.6.

   버전 3.12에서 변경: The macro arguments are now only evaluated
   once. If an argument has side effects, these are no longer
   duplicated.

Py_XSETREF(dst, src)

   Variant of "Py_SETREF" macro that uses "Py_XDECREF()" instead of
   "Py_DECREF()".

   Added in version 3.6.

   버전 3.12에서 변경: The macro arguments are now only evaluated
   once. If an argument has side effects, these are no longer
   duplicated.
