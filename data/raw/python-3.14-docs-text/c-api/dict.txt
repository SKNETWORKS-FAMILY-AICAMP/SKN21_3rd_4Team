딕셔너리 객체
*************

type PyDictObject

   이 "PyObject"의 서브 형은 파이썬 딕셔너리 객체를 나타냅니다.

PyTypeObject PyDict_Type
    * Part of the 안정 ABI.*

   이 "PyTypeObject" 인스턴스는 파이썬 딕셔너리 형을 나타냅니다. 이것
   은 파이썬 계층의 "dict"와 같은 객체입니다.

int PyDict_Check(PyObject *p)

   *p*가 dict 객체이거나 dict 형의 서브 형의 인스턴스면 참을 반환합니
   다. 이 함수는 항상 성공합니다.

int PyDict_CheckExact(PyObject *p)

   *p*가 dict 객체이지만, dict 형의 서브 형의 인스턴스는 아니면 참을
   반환합니다. 이 함수는 항상 성공합니다.

PyObject *PyDict_New()
    *반환값: 새 참조.** Part of the 안정 ABI.*

   새로운 빈 딕셔너리를 반환하거나, 실패하면 "NULL"을 반환합니다.

PyObject *PyDictProxy_New(PyObject *mapping)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   읽기 전용 동작을 강제하는 매핑을 위한 "types.MappingProxyType" 객체
   를 반환합니다. 이것은 일반적으로 비 동적 클래스 형을 위한 딕셔너리
   의 수정을 방지하기 위해 뷰를 만드는 데 사용됩니다.

PyTypeObject PyDictProxy_Type
    * Part of the 안정 ABI.*

   The type object for mapping proxy objects created by
   "PyDictProxy_New()" and for the read-only "__dict__" attribute of
   many built-in types. A "PyDictProxy_Type" instance provides a
   dynamic, read-only view of an underlying dictionary: changes to the
   underlying dictionary are reflected in the proxy, but the proxy
   itself does not support mutation operations. This corresponds to
   "types.MappingProxyType" in Python.

void PyDict_Clear(PyObject *p)
    * Part of the 안정 ABI.*

   기존 딕셔너리의 모든 키-값 쌍을 비웁니다.

int PyDict_Contains(PyObject *p, PyObject *key)
    * Part of the 안정 ABI.*

   Determine if dictionary *p* contains *key*.  If an item in *p*
   matches *key*, return "1", otherwise return "0".  On error, return
   "-1". This is equivalent to the Python expression "key in p".

int PyDict_ContainsString(PyObject *p, const char *key)

   이것은 "PyDict_Contains()"와 같지만, *key*가 PyObject*가 아닌 const
   char* UTF-8 인코딩된 바이트 문자열로 지정됩니다.

   Added in version 3.13.

PyObject *PyDict_Copy(PyObject *p)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *p*와 같은 키-값 쌍을 포함하는 새 딕셔너리를 반환합니다.

int PyDict_SetItem(PyObject *p, PyObject *key, PyObject *val)
    * Part of the 안정 ABI.*

   딕셔너리 *p*에 *val*을 *key* 키로 삽입합니다. *key*는 *해시 가능*해
   야 합니다. 그렇지 않으면 "TypeError"가 발생합니다. 성공하면 "0"을,
   실패하면 "-1"을 반환합니다. 이 함수는 *val*에 대한 참조를 훔치지 *
   않습니다*.

int PyDict_SetItemString(PyObject *p, const char *key, PyObject *val)
    * Part of the 안정 ABI.*

   이것은 "PyDict_SetItem()"와 같지만, *key*가 PyObject*가 아닌 const
   char* UTF-8 인코딩된 바이트 문자열로 지정됩니다.

int PyDict_DelItem(PyObject *p, PyObject *key)
    * Part of the 안정 ABI.*

   딕셔너리 *p*에서 키가 *key*인 항목을 제거합니다. *key*는 *해시 가능
   *해야 합니다. 그렇지 않으면 "TypeError"가 발생합니다. *key*가 딕셔
   너리에 없으면, "KeyError"가 발생합니다. 성공하면 "0"을, 실패하면
   "-1"을 반환합니다.

int PyDict_DelItemString(PyObject *p, const char *key)
    * Part of the 안정 ABI.*

   이것은 "PyDict_DelItem()"와 같지만, *key*가 PyObject*가 아닌 const
   char* UTF-8 인코딩된 바이트 문자열로 지정됩니다.

int PyDict_GetItemRef(PyObject *p, PyObject *key, PyObject **result)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   Return a new *strong reference* to the object from dictionary *p*
   which has a key *key*:

   * If the key is present, set **result* to a new *strong reference*
     to the value and return "1".

   * If the key is missing, set **result* to "NULL" and return "0".

   * On error, raise an exception and return "-1".

   Added in version 3.13.

   See also the "PyObject_GetItem()" function.

PyObject *PyDict_GetItem(PyObject *p, PyObject *key)
    *반환값: 빌린 참조.** Part of the 안정 ABI.*

   딕셔너리 *p*에서 키가 *key*인 객체에 대한 *빌린 참조*를 반환합니다.
   *key* 키가 없으면 예외를 설정하지 *않고* "NULL"을 반환합니다.

   참고:

     "__hash__()"와 "__eq__()" 메서드를 호출하는 동안 발생하는 예외는
     조용히 무시됩니다. 대신 "PyDict_GetItemWithError()" 함수를 사용하
     십시오.

   버전 3.10에서 변경: Calling this API without an *attached thread
   state* had been allowed for historical reason. It is no longer
   allowed.

PyObject *PyDict_GetItemWithError(PyObject *p, PyObject *key)
    *반환값: 빌린 참조.** Part of the 안정 ABI.*

   예외를 억제하지 않는 "PyDict_GetItem()"의 변형입니다. 예외가 발생하
   면 예외를 **설정하고** "NULL"을 반환합니다. 키가 없으면 예외를 설정
   하지 **않고** "NULL"을 반환합니다.

PyObject *PyDict_GetItemString(PyObject *p, const char *key)
    *반환값: 빌린 참조.** Part of the 안정 ABI.*

   이것은 "PyDict_GetItem()"와 같지만, *key*가 PyObject*가 아닌 const
   char* UTF-8로 인코딩된 바이트 문자열로 지정됩니다.

   참고:

     "__hash__()"와 "__eq__()" 메서드를 호출하는 동안이나 임시 "str"
     객체를 만드는 동안 발생하는 예외는 조용히 무시됩니다. 대신 자체
     "PyUnicode_FromString()" *key*와 함께 "PyDict_GetItemWithError()"
     함수를 사용하는 것이 좋습니다.

int PyDict_GetItemStringRef(PyObject *p, const char *key, PyObject **result)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   이것은 "PyDict_GetItemRef()"와 유시하지만, *key*가 PyObject*가 아닌
   const char* UTF-8로 인코딩된 바이트 문자열로 지정됩니다.

   Added in version 3.13.

PyObject *PyDict_SetDefault(PyObject *p, PyObject *key, PyObject *defaultobj)
    *반환값: 빌린 참조.*

   이것은 파이썬 수준의 "dict.setdefault()"와 같습니다. 존재하면, 딕셔
   너리 *p*에서 *key*에 해당하는 값을 반환합니다. 키가 dict에 없으면,
   값 *defaultobj*로 삽입되고, *defaultobj*가 반환됩니다. 이 함수는
   *key*의 해시 함수를 조회 및 삽입을 위해 독립적으로 평가하는 대신 한
   번만 평가합니다.

   Added in version 3.4.

int PyDict_SetDefaultRef(PyObject *p, PyObject *key, PyObject *default_value, PyObject **result)

   Inserts *default_value* into the dictionary *p* with a key of *key*
   if the key is not already present in the dictionary. If *result* is
   not "NULL", then **result* is set to a *strong reference* to either
   *default_value*, if the key was not present, or the existing value,
   if *key* was already present in the dictionary. Returns "1" if the
   key was present and *default_value* was not inserted, or "0" if the
   key was not present and *default_value* was inserted. On failure,
   returns "-1", sets an exception, and sets "*result" to "NULL".

   For clarity: if you have a strong reference to *default_value*
   before calling this function, then after it returns, you hold a
   strong reference to both *default_value* and **result* (if it's not
   "NULL"). These may refer to the same object: in that case you hold
   two separate references to it.

   Added in version 3.13.

int PyDict_Pop(PyObject *p, PyObject *key, PyObject **result)

   Remove *key* from dictionary *p* and optionally return the removed
   value. Do not raise "KeyError" if the key is missing.

   * If the key is present, set **result* to a new reference to the
     removed value if *result* is not "NULL", and return "1".

   * If the key is missing, set **result* to "NULL" if *result* is not
     "NULL", and return "0".

   * On error, raise an exception and return "-1".

   Similar to "dict.pop()", but without the default value and not
   raising "KeyError" if the key is missing.

   Added in version 3.13.

int PyDict_PopString(PyObject *p, const char *key, PyObject **result)

   이것은 "PyDict_Pop()"와 유사하지만, *key*가 PyObject*가 아닌 const
   char* UTF-8로 인코딩된 바이트 문자열로 지정됩니다.

   Added in version 3.13.

PyObject *PyDict_Items(PyObject *p)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   딕셔너리의 모든 항목을 포함하는 "PyListObject"를 반환합니다.

PyObject *PyDict_Keys(PyObject *p)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   딕셔너리의 모든 키를 포함하는 "PyListObject"를 반환합니다.

PyObject *PyDict_Values(PyObject *p)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   딕셔너리 *p*의 모든 값을 포함하는 "PyListObject"를 반환합니다.

Py_ssize_t PyDict_Size(PyObject *p)
    * Part of the 안정 ABI.*

   딕셔너리에 있는 항목의 수를 반환합니다. 이는 딕셔너리에 대한
   "len(p)"와 동등합니다.

Py_ssize_t PyDict_GET_SIZE(PyObject *p)

   Similar to "PyDict_Size()", but without error checking.

int PyDict_Next(PyObject *p, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)
    * Part of the 안정 ABI.*

   딕셔너리 *p*의 모든 키-값 쌍을 이터레이트 합니다. *ppos*에 의해 참
   조된 "Py_ssize_t"는, 이터레이션을 시작하기 위해 이 함수를 처음 호출
   하기 전에 "0"으로 초기화되어야 합니다; 이 함수는 딕셔너리의 각 쌍에
   대해 참을 반환하고, 모든 쌍이 보고되었으면 거짓을 반환합니다. 매개
   변수 *pkey*와 *pvalue*는 각각 키와 값으로 채울 PyObject* 변수를 가
   리 키거나, "NULL" 일 수 있습니다. 이들을 통해 반환된 참조는 모두 빌
   린(borrowed) 것입니다. 이터레이션 중에 *ppos*를 변경하면 안 됩니다.
   이 값은 내부 딕셔너리 구조 내의 오프셋을 나타내며, 구조가 희박하므
   로 오프셋이 연속되지 않습니다.

   예를 들면:

      PyObject *key, *value;
      Py_ssize_t pos = 0;

      while (PyDict_Next(self->dict, &pos, &key, &value)) {
          /* 값으로 흥미로운 작업을 수행합니다... */
          ...
      }

   딕셔너리 *p*는 이터레이션 중에 변경해서는 안 됩니다. 딕셔너리를 이
   터레이트 할 때 값을 변경하는 것은 안전하지만, 키 집합이 변경되지 않
   는 한만 그렇습니다. 예를 들면:

      PyObject *key, *value;
      Py_ssize_t pos = 0;

      while (PyDict_Next(self->dict, &pos, &key, &value)) {
          long i = PyLong_AsLong(value);
          if (i == -1 && PyErr_Occurred()) {
              return -1;
          }
          PyObject *o = PyLong_FromLong(i + 1);
          if (o == NULL)
              return -1;
          if (PyDict_SetItem(self->dict, key, o) < 0) {
              Py_DECREF(o);
              return -1;
          }
          Py_DECREF(o);
      }

   The function is not thread-safe in the *free-threaded* build
   without external synchronization.  You can use
   "Py_BEGIN_CRITICAL_SECTION" to lock the dictionary while iterating
   over it:

      Py_BEGIN_CRITICAL_SECTION(self->dict);
      while (PyDict_Next(self->dict, &pos, &key, &value)) {
          ...
      }
      Py_END_CRITICAL_SECTION();

   참고:

     On the free-threaded build, this function can be used safely
     inside a critical section. However, the references returned for
     *pkey* and *pvalue* are *borrowed* and are only valid while the
     critical section is held. If you need to use these objects
     outside the critical section or when the critical section can be
     suspended, create a *strong reference* (for example, using
     "Py_NewRef()").

int PyDict_Merge(PyObject *a, PyObject *b, int override)
    * Part of the 안정 ABI.*

   매핑 객체 *b*를 이터레이트 하면서, 키-값 쌍을 딕셔너리 *a*에 추가합
   니다. *b*는 딕셔너리거나 "PyMapping_Keys()"와 "PyObject_GetItem()"
   를 지원하는 모든 객체일 수 있습니다. *override*가 참이면, *a*에 있
   는 기존 쌍이 *b*에서 일치하는 키가 있으면 교체되고, 그렇지 않으면
   *a*와 일치하는 키가 없을 때만 쌍이 추가됩니다. 성공하면 "0"을 반환
   하고, 예외가 발생하면 "-1"을 반환합니다.

int PyDict_Update(PyObject *a, PyObject *b)
    * Part of the 안정 ABI.*

   이는 C에서 "PyDict_Merge(a, b, 1)"와 같고, 두 번째 인자에 "keys" 어
   트리뷰트가 없을 때 "PyDict_Update()"가 키-값 쌍의 시퀀스에 대해 이
   터레이트 하지 않는다는 점만 제외하면, 파이썬에서 "a.update(b)"와 유
   사합니다. 성공하면 "0"을 반환하고, 예외가 발생하면 "-1"을 반환합니
   다.

int PyDict_MergeFromSeq2(PyObject *a, PyObject *seq2, int override)
    * Part of the 안정 ABI.*

   *seq2*의 키-값 쌍으로 딕셔너리 *a*를 갱신하거나 병합합니다. *seq2*
   는 키-값 쌍으로 간주하는 길이 2의 이터러블 객체를 생성하는 이터러블
   객체여야 합니다. 중복 키가 있으면, *override*가 참이면 마지막이 승
   리하고, 그렇지 않으면 첫 번째가 승리합니다. 성공 시 "0"을 반환하고,
   예외가 발생하면 "-1"을 반환합니다. 동등한 파이썬은 이렇습니다(반환
   값 제외)

      def PyDict_MergeFromSeq2(a, seq2, override):
          for key, value in seq2:
              if override or key not in a:
                  a[key] = value

int PyDict_AddWatcher(PyDict_WatchCallback callback)

   Register *callback* as a dictionary watcher. Return a non-negative
   integer id which must be passed to future calls to
   "PyDict_Watch()". In case of error (e.g. no more watcher IDs
   available), return "-1" and set an exception.

   Added in version 3.12.

int PyDict_ClearWatcher(int watcher_id)

   Clear watcher identified by *watcher_id* previously returned from
   "PyDict_AddWatcher()". Return "0" on success, "-1" on error (e.g.
   if the given *watcher_id* was never registered.)

   Added in version 3.12.

int PyDict_Watch(int watcher_id, PyObject *dict)

   Mark dictionary *dict* as watched. The callback granted
   *watcher_id* by "PyDict_AddWatcher()" will be called when *dict* is
   modified or deallocated. Return "0" on success or "-1" on error.

   Added in version 3.12.

int PyDict_Unwatch(int watcher_id, PyObject *dict)

   Mark dictionary *dict* as no longer watched. The callback granted
   *watcher_id* by "PyDict_AddWatcher()" will no longer be called when
   *dict* is modified or deallocated. The dict must previously have
   been watched by this watcher. Return "0" on success or "-1" on
   error.

   Added in version 3.12.

type PyDict_WatchEvent

   Enumeration of possible dictionary watcher events:
   "PyDict_EVENT_ADDED", "PyDict_EVENT_MODIFIED",
   "PyDict_EVENT_DELETED", "PyDict_EVENT_CLONED",
   "PyDict_EVENT_CLEARED", or "PyDict_EVENT_DEALLOCATED".

   Added in version 3.12.

typedef int (*PyDict_WatchCallback)(PyDict_WatchEvent event, PyObject *dict, PyObject *key, PyObject *new_value)

   Type of a dict watcher callback function.

   If *event* is "PyDict_EVENT_CLEARED" or "PyDict_EVENT_DEALLOCATED",
   both *key* and *new_value* will be "NULL". If *event* is
   "PyDict_EVENT_ADDED" or "PyDict_EVENT_MODIFIED", *new_value* will
   be the new value for *key*. If *event* is "PyDict_EVENT_DELETED",
   *key* is being deleted from the dictionary and *new_value* will be
   "NULL".

   "PyDict_EVENT_CLONED" occurs when *dict* was previously empty and
   another dict is merged into it. To maintain efficiency of this
   operation, per-key "PyDict_EVENT_ADDED" events are not issued in
   this case; instead a single "PyDict_EVENT_CLONED" is issued, and
   *key* will be the source dictionary.

   The callback may inspect but must not modify *dict*; doing so could
   have unpredictable effects, including infinite recursion. Do not
   trigger Python code execution in the callback, as it could modify
   the dict as a side effect.

   If *event* is "PyDict_EVENT_DEALLOCATED", taking a new reference in
   the callback to the about-to-be-destroyed dictionary will resurrect
   it and prevent it from being freed at this time. When the
   resurrected object is destroyed later, any watcher callbacks active
   at that time will be called again.

   Callbacks occur before the notified modification to *dict* takes
   place, so the prior state of *dict* can be inspected.

   If the callback sets an exception, it must return "-1"; this
   exception will be printed as an unraisable exception using
   "PyErr_WriteUnraisable()". Otherwise it should return "0".

   There may already be a pending exception set on entry to the
   callback. In this case, the callback should return "0" with the
   same exception still set. This means the callback may not call any
   other API that can set an exception unless it saves and clears the
   exception state first, and restores it before returning.

   Added in version 3.12.


Dictionary View Objects
=======================

int PyDictViewSet_Check(PyObject *op)

   Return true if *op* is a view of a set inside a dictionary. This is
   currently equivalent to PyDictKeys_Check(op) ||
   PyDictItems_Check(op). This function always succeeds.

PyTypeObject PyDictKeys_Type
    * Part of the 안정 ABI.*

   Type object for a view of dictionary keys. In Python, this is the
   type of the object returned by "dict.keys()".

int PyDictKeys_Check(PyObject *op)

   Return true if *op* is an instance of a dictionary keys view. This
   function always succeeds.

PyTypeObject PyDictValues_Type
    * Part of the 안정 ABI.*

   Type object for a view of dictionary values. In Python, this is the
   type of the object returned by "dict.values()".

int PyDictValues_Check(PyObject *op)

   Return true if *op* is an instance of a dictionary values view.
   This function always succeeds.

PyTypeObject PyDictItems_Type
    * Part of the 안정 ABI.*

   Type object for a view of dictionary items. In Python, this is the
   type of the object returned by "dict.items()".

int PyDictItems_Check(PyObject *op)

   Return true if *op* is an instance of a dictionary items view. This
   function always succeeds.


Ordered Dictionaries
====================

Python's C API provides interface for "collections.OrderedDict" from
C. Since Python 3.7, dictionaries are ordered by default, so there is
usually little need for these functions; prefer "PyDict*" where
possible.

PyTypeObject PyODict_Type

   Type object for ordered dictionaries. This is the same object as
   "collections.OrderedDict" in the Python layer.

int PyODict_Check(PyObject *od)

   Return true if *od* is an ordered dictionary object or an instance
   of a subtype of the "OrderedDict" type.  This function always
   succeeds.

int PyODict_CheckExact(PyObject *od)

   Return true if *od* is an ordered dictionary object, but not an
   instance of a subtype of the "OrderedDict" type. This function
   always succeeds.

PyTypeObject PyODictKeys_Type

   Analogous to "PyDictKeys_Type" for ordered dictionaries.

PyTypeObject PyODictValues_Type

   Analogous to "PyDictValues_Type" for ordered dictionaries.

PyTypeObject PyODictItems_Type

   Analogous to "PyDictItems_Type" for ordered dictionaries.

PyObject *PyODict_New(void)

   Return a new empty ordered dictionary, or "NULL" on failure.

   This is analogous to "PyDict_New()".

int PyODict_SetItem(PyObject *od, PyObject *key, PyObject *value)

   Insert *value* into the ordered dictionary *od* with a key of
   *key*. Return "0" on success or "-1" with an exception set on
   failure.

   This is analogous to "PyDict_SetItem()".

int PyODict_DelItem(PyObject *od, PyObject *key)

   Remove the entry in the ordered dictionary *od* with key *key*.
   Return "0" on success or "-1" with an exception set on failure.

   This is analogous to "PyDict_DelItem()".

These are *soft deprecated* aliases to "PyDict" APIs:

+----------------------------------------------------+----------------------------------------------------+
| "PyODict"                                          | "PyDict"                                           |
|====================================================|====================================================|
| PyODict_GetItem(od, key)                           | "PyDict_GetItem()"                                 |
+----------------------------------------------------+----------------------------------------------------+
| PyODict_GetItemWithError(od, key)                  | "PyDict_GetItemWithError()"                        |
+----------------------------------------------------+----------------------------------------------------+
| PyODict_GetItemString(od, key)                     | "PyDict_GetItemString()"                           |
+----------------------------------------------------+----------------------------------------------------+
| PyODict_Contains(od, key)                          | "PyDict_Contains()"                                |
+----------------------------------------------------+----------------------------------------------------+
| PyODict_Size(od)                                   | "PyDict_Size()"                                    |
+----------------------------------------------------+----------------------------------------------------+
| PyODict_SIZE(od)                                   | "PyDict_GET_SIZE()"                                |
+----------------------------------------------------+----------------------------------------------------+
