부동 소수점 객체
****************

type PyFloatObject

   이 "PyObject"의 서브 형은 파이썬 부동 소수점 객체를 나타냅니다.

PyTypeObject PyFloat_Type
    * Part of the 안정 ABI.*

   이 "PyTypeObject" 인스턴스는 파이썬 부동 소수점 형을 나타냅니다. 이
   것은 파이썬 계층에서 "float"와 같은 객체입니다.

int PyFloat_Check(PyObject *p)

   인자가 "PyFloatObject" 나 "PyFloatObject"의 서브 형이면 참을 반환합
   니다. 이 함수는 항상 성공합니다.

int PyFloat_CheckExact(PyObject *p)

   인자가 "PyFloatObject"이지만 "PyFloatObject"의 서브 형은 아니면 참
   을 반환합니다. 이 함수는 항상 성공합니다.

PyObject *PyFloat_FromString(PyObject *str)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *str*의 문자열 값을 기반으로 "PyFloatObject" 객체를 만들거나, 실패
   하면 "NULL".

PyObject *PyFloat_FromDouble(double v)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *v*로부터 "PyFloatObject" 객체를 만들거나, 실패하면 "NULL".

double PyFloat_AsDouble(PyObject *pyfloat)
    * Part of the 안정 ABI.*

   *pyfloat* 의 내용의 C double 표현을 반환합니다. *pyfloat*가 파이썬
   부동 소수점 객체가 아니지만 "__float__()" 메서드가 있으면,
   *pyfloat*를 float로 변환하기 위해 이 메서드가 먼저 호출됩니다.
   "__float__()"가 정의되지 않았으면 "__index__()"로 대체합니다. 이 메
   서드는 실패하면 "-1.0"을 반환하므로, "PyErr_Occurred()"를 호출하여
   에러를 확인해야 합니다.

   버전 3.8에서 변경: 사용할 수 있으면 "__index__()"를 사용합니다.

double PyFloat_AS_DOUBLE(PyObject *pyfloat)

   에러 검사 없이 *pyfloat* 의 내용의 C double 표현을 반환합니다.

PyObject *PyFloat_GetInfo(void)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   float의 정밀도, 최솟값, 최댓값에 관한 정보를 포함한 structseq 인스
   턴스를 돌려줍니다. 헤더 파일 "float.h"를 감싸는 얇은 래퍼입니다.

double PyFloat_GetMax()
    * Part of the 안정 ABI.*

   최대 표현 가능한 유한 float *DBL_MAX*를 C double로 반환합니다.

double PyFloat_GetMin()
    * Part of the 안정 ABI.*

   최소 정규화된(normalized) 양의 float *DBL_MIN*를 C double로 반환합
   니다.

Py_INFINITY

   This macro expands a to constant expression of type double, that
   represents the positive infinity.

   On most platforms, this is equivalent to the "INFINITY" macro from
   the C11 standard "<math.h>" header.

Py_NAN

   This macro expands a to constant expression of type double, that
   represents a quiet not-a-number (qNaN) value.

   On most platforms, this is equivalent to the "NAN" macro from the
   C11 standard "<math.h>" header.

Py_HUGE_VAL

   Equivalent to "INFINITY".

   버전 3.14부터 폐지됨: The macro is *soft deprecated*.

Py_MATH_E

   The definition (accurate for a double type) of the "math.e"
   constant.

Py_MATH_El

   High precision (long double) definition of "e" constant.

Py_MATH_PI

   The definition (accurate for a double type) of the "math.pi"
   constant.

Py_MATH_PIl

   High precision (long double) definition of "pi" constant.

Py_MATH_TAU

   The definition (accurate for a double type) of the "math.tau"
   constant.

   Added in version 3.6.

Py_RETURN_NAN

   Return "math.nan" from a function.

   On most platforms, this is equivalent to "return
   PyFloat_FromDouble(NAN)".

Py_RETURN_INF(sign)

   Return "math.inf" or "-math.inf" from a function, depending on the
   sign of *sign*.

   On most platforms, this is equivalent to the following:

      return PyFloat_FromDouble(copysign(INFINITY, sign));

Py_IS_FINITE(X)

   Return "1" if the given floating-point number *X* is finite, that
   is, it is normal, subnormal or zero, but not infinite or NaN.
   Return "0" otherwise.

   버전 3.14부터 폐지됨: The macro is *soft deprecated*.  Use
   "isfinite" instead.

Py_IS_INFINITY(X)

   Return "1" if the given floating-point number *X* is positive or
   negative infinity.  Return "0" otherwise.

   버전 3.14부터 폐지됨: The macro is *soft deprecated*.  Use "isinf"
   instead.

Py_IS_NAN(X)

   Return "1" if the given floating-point number *X* is a not-a-number
   (NaN) value.  Return "0" otherwise.

   버전 3.14부터 폐지됨: The macro is *soft deprecated*.  Use "isnan"
   instead.


Pack and Unpack functions
=========================

The pack and unpack functions provide an efficient platform-
independent way to store floating-point values as byte strings. The
Pack routines produce a bytes string from a C double, and the Unpack
routines produce a C double from such a bytes string. The suffix (2, 4
or 8) specifies the number of bytes in the bytes string.

On platforms that appear to use IEEE 754 formats these functions work
by copying bits. On other platforms, the 2-byte format is identical to
the IEEE 754 binary16 half-precision format, the 4-byte format
(32-bit) is identical to the IEEE 754 binary32 single precision
format, and the 8-byte format to the IEEE 754 binary64 double
precision format, although the packing of INFs and NaNs (if such
things exist on the platform) isn't handled correctly, and attempting
to unpack a bytes string containing an IEEE INF or NaN will raise an
exception.

Note that NaNs type may not be preserved on IEEE platforms (signaling
NaN become quiet NaN), for example on x86 systems in 32-bit mode.

On non-IEEE platforms with more precision, or larger dynamic range,
than IEEE 754 supports, not all values can be packed; on non-IEEE
platforms with less precision, or smaller dynamic range, not all
values can be unpacked. What happens in such cases is partly
accidental (alas).

Added in version 3.11.


Pack functions
--------------

The pack routines write 2, 4 or 8 bytes, starting at *p*. *le* is an
int argument, non-zero if you want the bytes string in little-endian
format (exponent last, at "p+1", "p+3", or "p+6" "p+7"), zero if you
want big-endian format (exponent first, at *p*). The "PY_BIG_ENDIAN"
constant can be used to use the native endian: it is equal to "1" on
big endian processor, or "0" on little endian processor.

Return value: "0" if all is OK, "-1" if error (and an exception is
set, most likely "OverflowError").

There are two problems on non-IEEE platforms:

* What this does is undefined if *x* is a NaN or infinity.

* "-0.0" and "+0.0" produce the same bytes string.

int PyFloat_Pack2(double x, char *p, int le)

   Pack a C double as the IEEE 754 binary16 half-precision format.

int PyFloat_Pack4(double x, char *p, int le)

   Pack a C double as the IEEE 754 binary32 single precision format.

int PyFloat_Pack8(double x, char *p, int le)

   Pack a C double as the IEEE 754 binary64 double precision format.


Unpack functions
----------------

The unpack routines read 2, 4 or 8 bytes, starting at *p*.  *le* is an
int argument, non-zero if the bytes string is in little-endian format
(exponent last, at "p+1", "p+3" or "p+6" and "p+7"), zero if big-
endian (exponent first, at *p*). The "PY_BIG_ENDIAN" constant can be
used to use the native endian: it is equal to "1" on big endian
processor, or "0" on little endian processor.

Return value: The unpacked double.  On error, this is "-1.0" and
"PyErr_Occurred()" is true (and an exception is set, most likely
"OverflowError").

Note that on a non-IEEE platform this will refuse to unpack a bytes
string that represents a NaN or infinity.

double PyFloat_Unpack2(const char *p, int le)

   Unpack the IEEE 754 binary16 half-precision format as a C double.

double PyFloat_Unpack4(const char *p, int le)

   Unpack the IEEE 754 binary32 single precision format as a C double.

double PyFloat_Unpack8(const char *p, int le)

   Unpack the IEEE 754 binary64 double precision format as a C double.
