객체 프로토콜
*************

PyObject *Py_GetConstant(unsigned int constant_id)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   Get a *strong reference* to a constant.

   Set an exception and return "NULL" if *constant_id* is invalid.

   *constant_id* must be one of these constant identifiers:

   +------------------------------------------+-------+---------------------------+
   | Constant Identifier                      | Value | Returned object           |
   |==========================================|=======|===========================|
   | Py_CONSTANT_NONE                         | "0"   | "None"                    |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_FALSE                        | "1"   | "False"                   |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_TRUE                         | "2"   | "True"                    |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_ELLIPSIS                     | "3"   | "Ellipsis"                |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_NOT_IMPLEMENTED              | "4"   | "NotImplemented"          |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_ZERO                         | "5"   | "0"                       |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_ONE                          | "6"   | "1"                       |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_EMPTY_STR                    | "7"   | "''"                      |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_EMPTY_BYTES                  | "8"   | "b''"                     |
   +------------------------------------------+-------+---------------------------+
   | Py_CONSTANT_EMPTY_TUPLE                  | "9"   | "()"                      |
   +------------------------------------------+-------+---------------------------+

   Numeric values are only given for projects which cannot use the
   constant identifiers.

   Added in version 3.13.

   **CPython 구현 상세:** In CPython, all of these constants are
   *immortal*.

PyObject *Py_GetConstantBorrowed(unsigned int constant_id)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   Similar to "Py_GetConstant()", but return a *borrowed reference*.

   This function is primarily intended for backwards compatibility:
   using "Py_GetConstant()" is recommended for new code.

   The reference is borrowed from the interpreter, and is valid until
   the interpreter finalization.

   Added in version 3.13.

PyObject *Py_NotImplemented

   지정된 형 조합에 대해 연산이 구현되지 않았음을 알리는 데 사용되는
   "NotImplemented" 싱글톤.

Py_RETURN_NOTIMPLEMENTED

   C 함수 내에서 "Py_NotImplemented" 반환을 올바르게 처리합니다 (즉,
   "NotImplemented"에 대한 새로운 *강한 참조*를 만들고 반환합니다).

Py_PRINT_RAW

   Flag to be used with multiple functions that print the object (like
   "PyObject_Print()" and "PyFile_WriteObject()"). If passed, these
   functions use the "str()" of the object instead of the "repr()".

int PyObject_Print(PyObject *o, FILE *fp, int flags)

   파일 *fp*에 객체 *o*를 인쇄합니다. 에러 시 "-1"을 반환합니다. flags
   인자는 특정 인쇄 옵션을 활성화하는 데 사용됩니다. 현재 지원되는 유
   일한 옵션은 "Py_PRINT_RAW"입니다; 주어지면, "repr()" 대신 객체의
   "str()"이 기록됩니다.

int PyObject_HasAttrWithError(PyObject *o, PyObject *attr_name)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   *o*에 *attr_name* 어트리뷰트가 있으면 "1"을, 그렇지 않으면 "0"을 반
   환합니다. 이것은 파이썬 표현식 "hasattr(o, attr_name)"과 동등합니다
   . 실패하면, "-1"을 반환합니다.

   Added in version 3.13.

int PyObject_HasAttrStringWithError(PyObject *o, const char *attr_name)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   This is the same as "PyObject_HasAttrWithError()", but *attr_name*
   is specified as a const char* UTF-8 encoded bytes string, rather
   than a PyObject*.

   Added in version 3.13.

int PyObject_HasAttr(PyObject *o, PyObject *attr_name)
    * Part of the 안정 ABI.*

   *o*에 *attr_name* 어트리뷰트가 있으면 "1"을, 그렇지 않으면 "0"을 반
   환합니다. 이 함수는 항상 성공합니다.

   참고:

     Exceptions that occur when this calls "__getattr__()" and
     "__getattribute__()" methods aren't propagated, but instead given
     to "sys.unraisablehook()". For proper error handling, use
     "PyObject_HasAttrWithError()", "PyObject_GetOptionalAttr()" or
     "PyObject_GetAttr()" instead.

int PyObject_HasAttrString(PyObject *o, const char *attr_name)
    * Part of the 안정 ABI.*

   This is the same as "PyObject_HasAttr()", but *attr_name* is
   specified as a const char* UTF-8 encoded bytes string, rather than
   a PyObject*.

   참고:

     "__getattr__()"과 "__getattribute__()" 메서드를 호출할 때나 임시
     "str" 객체를 만드는 중에 발생하는 예외는 조용히 무시됩니다. 적절
     한 에러 처리를 위해서는, 대신
     "PyObject_HasAttrStringWithError()",
     "PyObject_GetOptionalAttrString()" 또는
     "PyObject_GetAttrString()"을 사용하십시오.

PyObject *PyObject_GetAttr(PyObject *o, PyObject *attr_name)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   객체 *o*에서 *attr_name*이라는 이름의 어트리뷰트를 가져옵니다. 성공
   하면 어트리뷰트 값을, 실패하면 "NULL"을 반환합니다. 이것은 파이썬
   표현식 "o.attr_name"과 동등합니다.

   If the missing attribute should not be treated as a failure, you
   can use "PyObject_GetOptionalAttr()" instead.

PyObject *PyObject_GetAttrString(PyObject *o, const char *attr_name)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   This is the same as "PyObject_GetAttr()", but *attr_name* is
   specified as a const char* UTF-8 encoded bytes string, rather than
   a PyObject*.

   If the missing attribute should not be treated as a failure, you
   can use "PyObject_GetOptionalAttrString()" instead.

int PyObject_GetOptionalAttr(PyObject *obj, PyObject *attr_name, PyObject **result);
    * Part of the 안정 ABI 버전 3.13 이후로.*

   Variant of "PyObject_GetAttr()" which doesn't raise
   "AttributeError" if the attribute is not found.

   If the attribute is found, return "1" and set **result* to a new
   *strong reference* to the attribute. If the attribute is not found,
   return "0" and set **result* to "NULL"; the "AttributeError" is
   silenced. If an error other than "AttributeError" is raised, return
   "-1" and set **result* to "NULL".

   Added in version 3.13.

int PyObject_GetOptionalAttrString(PyObject *obj, const char *attr_name, PyObject **result);
    * Part of the 안정 ABI 버전 3.13 이후로.*

   This is the same as "PyObject_GetOptionalAttr()", but *attr_name*
   is specified as a const char* UTF-8 encoded bytes string, rather
   than a PyObject*.

   Added in version 3.13.

PyObject *PyObject_GenericGetAttr(PyObject *o, PyObject *name)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   형 객체의 "tp_getattro" 슬롯에 배치되는 일반 어트리뷰트 게터
   (getter) 함수. 객체의 (있다면) "__dict__"에 있는 어트리뷰트뿐만 아
   니라 객체의 MRO에 있는 클래스의 딕셔너리에 있는 디스크립터를 찾습니
   다. 디스크립터 구현하기에 요약된 것처럼, 데이터 디스크립터는 인스턴
   스 어트리뷰트보다 우선하지만, 비 데이터 디스크립터는 그렇지 않습니
   다. 그렇지 않으면, "AttributeError"가 발생합니다.

int PyObject_SetAttr(PyObject *o, PyObject *attr_name, PyObject *v)
    * Part of the 안정 ABI.*

   객체 *o*에 대해, *attr_name*이라는 이름의 어트리뷰트 값을 *v* 값으
   로 설정합니다. 실패 시 예외를 발생시키고 "-1"을 반환합니다. 성공하
   면 "0"을 반환합니다. 이것은 파이썬 문장 "o.attr_name = v"와 동등합
   니다.

   *v*가 "NULL"이면, 어트리뷰트가 삭제됩니다. 이 동작은 폐지되었고
   "PyObject_DelAttr()"로 대체되었습니다만, 현재 제거할 계획이 없습니
   다.

int PyObject_SetAttrString(PyObject *o, const char *attr_name, PyObject *v)
    * Part of the 안정 ABI.*

   This is the same as "PyObject_SetAttr()", but *attr_name* is
   specified as a const char* UTF-8 encoded bytes string, rather than
   a PyObject*.

   *v*가 "NULL"이면, 어트리뷰트가 삭제되지만, 이 기능은 폐지되었고
   "PyObject_DelAttrString()"으로 대체되었습니다.

   The number of different attribute names passed to this function
   should be kept small, usually by using a statically allocated
   string as *attr_name*. For attribute names that aren't known at
   compile time, prefer calling "PyUnicode_FromString()" and
   "PyObject_SetAttr()" directly. For more details, see
   "PyUnicode_InternFromString()", which may be used internally to
   create a key object.

int PyObject_GenericSetAttr(PyObject *o, PyObject *name, PyObject *value)
    * Part of the 안정 ABI.*

   형 객체의 "tp_setattro" 슬롯에 배치되는 일반 어트리뷰트 세터
   (setter)와 딜리터(deleter) 함수. 객체의 MRO에 있는 클래스의 딕셔너
   리에서 데이터 디스크립터를 찾고, 발견되면 인스턴스 딕셔너리에 있는
   어트리뷰트를 설정하거나 삭제하는 것보다 우선합니다. 그렇지 않으면,
   객체의 (있다면) "__dict__"에서 어트리뷰트가 설정되거나 삭제됩니다.
   성공하면 "0"이 반환되고, 그렇지 않으면 "AttributeError"가 발생하고
   "-1"이 반환됩니다.

int PyObject_DelAttr(PyObject *o, PyObject *attr_name)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   객체 *o*에 대해, *attr_name*이라는 이름의 어트리뷰트를 삭제합니다.
   실패 시 "-1"을 반환합니다. 이것은 파이썬 문장 "del o.attr_name"과
   동등합니다.

int PyObject_DelAttrString(PyObject *o, const char *attr_name)
    * Part of the 안정 ABI 버전 3.13 이후로.*

   This is the same as "PyObject_DelAttr()", but *attr_name* is
   specified as a const char* UTF-8 encoded bytes string, rather than
   a PyObject*.

   The number of different attribute names passed to this function
   should be kept small, usually by using a statically allocated
   string as *attr_name*. For attribute names that aren't known at
   compile time, prefer calling "PyUnicode_FromString()" and
   "PyObject_DelAttr()" directly. For more details, see
   "PyUnicode_InternFromString()", which may be used internally to
   create a key object for lookup.

PyObject *PyObject_GenericGetDict(PyObject *o, void *context)
    *반환값: 새 참조.** Part of the 안정 ABI 버전 3.10 이후로.*

   "__dict__" 디스크립터의 게터(getter)를 위한 일반적인 구현. 필요하면
   딕셔너리를 만듭니다.

   This function may also be called to get the "__dict__" of the
   object *o*. Pass "NULL" for *context* when calling it. Since this
   function may need to allocate memory for the dictionary, it may be
   more efficient to call "PyObject_GetAttr()" when accessing an
   attribute on the object.

   On failure, returns "NULL" with an exception set.

   Added in version 3.3.

int PyObject_GenericSetDict(PyObject *o, PyObject *value, void *context)
    * Part of the 안정 ABI 버전 3.7 이후로.*

   "__dict__" 디스크립터의 세터(setter)를 위한 일반적인 구현. 이 구현
   은 딕셔너리 삭제를 허락하지 않습니다.

   Added in version 3.3.

PyObject **_PyObject_GetDictPtr(PyObject *obj)

   Return a pointer to "__dict__" of the object *obj*. If there is no
   "__dict__", return "NULL" without setting an exception.

   This function may need to allocate memory for the dictionary, so it
   may be more efficient to call "PyObject_GetAttr()" when accessing
   an attribute on the object.

PyObject *PyObject_RichCompare(PyObject *o1, PyObject *o2, int opid)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *opid*에 의해 지정된 연산을 사용하여 *o1*과 *o2*의 값을 비교합니다.
   *opid*는 "Py_LT", "Py_LE", "Py_EQ", "Py_NE", "Py_GT" 또는 "Py_GE"
   중 하나여야 하고 각각 "<", "<=", "==", "!=", ">" 또는 ">="에 해당합
   니다. 이는 파이썬 표현식 "o1 op o2"와 동등합니다. 여기서 "op"는
   *opid*에 해당하는 연산자입니다. 성공 시 비교 값을, 실패 시 "NULL"을
   반환합니다.

int PyObject_RichCompareBool(PyObject *o1, PyObject *o2, int opid)
    * Part of the 안정 ABI.*

   Compare the values of *o1* and *o2* using the operation specified
   by *opid*, like "PyObject_RichCompare()", but returns "-1" on
   error, "0" if the result is false, "1" otherwise.

참고:

  *o1*과 *o2*가 같은 객체이면, "PyObject_RichCompareBool()" 은 항상
  "Py_EQ"의 경우는 "1"을, "Py_NE"의 경우는 "0"을 반환합니다.

PyObject *PyObject_Format(PyObject *obj, PyObject *format_spec)
    * Part of the 안정 ABI.*

   Format *obj* using *format_spec*. This is equivalent to the Python
   expression "format(obj, format_spec)".

   *format_spec* may be "NULL". In this case the call is equivalent to
   "format(obj)". Returns the formatted string on success, "NULL" on
   failure.

PyObject *PyObject_Repr(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   객체 *o*의 문자열 표현을 계산합니다. 성공하면 문자열 표현을, 실패하
   면 "NULL"을 반환합니다. 이것은 파이썬 표현식 "repr(o)"와 동등합니다
   . "repr()" 내장 함수에 의해 호출됩니다.

   버전 3.4에서 변경: 이 함수에는 이제 디버그 어서션이 포함되어 있어
   활성 예외를 조용히 버리지 않도록 합니다.

PyObject *PyObject_ASCII(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   "PyObject_Repr()"처럼, 객체 *o*의 문자열 표현을 계산하지만, "\x",
   "\u" 또는 "\U" 이스케이프를 사용하여 "PyObject_Repr()"이 반환한 문
   자열에서 비 ASCII 문자를 이스케이프 합니다. 이것은 파이썬 2에서
   "PyObject_Repr()"에 의해 반환된 것과 유사한 문자열을 생성합니다.
   "ascii()" 내장 함수에 의해 호출됩니다.

PyObject *PyObject_Str(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   객체 *o*의 문자열 표현을 계산합니다. 성공 시 문자열 표현을, 실패 시
   "NULL"을 반환합니다. 이것은 파이썬 표현식 "str(o)"와 동등합니다.
   "str()" 내장 함수에 의해, 따라서 "print()" 함수에 의해서도 호출됩니
   다.

   버전 3.4에서 변경: 이 함수에는 이제 디버그 어서션이 포함되어 있어
   활성 예외를 조용히 버리지 않도록 합니다.

PyObject *PyObject_Bytes(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   객체 *o*의 바이트열 표현을 계산합니다. 실패하면 "NULL"을, 성공하면
   바이트열 객체를 반환됩니다. 이는 *o*가 정수가 아닐 때 파이썬 표현식
   "bytes(o)"와 동등합니다. "bytes(o)"와 달리, *o*가 정수이면 0으로 초
   기화된 바이트열 객체 대신 TypeError가 발생합니다.

int PyObject_IsSubclass(PyObject *derived, PyObject *cls)
    * Part of the 안정 ABI.*

   클래스 *derived*가 클래스 *cls*와 동일하거나 *cls*에서 파생되었으면
   "1"을 반환하고, 그렇지 않으면 "0"을 반환합니다. 에러가 발생하면
   "-1"을 반환합니다.

   *cls*가 튜플이면, *cls*의 모든 항목에 대해 검사가 수행됩니다. 적어
   도 하나의 검사에서 "1"을 반환하면 결과는 "1"이 되고, 그렇지 않으면
   "0"이 됩니다.

   *cls*에 "__subclasscheck__()" 메서드가 있으면, **PEP 3119**에 설명
   된 대로 서브 클래스 상태를 판별하기 위해 호출됩니다. 그렇지 않으면,
   *derived*가 직접 또는 간접 서브 클래스일 때 *cls*의 서브 클래스입니
   다, 즉 "cls.__mro__"에 포함되어 있습니다.

   일반적으로 클래스 객체(즉 "type"이나 파생 클래스의 인스턴스)만 클래
   스로 간주합니다. 그러나, 객체는 "__bases__" 어트리뷰트(베이스 클래
   스의 튜플이어야 합니다)를 가짐으로써 이를 재정의할 수 있습니다.

int PyObject_IsInstance(PyObject *inst, PyObject *cls)
    * Part of the 안정 ABI.*

   *inst*가 *cls* 클래스나 *cls*의 서브 클래스의 인스턴스이면 "1"을 반
   환하고, 그렇지 않으면 "0"을 반환합니다. 에러가 발생하면 "-1"을 반환
   하고 예외를 설정합니다.

   *cls*가 튜플이면, *cls*의 모든 항목에 대해 검사가 수행됩니다. 적어
   도 하나의 검사에서 "1"을 반환하면 결과는 "1"이 되고, 그렇지 않으면
   "0"이 됩니다.

   *cls*에 "__instancecheck__()" 메서드가 있으면, **PEP 3119**에 설명
   된 대로 서브 클래스 상태를 판별하기 위해 호출됩니다. 그렇지 않으면,
   *inst*는 해당 클래스가 *cls*의 서브 클래스일 때 *cls*의 인스턴스입
   니다.

   인스턴스 *inst*는 "__class__" 어트리뷰트를 가짐으로써 클래스로 간주
   하는 것을 재정의할 수 있습니다.

   객체 *cls*는 "__bases__" 어트리뷰트(베이스 클래스의 튜플이어야 합니
   다)를 가짐으로써, 클래스로 간주하는지와 베이스 클래스가 무엇인지를
   재정의할 수 있습니다.

Py_hash_t PyObject_Hash(PyObject *o)
    * Part of the 안정 ABI.*

   객체 *o*의 해시값을 계산하고 반환합니다. 실패하면 "-1"을 반환합니다
   . 이것은 파이썬 표현식 "hash(o)"와 동등합니다.

   버전 3.2에서 변경: 반환형은 이제 Py_hash_t입니다. 이것은
   "Py_ssize_t"와 같은 크기의 부호 있는 정수입니다.

Py_hash_t PyObject_HashNotImplemented(PyObject *o)
    * Part of the 안정 ABI.*

   "type(o)"가 *해시 가능*하지 않음을 나타내는 "TypeError"를 설정하고
   "-1"을 반환합니다. 이 함수는 "tp_hash" 슬롯에 저장될 때 특수한 처방
   을 받아서, 인터프리터에 형이 해시 가능하지 않음을 명시적으로 알립니
   다.

int PyObject_IsTrue(PyObject *o)
    * Part of the 안정 ABI.*

   객체 *o*를 참으로 간주하면 "1"을, 그렇지 않으면 "0"을 반환합니다.
   이것은 파이썬 표현식 "not not o"와 동등합니다. 실패하면 "-1"을 반환
   합니다.

int PyObject_Not(PyObject *o)
    * Part of the 안정 ABI.*

   객체 *o*를 참으로 간주하면 "0"을, 그렇지 않으면 "1"을 반환합니다.
   이것은 파이썬 표현식 "not o"와 동등합니다. 실패하면 "-1"을 반환합니
   다.

PyObject *PyObject_Type(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   *o*가 "NULL"이 아니면, 객체 *o*의 객체 형에 해당하는 형 객체를 반환
   합니다. 실패하면 "SystemError"를 발생시키고 "NULL"을 반환합니다. 이
   것은 파이썬 표현식 "type(o)"와 동등합니다. 이 함수는 반환 값에 대한
   새로운 *강한 참조*를 만듭니다. 새로운 *강한 참조*가 필요할 때를 제
   외하고, PyTypeObject* 형의 포인터를 반환하는 "Py_TYPE()" 함수 대신
   이 함수를 사용할 이유가 없습니다.

int PyObject_TypeCheck(PyObject *o, PyTypeObject *type)

   객체 *o*가 *type* 형이거나 *type*의 서브 형이면 0이 아닌 값을 반환
   하고, 그렇지 않으면 "0"을 반환합니다. 두 매개 변수 모두 "NULL"이 아
   니어야 합니다.

Py_ssize_t PyObject_Size(PyObject *o)
Py_ssize_t PyObject_Length(PyObject *o)
    * Part of the 안정 ABI.*

   객체 *o*의 길이를 반환합니다. 객체 *o*가 시퀀스와 매핑 프로토콜을
   제공하면, 시퀀스 길이가 반환됩니다. 에러가 발생하면 "-1"이 반환됩니
   다. 이것은 파이썬 표현식 "len(o)"와 동등합니다.

Py_ssize_t PyObject_LengthHint(PyObject *o, Py_ssize_t defaultvalue)

   *o* 객체의 추정된 길이를 반환합니다. 먼저 실제 길이를 반환하려고 시
   도한 다음, "__length_hint__()"를 사용하여 추정값을 반환하고, 마지막
   으로 기본값을 반환합니다. 에러 시 "-1"을 반환합니다. 이것은 파이썬
   표현식 "operator.length_hint(o, defaultvalue)"와 동등합니다.

   Added in version 3.4.

PyObject *PyObject_GetItem(PyObject *o, PyObject *key)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   객체 *key*에 해당하는 *o*의 요소를 반환하거나 실패 시 "NULL"을 반환
   합니다. 이것은 파이썬 표현식 "o[key]"와 동등합니다.

int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *v)
    * Part of the 안정 ABI.*

   객체 *key*를 값 *v*에 매핑합니다. 실패 시 예외를 발생시키고 "-1"을
   반환합니다; 성공하면 "0"을 반환합니다. 이것은 파이썬 문장 "o[key] =
   v"와 동등합니다. 이 함수는 *v*에 대한 참조를 훔치지 *않습니다*.

int PyObject_DelItem(PyObject *o, PyObject *key)
    * Part of the 안정 ABI.*

   객체 *o*에서 객체 *key*에 대한 매핑을 제거합니다. 실패하면 "-1"을
   반환합니다. 이것은 파이썬 문장 "del o[key]"와 동등합니다.

int PyObject_DelItemString(PyObject *o, const char *key)
    * Part of the 안정 ABI.*

   This is the same as "PyObject_DelItem()", but *key* is specified as
   a const char* UTF-8 encoded bytes string, rather than a PyObject*.

PyObject *PyObject_Dir(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   이것은 파이썬 표현식 "dir(o)"와 동등하며, 객체 인자에 적합한 문자열
   의 (비어있을 수 있는) 리스트를 반환하거나, 에러가 있으면 "NULL"을
   반환합니다. 인자가 "NULL"이면, 파이썬 "dir()"과 비슷하며, 현재 지역
   (locals)의 이름들을 반환합니다; 이 경우, 실행 프레임이 활성화되어
   있지 않으면 "NULL"이 반환되지만 "PyErr_Occurred()"는 거짓을 반환합
   니다.

PyObject *PyObject_GetIter(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   이것은 파이썬 표현식 "iter(o)"와 동등합니다. 객체 인자에 대한 새로
   운 이터레이터를 반환하거나, 객체가 이미 이터레이터이면 객체 자체를
   반환합니다. 객체를 이터레이트 할 수 없으면 "TypeError"를 발생시키고
   "NULL"을 반환합니다.

PyObject *PyObject_SelfIter(PyObject *obj)
    *반환값: 새 참조.** Part of the 안정 ABI.*

   This is equivalent to the Python "__iter__(self): return self"
   method. It is intended for *iterator* types, to be used in the
   "PyTypeObject.tp_iter" slot.

PyObject *PyObject_GetAIter(PyObject *o)
    *반환값: 새 참조.** Part of the 안정 ABI 버전 3.10 이후로.*

   이것은 파이썬 표현식 "aiter(o)"와 동등합니다. "AsyncIterable"을 받
   아서 그 것의 "AsyncIterator"를 반환합니다. 보통 새 이터레이터이지만
   , 인자가 "AsyncIterator"면 그 자신을 반환합니다. 객체를 이터레이트
   할 수 없으면 "TypeError"를 발생시키고 "NULL"을 반환합니다.

   Added in version 3.10.

void *PyObject_GetTypeData(PyObject *o, PyTypeObject *cls)
    * Part of the 안정 ABI 버전 3.12 이후로.*

   Get a pointer to subclass-specific data reserved for *cls*.

   The object *o* must be an instance of *cls*, and *cls* must have
   been created using negative "PyType_Spec.basicsize". Python does
   not check this.

   On error, set an exception and return "NULL".

   Added in version 3.12.

Py_ssize_t PyType_GetTypeDataSize(PyTypeObject *cls)
    * Part of the 안정 ABI 버전 3.12 이후로.*

   Return the size of the instance memory space reserved for *cls*,
   i.e. the size of the memory "PyObject_GetTypeData()" returns.

   This may be larger than requested using "-PyType_Spec.basicsize";
   it is safe to use this larger size (e.g. with "memset()").

   The type *cls* **must** have been created using negative
   "PyType_Spec.basicsize". Python does not check this.

   On error, set an exception and return a negative value.

   Added in version 3.12.

void *PyObject_GetItemData(PyObject *o)

   Get a pointer to per-item data for a class with
   "Py_TPFLAGS_ITEMS_AT_END".

   On error, set an exception and return "NULL". "TypeError" is raised
   if *o* does not have "Py_TPFLAGS_ITEMS_AT_END" set.

   Added in version 3.12.

int PyObject_VisitManagedDict(PyObject *obj, visitproc visit, void *arg)

   Visit the managed dictionary of *obj*.

   This function must only be called in a traverse function of the
   type which has the "Py_TPFLAGS_MANAGED_DICT" flag set.

   Added in version 3.13.

void PyObject_ClearManagedDict(PyObject *obj)

   Clear the managed dictionary of *obj*.

   This function must only be called in a clear function of the type
   which has the "Py_TPFLAGS_MANAGED_DICT" flag set.

   Added in version 3.13.

int PyUnstable_Object_EnableDeferredRefcount(PyObject *obj)

   *이것은 불안정 API. It may change without warning in minor
   releases.*

   Enable deferred reference counting on *obj*, if supported by the
   runtime.  In the *free-threaded* build, this allows the interpreter
   to avoid reference count adjustments to *obj*, which may improve
   multi-threaded performance.  The tradeoff is that *obj* will only
   be deallocated by the tracing garbage collector, and not when the
   interpreter no longer has any references to it.

   This function returns "1" if deferred reference counting is enabled
   on *obj*, and "0" if deferred reference counting is not supported
   or if the hint was ignored by the interpreter, such as when
   deferred reference counting is already enabled on *obj*. This
   function is thread-safe, and cannot fail.

   This function does nothing on builds with the *GIL* enabled, which
   do not support deferred reference counting. This also does nothing
   if *obj* is not an object tracked by the garbage collector (see
   "gc.is_tracked()" and "PyObject_GC_IsTracked()").

   This function is intended to be used soon after *obj* is created,
   by the code that creates it, such as in the object's "tp_new" slot.

   Added in version 3.14.

int PyUnstable_Object_IsUniqueReferencedTemporary(PyObject *obj)

   *이것은 불안정 API. It may change without warning in minor
   releases.*

   Check if *obj* is a unique temporary object. Returns "1" if *obj*
   is known to be a unique temporary object, and "0" otherwise.  This
   function cannot fail, but the check is conservative, and may return
   "0" in some cases even if *obj* is a unique temporary object.

   If an object is a unique temporary, it is guaranteed that the
   current code has the only reference to the object. For arguments to
   C functions, this should be used instead of checking if the
   reference count is "1". Starting with Python 3.14, the interpreter
   internally avoids some reference count modifications when loading
   objects onto the operands stack by *borrowing* references when
   possible, which means that a reference count of "1" by itself does
   not guarantee that a function argument uniquely referenced.

   In the example below, "my_func" is called with a unique temporary
   object as its argument:

      my_func([1, 2, 3])

   In the example below, "my_func" is **not** called with a unique
   temporary object as its argument, even if its refcount is "1":

      my_list = [1, 2, 3]
      my_func(my_list)

   See also the function "Py_REFCNT()".

   Added in version 3.14.

int PyUnstable_IsImmortal(PyObject *obj)

   *이것은 불안정 API. It may change without warning in minor
   releases.*

   This function returns non-zero if *obj* is *immortal*, and zero
   otherwise. This function cannot fail.

   참고:

     Objects that are immortal in one CPython version are not
     guaranteed to be immortal in another.

   Added in version 3.14.

int PyUnstable_TryIncRef(PyObject *obj)

   *이것은 불안정 API. It may change without warning in minor
   releases.*

   Increments the reference count of *obj* if it is not zero.  Returns
   "1" if the object's reference count was successfully incremented.
   Otherwise, this function returns "0".

   "PyUnstable_EnableTryIncRef()" must have been called earlier on
   *obj* or this function may spuriously return "0" in the *free
   threading* build.

   This function is logically equivalent to the following C code,
   except that it behaves atomically in the *free threading* build:

      if (Py_REFCNT(op) > 0) {
         Py_INCREF(op);
         return 1;
      }
      return 0;

   This is intended as a building block for managing weak references
   without the overhead of a Python weak reference object.

   Typically, correct use of this function requires support from
   *obj*'s deallocator ("tp_dealloc"). For example, the following
   sketch could be adapted to implement a "weakmap" that works like a
   "WeakValueDictionary" for a specific type:

      PyMutex mutex;

      PyObject *
      add_entry(weakmap_key_type *key, PyObject *value)
      {
          PyUnstable_EnableTryIncRef(value);
          weakmap_type weakmap = ...;
          PyMutex_Lock(&mutex);
          weakmap_add_entry(weakmap, key, value);
          PyMutex_Unlock(&mutex);
          Py_RETURN_NONE;
      }

      PyObject *
      get_value(weakmap_key_type *key)
      {
          weakmap_type weakmap = ...;
          PyMutex_Lock(&mutex);
          PyObject *result = weakmap_find(weakmap, key);
          if (PyUnstable_TryIncRef(result)) {
              // `result` is safe to use
              PyMutex_Unlock(&mutex);
              return result;
          }
          // if we get here, `result` is starting to be garbage-collected,
          // but has not been removed from the weakmap yet
          PyMutex_Unlock(&mutex);
          return NULL;
      }

      // tp_dealloc function for weakmap values
      void
      value_dealloc(PyObject *value)
      {
          weakmap_type weakmap = ...;
          PyMutex_Lock(&mutex);
          weakmap_remove_value(weakmap, value);

          ...
          PyMutex_Unlock(&mutex);
      }

   Added in version 3.14.

void PyUnstable_EnableTryIncRef(PyObject *obj)

   *이것은 불안정 API. It may change without warning in minor
   releases.*

   Enables subsequent uses of "PyUnstable_TryIncRef()" on *obj*.  The
   caller must hold a *strong reference* to *obj* when calling this.

   Added in version 3.14.

int PyUnstable_Object_IsUniquelyReferenced(PyObject *op)

   *이것은 불안정 API. It may change without warning in minor
   releases.*

   Determine if *op* only has one reference.

   On GIL-enabled builds, this function is equivalent to Py_REFCNT(op)
   == 1.

   On a *free threaded* build, this checks if *op*'s *reference count*
   is equal to one and additionally checks if *op* is only used by
   this thread. Py_REFCNT(op) == 1 is **not** thread-safe on free
   threaded builds; prefer this function.

   The caller must hold an *attached thread state*, despite the fact
   that this function doesn't call into the Python interpreter. This
   function cannot fail.

   Added in version 3.14.
